language: rs
name: HumanEval_6_parse_nested_parens
results:
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut results = Vec::new();\n    let mut nest_level =\
    \ 0;\n    let mut max_nest_level = 0;\n    for c in paren_string.chars() {\n \
    \       if c == '(' {\n            nest_level += 1;\n            if nest_level\
    \ > max_nest_level {\n                max_nest_level = nest_level;\n         \
    \   }\n        } else if c == ')' {\n            nest_level -= 1;\n        } else\
    \ if c == ' ' {\n            results.push(max_nest_level);\n            max_nest_level\
    \ = 0;\n            nest_level = 0;\n        }\n    }\n    results.push(max_nest_level);\n\
    \    results\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n   \
    \ assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822097
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = Vec::new();\n    let mut curr_nesting\
    \ = 0;\n    let mut max_curr_nesting = 0;\n    for paren in paren_string.chars()\
    \ {\n        if paren == '(' {\n            curr_nesting += 1;\n            if\
    \ curr_nesting > max_curr_nesting {\n                max_curr_nesting = curr_nesting;\n\
    \            }\n        } else if paren == ')' {\n            curr_nesting -=\
    \ 1;\n        } else if paren == ' ' {\n            max_nesting.push(max_curr_nesting);\n\
    \            max_curr_nesting = 0;\n            curr_nesting = 0;\n        }\n\
    \    }\n    max_nesting.push(max_curr_nesting);\n    max_nesting\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822097
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth: isize = 0;\n    let mut current_depth:\
    \ isize = 0;\n    let mut results: Vec<isize> = Vec::new();\n\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            current_depth += 1;\n            if current_depth\
    \ > max_depth {\n                max_depth = current_depth;\n            }\n \
    \       } else if c == ')' {\n            current_depth -= 1;\n        } else\
    \ if c == ' ' {\n            results.push(max_depth);\n            max_depth =\
    \ 0;\n            current_depth = 0;\n        }\n    }\n\n    results.push(max_depth);\n\
    \    results\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n   \
    \ assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822097
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut levels = Vec::new();\n    for paren_group in paren_string.split_whitespace()\
    \ {\n        let mut level = 0;\n        let mut max_level = 0;\n        for c\
    \ in paren_group.chars() {\n            if c == '(' {\n                level +=\
    \ 1;\n            } else if c == ')' {\n                level -= 1;\n        \
    \    } else {\n                panic!(\"Invalid character found in parentheses\
    \ string.\");\n            }\n            if level > max_level {\n           \
    \     max_level = level;\n            }\n        }\n        levels.push(max_level);\n\
    \    }\n    levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822097
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = Vec::new();\n    let\
    \ mut max_depth: isize = 0;\n    for char in paren_string.chars() {\n        match\
    \ char {\n            '(' => {\n                paren_stack.push(1);\n       \
    \         max_depth += 1;\n            }\n            ')' => {\n             \
    \   paren_stack.pop();\n                max_depth -= 1;\n            }\n     \
    \       _ => panic!(\"Unexpected char in input string\"),\n        }\n    }\n\
    \    return paren_stack;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''Unexpected char in input string'', /tmp/tmpdeyszup7.rs:17:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822097
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut levels: Vec<isize> = Vec::new();\n    let paren_groups:\
    \ Vec<&str> = paren_string.split(\" \").collect();\n    for paren_group in paren_groups\
    \ {\n        let mut level: isize = 0;\n        let mut max_level: isize = 0;\n\
    \        for ch in paren_group.chars() {\n            if ch == '(' {\n       \
    \         level += 1;\n            } else if ch == ')' {\n                level\
    \ -= 1;\n            }\n            if level > max_level {\n                max_level\
    \ = level;\n            }\n        }\n        levels.push(max_level);\n    }\n\
    \    levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822097
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_level = 0;\n    let mut curr_level = 0;\n \
    \   let mut result = Vec::new();\n    for c in paren_string.chars() {\n      \
    \  if c == '(' {\n            curr_level += 1;\n            if curr_level > max_level\
    \ {\n                max_level = curr_level;\n            }\n        } else if\
    \ c == ')' {\n            curr_level -= 1;\n        } else if c == ' ' {\n   \
    \         result.push(max_level);\n            max_level = 0;\n            curr_level\
    \ = 0;\n        }\n    }\n    result.push(max_level);\n    result\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822097
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level_vec: Vec<isize> = Vec::new();\n    let mut\
    \ level: isize = 0;\n    let mut max_level: isize = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            level += 1;\n            if level > max_level\
    \ {\n                max_level = level;\n            }\n        } else if c ==\
    \ ')' {\n            level -= 1;\n        } else if c == ' ' {\n            level_vec.push(max_level);\n\
    \            max_level = 0;\n            level = 0;\n        }\n    }\n    level_vec.push(max_level);\n\
    \    level_vec\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n \
    \   assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822097
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let groups: Vec<&str> = paren_string.split(\" \").collect();\n\
    \    let mut results: Vec<isize> = Vec::new();\n    for group in groups {\n  \
    \      results.push(paren_helper(group));\n    }\n    results\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `paren_helper` in this scope\n --> /tmp/tmphd7728k5.rs:8:22\n\
    \  |\n8 |         results.push(paren_helper(group));\n  |                    \
    \  ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let paren_groups: Vec<&str> = paren_string.split(\" \"\
    ).collect();\n    paren_groups.iter().map(|group| {\n        let mut max_nesting_level\
    \ = 0;\n        let mut current_nesting_level = 0;\n        for ch in group.chars()\
    \ {\n            match ch {\n                '(' => {\n                    current_nesting_level\
    \ += 1;\n                    if current_nesting_level > max_nesting_level {\n\
    \                        max_nesting_level = current_nesting_level;\n        \
    \            }\n                }\n                ')' => {\n                \
    \    current_nesting_level -= 1;\n                }\n                _ => {\n\
    \                    panic!(\"Invalid input!\");\n                }\n        \
    \    }\n        }\n        max_nesting_level\n    }).collect()\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822097
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_chars = paren_string.chars();\n    let mut\
    \ depth = 0;\n    let mut max_depth = 0;\n    let mut max_depth_per_group = Vec::new();\n\
    \    while let Some(c) = paren_chars.next() {\n        match c {\n           \
    \ '(' => {\n                depth += 1;\n                if depth > max_depth\
    \ {\n                    max_depth = depth;\n                }\n            }\n\
    \            ')' => {\n                depth -= 1;\n            }\n          \
    \  ' ' => {\n                max_depth_per_group.push(max_depth);\n          \
    \      max_depth = 0;\n            }\n            _ => (),\n        }\n    }\n\
    \    max_depth_per_group.push(max_depth);\n    max_depth_per_group\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822097
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_counter = isize::from(0);\n    let mut max_level\
    \ = isize::from(0);\n    let mut final_vector = Vec::new();\n\n    for paren in\
    \ paren_string.chars() {\n        if paren == '(' {\n            paren_counter\
    \ += 1;\n            if paren_counter > max_level {\n                max_level\
    \ = paren_counter;\n            }\n        } else if paren == ')' {\n        \
    \    paren_counter -= 1;\n        } else if paren == ' ' {\n            // If\
    \ we have completed processing a group\n            if paren_counter == 0 {\n\
    \                final_vector.push(max_level);\n                max_level = 0;\n\
    \            }\n        }\n    }\n\n    final_vector\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `isize: From<i32>` is not satisfied\n   -->\
    \ /tmp/tmpjfm81rf1.rs:5:29\n    |\n5   |     let mut paren_counter = isize::from(0);\n\
    \    |                             ^^^^^^^^^^^ the trait `From<i32>` is not implemented\
    \ for `isize`\n    |\n    = help: the following implementations were found:\n\
    \              <isize as From<NonZeroIsize>>\n              <isize as From<bool>>\n\
    \              <isize as From<i16>>\n              <isize as From<i8>>\n     \
    \         <isize as From<u8>>\nnote: required by `from`\n\nerror[E0277]: the trait\
    \ bound `isize: From<i32>` is not satisfied\n   --> /tmp/tmpjfm81rf1.rs:6:25\n\
    \    |\n6   |     let mut max_level = isize::from(0);\n    |                 \
    \        ^^^^^^^^^^^ the trait `From<i32>` is not implemented for `isize`\n  \
    \  |\n    = help: the following implementations were found:\n              <isize\
    \ as From<NonZeroIsize>>\n              <isize as From<bool>>\n              <isize\
    \ as From<i16>>\n              <isize as From<i8>>\n              <isize as From<u8>>\n\
    note: required by `from`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822096
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_counts = Vec::new();\n    let mut left_parentheses_count\
    \ = 0;\n    let mut right_parentheses_count = 0;\n    let mut max_count = 0;\n\
    \    for c in paren_string.chars() {\n        if c == '(' {\n            left_parentheses_count\
    \ += 1;\n            max_count = std::cmp::max(max_count, left_parentheses_count);\n\
    \        } else if c == ')' {\n            right_parentheses_count += 1;\n   \
    \         if right_parentheses_count == left_parentheses_count {\n           \
    \     paren_counts.push(max_count);\n                max_count = 0;\n        \
    \        left_parentheses_count = 0;\n                right_parentheses_count\
    \ = 0;\n            }\n        }\n    }\n    paren_counts\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 3, 1, 5]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpxpn5iwbq.rs:28:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822097
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result: Vec<isize> = Vec::new();\n    let mut deepest_level:\
    \ isize = 0;\n    let mut current_level: isize = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            current_level += 1;\n            if current_level\
    \ > deepest_level {\n                deepest_level = current_level;\n        \
    \    }\n        } else if c == ')' {\n            current_level -= 1;\n      \
    \  } else if c == ' ' {\n            result.push(deepest_level);\n           \
    \ deepest_level = 0;\n            current_level = 0;\n        }\n    }\n    result.push(deepest_level);\n\
    \    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822097
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    // Tokenize the input string and construct a Vec of groups.\n\
    \    let mut group_stack: Vec<Vec<char>> = Vec::new();\n    let mut group: Vec<char>\
    \ = Vec::new();\n    for c in paren_string.chars() {\n        if c == '(' {\n\
    \            group.push(c);\n        } else if c == ')' {\n            group.push(c);\n\
    \        } else if c == ' ' {\n            if !group.is_empty() {\n          \
    \      group_stack.push(group);\n                group = Vec::new();\n       \
    \     }\n        }\n    }\n    // Push the last group if it is not empty.\n  \
    \  if !group.is_empty() {\n        group_stack.push(group);\n    }\n\n    // Iterate\
    \ through the group stack and calculate the nesting level for each group.\n  \
    \  let mut paren_count: Vec<isize> = Vec::new();\n    for group in group_stack\
    \ {\n        let mut prev_count: isize = 0;\n        let mut curr_count: isize\
    \ = 0;\n        for c in group {\n            if c == '(' {\n                curr_count\
    \ += 1;\n            } else if c == ')' {\n                curr_count -= 1;\n\
    \            }\n            if curr_count > prev_count {\n                prev_count\
    \ = curr_count;\n            }\n        }\n        paren_count.push(prev_count);\n\
    \    }\n    paren_count\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822097
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut stack = Vec::new();\n\
    \    let mut total_depth = 0;\n    let mut depth = 0;\n    let mut c = ' ';\n\
    \    for c in paren_string.chars() {\n        if c == '(' {\n            stack.push(c);\n\
    \            depth += 1;\n            total_depth = std::cmp::max(total_depth,\
    \ depth);\n        } else if c == ')' {\n            let popped = stack.pop();\n\
    \            if popped.is_none() {\n                result.push(-1);\n       \
    \         continue;\n            }\n            depth -= 1;\n        } else if\
    \ c == ' ' {\n            if depth != 0 {\n                result.push(-1);\n\
    \            } else {\n                result.push(total_depth);\n           \
    \ }\n            depth = 0;\n            total_depth = 0;\n        }\n    }\n\
    \    if depth != 0 {\n        result.push(-1);\n    } else {\n        result.push(total_depth);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822097
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_level = 0;\n    let mut current_level = 0;\n\
    \    let mut level_list = Vec::new();\n\n    for paren in paren_string.chars()\
    \ {\n        match paren {\n            '(' => {\n                current_level\
    \ += 1;\n                if current_level > max_level {\n                    max_level\
    \ = current_level;\n                }\n            }\n            ')' => {\n \
    \               level_list.push(current_level);\n                current_level\
    \ -= 1;\n            }\n            _ => panic!(\"Invalid input\"),\n        }\n\
    \    }\n\n    level_list\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''Invalid input'', /tmp/tmp0xsaf_ca.rs:21:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822097
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut stack: Vec<char> = Vec::new();\n    let mut levels:\
    \ Vec<isize> = Vec::new();\n    let mut level: isize = 0;\n    let mut max_level:\
    \ isize = 0;\n    for c in paren_string.chars() {\n        if c == '(' {\n   \
    \         stack.push(c);\n            level += 1;\n            if level > max_level\
    \ {\n                max_level = level;\n            }\n        } else if c ==\
    \ ')' {\n            stack.pop();\n            levels.push(max_level);\n     \
    \       level -= 1;\n            max_level = level;\n        }\n    }\n    return\
    \ levels;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 2, 1, 3, 2, 1, 1, 3, 2, 2, 2, 1]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp_h2tp473.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822097
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_count = 0;\n    let mut count = 0;\n    let\
    \ mut nested_count = Vec::new();\n    for character in paren_string.chars() {\n\
    \        if character == '(' {\n            count += 1;\n            if count\
    \ > max_count {\n                max_count = count;\n            }\n        }\
    \ else if character == ')' {\n            count -= 1;\n        } else if character\
    \ == ' ' {\n            nested_count.push(max_count);\n            max_count =\
    \ 0;\n            count = 0;\n        }\n    }\n    nested_count.push(max_count);\n\
    \    nested_count\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822097
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut last_level =\
    \ 0;\n    let mut curr_level = 0;\n    for ch in paren_string.chars() {\n    \
    \    match ch {\n            '(' => {\n                curr_level += 1;\n    \
    \        }\n            ')' => {\n                curr_level -= 1;\n         \
    \   }\n            ' ' => {\n                if curr_level == 0 {\n          \
    \          result.push(last_level);\n                    last_level = 0;\n   \
    \             } else {\n                    last_level = curr_level;\n       \
    \         }\n            }\n            _ => panic!(\"Invalid input\"),\n    \
    \    }\n    }\n    result.push(last_level);\n    result\n}\n\nfn main() {\n  \
    \  let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpzor9371z.rs:33:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822097
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n        .map(|s|\
    \ s.chars().fold(0, |max, c| {\n            if c == '(' {\n                max\
    \ + 1\n            } else if c == ')' {\n                max - 1\n           \
    \ } else {\n                max\n            }\n        }))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpsj8sntvy.rs:21:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822097
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut output = Vec::new();\n    let mut max_depth = 0;\n\
    \    let mut curr_depth = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            curr_depth += 1;\n            if curr_depth > max_depth\
    \ {\n                max_depth = curr_depth;\n            }\n        } else if\
    \ c == ')' {\n            curr_depth -= 1;\n        } else if c == ' ' {\n   \
    \         output.push(max_depth);\n            max_depth = 0;\n            curr_depth\
    \ = 0;\n        }\n    }\n    output.push(max_depth);\n    output\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822097
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut current_depth = 0;\n\
    \    let mut last_paren = false;\n    let mut output = Vec::new();\n\n    for\
    \ paren in paren_string.chars() {\n        if paren == '(' {\n            current_depth\
    \ += 1;\n            last_paren = true;\n        } else if paren == ')' {\n  \
    \          current_depth -= 1;\n            last_paren = true;\n        } else\
    \ if last_paren {\n            last_paren = false;\n            output.push(max_depth);\n\
    \            max_depth = 0;\n        }\n\n        if current_depth > max_depth\
    \ {\n            max_depth = current_depth;\n        }\n    }\n\n    output.push(max_depth);\n\
    \    output\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822097
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut levels: Vec<isize> = Vec::new();\n    let mut stack:\
    \ Vec<isize> = Vec::new();\n    let mut curr_level: isize = 0;\n    let mut max_level:\
    \ isize = 0;\n    for c in paren_string.chars() {\n        match c {\n       \
    \     '(' => {\n                curr_level += 1;\n                stack.push(curr_level);\n\
    \                if curr_level > max_level {\n                    max_level =\
    \ curr_level;\n                }\n            }\n            ')' => {\n      \
    \          if stack.is_empty() {\n                    return vec![-1];\n     \
    \           }\n                curr_level = stack.pop().unwrap();\n          \
    \  }\n            ' ' => {\n                if !stack.is_empty() {\n         \
    \           return vec![-1];\n                }\n                levels.push(max_level);\n\
    \                max_level = 0;\n                curr_level = 0;\n           \
    \ }\n            _ => {\n                return vec![-1];\n            }\n   \
    \     }\n    }\n    if !stack.is_empty() {\n        return vec![-1];\n    }\n\
    \    levels.push(max_level);\n    levels\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 3, 1, 4]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpgn6ltunf.rs:46:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822097
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n        .map(|x|\
    \ {\n            let mut count = 0;\n            let mut max_count = 0;\n    \
    \        for ch in x.chars() {\n                if ch == '(' {\n             \
    \       count += 1;\n                } else if ch == ')' {\n                 \
    \   count -= 1;\n                }\n                if count > max_count {\n \
    \                   max_count = count;\n                }\n            }\n   \
    \         max_count\n        })\n        .collect()\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822097
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut idx = 0;\n    let mut max_nesting = 0;\n    let\
    \ mut curr_nesting = 0;\n    let mut num_tokens = 0;\n    let mut res: Vec<isize>\
    \ = Vec::new();\n\n    while idx < paren_string.len() {\n        match paren_string.chars().nth(idx).unwrap()\
    \ {\n            '(' => {\n                curr_nesting += 1;\n              \
    \  if curr_nesting > max_nesting {\n                    max_nesting = curr_nesting;\n\
    \                }\n            }\n            ')' => {\n                curr_nesting\
    \ -= 1;\n            }\n            ' ' => {\n                if num_tokens ==\
    \ 0 {\n                    res.push(max_nesting);\n                    max_nesting\
    \ = 0;\n                    curr_nesting = 0;\n                }\n           \
    \     num_tokens += 1;\n            }\n            _ => {}\n        }\n      \
    \  idx += 1;\n    }\n    res.push(max_nesting);\n    res\n}\n\nfn main() {\n \
    \   let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpeog6mv17.rs:40:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822097
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n        .map(|group|\
    \ count_max_nested_parens(&mut group.chars()))\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_max_nested_parens` in this scope\n\
    \ --> /tmp/tmp1lpx90f8.rs:7:22\n  |\n7 |         .map(|group| count_max_nested_parens(&mut\
    \ group.chars()))\n  |                      ^^^^^^^^^^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822097
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    // TODO: Write your solution here.\n    vec![]\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp9lk0cbsp.rs:11:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822097
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    // Converts the string into vector of characters.\n   \
    \ let mut paren_vec: Vec<char> = paren_string.chars().collect();\n    // This\
    \ vector stores current maximum level of nested parens at the given index.\n \
    \   let mut nested_parens: Vec<isize> = vec![0; paren_vec.len()];\n    // This\
    \ variable is used to construct the output vector.\n    let mut current_group_index:\
    \ usize = 0;\n    // This variable is used to construct the output vector.\n \
    \   let mut max_group_index: usize = 0;\n    // This variable keeps track of current\
    \ level of nesting.\n    let mut depth: isize = 0;\n    for i in 0..paren_vec.len()\
    \ {\n        // Increment depth for every left parenthesis encountered.\n    \
    \    if paren_vec[i] == '(' {\n            depth += 1;\n        }\n        //\
    \ Decrement depth for every right parenthesis encountered.\n        else if paren_vec[i]\
    \ == ')' {\n            depth -= 1;\n        }\n        // If a space is encountered,\
    \ the current group has been completed.\n        // Store the max nested level\
    \ and move to the next group.\n        else if paren_vec[i] == ' ' {\n       \
    \     nested_parens[current_group_index] =\n                cmp::max(nested_parens[current_group_index],\
    \ depth);\n            current_group_index += 1;\n            depth = 0;\n   \
    \     }\n        // This is a corner case where the paren string ends with a space\n\
    \        // instead of a group of parens.\n        if i == paren_vec.len() - 1\
    \ {\n            nested_parens[current_group_index] =\n                cmp::max(nested_parens[current_group_index],\
    \ depth);\n            current_group_index += 1;\n            depth = 0;\n   \
    \     }\n    }\n    nested_parens.truncate(current_group_index);\n    nested_parens\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmp0657o9go.rs:28:17\n   |\n28 |                 cmp::max(nested_parens[current_group_index],\
    \ depth);\n   |                 ^^^ use of undeclared crate or module `cmp`\n\n\
    error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n  -->\
    \ /tmp/tmp0657o9go.rs:36:17\n   |\n36 |                 cmp::max(nested_parens[current_group_index],\
    \ depth);\n   |                 ^^^ use of undeclared crate or module `cmp`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659822097
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut results = Vec::new();\n    let mut current_nesting_level\
    \ = 0;\n    let mut max_nesting_level = 0;\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                current_nesting_level\
    \ += 1;\n                if current_nesting_level > max_nesting_level {\n    \
    \                max_nesting_level = current_nesting_level;\n                }\n\
    \            }\n            ')' => {\n                current_nesting_level -=\
    \ 1;\n            }\n            ' ' => {\n                if current_nesting_level\
    \ != 0 {\n                    panic!(\"Unbalanced parens\");\n               \
    \ }\n                results.push(max_nesting_level);\n                max_nesting_level\
    \ = 0;\n            }\n            _ => panic!(\"Invalid characters in string\"\
    ),\n        }\n    }\n    if current_nesting_level != 0 {\n        panic!(\"Unbalanced\
    \ parens\");\n    }\n    results.push(max_nesting_level);\n    results\n}\n\n\
    fn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822097
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n        .map(|group|\
    \ {\n            let mut level = 0;\n            let mut max_level = 0;\n    \
    \        for c in group.chars() {\n                match c {\n               \
    \     '(' => level += 1,\n                    ')' => level -= 1,\n           \
    \         _ => {}\n                }\n                max_level = max_level.max(level);\n\
    \            }\n            max_level\n        })\n        .collect()\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822097
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split(\" \")\n        .map(|x| {\n\
    \            let mut depth = 0;\n            let mut max_depth = 0;\n        \
    \    for c in x.chars() {\n                if c == '(' {\n                   \
    \ depth += 1;\n                } else if c == ')' {\n                    depth\
    \ -= 1;\n                }\n\n                if depth > max_depth {\n       \
    \             max_depth = depth;\n                }\n            }\n         \
    \   max_depth\n        })\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822097
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_parens = vec![];\n    let mut paren_level =\
    \ 0;\n    let mut max_level = 0;\n    let mut in_parens = false;\n    for c in\
    \ paren_string.chars() {\n        match c {\n            '(' => {\n          \
    \      paren_level += 1;\n                in_parens = true;\n            }\n \
    \           ')' => {\n                paren_level -= 1;\n                if paren_level\
    \ == 0 {\n                    in_parens = false;\n                    max_parens.push(max_level);\n\
    \                    max_level = 0;\n                }\n            }\n      \
    \      ' ' => {\n                if in_parens {\n                    max_level\
    \ = max(max_level, paren_level);\n                }\n            }\n         \
    \   _ => {}\n        }\n    }\n    max_parens\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpytu7qdg9.rs:25:33\n\
    \   |\n25 |                     max_level = max(max_level, paren_level);\n   |\
    \                                 ^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659822097
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut output: Vec<isize> = Vec::new();\n    let mut stack:\
    \ Vec<char> = Vec::new();\n    let mut paren_chars: Vec<char> = paren_string.chars().collect();\n\
    \    let mut deepest_nesting: isize = 0;\n    let mut i: usize = 0;\n    while\
    \ i < paren_chars.len() {\n        match paren_chars[i] {\n            '(' =>\
    \ {\n                stack.push(paren_chars[i]);\n                deepest_nesting\
    \ += 1;\n            }\n            ')' => {\n                match stack.pop()\
    \ {\n                    Some(_) => {\n                        deepest_nesting\
    \ -= 1;\n                    }\n                    None => {}\n             \
    \   }\n            }\n            ' ' => {\n                output.push(deepest_nesting);\n\
    \                deepest_nesting = 0;\n            }\n            _ => {\n   \
    \             stack.push(paren_chars[i]);\n            }\n        }\n        i\
    \ += 1;\n    }\n    if !stack.is_empty() {\n        output.push(deepest_nesting);\n\
    \    }\n    output\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp9n_m3qr0.rs:42:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822097
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split(\" \")\n        .map(|s| s.chars().fold(0isize,\
    \ |acc, c| {\n            if c == '(' {\n                acc + 1\n           \
    \ } else if c == ')' {\n                acc - 1\n            } else {\n      \
    \          acc\n            }\n        }))\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmps0h6pg0z.rs:21:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822097
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut levels: Vec<isize> = Vec::new();\n    let mut depth:\
    \ isize = 0;\n    let mut start: bool = false;\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                if start {\n   \
    \                 depth += 1;\n                } else {\n                    start\
    \ = true;\n                }\n            }\n            ')' => {\n          \
    \      if depth == 0 {\n                    start = false;\n                 \
    \   levels.push(0);\n                } else {\n                    depth -= 1;\n\
    \                }\n            }\n            _ => {\n                if start\
    \ {\n                    levels.push(depth);\n                    start = false;\n\
    \                }\n            }\n        }\n    }\n    if start {\n        levels.push(depth);\n\
    \    }\n    levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpon969k77.rs:41:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822097
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut output: Vec<isize> = Vec::new();\n    let mut current_max\
    \ = 0;\n    let mut open_paren_count = 0;\n    for c in paren_string.chars() {\n\
    \        if c == '(' {\n            open_paren_count += 1;\n            if open_paren_count\
    \ > current_max {\n                current_max = open_paren_count;\n         \
    \   }\n        } else if c == ')' {\n            open_paren_count -= 1;\n    \
    \    } else if c == ' ' {\n            // reset\n            output.push(current_max);\n\
    \            current_max = 0;\n            open_paren_count = 0;\n        }\n\
    \    }\n    output.push(current_max);\n    output\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822097
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut res = Vec::new();\n    let mut paren_group_iter\
    \ = paren_string.split_whitespace();\n    while let Some(group) = paren_group_iter.next()\
    \ {\n        let mut paren_iter = group.chars();\n        let mut curr_max = 0;\n\
    \        let mut curr_nesting = 0;\n        while let Some(paren) = paren_iter.next()\
    \ {\n            if paren == '(' {\n                curr_nesting += 1;\n     \
    \           if curr_nesting > curr_max {\n                    curr_max = curr_nesting;\n\
    \                }\n            } else if paren == ')' {\n                curr_nesting\
    \ -= 1;\n            }\n        }\n        res.push(curr_max);\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822097
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut vec = Vec::new();\n    let paren_string = paren_string.chars().collect::<Vec<char>>();\n\
    \    let mut max_nesting = 0;\n    let mut nesting = 0;\n    for i in paren_string\
    \ {\n        match i {\n            '(' => {\n                nesting += 1;\n\
    \                if nesting > max_nesting {\n                    max_nesting =\
    \ nesting;\n                }\n            }\n            ')' => {\n         \
    \       nesting -= 1;\n            }\n            ' ' => {\n                vec.push(max_nesting);\n\
    \                max_nesting = 0;\n                nesting = 0;\n            }\n\
    \            _ => (),\n        }\n    }\n    vec.push(max_nesting);\n    vec\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822097
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    // Initialize a stack to keep track of the current depth\
    \ of nesting\n    let mut stack: Vec<isize> = Vec::new();\n    // Initialize the\
    \ depth to zero\n    let mut depth: isize = 0;\n    // Initialize a vector to\
    \ store the maximum nesting of each individual group\n    let mut max_nest: Vec<isize>\
    \ = Vec::new();\n    // Iterate through each character\n    for c in paren_string.chars()\
    \ {\n        // Match on the character being a '(', ')' or a space\n        match\
    \ c {\n            '(' => {\n                // Increment the depth\n        \
    \        depth += 1;\n                // Push the depth to the stack\n       \
    \         stack.push(depth);\n            }\n            ')' => {\n          \
    \      // Match on the stack being empty\n                match stack.pop() {\n\
    \                    // If it's empty, then there's an error\n               \
    \     None => panic!(\"No matching '(' to close out with\"),\n               \
    \     // Otherwise, the depth is what was just popped off the stack\n        \
    \            Some(x) => depth = x,\n                }\n            }\n       \
    \     ' ' => {\n                // Store the maximum depth of the current group\n\
    \                max_nest.push(depth);\n                // Clear the stack and\
    \ reset the depth\n                stack.clear();\n                depth = 0;\n\
    \            }\n            _ => panic!(\"Unrecognized character!\"),\n      \
    \  }\n    }\n    // Store the maximum depth of the last group\n    max_nest.push(depth);\n\
    \    // Return the vector of maximum depths\n    max_nest\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 1, 1]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpzqulesck.rs:48:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822097
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    // Split input string into groups of nested parentheses\
    \ separated by spaces.\n    let mut paren_strings = paren_string.split_whitespace();\n\
    \    let mut levels: Vec<isize> = Vec::new();\n\n    loop {\n        // Assign\
    \ parens to current_group. If there are no more group in the input, exit loop.\n\
    \        let current_group = match paren_strings.next() {\n            Some(x)\
    \ => x,\n            None => break,\n        };\n\n        // Maximum level of\
    \ nesting in this group\n        let mut current_level = 0;\n        // Number\
    \ of open parens so far in this group\n        let mut current_open = 0;\n\n \
    \       // Iterate through every parenthesis in the group\n        for &paren\
    \ in current_group.as_bytes() {\n            match paren {\n                b'('\
    \ => {\n                    // If open paren, increment current_open, then see\
    \ if the current_open is\n                    // greater than current_level. If\
    \ so, assign it to current_level.\n                    current_open += 1;\n  \
    \                  if current_open > current_level {\n                       \
    \ current_level = current_open;\n                    }\n                }\n  \
    \              b')' => {\n                    // If close paren, just decrement\
    \ current_open.\n                    current_open -= 1;\n                }\n \
    \               _ => {\n                    // Panic on any invalid character.\n\
    \                    panic!(\"unexpected character {}\", paren as char);\n   \
    \             }\n            }\n        }\n\n        // Confirm that current_open\
    \ is zero at the end of the group, then add current_level to levels.\n       \
    \ assert_eq!(current_open, 0);\n        levels.push(current_level);\n    }\n\n\
    \    levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822097
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut stack = Vec::new();\n    let mut max_stack_size\
    \ = 0;\n    let mut count = Vec::new();\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                stack.push(c);\n   \
    \             if stack.len() > max_stack_size {\n                    max_stack_size\
    \ = stack.len();\n                }\n            }\n            ')' => {\n   \
    \             stack.pop();\n            }\n            ' ' => {\n            \
    \    count.push(max_stack_size as isize);\n                max_stack_size = 0;\n\
    \            }\n            _ => {}\n        }\n    }\n    count.push(max_stack_size\
    \ as isize);\n    count\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822097
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    // This is a stack to keep track of the current deepest\
    \ level of paren nesting.\n    let mut deepest_stack: Vec<isize> = Vec::new();\n\
    \    // This is a buffer to keep track of the current nesting level of paren nesting.\n\
    \    let mut buffer_stack: Vec<isize> = Vec::new();\n    let mut current_level:\
    \ isize = 0;\n    let mut output: Vec<isize> = Vec::new();\n\n    // For each\
    \ character in the input string\n    for c in paren_string.chars() {\n       \
    \ // If the character is a '(', push 1 to buffer stack and update the current\
    \ level\n        if c == '(' {\n            buffer_stack.push(1);\n          \
    \  current_level += 1;\n        }\n        // If the character is a ')', pop from\
    \ the buffer stack and update the current level\n        else if c == ')' {\n\
    \            buffer_stack.pop();\n            current_level -= 1;\n        }\n\
    \        // If the character is a space, compare the current level with the deepest\
    \ level on the stack\n        // If current level is greater than the deepest\
    \ level, push current level to the stack\n        // Otherwise, pop the stack\
    \ and push current level to the stack\n        else if c == ' ' {\n          \
    \  if deepest_stack.is_empty() {\n                deepest_stack.push(current_level);\n\
    \            } else if current_level > deepest_stack[deepest_stack.len() - 1]\
    \ {\n                deepest_stack.push(current_level);\n            } else {\n\
    \                deepest_stack.pop();\n                deepest_stack.push(current_level);\n\
    \            }\n        }\n    }\n\n    // For each level on the stack, push to\
    \ the output vector\n    for level in deepest_stack {\n        output.push(level);\n\
    \    }\n\n    // Return the output vector\n    output\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpgzxyq3yw.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822097
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0;\n    let mut max_levels = Vec::new();\n\
    \    let mut current_level = 0;\n    let mut is_level_started = false;\n    for\
    \ c in paren_string.chars() {\n        if c == '(' {\n            if is_level_started\
    \ {\n                level += 1;\n            } else {\n                is_level_started\
    \ = true;\n            }\n        } else if c == ')' {\n            if level ==\
    \ 0 {\n                max_levels.push(current_level);\n                current_level\
    \ = 0;\n                is_level_started = false;\n            } else {\n    \
    \            level -= 1;\n            }\n        } else if c == ' ' {\n      \
    \      if is_level_started {\n                current_level = level;\n       \
    \     }\n        }\n    }\n    max_levels\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpom7nt0x6.rs:35:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822097
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth: isize = 0;\n    let mut curr_depth:\
    \ isize = 0;\n    let mut output: Vec<isize> = Vec::new();\n\n    for char in\
    \ paren_string.chars() {\n        match char {\n            '(' => {\n       \
    \         curr_depth += 1;\n                if curr_depth > max_depth {\n    \
    \                max_depth = curr_depth;\n                }\n            }\n \
    \           ')' => {\n                curr_depth -= 1;\n            }\n      \
    \      ' ' => {\n                output.push(max_depth);\n                max_depth\
    \ = 0;\n                curr_depth = 0;\n            }\n            _ => (),\n\
    \        }\n    }\n    output.push(max_depth);\n    output\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822097
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut levels = Vec::new();\n    let mut level = 0;\n\
    \    for c in paren_string.chars() {\n        match c {\n            '(' => level\
    \ += 1,\n            ')' => level -= 1,\n            _ => (),\n        }\n   \
    \     levels.push(level);\n    }\n    levels\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 1, 2, 1, 0, 0, 1, 2, 3, 2, 1, 0, 0, 1, 0, 0, 1, 2, 3, 2, 1, 2, 1, 2,\
    \ 1, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp44hlmp7k.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822097
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut current_level\
    \ = 0;\n    let mut max_level = 0;\n    for char in paren_string.chars() {\n \
    \       if char == '(' {\n            current_level += 1;\n            if current_level\
    \ > max_level {\n                max_level = current_level;\n            }\n \
    \       } else if char == ')' {\n            current_level -= 1;\n        }\n\
    \    }\n    paren_levels.push(max_level);\n    paren_levels\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp5jqw9vbq.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822097
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                if depth != 0 {\n                 \
    \   panic!(\"Parser error!\");\n                }\n                depths.push(max_depth);\n\
    \                max_depth = 0;\n            }\n            _ => panic!(\"Parser\
    \ error!\"),\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\n\
    fn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822097
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut list_of_max_nesting = Vec::new();\n    let mut\
    \ start_nesting = 0;\n    let mut max_nesting = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            start_nesting += 1;\n            if start_nesting\
    \ > max_nesting {\n                max_nesting = start_nesting;\n            }\n\
    \        } else if c == ')' {\n            start_nesting -= 1;\n        } else\
    \ if c == ' ' {\n            list_of_max_nesting.push(max_nesting);\n        \
    \    max_nesting = 0;\n            start_nesting = 0;\n        }\n    }\n    if\
    \ max_nesting > 0 {\n        list_of_max_nesting.push(max_nesting);\n    }\n \
    \   list_of_max_nesting\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822097
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut vec = Vec::new();\n    let v = paren_string.split_whitespace().collect::<Vec<&str>>();\n\
    \    for i in v {\n        vec.push(i.chars().fold(0, |mut acc, c| {\n       \
    \     if c == '(' {\n                acc += 1;\n            } else if c == ')'\
    \ {\n                acc -= 1;\n            }\n            acc\n        }));\n\
    \    }\n    vec\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp55_2v8wd.rs:22:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822097
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = vec![];\n    let mut curr_count =\
    \ 0;\n    let mut max_count = 0;\n    for c in paren_string.chars() {\n      \
    \  match c {\n            '(' => {\n                curr_count += 1;\n       \
    \         if curr_count > max_count {\n                    max_count = curr_count;\n\
    \                }\n            }\n            ')' => {\n                curr_count\
    \ -= 1;\n            }\n            ' ' => {\n                max_nesting.push(max_count);\n\
    \                max_count = 0;\n                curr_count = 0;\n           \
    \ }\n            _ => {\n                println!(\"Invalid character\");\n  \
    \          }\n        }\n    }\n    max_nesting.push(max_count);\n    max_nesting\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822097
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut groups = paren_string.split_whitespace();\n   \
    \ let mut max_depth_vec = Vec::new();\n    while let Some(group) = groups.next()\
    \ {\n        let mut level = 0;\n        let mut deepest_level = 0;\n        for\
    \ paren in group.chars() {\n            match paren {\n                '(' =>\
    \ level += 1,\n                ')' => level -= 1,\n                _ => panic!(\"\
    Unknown character in group\"),\n            }\n            if level > deepest_level\
    \ {\n                deepest_level = level;\n            }\n        }\n      \
    \  max_depth_vec.push(deepest_level);\n    }\n    max_depth_vec\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822097
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_nesting_count = Vec::new();\n    let mut\
    \ current_count = 0;\n    let mut max_count = 0;\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                current_count +=\
    \ 1;\n                if current_count > max_count {\n                    max_count\
    \ = current_count;\n                }\n            }\n            ')' => {\n \
    \               current_count -= 1;\n            }\n            ' ' => {\n   \
    \             paren_nesting_count.push(max_count);\n                max_count\
    \ = 0;\n                current_count = 0;\n            }\n            _ => {}\n\
    \        }\n    }\n    paren_nesting_count.push(max_count);\n    paren_nesting_count\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822098
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0;\n    let mut res = Vec::new();\n   \
    \ for ch in paren_string.chars() {\n        match ch {\n            '(' => level\
    \ += 1,\n            ')' => level -= 1,\n            _ => {}\n        }\n    \
    \    res.push(level);\n    }\n    res\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 1, 2, 1, 0, 0, 1, 2, 3, 2, 1, 0, 0, 1, 0, 0, 1, 2, 3, 2, 1, 2, 1, 2,\
    \ 1, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpb5_q6vuu.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822098
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_levels = Vec::new();\n    let mut level = 0;\n\
    \    let mut max_level = 0;\n    for c in paren_string.chars() {\n        if c\
    \ == '(' {\n            level += 1;\n            if level > max_level {\n    \
    \            max_level = level;\n            }\n        } else if c == ')' {\n\
    \            level -= 1;\n        } else if c == ' ' {\n            if level !=\
    \ 0 {\n                panic!(\"Invalid parentheses in paren_string: {}\", paren_string);\n\
    \            }\n            max_levels.push(max_level);\n            max_level\
    \ = 0;\n        } else {\n            panic!(\"Invalid character {} in paren_string:\
    \ {}\", c, paren_string);\n        }\n    }\n    max_levels.push(max_level);\n\
    \    return max_levels;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822098
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split(\" \")\n        .map(|item|\
    \ get_nested_parens_levels(item))\n        .collect()\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_nested_parens_levels` in this scope\n\
    \ --> /tmp/tmp5v4c5db2.rs:7:21\n  |\n7 |         .map(|item| get_nested_parens_levels(item))\n\
    \  |                     ^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822097
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    //vec![paren_string.len() as isize]\n    //TODO : Implement\
    \ this function\n    let mut depth = 0;\n    let mut max_depth = 0;\n    let mut\
    \ depths = Vec::new();\n    for ch in paren_string.chars() {\n        if ch ==\
    \ '(' {\n            depth += 1;\n            if depth > max_depth {\n       \
    \         max_depth = depth;\n            }\n        } else if ch == ')' {\n \
    \           depth -= 1;\n        } else if ch == ' ' {\n            depths.push(max_depth);\n\
    \            max_depth = 0;\n            depth = 0;\n        }\n    }\n    depths.push(max_depth);\n\
    \    depths\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822098
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth: isize = 0;\n    let mut curr_depth:\
    \ isize = 0;\n    let mut depths: Vec<isize> = Vec::new();\n\n    for ch in paren_string.chars()\
    \ {\n        if ch == '(' {\n            curr_depth += 1;\n            if curr_depth\
    \ > max_depth {\n                max_depth = curr_depth;\n            }\n    \
    \    } else if ch == ')' {\n            curr_depth -= 1;\n        } else if ch\
    \ == ' ' {\n            depths.push(max_depth);\n            max_depth = 0;\n\
    \            curr_depth = 0;\n        }\n    }\n    depths.push(max_depth);\n\
    \    depths\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822098
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = isize::min_value();\n    let mut depth\
    \ = 0;\n    let mut depths = Vec::new();\n    for char in paren_string.chars()\
    \ {\n        match char {\n            '(' => {\n                depth += 1;\n\
    \                if depth > max_depth {\n                    max_depth = depth;\n\
    \                }\n            }\n            ')' => {\n                depth\
    \ -= 1;\n            }\n            ' ' => {\n                if depth == 0 {\n\
    \                    depths.push(max_depth);\n                    max_depth =\
    \ isize::min_value();\n                }\n            }\n            _ => {}\n\
    \        }\n    }\n    if depth == 0 {\n        depths.push(max_depth);\n    }\n\
    \    depths\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822098
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level_stack: Vec<isize> = Vec::new();\n    let\
    \ mut max_level: isize = 0;\n    let mut current_level: isize = 0;\n    let mut\
    \ output: Vec<isize> = Vec::new();\n\n    for c in paren_string.chars() {\n  \
    \      match c {\n            '(' => {\n                current_level += 1;\n\
    \                level_stack.push(current_level);\n                if current_level\
    \ > max_level {\n                    max_level = current_level;\n            \
    \    }\n            }\n            ')' => {\n                current_level -=\
    \ 1;\n                level_stack.pop();\n            }\n            ' ' => {\n\
    \                if !level_stack.is_empty() {\n                    println!(\"\
    Error: Invalid string detected!\");\n                    return output;\n    \
    \            }\n                current_level = 0;\n                output.push(max_level);\n\
    \                max_level = 0;\n            }\n            _ => {\n         \
    \       println!(\"Error: Invalid string detected!\");\n                return\
    \ output;\n            }\n        }\n    }\n\n    output.push(max_level);\n  \
    \  output\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822098
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut levels: Vec<isize> = Vec::new();\n    for parens\
    \ in paren_string.split_whitespace() {\n        let mut level = 0;\n        let\
    \ mut max_level = 0;\n        for paren in parens.chars() {\n            if paren\
    \ == '(' {\n                level += 1;\n            } else if paren == ')' {\n\
    \                level -= 1;\n            }\n            if level > max_level\
    \ {\n                max_level = level;\n            }\n        }\n        levels.push(max_level);\n\
    \    }\n    levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822098
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut stack: Vec<isize> = Vec::new();\n    let mut paren_string\
    \ = paren_string.split_whitespace();\n    let mut levels: Vec<isize> = Vec::new();\n\
    \    for paren in paren_string {\n        let mut current_max = 0;\n        for\
    \ c in paren.chars() {\n            if c == '(' {\n                stack.push(1);\n\
    \                current_max += 1;\n            } else if c == ')' {\n       \
    \         if stack.is_empty() {\n                    current_max = -1;\n     \
    \               break;\n                } else {\n                    stack.pop();\n\
    \                }\n            }\n        }\n        if !stack.is_empty() {\n\
    \            current_max = -1;\n        }\n        levels.push(current_max);\n\
    \    }\n    levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 3, 1, 5]`,\n right: `[2, 3, 1, 3]`', /tmp/tmprtu4mfw1.rs:33:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822098
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut last_start_idx = 0;\n    let mut max_levels = vec![];\n\
    \    let mut num_open_parens = 0;\n    let mut max_num_open_parens = 0;\n    for\
    \ (idx, c) in paren_string.chars().enumerate() {\n        if c == '(' {\n    \
    \        num_open_parens += 1;\n            if num_open_parens > max_num_open_parens\
    \ {\n                max_num_open_parens = num_open_parens;\n            }\n \
    \       } else if c == ')' {\n            num_open_parens -= 1;\n            if\
    \ num_open_parens == 0 {\n                max_levels.push(max_num_open_parens);\n\
    \                max_num_open_parens = 0;\n                last_start_idx = idx\
    \ + 1;\n            }\n        }\n    }\n    return max_levels;\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822098
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut output = Vec::new();\n    for group in paren_string.split_whitespace()\
    \ {\n        let mut paren_stack = vec![];\n        let mut max_depth = 0;\n \
    \       for c in group.chars() {\n            match c {\n                '(' =>\
    \ {\n                    paren_stack.push(c);\n                    max_depth =\
    \ cmp::max(max_depth, paren_stack.len() as isize);\n                }\n      \
    \          ')' => {\n                    paren_stack.pop();\n                }\n\
    \                _ => {}\n            }\n        }\n        output.push(max_depth);\n\
    \    }\n    output\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmpdz7gbzw6.rs:13:33\n   |\n13 |                     max_depth = cmp::max(max_depth,\
    \ paren_stack.len() as isize);\n   |                                 ^^^ use of\
    \ undeclared crate or module `cmp`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659822097
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_vec: Vec<char> = Vec::new();\n    let mut\
    \ idx_vec: Vec<usize> = Vec::new();\n    let mut max_level: isize = 0;\n    let\
    \ mut level: isize = 0;\n    let mut max_vec: Vec<isize> = Vec::new();\n\n   \
    \ for (idx, c) in paren_string.chars().enumerate() {\n        if c == '(' {\n\
    \            level += 1;\n            paren_vec.push(c);\n            idx_vec.push(idx);\n\
    \        } else if c == ')' {\n            if level > max_level {\n          \
    \      max_level = level;\n            }\n            level -= 1;\n          \
    \  paren_vec.push(c);\n            idx_vec.push(idx);\n        }\n    }\n\n  \
    \  println!(\"paren_vec = {:?}\", paren_vec);\n    println!(\"idx_vec = {:?}\"\
    , idx_vec);\n    println!(\"max_level = {}\", max_level);\n\n    for _ in 0..max_level\
    \ {\n        max_vec.push(0);\n    }\n\n    for i in 0..paren_vec.len() {\n  \
    \      if paren_vec[i] == '(' {\n            let mut search_idx = i + 1;\n   \
    \         while search_idx < paren_vec.len() {\n                if paren_vec[search_idx]\
    \ == ')' {\n                    let level_diff = (idx_vec[search_idx] - idx_vec[i])\
    \ as isize;\n                    if level_diff < max_level && level_diff >= 0\
    \ {\n                        max_vec[level_diff as usize] += 1;\n            \
    \        }\n                    search_idx += 1;\n                } else {\n \
    \                   search_idx += 1;\n                }\n            }\n     \
    \   }\n    }\n\n    println!(\"max_vec = {:?}\", max_vec);\n\n    max_vec\n}\n\
    \nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 7, 7]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp5tsz5ohf.rs:58:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: 'paren_vec = [''('', ''('', '')'', ''('', '')'', '')'', ''('', ''('', ''('',
    '')'', '')'', '')'', ''('', '')'', ''('', ''('', ''('', '')'', '')'', ''('', '')'',
    ''('', '')'', '')'']

    idx_vec = [0, 1, 2, 3, 4, 5, 7, 8, 9, 10, 11, 12, 14, 15, 17, 18, 19, 20, 21,
    22, 23, 24, 25, 26]

    max_level = 3

    max_vec = [0, 7, 7]

    '
  timestamp: 1659822098
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n        .map(|x|\
    \ parse_nested_parens_helper(x))\n        .collect()\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `parse_nested_parens_helper` in this\
    \ scope\n --> /tmp/tmpwevy9yap.rs:7:18\n  |\n7 |         .map(|x| parse_nested_parens_helper(x))\n\
    \  |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822097
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut parsed_parens: Vec<isize> = Vec::new();\n    let\
    \ mut paren_stack: Vec<char> = Vec::new();\n    let mut max_level: isize = 0;\n\
    \    let mut level: isize = 0;\n\n    for ch in paren_string.chars() {\n     \
    \   if ch == '(' {\n            paren_stack.push(ch);\n            level += 1;\n\
    \            if level > max_level {\n                max_level = level;\n    \
    \        }\n        } else if ch == ')' {\n            if paren_stack.pop() ==\
    \ Some('(') {\n                level -= 1;\n            } else {\n           \
    \     level = 0;\n            }\n        } else if ch == ' ' {\n            parsed_parens.push(max_level);\n\
    \            max_level = 0;\n            level = 0;\n        }\n    }\n\n    parsed_parens.push(max_level);\n\
    \    parsed_parens\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822098
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut stack: Vec<isize> = Vec::new();\n    let mut max_nesting:\
    \ isize = 0;\n    let mut max_nesting_vec: Vec<isize> = Vec::new();\n    let paren_string\
    \ = paren_string.trim().to_string();\n    let chars: Vec<char> = paren_string.chars().collect();\n\
    \    for ch in chars {\n        match ch {\n            '(' => {\n           \
    \     max_nesting += 1;\n                stack.push(max_nesting);\n          \
    \  }\n            ')' => {\n                max_nesting_vec.push(stack.pop().unwrap());\n\
    \            }\n            _ => {\n                panic!(\"Unexpected character\"\
    );\n            }\n        }\n    }\n    max_nesting_vec\n}\n\nfn main() {\n \
    \   let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''Unexpected character'', /tmp/tmp4ubifaes.rs:20:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822098
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting_level: isize = 0;\n    let mut max_levels:\
    \ Vec<isize> = Vec::new();\n    let mut curr_nesting_level: isize = 0;\n    for\
    \ c in paren_string.chars() {\n        if c == '(' {\n            curr_nesting_level\
    \ += 1;\n            if curr_nesting_level > max_nesting_level {\n           \
    \     max_nesting_level = curr_nesting_level;\n            }\n        } else if\
    \ c == ')' {\n            if curr_nesting_level == max_nesting_level {\n     \
    \           max_levels.push(max_nesting_level);\n            }\n            curr_nesting_level\
    \ -= 1;\n        }\n    }\n    max_levels\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 2, 3, 3]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp0qkbk3cs.rs:26:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822098
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut output: Vec<isize> = Vec::new();\n    let mut stack:\
    \ Vec<char> = Vec::new();\n    let mut current_max = 0;\n    let mut current_sum\
    \ = 0;\n    for c in paren_string.chars() {\n        match c {\n            '('\
    \ => {\n                stack.push(c);\n                current_sum += 1;\n  \
    \              if current_sum > current_max {\n                    current_max\
    \ = current_sum;\n                }\n            }\n            ')' => {\n   \
    \             stack.pop();\n                current_sum -= 1;\n            }\n\
    \            ' ' => {\n                output.push(current_max);\n           \
    \     current_max = 0;\n                current_sum = 0;\n            }\n    \
    \        _ => panic!(\"Unrecognized character in string\"),\n        }\n    }\n\
    \    output.push(current_max);\n    output\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822098
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut groups = paren_string.split_whitespace();\n   \
    \ let mut max_nest_levels = Vec::new();\n    loop {\n        match groups.next()\
    \ {\n            Some(group) => {\n                max_nest_levels.push(get_max_nest_level(group));\n\
    \            }\n            None => {\n                break;\n            }\n\
    \        }\n    }\n    max_nest_levels\n}\n\nfn main() {\n    let candidate =\
    \ parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_max_nest_level` in this scope\n\
    \  --> /tmp/tmpgxkik55q.rs:10:38\n   |\n10 |                 max_nest_levels.push(get_max_nest_level(group));\n\
    \   |                                      ^^^^^^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `max_nest_levels`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822097
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut out = Vec::new();\n    let mut max_depth = 0;\n\
    \    let mut current_depth = 0;\n    for c in paren_string.chars() {\n       \
    \ if c == '(' {\n            current_depth += 1;\n            if current_depth\
    \ > max_depth {\n                max_depth = current_depth;\n            }\n \
    \       } else if c == ')' {\n            current_depth -= 1;\n        } else\
    \ if c == ' ' {\n            out.push(max_depth);\n            max_depth = 0;\n\
    \            current_depth = 0;\n        }\n    }\n    out.push(max_depth);\n\
    \    out\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822098
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_level: isize = 0;\n    let mut count: isize\
    \ = 0;\n    let mut result: Vec<isize> = Vec::new();\n\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            count += 1;\n            if count > max_level\
    \ {\n                max_level = count;\n            }\n        } else if c ==\
    \ ')' {\n            count -= 1;\n        } else if c == ' ' {\n            result.push(max_level);\n\
    \            max_level = 0;\n            count = 0;\n        }\n    }\n    result.push(max_level);\n\
    \    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822098
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n        .map(|s|\
    \ count_nesting_level(s))\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_nesting_level` in this scope\n\
    \ --> /tmp/tmplpgwp4n3.rs:7:18\n  |\n7 |         .map(|s| count_nesting_level(s))\n\
    \  |                  ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659822097
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut results = Vec::new();\n    for g in paren_string.split_whitespace()\
    \ {\n        let mut max_nest = 0;\n        let mut current_nest = 0;\n      \
    \  for c in g.chars() {\n            match c {\n                '(' => current_nest\
    \ += 1,\n                ')' => current_nest -= 1,\n                _ => {}\n\
    \            }\n            if current_nest > max_nest {\n                max_nest\
    \ = current_nest;\n            }\n        }\n        results.push(max_nest);\n\
    \    }\n    results\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822098
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut deepest_nesting_array = Vec::new();\n    let paren_array:\
    \ Vec<&str> = paren_string.split(\" \").collect();\n    for paren_group in paren_array\
    \ {\n        let mut open_paren_count = 0;\n        let mut max_open_paren_count\
    \ = 0;\n        for c in paren_group.chars() {\n            if c == '(' {\n  \
    \              open_paren_count += 1;\n                if open_paren_count > max_open_paren_count\
    \ {\n                    max_open_paren_count = open_paren_count;\n          \
    \      }\n            } else if c == ')' {\n                open_paren_count -=\
    \ 1;\n            }\n        }\n        deepest_nesting_array.push(max_open_paren_count);\n\
    \    }\n    deepest_nesting_array\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822098
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut answers: Vec<isize> = Vec::new();\n    for group\
    \ in paren_string.split_whitespace() {\n        // keep track of the current level\
    \ of nested parens\n        let mut level: isize = 0;\n        // keep track of\
    \ the max level of nested parens\n        let mut max_level: isize = 0;\n    \
    \    // iterate through the current group and update levels of nesting as we go\n\
    \        for paren in group.chars() {\n            if paren == '(' {\n       \
    \         level += 1;\n            } else if paren == ')' {\n                level\
    \ -= 1;\n            }\n            // update max level if needed\n          \
    \  if level > max_level {\n                max_level = level;\n            }\n\
    \        }\n        answers.push(max_level);\n    }\n    answers\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822098
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut res: Vec<isize> = Vec::new();\n    let mut curr_count:\
    \ isize = 0;\n    let mut max_count: isize = 0;\n    let mut first_paren: bool\
    \ = true;\n    for c in paren_string.chars() {\n        match c {\n          \
    \  '(' => {\n                if first_paren {\n                    curr_count\
    \ = 0;\n                    first_paren = false;\n                }\n        \
    \        curr_count += 1;\n                if curr_count > max_count {\n     \
    \               max_count = curr_count;\n                }\n            }\n  \
    \          ')' => {\n                curr_count -= 1;\n            }\n       \
    \     ' ' => {\n                first_paren = true;\n                res.push(max_count);\n\
    \                max_count = 0;\n            }\n            _ => (),\n       \
    \ }\n    }\n    res.push(max_count);\n    res\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822098
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut stack: Vec<isize> = Vec::new();\n    let mut max_nesting\
    \ = 0;\n    let mut max_nesting_vec: Vec<isize> = Vec::new();\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            max_nesting += 1;\n            stack.push(max_nesting);\n\
    \        } else if c == ')' {\n            let pop = stack.pop().unwrap();\n \
    \           max_nesting_vec.push(pop);\n            max_nesting -= 1;\n      \
    \  }\n    }\n    max_nesting_vec\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 2, 1, 3, 2, 1, 1, 3, 2, 2, 2, 1]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpukki8lpx.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822098
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut depths = Vec::new();\n    let mut depth = 0;\n\
    \    let mut max_depth = 0;\n    for ch in paren_string.chars() {\n        if\
    \ ch == '(' {\n            depth += 1;\n            if depth > max_depth {\n \
    \               max_depth = depth;\n            }\n        } else if ch == ')'\
    \ {\n            depth -= 1;\n        } else if ch == ' ' {\n            depths.push(max_depth);\n\
    \            max_depth = 0;\n            depth = 0;\n        }\n    }\n    depths.push(max_depth);\n\
    \    depths\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822098
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_level = 0;\n    let mut level = 0;\n    let\
    \ mut deepest_level = Vec::new();\n    for each_char in paren_string.chars() {\n\
    \        match each_char {\n            '(' => {\n                level += 1;\n\
    \                if level > max_level {\n                    max_level = level;\n\
    \                }\n            }\n            ')' => {\n                level\
    \ -= 1;\n            }\n            ' ' => {\n                deepest_level.push(max_level);\n\
    \                max_level = 0;\n                level = 0;\n            }\n \
    \           _ => (),\n        }\n    }\n    deepest_level.push(max_level);\n \
    \   deepest_level\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822098
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut nesting_levels =\
    \ Vec::new();\n    let mut paren_string = paren_string.chars();\n    while let\
    \ Some(c) = paren_string.next() {\n        if c == '(' {\n            max_nesting\
    \ += 1;\n        } else if c == ')' {\n            nesting_levels.push(max_nesting);\n\
    \            max_nesting -= 1;\n        } else if c == ' ' {\n            nesting_levels.push(max_nesting);\n\
    \        }\n    }\n    nesting_levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 2, 1, 0, 3, 2, 1, 0, 1, 0, 3, 2, 2, 2, 1]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpop5qgtm5.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822098
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut output: Vec<isize> = Vec::new();\n    let mut nested_level:\
    \ isize = 0;\n    let mut max_nested_level: isize = 0;\n    let mut paren_string\
    \ = paren_string.trim().to_string();\n    paren_string.push(' ');\n\n    for c\
    \ in paren_string.chars() {\n        if c == '(' {\n            nested_level +=\
    \ 1;\n            if nested_level > max_nested_level {\n                max_nested_level\
    \ = nested_level;\n            }\n        } else if c == ')' {\n            nested_level\
    \ -= 1;\n        } else if c == ' ' {\n            output.push(max_nested_level);\n\
    \            max_nested_level = 0;\n            nested_level = 0;\n        }\n\
    \    }\n\n    output\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822098
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut stack: Vec<isize> = Vec::new();\n    let mut max:\
    \ isize = 0;\n    let mut levels: Vec<isize> = Vec::new();\n\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                stack.push(max);\n\
    \                max += 1;\n            }\n            ')' => {\n            \
    \    levels.push(max);\n                max = stack.pop().unwrap();\n        \
    \    }\n            _ => panic!(\"Invalid character\"),\n        }\n    }\n\n\
    \    return levels;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''Invalid character'', /tmp/tmpo7i3tskh.rs:19:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822098
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut curr_depth =\
    \ 0;\n    let mut max_depth = 0;\n    for char in paren_string.chars() {\n   \
    \     match char {\n            '(' => {\n                curr_depth += 1;\n \
    \               if curr_depth > max_depth {\n                    max_depth = curr_depth;\n\
    \                }\n            }\n            ')' => {\n                curr_depth\
    \ -= 1;\n            }\n            ' ' => {\n                result.push(max_depth);\n\
    \                max_depth = 0;\n                curr_depth = 0;\n           \
    \ }\n            _ => {}\n        }\n    }\n    result.push(max_depth);\n    result\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822098
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_levels = Vec::new();\n    let mut paren_groups\
    \ = paren_string.split(\" \");\n    for group in paren_groups {\n        max_levels.push(calculate_max_depth(group.to_string()));\n\
    \    }\n    max_levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `calculate_max_depth` in this scope\n\
    \ --> /tmp/tmpt30fbcj3.rs:8:25\n  |\n8 |         max_levels.push(calculate_max_depth(group.to_string()));\n\
    \  |                         ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822098
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let paren_char_vec: Vec<char> = paren_string.chars().collect();\n\
    \    let mut track_vec: Vec<isize> = Vec::new();\n    let mut curr_level = 0;\n\
    \    let mut max_level = 0;\n    for i in 0..paren_char_vec.len() {\n        if\
    \ paren_char_vec[i] == '(' {\n            curr_level += 1;\n            if curr_level\
    \ > max_level {\n                max_level = curr_level;\n            }\n    \
    \    } else if paren_char_vec[i] == ')' {\n            curr_level -= 1;\n    \
    \    } else if paren_char_vec[i] == ' ' {\n            track_vec.push(max_level);\n\
    \            max_level = 0;\n            curr_level = 0;\n        }\n    }\n \
    \   track_vec.push(max_level);\n    track_vec\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822098
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    // List of integers representing the maximum levels of\
    \ nesting\n    let mut levels: Vec<isize> = Vec::new();\n\n    // Splits the string\
    \ into groups separated by spaces\n    let mut paren_groups: Vec<&str> = paren_string.split(\"\
    \ \").collect();\n\n    for group in paren_groups {\n        // Replace all left\
    \ parenthesis with '(' and right with ')'\n        let mut clean_group = group.to_string();\n\
    \        clean_group = clean_group.replace(\"(\", \"(\");\n        clean_group\
    \ = clean_group.replace(\")\", \")\");\n\n        // Initialize the max_level\
    \ to 0\n        let mut max_level: isize = 0;\n        // Initialize the current\
    \ level to 0\n        let mut current_level: isize = 0;\n\n        // Iterate\
    \ through the entire string\n        for char in clean_group.chars() {\n     \
    \       // If it's a left parenthesis increment the current level by 1\n     \
    \       if char == '(' {\n                current_level += 1;\n            }\n\
    \            // If it's a right parenthesis decrement the current level by 1\n\
    \            else if char == ')' {\n                current_level -= 1;\n    \
    \        }\n\n            // Update the max level if the current level is greater\
    \ than the max\n            if current_level > max_level {\n                max_level\
    \ = current_level;\n            }\n        }\n\n        // Add the max level to\
    \ the list of levels\n        levels.push(max_level);\n    }\n\n    levels\n}\n\
    \nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822098
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    // 0th index represents the number of open parentheses,\
    \ and the 1st index represents the level of deepest nesting of parentheses.\n\
    \    let mut counter: (isize, isize) = (0, 0);\n    let mut max_counter: (isize,\
    \ isize) = (0, 0);\n    let mut result: Vec<isize> = Vec::new();\n\n    for c\
    \ in paren_string.chars() {\n        if c == '(' {\n            counter.0 += 1;\n\
    \            if counter.0 > max_counter.0 {\n                max_counter.0 = counter.0;\n\
    \                max_counter.1 += 1;\n            }\n        } else if c == ')'\
    \ {\n            counter.0 -= 1;\n        } else if c == ' ' {\n            result.push(max_counter.1);\n\
    \            max_counter = (0, 0);\n        }\n    }\n    result.push(max_counter.1);\n\
    \    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822098
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    // This vector is used to store results for each input\
    \ group.\n    let mut paren_count = Vec::new();\n    // Loop over each character\
    \ in the input string.\n    for c in paren_string.chars() {\n        // If we\
    \ find a left paren we push a 1 onto the end of the current result vector.\n \
    \       if c == '(' {\n            paren_count.push(1);\n        } else if c ==\
    \ ')' {\n            // If we find a right paren then we need to check to see\
    \ if the last element in the result\n            // vector is a 1 (it will be\
    \ if it's the end of a group).\n            if let Some(count) = paren_count.last_mut()\
    \ {\n                // We need to increment our count but only if it's a 1 otherwise\
    \ we leave it as is.\n                if *count == 1 {\n                    *count\
    \ += 1;\n                }\n            }\n        } else if c == ' ' {\n    \
    \        // We've encountered a space which means we've finished with the current\
    \ group.\n            // We therefore need to find the maximum value in the vector\
    \ and push it to the result vector.\n            if let Some(count) = paren_count.pop()\
    \ {\n                // The count variable is the deepest level of nesting for\
    \ the current group.\n                paren_count.push(count);\n            }\n\
    \        }\n    }\n    // Finally, we need to return the result vector.\n    paren_count\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 2]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpmnwoaoxs.rs:36:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822098
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut levels: Vec<isize> = Vec::new();\n    let mut current_level\
    \ = 0;\n    let mut max_level = 0;\n    for c in paren_string.chars() {\n    \
    \    if c == '(' {\n            current_level += 1;\n            if current_level\
    \ > max_level {\n                max_level = current_level;\n            }\n \
    \       } else if c == ')' {\n            current_level -= 1;\n        } else\
    \ if c == ' ' {\n            levels.push(max_level);\n            max_level =\
    \ 0;\n            current_level = 0;\n        }\n    }\n    levels.push(max_level);\n\
    \    levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822098
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0;\n    let mut max_levels = Vec::new();\n\
    \    for ch in paren_string.chars() {\n        match ch {\n            '(' =>\
    \ level += 1,\n            ')' => {\n                level -= 1;\n           \
    \     if level == 0 {\n                    max_levels.push(max_levels.pop().unwrap_or(0)\
    \ + 1);\n                }\n            }\n            ' ' => {\n            \
    \    max_levels.push(max_levels.pop().unwrap_or(0));\n            }\n        \
    \    _ => continue,\n        }\n    }\n    max_levels\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0499]: cannot borrow `max_levels` as mutable more than once at a\
    \ time\n  --> /tmp/tmp5683ecru.rs:13:37\n   |\n13 |                     max_levels.push(max_levels.pop().unwrap_or(0)\
    \ + 1);\n   |                     ---------- ---- ^^^^^^^^^^ second mutable borrow\
    \ occurs here\n   |                     |          |\n   |                   \
    \  |          first borrow later used by call\n   |                     first\
    \ mutable borrow occurs here\n\nerror[E0499]: cannot borrow `max_levels` as mutable\
    \ more than once at a time\n  --> /tmp/tmp5683ecru.rs:17:33\n   |\n17 |      \
    \           max_levels.push(max_levels.pop().unwrap_or(0));\n   |            \
    \     ---------- ---- ^^^^^^^^^^ second mutable borrow occurs here\n   |     \
    \            |          |\n   |                 |          first borrow later\
    \ used by call\n   |                 first mutable borrow occurs here\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0499`.\n"
  stdout: ''
  timestamp: 1659822098
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_count: isize = 0;\n    let mut count: isize\
    \ = 0;\n    let mut result: Vec<isize> = Vec::new();\n\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            count += 1;\n            if count > max_count\
    \ {\n                max_count = count;\n            }\n        } else if c ==\
    \ ')' {\n            count -= 1;\n        } else if c == ' ' {\n            //\
    \ handle the case when the group of parentheses is complete and we are looking\
    \ at the\n            // next group of parenthesees.\n            result.push(max_count);\n\
    \            max_count = 0;\n            count = 0;\n        }\n    }\n\n    //\
    \ last group of parentheses.\n    result.push(max_count);\n\n    result\n}\n\n\
    fn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822098
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let paren_string = paren_string.trim();\n    let mut max_depth\
    \ = Vec::new();\n    let mut current_depth = 0;\n    let mut max_current_depth\
    \ = 0;\n    for paren in paren_string.chars() {\n        match paren {\n     \
    \       '(' => {\n                current_depth += 1;\n                if current_depth\
    \ > max_current_depth {\n                    max_current_depth = current_depth;\n\
    \                }\n            }\n            ')' => {\n                if current_depth\
    \ > 0 {\n                    current_depth -= 1;\n                }\n        \
    \    }\n            ' ' => {\n                max_depth.push(max_current_depth);\n\
    \                max_current_depth = 0;\n                current_depth = 0;\n\
    \            }\n            _ => println!(\"Should never get here\"),\n      \
    \  }\n    }\n    max_depth.push(max_current_depth);\n    max_depth\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822098
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut stack = vec![];\n    let mut results = vec![];\n\
    \    let mut input_chars = paren_string.chars();\n    while let Some(paren) =\
    \ input_chars.next() {\n        match paren {\n            '(' => {\n        \
    \        stack.push(paren);\n            }\n            ')' => {\n           \
    \     stack.pop();\n                if input_chars.peek() == Some(&' ') {\n  \
    \                  results.push(stack.len() as isize);\n                }\n  \
    \          }\n            _ => continue,\n        }\n    }\n    results\n}\n\n\
    fn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `peek` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmpki5almq5.rs:15:32\n   |\n15 |                 if input_chars.peek()\
    \ == Some(&' ') {\n   |                                ^^^^ method not found in\
    \ `Chars<'_>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659822098
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    // `paren_count` is the number of opening parentheses at\
    \ the current depth.\n    // E.g. `(()(()))` has 3 opening parens at depth 1.\n\
    \    let mut max_paren_count = 0;\n    let mut paren_count = 0;\n    let mut paren_depths\
    \ = Vec::new();\n\n    for c in paren_string.chars() {\n        match c {\n  \
    \          '(' => {\n                paren_count += 1;\n                if paren_count\
    \ > max_paren_count {\n                    max_paren_count = paren_count;\n  \
    \              }\n            }\n            ')' => {\n                paren_count\
    \ -= 1;\n            }\n            ' ' => {\n                paren_depths.push(max_paren_count);\n\
    \                max_paren_count = 0;\n                paren_count = 0;\n    \
    \        }\n            _ => panic!(\"Invalid character in the input string\"\
    ),\n        }\n    }\n    paren_depths.push(max_paren_count);\n    paren_depths\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822098
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut parsed_string = String::new();\n    let mut index\
    \ = 0;\n    let mut max_nesting_depth = 0;\n    let mut top_depth = 0;\n    let\
    \ mut depths = Vec::new();\n\n    while index < paren_string.len() {\n       \
    \ let (mut i, mut j) = (index, index);\n        let (mut left_parens, mut right_parens)\
    \ = (0, 0);\n        let mut depth = 0;\n\n        while j < paren_string.len()\
    \ && paren_string.chars().nth(j).unwrap() != ' ' {\n            match paren_string.chars().nth(j).unwrap()\
    \ {\n                '(' => {\n                    left_parens += 1;\n       \
    \             depth += 1;\n                    if depth > max_nesting_depth {\n\
    \                        max_nesting_depth = depth;\n                    }\n \
    \               }\n                ')' => {\n                    right_parens\
    \ += 1;\n                    depth -= 1;\n                }\n                _\
    \ => {}\n            }\n            j += 1;\n        }\n\n        for _k in i..j\
    \ {\n            parsed_string.push(paren_string.chars().nth(i).unwrap());\n \
    \           i += 1;\n        }\n\n        if left_parens != right_parens {\n \
    \           println!(\"Invalid string: {}\", parsed_string);\n            return\
    \ depths;\n        }\n\n        depths.push(max_nesting_depth);\n        max_nesting_depth\
    \ = 0;\n        parsed_string.clear();\n        index = j + 1;\n    }\n\n    return\
    \ depths;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822098
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut nesting_levels = Vec::new();\n    let mut nest_level\
    \ = 0;\n    for paren in paren_string.chars() {\n        match paren {\n     \
    \       '(' => nest_level += 1,\n            ')' => {\n                if nest_level\
    \ > 0 {\n                    nest_level -= 1;\n                } else {\n    \
    \                panic!(\"Unbalanced right parenthesis\");\n                }\n\
    \            }\n            _ => panic!(\"Unrecognized parenthesis character\"\
    ),\n        }\n    }\n    if nest_level != 0 {\n        panic!(\"Unbalanced left\
    \ parenthesis\");\n    }\n    nesting_levels\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''Unrecognized parenthesis character'', /tmp/tmpdd5al4ud.rs:17:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822098
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting_counts = Vec::new();\n    let mut deepest_nesting_count\
    \ = 0;\n    let mut nesting_count = 0;\n    for c in paren_string.chars() {\n\
    \        if c == '(' {\n            nesting_count += 1;\n            if nesting_count\
    \ > deepest_nesting_count {\n                deepest_nesting_count = nesting_count;\n\
    \            }\n        } else if c == ')' {\n            if nesting_count > 0\
    \ {\n                nesting_count -= 1;\n            } else {\n             \
    \   max_nesting_counts.push(-1);\n                deepest_nesting_count = 0;\n\
    \                nesting_count = 0;\n            }\n        } else if c == ' '\
    \ {\n            max_nesting_counts.push(deepest_nesting_count);\n           \
    \ deepest_nesting_count = 0;\n            nesting_count = 0;\n        }\n    }\n\
    \    if deepest_nesting_count > 0 {\n        max_nesting_counts.push(deepest_nesting_count);\n\
    \    }\n    max_nesting_counts\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822098
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut nesting_per_paren = Vec::new();\n    let mut current_nesting\
    \ = 0;\n    let mut max_nesting = 0;\n    for c in paren_string.chars() {\n  \
    \      if c == '(' {\n            current_nesting += 1;\n            if current_nesting\
    \ > max_nesting {\n                max_nesting = current_nesting;\n          \
    \  }\n        } else if c == ')' {\n            current_nesting -= 1;\n      \
    \  } else if c == ' ' {\n            nesting_per_paren.push(max_nesting);\n  \
    \          max_nesting = 0;\n            current_nesting = 0;\n        }\n   \
    \ }\n    nesting_per_paren.push(max_nesting);\n    nesting_per_paren\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822098
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n        .map(|str|\
    \ {\n            let mut l_count = 0;\n            let mut h_count = 0;\n    \
    \        for c in str.chars() {\n                match c {\n                 \
    \   '(' => {\n                        l_count += 1;\n                        if\
    \ l_count > h_count {\n                            h_count = l_count;\n      \
    \                  }\n                    }\n                    ')' => {\n  \
    \                      l_count -= 1;\n                    }\n                \
    \    _ => {\n                        continue;\n                    }\n      \
    \          }\n            }\n            h_count\n        })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822098
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let paren_tokens: Vec<char> = paren_string.chars().collect();\n\
    \    let mut paren_deep: Vec<isize> = Vec::new();\n    let mut paren_count: isize\
    \ = 0;\n    let mut max_paren_deep: isize = 0;\n    for i in 0..paren_tokens.len()\
    \ {\n        let token = paren_tokens[i];\n        if token == '(' {\n       \
    \     paren_count += 1;\n            if paren_count > max_paren_deep {\n     \
    \           max_paren_deep = paren_count;\n            }\n        } else if token\
    \ == ')' {\n            paren_count -= 1;\n        } else if token == ' ' {\n\
    \            if paren_count == 0 {\n                paren_deep.push(max_paren_deep);\n\
    \                max_paren_deep = 0;\n            }\n        }\n    }\n    paren_deep.push(max_paren_deep);\n\
    \    paren_deep\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822098
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut results = Vec::new();\n    let mut depth = 0;\n\
    \    let mut max_depth = 0;\n    let char_iter = paren_string.chars();\n    for\
    \ c in char_iter {\n        match c {\n            '(' => {\n                depth\
    \ += 1;\n                if depth > max_depth {\n                    max_depth\
    \ = depth;\n                }\n            }\n            ')' => {\n         \
    \       depth -= 1;\n            }\n            ' ' => {\n                results.push(max_depth);\n\
    \                max_depth = 0;\n                depth = 0;\n            }\n \
    \           _ => {\n                println!(\"Unexpected character found\");\n\
    \            }\n        }\n    }\n    results.push(max_depth);\n    results\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822098
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut output = Vec::new();\n    for paren_string in paren_string.split_whitespace()\
    \ {\n        output.push(parse_nested_parens_helper(paren_string));\n    }\n \
    \   output\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `parse_nested_parens_helper` in this\
    \ scope\n --> /tmp/tmpakb7xi3c.rs:7:21\n  |\n7 |         output.push(parse_nested_parens_helper(paren_string));\n\
    \  |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822098
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n        .map(|paren_group|\
    \ {\n            let mut paren_vec: Vec<u8> = paren_group.bytes().collect();\n\
    \            let mut max_depth = 0;\n            let mut current_depth = 0;\n\
    \            for paren in paren_vec {\n                match paren {\n       \
    \             b'(' => {\n                        current_depth += 1;\n       \
    \                 if current_depth > max_depth {\n                           \
    \ max_depth = current_depth;\n                        }\n                    }\n\
    \                    b')' => {\n                        current_depth -= 1;\n\
    \                    }\n                    _ => {}\n                }\n     \
    \       }\n            max_depth as isize\n        })\n        .collect()\n}\n\
    \nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822098
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nested_parentheses = Vec::new();\n    let mut\
    \ current_level = 0;\n    let mut max_level = 0;\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                current_level +=\
    \ 1;\n                if current_level > max_level {\n                    max_level\
    \ = current_level;\n                }\n            }\n            ')' => {\n \
    \               if current_level > 0 {\n                    current_level -= 1;\n\
    \                }\n            }\n            _ => continue,\n        }\n   \
    \ }\n    max_nested_parentheses.push(max_level);\n    max_nested_parentheses\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpz48uulcu.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822098
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result: Vec<isize> = Vec::new();\n    let mut current_group:\
    \ Vec<isize> = Vec::new();\n    let mut current_level: isize = 0;\n    let mut\
    \ max_level: isize = 0;\n    let mut group_separator_seen: bool = false;\n\n \
    \   for c in paren_string.chars() {\n        if c == '(' {\n            current_level\
    \ += 1;\n            if current_level > max_level {\n                max_level\
    \ = current_level;\n            }\n        } else if c == ')' {\n            current_level\
    \ -= 1;\n        } else if c == ' ' {\n            group_separator_seen = true;\n\
    \        } else {\n            panic!(\"Invalid character in input\");\n     \
    \   }\n\n        if group_separator_seen {\n            current_group.push(max_level);\n\
    \            max_level = 0;\n            current_level = 0;\n            group_separator_seen\
    \ = false;\n        }\n    }\n\n    if current_level > 0 {\n        panic!(\"\
    Unbalanced parens in input\");\n    }\n\n    result.append(&mut current_group);\n\
    \    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 1]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp45b0q0vu.rs:43:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822098
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    // Flag to determine if next input is expected to be part\
    \ of the string.\n    let mut next_paren = true;\n    // Final output that will\
    \ be returned.\n    let mut paren_vec = Vec::new();\n    // temporary variables\n\
    \    let mut paren_count = 0;\n    let mut paren_str = String::new();\n\n    for\
    \ ch in paren_string.chars() {\n        if ch == ' ' {\n            // If input\
    \ is a space and we are expecting input as part of the string, then we have found\
    \ the end of the string and need to evaluate.\n            if next_paren {\n \
    \               paren_vec.push(nested_parens(&paren_str));\n                paren_str\
    \ = String::new();\n            }\n            // If input is a space and we are\
    \ not expecting input as part of the string, then we don't care.\n           \
    \ next_paren = true;\n        } else {\n            // Input is a parenthesis\
    \ and we are expecting input as part of the string.\n            if next_paren\
    \ {\n                next_paren = false;\n            }\n            paren_str.push(ch);\n\
    \        }\n    }\n    // If there is still a string to evaluate and it is not\
    \ empty, we need to evaluate.\n    if !next_paren && !paren_str.is_empty() {\n\
    \        paren_vec.push(nested_parens(&paren_str));\n    }\n    paren_vec\n}\n\
    \nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `nested_parens` in this scope\n  -->\
    \ /tmp/tmpvimcav8t.rs:17:32\n   |\n17 |                 paren_vec.push(nested_parens(&paren_str));\n\
    \   |                                ^^^^^^^^^^^^^ help: a local variable with\
    \ a similar name exists: `next_paren`\n\nerror[E0425]: cannot find function `nested_parens`\
    \ in this scope\n  --> /tmp/tmpvimcav8t.rs:32:24\n   |\n32 |         paren_vec.push(nested_parens(&paren_str));\n\
    \   |                        ^^^^^^^^^^^^^ help: a local variable with a similar\
    \ name exists: `next_paren`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822098
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_level: isize = 0;\n    let mut current_level:\
    \ isize = 0;\n    let mut levels = Vec::new();\n\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            current_level += 1;\n            if current_level\
    \ > max_level {\n                max_level = current_level;\n            }\n \
    \       } else if c == ')' {\n            if current_level > 0 {\n           \
    \     current_level -= 1;\n            }\n        } else if c == ' ' {\n     \
    \       levels.push(max_level);\n            max_level = 0;\n            current_level\
    \ = 0;\n        }\n    }\n\n    levels.push(max_level);\n    levels\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822098
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let paren_string = paren_string.trim();\n    let paren_chars:\
    \ Vec<char> = paren_string.chars().collect();\n    let mut max_level = 0;\n  \
    \  let mut curr_level = 0;\n    let mut max_level_vec = Vec::new();\n    for &p\
    \ in paren_chars.iter() {\n        if p == '(' {\n            curr_level += 1;\n\
    \            if curr_level > max_level {\n                max_level = curr_level;\n\
    \            }\n        } else if p == ')' {\n            curr_level -= 1;\n \
    \           if curr_level == 0 {\n                max_level_vec.push(max_level);\n\
    \                max_level = 0;\n            }\n        }\n    }\n    max_level_vec\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822099
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting_levels = Vec::new();\n    for paren_group\
    \ in paren_string.split_whitespace() {\n        let mut stack: Vec<char> = Vec::new();\n\
    \        let mut current_nesting_level = 0;\n        let mut max_nesting_level\
    \ = 0;\n        for paren in paren_group.chars() {\n            if paren == '('\
    \ {\n                stack.push(paren);\n                current_nesting_level\
    \ += 1;\n                if current_nesting_level > max_nesting_level {\n    \
    \                max_nesting_level = current_nesting_level;\n                }\n\
    \            } else if paren == ')' {\n                if !stack.is_empty() {\n\
    \                    stack.pop();\n                    current_nesting_level -=\
    \ 1;\n                } else {\n                    panic!(\"Error: Mismatched\
    \ parentheses\")\n                }\n            } else {\n                panic!(\"\
    Error: Unrecognized character\")\n            }\n        }\n        if !stack.is_empty()\
    \ {\n            panic!(\"Error: Mismatched parentheses\")\n        }\n      \
    \  max_nesting_levels.push(max_nesting_level);\n    }\n    max_nesting_levels\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822099
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut res = Vec::new();\n    for group in paren_string.split_whitespace()\
    \ {\n        let mut max_level = 0;\n        let mut level = 0;\n        for paren\
    \ in group.chars() {\n            if paren == '(' {\n                level +=\
    \ 1;\n            } else {\n                level -= 1;\n            }\n     \
    \       max_level = level.max(max_level);\n        }\n        res.push(max_level);\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822099
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting_levels = Vec::new();\n    let mut max_current_nesting\
    \ = 0;\n    let mut current_nesting = 0;\n    for character in paren_string.chars()\
    \ {\n        match character {\n            '(' => {\n                current_nesting\
    \ += 1;\n                if current_nesting > max_current_nesting {\n        \
    \            max_current_nesting = current_nesting;\n                }\n     \
    \       }\n            ')' => {\n                current_nesting -= 1;\n     \
    \       }\n            ' ' => {\n                max_nesting_levels.push(max_current_nesting);\n\
    \                max_current_nesting = 0;\n                current_nesting = 0;\n\
    \            }\n            _ => {\n                panic!(\"Unexpected character\
    \ in paren_string\");\n            }\n        }\n    }\n    if current_nesting\
    \ == 0 {\n        max_nesting_levels.push(max_current_nesting);\n    }\n    max_nesting_levels\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822099
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_depth: Vec<isize> = Vec::new();\n    for\
    \ group in paren_string.split_whitespace() {\n        let mut level = 0;\n   \
    \     let mut max_level = 0;\n        for paren in group.chars() {\n         \
    \   match paren {\n                '(' => level += 1,\n                ')' =>\
    \ level -= 1,\n                _ => panic!(\"Invalid paren string {}\", group),\n\
    \            }\n            if level > max_level {\n                max_level\
    \ = level;\n            }\n        }\n        paren_depth.push(max_level);\n \
    \   }\n    paren_depth\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822099
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut stack = Vec::new();\n    let mut paren_string =\
    \ paren_string;\n    let mut max_depth = 0;\n    while !paren_string.is_empty()\
    \ {\n        max_depth = 0;\n        let mut remaining_paren_string = String::new();\n\
    \        for c in paren_string.chars() {\n            match c {\n            \
    \    '(' => {\n                    stack.push(c);\n                    max_depth\
    \ += 1;\n                }\n                ')' => {\n                    if stack.pop().is_none()\
    \ {\n                        max_depth = 0;\n                        break;\n\
    \                    }\n                }\n                ' ' => {\n        \
    \            if !stack.is_empty() {\n                        remaining_paren_string.push(c);\n\
    \                    }\n                }\n                _ => return vec![-1],\n\
    \            }\n        }\n        if !stack.is_empty() {\n            max_depth\
    \ = 0;\n        }\n        println!(\"{}\", max_depth);\n        paren_string\
    \ = remaining_paren_string;\n    }\n    vec![max_depth]\n}\n\nfn main() {\n  \
    \  let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[12]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp99zcz87w.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: '12

    '
  timestamp: 1659822099
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut vec = Vec::new();\n    let mut max_depth = 0;\n\
    \    let mut depth = 0;\n    for c in paren_string.chars() {\n        if c ==\
    \ '(' {\n            depth += 1;\n            if depth > max_depth {\n       \
    \         max_depth = depth;\n            }\n        } else if c == ')' {\n  \
    \          depth -= 1;\n        } else if c == ' ' {\n            vec.push(max_depth);\n\
    \            max_depth = 0;\n            depth = 0;\n        }\n    }\n    if\
    \ max_depth > 0 {\n        vec.push(max_depth);\n    }\n    vec\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822099
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut current_depth = 0;\n\
    \    let mut max_depth_list = Vec::new();\n\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                current_depth +=\
    \ 1;\n                if current_depth > max_depth {\n                    max_depth\
    \ = current_depth;\n                }\n            }\n            ')' => {\n \
    \               if current_depth > 0 {\n                    current_depth -= 1;\n\
    \                }\n            }\n            ' ' => {\n                max_depth_list.push(max_depth);\n\
    \                max_depth = 0;\n                current_depth = 0;\n        \
    \    }\n            _ => println!(\"Invalid character {}\", c),\n        }\n \
    \   }\n    max_depth_list.push(max_depth);\n    max_depth_list\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822099
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let paren_string = paren_string.trim().to_string();\n \
    \   let mut max_count = 0;\n    let mut count = 0;\n    let mut result = Vec::new();\n\
    \    for ch in paren_string.chars() {\n        if ch == '(' {\n            count\
    \ += 1;\n            if count > max_count {\n                max_count = count;\n\
    \            }\n        } else if ch == ')' {\n            count -= 1;\n     \
    \   } else if ch == ' ' {\n            result.push(max_count);\n            max_count\
    \ = 0;\n            count = 0;\n        }\n    }\n    result.push(max_count);\n\
    \    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822099
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut levels: Vec<isize> = Vec::new();\n    let mut cnt:\
    \ isize = 0;\n    let mut max_cnt: isize = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            cnt += 1;\n            if cnt > max_cnt\
    \ {\n                max_cnt = cnt;\n            }\n        } else if c == ')'\
    \ {\n            cnt -= 1;\n        } else if c == ' ' {\n            levels.push(max_cnt);\n\
    \            max_cnt = 0;\n            cnt = 0;\n        }\n    }\n    levels.push(max_cnt);\n\
    \    levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822099
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n        .map(|parens|\
    \ {\n            let mut current_depth = 0;\n            let mut max_depth = 0;\n\
    \            for c in parens.chars() {\n                if c == '(' {\n      \
    \              current_depth += 1;\n                    if current_depth > max_depth\
    \ {\n                        max_depth = current_depth;\n                    }\n\
    \                } else if c == ')' {\n                    current_depth -= 1;\n\
    \                }\n            }\n            max_depth\n        })\n       \
    \ .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n   \
    \ assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822099
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    // Use Stack to track the maximum level of nested parentheses\n\
    \    let mut paren_stack: Vec<isize> = Vec::new();\n    let mut max_level: isize\
    \ = 0;\n    for c in paren_string.chars() {\n        match c {\n            '('\
    \ => {\n                paren_stack.push(max_level + 1);\n                max_level\
    \ += 1;\n            }\n            ')' => {\n                paren_stack.pop();\n\
    \                if paren_stack.is_empty() {\n                    paren_stack.push(0);\n\
    \                }\n                max_level = paren_stack.last().unwrap().clone();\n\
    \            }\n            _ => println!(\"Invalid character {}\", c),\n    \
    \    }\n    }\n    // TODO: Remove empty element\n    paren_stack\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpqjkyryxy.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: "Invalid character  \nInvalid character  \nInvalid character  \n"
  timestamp: 1659822099
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n        .map(|item|\
    \ {\n            let mut max_level = 0;\n            let mut level = 0;\n    \
    \        for ch in item.chars() {\n                if ch == '(' {\n          \
    \          level += 1;\n                    if level > max_level {\n         \
    \               max_level = level;\n                    }\n                } else\
    \ if ch == ')' {\n                    level -= 1;\n                }\n       \
    \     }\n            max_level\n        })\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822099
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    // Split the input string into separate tokens representing\
    \ each nested group of parentheses.\n    let paren_tokens: Vec<&str> = paren_string.split_whitespace().collect();\n\
    \n    // For each group, determine the deepest level of nesting\n    paren_tokens.iter().map(|token|\
    \ {\n        let mut count = 0;\n        let mut max_count = 0;\n        for paren\
    \ in token.chars() {\n            if paren == '(' {\n                count +=\
    \ 1;\n            } else if paren == ')' {\n                count -= 1;\n    \
    \        }\n            if count > max_count {\n                max_count = count;\n\
    \            }\n        }\n        max_count\n    }).collect()\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822099
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut count = 0;\n\
    \    let mut max_count = 0;\n    for paren in paren_string.chars() {\n       \
    \ if paren == '(' {\n            count += 1;\n            if count > max_count\
    \ {\n                max_count = count;\n            }\n        } else if paren\
    \ == ')' {\n            count -= 1;\n        }\n        if paren == ' ' {\n  \
    \          result.push(max_count);\n            max_count = 0;\n            count\
    \ = 0;\n        }\n    }\n    if count == 0 {\n        result.push(max_count);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822099
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result: Vec<isize> = Vec::new();\n    let mut paren_vec:\
    \ Vec<char> = paren_string.chars().collect();\n    let mut running_maximum: isize\
    \ = 0;\n    let mut current_depth: isize = 0;\n    while !paren_vec.is_empty()\
    \ {\n        match paren_vec.pop() {\n            Some('(') => {\n           \
    \     current_depth -= 1;\n                if current_depth < running_maximum\
    \ {\n                    running_maximum = current_depth;\n                }\n\
    \            }\n            Some(')') => {\n                current_depth += 1;\n\
    \                if current_depth > running_maximum {\n                    running_maximum\
    \ = current_depth;\n                }\n            }\n            Some(' ') =>\
    \ {\n                result.push(running_maximum.abs());\n                running_maximum\
    \ = 0;\n                current_depth = 0;\n            }\n            _ => {\n\
    \                panic!(\"Input error!\");\n            }\n        }\n    }\n\
    \    result.push(running_maximum.abs());\n    result\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpapy9gl22.rs:39:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822099
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack: Vec<String> = Vec::new();\n    let\
    \ mut max_depth = 0;\n    let mut max_depth_vec: Vec<isize> = Vec::new();\n  \
    \  for c in paren_string.chars() {\n        match c {\n            '(' => {\n\
    \                paren_stack.push(c.to_string());\n                if paren_stack.len()\
    \ > max_depth {\n                    max_depth = paren_stack.len();\n        \
    \        }\n            }\n            ')' => {\n                match paren_stack.pop()\
    \ {\n                    Some(_) => (),\n                    None => {\n     \
    \                   max_depth_vec.push(-1);\n                        break;\n\
    \                    }\n                }\n            }\n            _ => {\n\
    \                max_depth_vec.push(-1);\n                break;\n           \
    \ }\n        }\n    }\n    if !paren_stack.is_empty() {\n        max_depth_vec.push(-1);\n\
    \    } else {\n        max_depth_vec.push(max_depth as isize);\n    }\n    max_depth_vec\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-1, 2]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpeqa6xoxk.rs:41:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822099
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut stack: Vec<isize> = Vec::new();\n    let mut result:\
    \ Vec<isize> = Vec::new();\n    for ch in paren_string.chars() {\n        if ch\
    \ == '(' {\n            stack.push(1);\n        } else if ch == ')' {\n      \
    \      stack.push(-1);\n        } else if ch == ' ' {\n            let mut temp\
    \ = 0;\n            while let Some(x) = stack.pop() {\n                temp +=\
    \ x;\n                if temp == 0 {\n                    break;\n           \
    \     }\n            }\n            result.push(temp);\n        }\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp3kyp828y.rs:28:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822099
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth: isize = 0;\n    let mut depths: Vec<isize>\
    \ = Vec::new();\n    let mut current_depth: isize = 0;\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                current_depth +=\
    \ 1;\n                if current_depth > max_depth {\n                    max_depth\
    \ = current_depth;\n                }\n            }\n            ')' => {\n \
    \               current_depth -= 1;\n            }\n            ' ' => {\n   \
    \             if max_depth > 0 {\n                    depths.push(max_depth);\n\
    \                    max_depth = 0;\n                }\n                current_depth\
    \ = 0;\n            }\n            _ => (),\n        }\n    }\n    depths\n}\n\
    \nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 1]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp30h0cggi.rs:34:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822099
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n        .map(|paren_group|\
    \ {\n            let max_nesting = paren_group\n                .chars()\n   \
    \             .fold(0isize, |acc, ch| match ch {\n                    '(' => acc\
    \ + 1,\n                    ')' => acc - 1,\n                    _ => acc,\n \
    \               });\n            if max_nesting > 0 {\n                panic!(\"\
    Invalid group: {}\", paren_group);\n            }\n            -max_nesting\n\
    \        })\n        .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpyqbrto0g.rs:25:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822099
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nested = Vec::new();\n    let mut counter =\
    \ 0;\n    let mut max_counter = 0;\n    for ch in paren_string.chars() {\n   \
    \     match ch {\n            '(' => {\n                counter += 1;\n      \
    \          if counter > max_counter {\n                    max_counter = counter;\n\
    \                }\n            }\n            ')' => {\n                counter\
    \ -= 1;\n            }\n            ' ' => {\n                max_nested.push(max_counter);\n\
    \                max_counter = 0;\n                counter = 0;\n            }\n\
    \            _ => (),\n        }\n    }\n    max_nested.push(max_counter);\n \
    \   max_nested\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n \
    \   assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822099
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut depth = 0;\n    let mut depths = Vec::new();\n\
    \    for c in paren_string.chars() {\n        match c {\n            '(' => depth\
    \ += 1,\n            ')' => depth -= 1,\n            _ => (),\n        }\n   \
    \     depths.push(depth);\n    }\n    depths\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 1, 2, 1, 0, 0, 1, 2, 3, 2, 1, 0, 0, 1, 0, 0, 1, 2, 3, 2, 1, 2, 1, 2,\
    \ 1, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmply1k4rwo.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822099
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let paren_split = paren_string.split_whitespace();\n\
    \    for group in paren_split {\n        let mut nest_count = 0;\n        let\
    \ mut max_nest = 0;\n        for c in group.chars() {\n            if c == '('\
    \ {\n                nest_count += 1;\n            } else if c == ')' {\n    \
    \            nest_count -= 1;\n            }\n            if nest_count > max_nest\
    \ {\n                max_nest = nest_count;\n            }\n        }\n      \
    \  result.push(max_nest);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822099
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting_levels = Vec::new();\n    let mut current_nesting_level\
    \ = 0;\n    let mut max_nesting_level = 0;\n    for ch in paren_string.chars()\
    \ {\n        if ch == '(' {\n            current_nesting_level += 1;\n       \
    \     if current_nesting_level > max_nesting_level {\n                max_nesting_level\
    \ = current_nesting_level;\n            }\n        } else if ch == ')' {\n   \
    \         if current_nesting_level > 0 {\n                current_nesting_level\
    \ -= 1;\n            } else {\n                // We only reach this line if there\
    \ are mismatched parentheses\n                max_nesting_levels.push(-1);\n \
    \               // Reset for the next group\n                current_nesting_level\
    \ = 0;\n                max_nesting_level = 0;\n            }\n        } else\
    \ if ch == ' ' {\n            // We only get here if the string is empty or there\
    \ are trailing spaces\n            max_nesting_levels.push(max_nesting_level);\n\
    \            // Reset for the next group\n            current_nesting_level =\
    \ 0;\n            max_nesting_level = 0;\n        }\n    }\n    // We only get\
    \ here if there are no trailing spaces\n    max_nesting_levels.push(max_nesting_level);\n\
    \    max_nesting_levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822099
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut current_level\
    \ = 0;\n    let mut max_level = 0;\n    let paren_char_vec: Vec<char> = paren_string.chars().collect();\n\
    \    for c in paren_char_vec {\n        if c == '(' {\n            current_level\
    \ += 1;\n            if current_level > max_level {\n                max_level\
    \ = current_level;\n            }\n        } else if c == ')' {\n            current_level\
    \ -= 1;\n        } else if c == ' ' {\n            result.push(max_level);\n \
    \           max_level = 0;\n            current_level = 0;\n        }\n    }\n\
    \    result.push(max_level);\n    result\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822099
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_vec: Vec<isize> = Vec::new();\n    let mut\
    \ paren_count: isize = 0;\n    let mut max_paren_count: isize = 0;\n    for ch\
    \ in paren_string.chars() {\n        match ch {\n            '(' => {\n      \
    \          paren_count += 1;\n                if paren_count > max_paren_count\
    \ {\n                    max_paren_count = paren_count;\n                }\n \
    \           }\n            ')' => {\n                paren_count -= 1;\n     \
    \       }\n            _ => {}\n        }\n    }\n    paren_vec.push(max_paren_count);\n\
    \    paren_vec\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n \
    \   assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpb0n7gt1p.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822099
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut res = Vec::new();\n    let mut paren_stack = Vec::new();\n\
    \    for paren in paren_string.chars() {\n        match paren {\n            '('\
    \ => {\n                paren_stack.push(paren);\n            }\n            ')'\
    \ => {\n                let _ = paren_stack.pop();\n                res.push(paren_stack.len()\
    \ as isize);\n            }\n            _ => panic!(\"unexpected parenthesis\
    \ : {}\", paren),\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''unexpected parenthesis :  '', /tmp/tmpvxonkbwu.rs:16:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822099
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting_vector: Vec<isize> = Vec::new();\n\
    \    let mut current_level: isize = 0;\n    let mut max_level: isize = 0;\n  \
    \  for single_char in paren_string.chars() {\n        if single_char == '(' {\n\
    \            current_level += 1;\n            if current_level > max_level {\n\
    \                max_level = current_level;\n            }\n        } else if\
    \ single_char == ')' {\n            current_level -= 1;\n        } else if single_char\
    \ == ' ' {\n            max_nesting_vector.push(max_level);\n            max_level\
    \ = 0;\n            current_level = 0;\n        }\n    }\n    max_nesting_vector.push(max_level);\n\
    \    max_nesting_vector\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822099
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split(\" \")\n        .map(|group|\
    \ {\n            let mut max_level = 0;\n            let mut level = 0;\n    \
    \        for c in group.chars() {\n                match c {\n               \
    \     '(' => {\n                        level += 1;\n                        if\
    \ level > max_level {\n                            max_level = level;\n      \
    \                  }\n                    }\n                    ')' => {\n  \
    \                      level -= 1;\n                    }\n                  \
    \  _ => {}\n                }\n            }\n            max_level\n        })\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822099
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut levels: Vec<isize> = Vec::new();\n    let mut max_level\
    \ = 0;\n    let mut current_level = 0;\n    for c in paren_string.chars() {\n\
    \        if c == '(' {\n            current_level += 1;\n            if current_level\
    \ > max_level {\n                max_level = current_level;\n            }\n \
    \       } else if c == ')' {\n            current_level -= 1;\n        } else\
    \ if c == ' ' {\n            levels.push(max_level);\n            max_level =\
    \ 0;\n            current_level = 0;\n        }\n    }\n    levels.push(max_level);\n\
    \    levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822099
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut maximum_depth = Vec::new();\n    let groups: Vec<&str>\
    \ = paren_string.split(\" \").collect();\n    for group in groups {\n        let\
    \ mut depth = 0;\n        let mut max_depth = 0;\n        for c in group.chars()\
    \ {\n            if c == '(' {\n                depth += 1;\n            } else\
    \ if c == ')' {\n                depth -= 1;\n            }\n            if depth\
    \ > max_depth {\n                max_depth = depth;\n            }\n        }\n\
    \        maximum_depth.push(max_depth);\n    }\n    maximum_depth\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822099
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut depth = 0;\n    let mut max_depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depths.push(max_depth);\n\
    \                max_depth = 0;\n                depth = 0;\n            }\n \
    \           _ => continue,\n        }\n    }\n    depths\n}\n\nfn main() {\n \
    \   let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 1, 0, 3, 0, 0, 1, 3, 0, 1, 1, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp289rad8i.rs:29:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822099
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut depth_counts: Vec<isize> = Vec::new();\n    let\
    \ mut depth_count: isize = 0;\n    let mut max_depth: isize = 0;\n    for c in\
    \ paren_string.chars() {\n        match c {\n            '(' => {\n          \
    \      depth_count += 1;\n                if depth_count > max_depth {\n     \
    \               max_depth = depth_count;\n                }\n            }\n \
    \           ')' => {\n                depth_count -= 1;\n            }\n     \
    \       ' ' => {\n                depth_counts.push(max_depth);\n            \
    \    max_depth = 0;\n                depth_count = 0;\n            }\n       \
    \     _ => {}\n        }\n    }\n    depth_counts.push(max_depth);\n    depth_counts\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822099
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut levels = Vec::new();\n    for character in paren_string.chars() {\n    \
    \    if character == '(' {\n            depth += 1;\n            if depth > max_depth\
    \ {\n                max_depth = depth;\n            }\n        } else if character\
    \ == ')' {\n            depth -= 1;\n        } else if character == ' ' {\n  \
    \          levels.push(max_depth);\n            max_depth = 0;\n            depth\
    \ = 0;\n        }\n    }\n    levels.push(max_depth);\n    levels\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822099
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_levels: Vec<isize> = Vec::new();\n    for paren_group\
    \ in paren_string.split(\" \") {\n        let mut paren_level = 0;\n        let\
    \ mut paren_max = 0;\n        for ch in paren_group.chars() {\n            if\
    \ ch == '(' {\n                paren_level += 1;\n            } else if ch ==\
    \ ')' {\n                paren_level -= 1;\n            }\n            if paren_level\
    \ > paren_max {\n                paren_max = paren_level;\n            }\n   \
    \     }\n        max_levels.push(paren_max);\n    }\n    max_levels\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822099
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n        .map(|s|\
    \ get_nested_parens_count(s))\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_nested_parens_count` in this scope\n\
    \ --> /tmp/tmp8l_7ymha.rs:7:18\n  |\n7 |         .map(|s| get_nested_parens_count(s))\n\
    \  |                  ^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822099
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_count = 0;\n    let mut max_paren_count =\
    \ 0;\n    let mut max_paren_counts = Vec::new();\n\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                paren_count += 1;\n\
    \                if paren_count > max_paren_count {\n                    max_paren_count\
    \ = paren_count;\n                }\n            }\n            ')' => {\n   \
    \             paren_count -= 1;\n            }\n            ' ' => {\n       \
    \         max_paren_counts.push(max_paren_count);\n                max_paren_count\
    \ = 0;\n                paren_count = 0;\n            }\n            _ => panic!(\"\
    String must contain only spaces, parens, and digits\"),\n        }\n    }\n  \
    \  max_paren_counts.push(max_paren_count);\n    max_paren_counts\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822099
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_groups: Vec<isize> = Vec::new();\n    let\
    \ mut current_level: isize = 0;\n    let mut max_level: isize = 0;\n    for c\
    \ in paren_string.chars() {\n        if c == '(' {\n            current_level\
    \ += 1;\n            if current_level > max_level {\n                max_level\
    \ = current_level;\n            }\n        } else if c == ')' {\n            current_level\
    \ -= 1;\n        } else if c == ' ' {\n            paren_groups.push(max_level);\n\
    \            max_level = 0;\n            current_level = 0;\n        }\n    }\n\
    \    paren_groups.push(max_level);\n    paren_groups\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822099
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut stack: Vec<isize> = Vec::new();\n    let mut max_stack_value:\
    \ isize = 0;\n    let mut output: Vec<isize> = Vec::new();\n\n    for character\
    \ in paren_string.chars() {\n        match character {\n            '(' => {\n\
    \                if stack.is_empty() {\n                    stack.push(1);\n \
    \               } else {\n                    stack.push(stack.last().unwrap()\
    \ + 1);\n                }\n            }\n            ')' => {\n            \
    \    max_stack_value = std::cmp::max(max_stack_value, stack.pop().unwrap());\n\
    \            }\n            _ => {}\n        }\n    }\n\n    output.push(max_stack_value);\n\
    \    output\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp8vflhs_b.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822099
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n        .map(|s|\
    \ {\n            let mut depth = 0;\n            let mut max_depth = 0;\n    \
    \        for c in s.chars() {\n                match c {\n                   \
    \ '(' => depth += 1,\n                    ')' => depth -= 1,\n               \
    \     _ => {}\n                }\n                max_depth = max_depth.max(depth);\n\
    \            }\n            max_depth\n        })\n        .collect()\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822099
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut highest_level: isize = 0;\n    let mut current_level:\
    \ isize = 0;\n    let mut deepest_levels: Vec<isize> = Vec::new();\n\n    for\
    \ c in paren_string.chars() {\n        match c {\n            '(' => {\n     \
    \           current_level += 1;\n                if current_level > highest_level\
    \ {\n                    highest_level = current_level;\n                }\n \
    \           }\n            ')' => {\n                if current_level > 0 {\n\
    \                    current_level -= 1;\n                }\n            }\n \
    \           _ => {}\n        }\n    }\n\n    for _ in 0..highest_level {\n   \
    \     deepest_levels.push(0);\n    }\n\n    current_level = 0;\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                current_level +=\
    \ 1;\n            }\n            ')' => {\n                if current_level >\
    \ 0 {\n                    current_level -= 1;\n                    deepest_levels[current_level\
    \ as usize] += 1;\n                }\n            }\n            _ => {}\n   \
    \     }\n    }\n\n    return deepest_levels;\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 6, 2]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpfx4frmpl.rs:51:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822099
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack: Vec<char> = Vec::new();\n    let mut\
    \ max_level: Vec<isize> = Vec::new();\n    let mut level: isize = 0;\n    let\
    \ mut max_depth: isize = 0;\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                level += 1;\n                if level\
    \ > max_depth {\n                    max_depth = level;\n                }\n \
    \               paren_stack.push(c);\n            }\n            ')' => {\n  \
    \              level -= 1;\n                paren_stack.push(c);\n           \
    \ }\n            ' ' => {\n                if paren_stack.len() > 0 {\n      \
    \              max_level.push(max_depth);\n                    max_depth = 0;\n\
    \                    paren_stack.clear();\n                }\n            }\n\
    \            _ => panic!(\"Character {} not allowed in parentheses string!\",\
    \ c),\n        }\n    }\n    if paren_stack.len() > 0 {\n        max_level.push(max_depth);\n\
    \    }\n    max_level\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822099
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n        .map(|x|\
    \ get_max_nesting(x))\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_max_nesting` in this scope\n -->\
    \ /tmp/tmp_3xlb0ik.rs:7:18\n  |\n7 |         .map(|x| get_max_nesting(x))\n  |\
    \                  ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659822099
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_level = vec![];\n    let mut curr_level = 0;\n\
    \    let mut sum = 0;\n    let mut max_level_sum = 0;\n    let mut curr_paren\
    \ = paren_string.chars();\n    let mut prev_open = false;\n    while let Some(c)\
    \ = curr_paren.next() {\n        if c == '(' {\n            curr_level += 1;\n\
    \            sum += curr_level;\n            prev_open = true;\n        } else\
    \ if c == ')' {\n            if sum > max_level_sum {\n                max_level_sum\
    \ = sum;\n                max_level.push(max_level_sum);\n            }\n    \
    \        curr_level -= 1;\n            sum -= curr_level;\n            prev_open\
    \ = false;\n        } else if c == ' ' {\n            if sum > max_level_sum {\n\
    \                max_level_sum = sum;\n                max_level.push(max_level_sum);\n\
    \            }\n            sum = 0;\n            prev_open = false;\n       \
    \ }\n    }\n    // Add the last element to the max_level_sum if it is not the\
    \ closing parentheses of the last\n    // group of parentheses.\n    if prev_open\
    \ {\n        max_level.push(max_level_sum);\n    }\n    max_level\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 4, 6]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpyezp57ya.rs:43:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822099
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut current_max = 0;\n    let mut max = 0;\n    let\
    \ mut paren_levels = Vec::new();\n    for c in paren_string.chars() {\n      \
    \  if c == '(' {\n            current_max += 1;\n            if current_max >\
    \ max {\n                max = current_max;\n            }\n        } else if\
    \ c == ')' {\n            if current_max > 0 {\n                current_max -=\
    \ 1;\n            }\n        } else if c == ' ' {\n            paren_levels.push(max);\n\
    \            max = 0;\n            current_max = 0;\n        }\n    }\n    paren_levels.push(max);\n\
    \    paren_levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822099
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack: Vec<char> = Vec::new();\n    let mut\
    \ max_nesting: isize = 0;\n    let mut max_nesting_vec: Vec<isize> = Vec::new();\n\
    \    for c in paren_string.chars() {\n        match c {\n            '(' => {\n\
    \                max_nesting += 1;\n                paren_stack.push(c);\n   \
    \         }\n            ')' => {\n                paren_stack.pop();\n      \
    \          max_nesting -= 1;\n            }\n            ' ' => {\n          \
    \      max_nesting_vec.push(max_nesting);\n                max_nesting = 0;\n\
    \            }\n            _ => println!(\"Invalid character\"),\n        }\n\
    \    }\n    max_nesting_vec.push(max_nesting);\n    max_nesting_vec\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpbn4vk78c.rs:31:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822099
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_vec: Vec<char> = Vec::new();\n    let mut\
    \ paren_count: Vec<isize> = Vec::new();\n    let mut max_count: isize = 0;\n \
    \   let mut curr_count: isize = 0;\n\n    // Split the string into groups using\
    \ space delimiter and put the groups into a vector\n    let paren_groups: Vec<&str>\
    \ = paren_string.split(\" \").collect();\n\n    // For each of the groups\n  \
    \  for each_group in paren_groups {\n        // For each of the characters in\
    \ the group\n        for each_char in each_group.chars() {\n            // If\
    \ the character is a left parentheses\n            if each_char == '(' {\n   \
    \             // Increment the current nesting level count\n                curr_count\
    \ += 1;\n                // If the current count exceeds the maximum count, update\
    \ the maximum count\n                if curr_count > max_count {\n           \
    \         max_count = curr_count;\n                }\n            }\n        \
    \    // If the character is a right parentheses\n            else if each_char\
    \ == ')' {\n                // If the character is a left parentheses, decrement\
    \ the current nesting level count\n                curr_count -= 1;\n        \
    \    }\n        }\n        // After all the characters in the group are processed,\
    \ push the maximum nesting level\n        // count to the parenthesis count vector\n\
    \        paren_count.push(max_count);\n        // Reset the current nesting level\
    \ count and maximum nesting level count\n        curr_count = 0;\n        max_count\
    \ = 0;\n    }\n\n    paren_count\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822100
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_levels = Vec::new();\n    let mut current_level\
    \ = 0;\n    let mut max_level = 0;\n    for c in paren_string.chars() {\n    \
    \    match c {\n            '(' => {\n                current_level += 1;\n  \
    \              if current_level > max_level {\n                    max_level =\
    \ current_level;\n                }\n            }\n            ')' => {\n   \
    \             current_level -= 1;\n            }\n            ' ' => {\n     \
    \           max_levels.push(max_level);\n                max_level = 0;\n    \
    \            current_level = 0;\n            }\n            _ => continue,\n \
    \       }\n    }\n    max_levels.push(max_level);\n    max_levels\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822100
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut group_counts = Vec::new();\n    let mut current_max\
    \ = 0;\n    let mut current_count = 0;\n    let mut current_group = Vec::new();\n\
    \    for s in paren_string.split(\" \") {\n        let chars: Vec<char> = s.chars().collect();\n\
    \        for c in chars {\n            match c {\n                '(' => {\n \
    \                   current_count += 1;\n                    if current_count\
    \ > current_max {\n                        current_max = current_count;\n    \
    \                }\n                }\n                ')' => {\n            \
    \        current_count -= 1;\n                }\n                _ => continue,\n\
    \            }\n        }\n        group_counts.push(current_max);\n        current_max\
    \ = 0;\n        current_count = 0;\n    }\n    group_counts\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n --> /tmp/tmp4xslsgb8.rs:8:29\n\
    \  |\n8 |     let mut current_group = Vec::new();\n  |         -----------------\
    \   ^^^^^^^^ cannot infer type for type parameter `T`\n  |         |\n  |    \
    \     consider giving `current_group` the explicit type `Vec<T>`, where the type\
    \ parameter `T` is specified\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659822099
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut results = Vec::new();\n    for each_group in paren_string.split_whitespace()\
    \ {\n        let mut depth = 0;\n        let mut result = 0;\n        for each_char\
    \ in each_group.chars() {\n            if each_char == '(' {\n               \
    \ depth += 1;\n                if depth > result {\n                    result\
    \ = depth;\n                }\n            } else if each_char == ')' {\n    \
    \            depth -= 1;\n            }\n        }\n        results.push(result);\n\
    \    }\n    results\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822100
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result: Vec<isize> = Vec::new();\n    let mut max_level:\
    \ isize = 0;\n    let mut current_level: isize = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            current_level += 1;\n            if current_level\
    \ > max_level {\n                max_level = current_level;\n            }\n \
    \       } else if c == ')' {\n            current_level -= 1;\n        } else\
    \ if c == ' ' {\n            result.push(max_level);\n            max_level =\
    \ 0;\n            current_level = 0;\n        }\n    }\n    result.push(max_level);\n\
    \    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822100
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut res = Vec::new();\n    let paren_string = paren_string.trim();\n\
    \    let mut start_idx = 0usize;\n    let mut max_level = 0isize;\n    let mut\
    \ curr_level = 0isize;\n    let mut in_parens = false;\n    while start_idx <\
    \ paren_string.len() {\n        if !in_parens && paren_string.chars().nth(start_idx).unwrap()\
    \ == '(' {\n            in_parens = true;\n            start_idx += 1;\n     \
    \       continue;\n        }\n        if in_parens && paren_string.chars().nth(start_idx).unwrap()\
    \ == '(' {\n            curr_level += 1;\n            start_idx += 1;\n      \
    \      continue;\n        }\n        if in_parens && paren_string.chars().nth(start_idx).unwrap()\
    \ == ')' {\n            curr_level -= 1;\n            start_idx += 1;\n      \
    \      continue;\n        }\n        if in_parens && paren_string.chars().nth(start_idx).unwrap()\
    \ == ' ' {\n            max_level = max(max_level, curr_level);\n            curr_level\
    \ = 0;\n            in_parens = false;\n            start_idx += 1;\n        \
    \    continue;\n        }\n    }\n    max_level = max(max_level, curr_level);\n\
    \    res.push(max_level);\n    res\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmppysyvpx7.rs:28:25\n\
    \   |\n28 |             max_level = max(max_level, curr_level);\n   |        \
    \                 ^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror[E0425]: cannot find\
    \ function `max` in this scope\n  --> /tmp/tmppysyvpx7.rs:35:17\n   |\n35 |  \
    \   max_level = max(max_level, curr_level);\n   |                 ^^^ not found\
    \ in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use\
    \ std::cmp::max;\n   |\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822099
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let paren_string = paren_string.replace(\" \", \"\");\n\
    \    let mut paren_count = 0;\n    let mut max_count = 0;\n    let mut groups:\
    \ Vec<isize> = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                paren_count += 1;\n             \
    \   if paren_count > max_count {\n                    max_count = paren_count;\n\
    \                }\n            }\n            ')' => {\n                paren_count\
    \ -= 1;\n            }\n            _ => {\n                panic!(\"Unexpected\
    \ character: {}\", c);\n            }\n        }\n        if paren_count == 0\
    \ {\n            groups.push(max_count);\n            max_count = 0;\n       \
    \ }\n    }\n    groups\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822100
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = vec![];\n    for group in paren_string.split(\"\
    \ \") {\n        let mut nesting_level = 0;\n        let mut max_group_nesting\
    \ = 0;\n        for c in group.chars() {\n            match c {\n            \
    \    '(' => nesting_level += 1,\n                ')' => nesting_level -= 1,\n\
    \                _ => (),\n            }\n            if nesting_level > max_group_nesting\
    \ {\n                max_group_nesting = nesting_level;\n            }\n     \
    \   }\n        max_nesting.push(max_group_nesting);\n    }\n    max_nesting\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822100
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = Vec::new();\n    let\
    \ mut max_deep: Vec<isize> = Vec::new();\n    let mut current_deep: isize = 0;\n\
    \    let mut total_deep: isize = 0;\n    let chars: Vec<char> = paren_string.chars().collect();\n\
    \    for c in chars {\n        match c {\n            '(' => {\n             \
    \   total_deep += 1;\n                current_deep += 1;\n                paren_stack.push(c);\n\
    \            }\n            ')' => {\n                total_deep -= 1;\n     \
    \           paren_stack.pop();\n                if total_deep < 0 {\n        \
    \            max_deep.push(current_deep);\n                    current_deep =\
    \ 0;\n                    total_deep = 0;\n                }\n            }\n\
    \            _ => {\n                if total_deep != 0 {\n                  \
    \  max_deep.push(current_deep);\n                    current_deep = 0;\n     \
    \               total_deep = 0;\n                }\n            }\n        }\n\
    \    }\n    if total_deep != 0 {\n        max_deep.push(current_deep);\n    }\n\
    \    return max_deep;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0v442zfj.rs:15:34\n   |\n\
    15 |                 paren_stack.push(c);\n   |                              \
    \    ^ expected `isize`, found `char`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659822099
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut vec = Vec::new();\n    for group in paren_string.split_whitespace()\
    \ {\n        let mut max_count = 0;\n        let mut current_count = 0;\n    \
    \    for c in group.chars() {\n            if c == '(' {\n                current_count\
    \ += 1;\n            } else if c == ')' {\n                current_count -= 1;\n\
    \            } else {\n                panic!(\"Unknown character\");\n      \
    \      }\n            if current_count > max_count {\n                max_count\
    \ = current_count;\n            }\n        }\n        vec.push(max_count);\n \
    \   }\n    vec\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n \
    \   assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822100
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut v = vec![];\n    for paren in paren_string.split_whitespace()\
    \ {\n        let mut curr_level = 0;\n        let mut max_level = 0;\n       \
    \ for c in paren.chars() {\n            if c == '(' {\n                curr_level\
    \ += 1;\n            } else if c == ')' {\n                curr_level -= 1;\n\
    \            }\n            if curr_level > max_level {\n                max_level\
    \ = curr_level;\n            }\n        }\n        v.push(max_level);\n    }\n\
    \    v\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822100
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    //TODO: complete this function\n    let mut result = Vec::new();\n\
    \    for line in paren_string.lines() {\n        let mut counter = 0;\n      \
    \  let mut max_level = 0;\n        for c in line.chars() {\n            if c ==\
    \ '(' {\n                counter += 1;\n                if counter > max_level\
    \ {\n                    max_level = counter;\n                }\n           \
    \ } else if c == ')' {\n                counter -= 1;\n            }\n       \
    \ }\n        result.push(max_level);\n    }\n    result\n}\n\nfn main() {\n  \
    \  let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpspcpxt57.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822100
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack: Vec<i32> = Vec::new();\n    let mut\
    \ max_level: isize = 0;\n    let mut levels: Vec<isize> = Vec::new();\n    for\
    \ paren in paren_string.chars() {\n        if paren == '(' {\n            max_level\
    \ += 1;\n            paren_stack.push(1);\n        } else if paren == ')' {\n\
    \            if paren_stack.len() > 0 {\n                paren_stack.pop();\n\
    \            } else {\n                println!(\"Invalid parentheses characters,\
    \ not balanced.\");\n                return Vec::new();\n            }\n     \
    \       max_level -= 1;\n        } else if paren == ' ' {\n            if paren_stack.len()\
    \ == 0 {\n                levels.push(max_level);\n                max_level =\
    \ 0;\n            } else {\n                println!(\"Invalid parentheses characters,\
    \ not balanced.\");\n                return Vec::new();\n            }\n     \
    \   } else {\n            println!(\"Invalid parentheses characters\");\n    \
    \        return Vec::new();\n        }\n    }\n    levels\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp8afmxdln.rs:38:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822100
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n        .map(|paren_group|\
    \ {\n            // First and second elements of the tuple returned are the min\
    \ and max depth of nesting respectively.\n            paren_group\n          \
    \      .chars()\n                .fold((0, 0), |(min_depth, max_depth), curr_char|\
    \ {\n                    match curr_char {\n                        '(' => (min_depth\
    \ + 1, max_depth + 1),\n                        ')' => {\n                   \
    \         if min_depth == 0 {\n                                (0, max_depth)\n\
    \                            } else {\n                                (min_depth\
    \ - 1, max_depth)\n                            }\n                        }\n\
    \                        _ => (min_depth, max_depth),\n                    }\n\
    \                })\n                .1\n        })\n        .collect()\n}\n\n\
    fn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 3, 1, 5]`,\n right: `[2, 3, 1, 3]`', /tmp/tmprr7pra8k.rs:31:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822100
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n        .map(|s|\
    \ {\n            let mut level = 0;\n            let mut max_level = 0;\n    \
    \        for c in s.chars() {\n                if c == '(' {\n               \
    \     level += 1;\n                    if level > max_level {\n              \
    \          max_level = level;\n                    }\n                } else if\
    \ c == ')' {\n                    level -= 1;\n                }\n           \
    \ }\n            max_level\n        })\n        .collect()\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822100
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut res: Vec<isize> = Vec::new();\n    let mut prev_level\
    \ = 0;\n    let mut current_level = 0;\n    for ch in paren_string.chars() {\n\
    \        if ch == '(' {\n            current_level += 1;\n        } else if ch\
    \ == ')' {\n            current_level -= 1;\n        } else if ch == ' ' {\n \
    \           res.push(current_level - prev_level);\n            prev_level = current_level;\n\
    \        }\n    }\n    res.push(current_level - prev_level);\n    res\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp0l2ao_je.rs:24:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822100
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0;\n    let mut levels = Vec::new();\n\
    \    for paren in paren_string.chars() {\n        match paren {\n            '('\
    \ => {\n                level += 1;\n                levels.push(level);\n   \
    \         }\n            ')' => {\n                level -= 1;\n             \
    \   levels.push(level);\n            }\n            _ => (),\n        }\n    }\n\
    \    levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 1, 2, 1, 0, 1, 2, 3, 2, 1, 0, 1, 0, 1, 2, 3, 2, 1, 2, 1, 2, 1, 0]`,\n\
    \ right: `[2, 3, 1, 3]`', /tmp/tmpvduz1i85.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822100
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split(\" \")\n        .map(|group|\
    \ group.chars().fold(0, |max_nesting, ch| match ch {\n            '(' => max_nesting\
    \ + 1,\n            ')' => max_nesting - 1,\n            _ => max_nesting,\n \
    \       }))\n        .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpvt4tv_a6.rs:17:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822100
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = Vec::new();\n    let mut current_nesting\
    \ = 0;\n    let mut max_nesting_per_group = 0;\n    let mut paren_iter = paren_string.chars();\n\
    \    let mut parent_char = paren_iter.next();\n    while parent_char != None {\n\
    \        match parent_char.unwrap() {\n            '(' => {\n                current_nesting\
    \ += 1;\n                if current_nesting > max_nesting_per_group {\n      \
    \              max_nesting_per_group = current_nesting;\n                }\n \
    \           }\n            ')' => {\n                current_nesting -= 1;\n \
    \           }\n            ' ' => {\n                max_nesting.push(max_nesting_per_group);\n\
    \                max_nesting_per_group = 0;\n                current_nesting =\
    \ 0;\n            }\n            _ => {\n                panic!(\"Invalid character\
    \ in the string\");\n            }\n        }\n        parent_char = paren_iter.next();\n\
    \    }\n    max_nesting.push(max_nesting_per_group);\n    max_nesting\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822100
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut temp = 0;\n \
    \   let mut current_max = 0;\n    for i in paren_string.chars() {\n        if\
    \ i == '(' {\n            temp += 1;\n            if temp > current_max {\n  \
    \              current_max = temp;\n            }\n        } else if i == ')'\
    \ {\n            temp -= 1;\n        } else if i == ' ' {\n            result.push(current_max);\n\
    \            current_max = 0;\n            temp = 0;\n        }\n    }\n    result.push(current_max);\n\
    \    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822100
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut depth_vec = Vec::new();\n    let mut depth = 0;\n\
    \    let mut max_depth = 0;\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depth_vec.push(max_depth);\n      \
    \          max_depth = 0;\n                depth = 0;\n            }\n       \
    \     _ => {}\n        }\n    }\n    depth_vec.push(max_depth);\n    depth_vec\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822100
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut stack = Vec::new();\n\
    \    let mut deepest_level = 0;\n    let mut current_level = 0;\n    let mut previous_level\
    \ = 0;\n    let mut previous_char = ' ';\n    let mut is_end_of_group = false;\n\
    \n    for ch in paren_string.chars() {\n        if ch == '(' {\n            if\
    \ is_end_of_group {\n                result.push(deepest_level);\n           \
    \     deepest_level = 0;\n                current_level = 0;\n               \
    \ previous_level = 0;\n                is_end_of_group = false;\n            }\n\
    \            stack.push(ch);\n            current_level += 1;\n            if\
    \ current_level > deepest_level {\n                deepest_level = current_level;\n\
    \            }\n        } else if ch == ')' {\n            if stack.is_empty()\
    \ {\n                panic!(\"Invalid string - parentheses mismatch detected\"\
    );\n            }\n            stack.pop();\n            previous_level = current_level;\n\
    \            current_level -= 1;\n        } else if ch == ' ' {\n            if\
    \ is_end_of_group {\n                panic!(\"Invalid string - multiple spaces\
    \ detected\");\n            }\n            if previous_char == ')' && previous_level\
    \ > 0 {\n                panic!(\"Invalid string - parentheses mismatch detected\"\
    );\n            }\n            is_end_of_group = true;\n        } else {\n   \
    \         panic!(\"Invalid string - non-parentheses character detected\");\n \
    \       }\n        previous_char = ch;\n    }\n\n    if !stack.is_empty() {\n\
    \        panic!(\"Invalid string - parentheses mismatch detected\");\n    }\n\n\
    \    result.push(deepest_level);\n    result\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''Invalid string - parentheses mismatch detected'',
    /tmp/tmp1jcjtgb_.rs:39:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822100
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result: Vec<isize> = Vec::new();\n    let mut num_parens:\
    \ isize = 0;\n    let mut max_num_parens: isize = 0;\n    for ch in paren_string.chars()\
    \ {\n        match ch {\n            '(' => {\n                num_parens += 1;\n\
    \                if num_parens > max_num_parens {\n                    max_num_parens\
    \ = num_parens;\n                }\n            }\n            ')' => {\n    \
    \            num_parens -= 1;\n            }\n            ' ' => {\n         \
    \       result.push(max_num_parens);\n                max_num_parens = 0;\n  \
    \              num_parens = 0;\n            }\n            _ => {}\n        }\n\
    \    }\n    result.push(max_num_parens);\n    result\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822100
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut output = Vec::new();\n    let mut current_level\
    \ = 0;\n    let mut max_level = 0;\n    for char in paren_string.chars() {\n \
    \       if char == '(' {\n            current_level += 1;\n            if current_level\
    \ > max_level {\n                max_level = current_level;\n            }\n \
    \       } else if char == ')' {\n            current_level -= 1;\n        } else\
    \ if char == ' ' {\n            output.push(max_level);\n            max_level\
    \ = 0;\n            current_level = 0;\n        }\n    }\n    output.push(max_level);\n\
    \    output\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822100
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut current_depth = 0;\n\
    \    let mut depths: Vec<isize> = Vec::new();\n\n    // Iterate over the string\n\
    \    for c in paren_string.chars() {\n        match c {\n            '(' => {\n\
    \                // Increment depth for an opening parenthesis\n             \
    \   current_depth += 1;\n                // Update max depth if needed\n     \
    \           if current_depth > max_depth {\n                    max_depth = current_depth;\n\
    \                }\n            }\n            ')' => {\n                // Decrement\
    \ depth for a closing parenthesis\n                current_depth -= 1;\n     \
    \       }\n            ' ' => {\n                // Got to next group, add the\
    \ result to the depths vector and reset depth\n                depths.push(max_depth);\n\
    \                max_depth = 0;\n                current_depth = 0;\n        \
    \    }\n            _ => {}\n        }\n    }\n\n    // Push result for the last\
    \ group\n    depths.push(max_depth);\n\n    depths\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822100
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut depth = 0;\n    let mut max_depth = 0;\n    let\
    \ mut output = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                output.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    output.push(max_depth);\n    output\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822100
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut v = Vec::new();\n    for s in paren_string.split_whitespace()\
    \ {\n        let mut stack = Vec::new();\n        let mut max_cnt = 0;\n     \
    \   let mut curr_cnt = 0;\n        for c in s.chars() {\n            if c == '('\
    \ {\n                curr_cnt += 1;\n                max_cnt = std::cmp::max(max_cnt,\
    \ curr_cnt);\n                stack.push(c);\n            } else if c == ')' {\n\
    \                if stack.pop().is_none() {\n                    println!(\"Mismatched\
    \ parentheses in {}\", s);\n                    return Vec::new();\n         \
    \       }\n                curr_cnt -= 1;\n            }\n        }\n        if\
    \ stack.is_empty() {\n            v.push(max_cnt);\n        } else {\n       \
    \     println!(\"Mismatched parentheses in {}\", s);\n            return Vec::new();\n\
    \        }\n    }\n    v\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822100
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut out_vec = Vec::new();\n    let mut curr_nest_level\
    \ = 0;\n    let mut max_nest_level = 0;\n    for i in paren_string.chars() {\n\
    \        match i {\n            '(' => {\n                curr_nest_level += 1;\n\
    \                if curr_nest_level > max_nest_level {\n                    max_nest_level\
    \ = curr_nest_level;\n                }\n            }\n            ')' => {\n\
    \                curr_nest_level -= 1;\n            }\n            ' ' => {\n\
    \                out_vec.push(max_nest_level);\n                max_nest_level\
    \ = 0;\n                curr_nest_level = 0;\n            }\n            _ =>\
    \ {\n                panic!(\"Input contains invalid characters! Make sure input\
    \ is a string of nested parens separated by spaces.\");\n            }\n     \
    \   }\n    }\n    out_vec.push(max_nest_level);\n    out_vec\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822100
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_groups: Vec<String> = paren_string.split_whitespace().map(|s|\
    \ s.to_string()).collect();\n    let mut output: Vec<isize> = Vec::new();\n  \
    \  while !paren_groups.is_empty() {\n        let mut count = 0;\n        let mut\
    \ max_count = 0;\n        let mut parens = paren_groups.pop().unwrap();\n    \
    \    for ch in parens.chars() {\n            if ch == '(' {\n                count\
    \ += 1;\n            } else if ch == ')' {\n                count -= 1;\n    \
    \        }\n            if count > max_count {\n                max_count = count;\n\
    \            }\n        }\n        output.push(max_count);\n    }\n    output\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 1, 3, 2]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpjeibg9sb.rs:28:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822100
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut stack: Vec<u8> = Vec::new();\n    let mut current_level\
    \ = 0;\n    let mut levels: Vec<isize> = Vec::new();\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                stack.push(c as\
    \ u8);\n                current_level += 1;\n            }\n            ')' =>\
    \ {\n                stack.pop();\n                if stack.is_empty() {\n   \
    \                 levels.push(current_level);\n                    current_level\
    \ = 0;\n                } else {\n                    current_level -= 1;\n  \
    \              }\n            }\n            _ => continue,\n        }\n    }\n\
    \    levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 1, 1]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp4mn7zfsw.rs:31:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822100
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    // split on space to get the multiple groups\n    let groups\
    \ = paren_string.split(\" \");\n    let mut results = Vec::new();\n    // iterate\
    \ through each group\n    for g in groups {\n        let mut depth = 0;\n    \
    \    let mut max_depth = 0;\n        for c in g.chars() {\n            if c ==\
    \ '(' {\n                depth += 1;\n            } else if c == ')' {\n     \
    \           depth -= 1;\n            }\n            if depth > max_depth {\n \
    \               max_depth = depth;\n            }\n        }\n        results.push(max_depth);\n\
    \    }\n    results\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822100
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n        .map(|x|\
    \ {\n            let mut paren_stack = vec![];\n            let mut max_depth\
    \ = 0;\n            let mut depth = 0;\n            for c in x.chars() {\n   \
    \             match c {\n                    '(' => {\n                      \
    \  depth += 1;\n                        if depth > max_depth {\n             \
    \               max_depth = depth;\n                        }\n              \
    \          paren_stack.push(c);\n                    }\n                    ')'\
    \ => {\n                        if paren_stack.pop().is_none() {\n           \
    \                 panic!(\"No opening parens for closing paren.\");\n        \
    \                }\n                        depth -= 1;\n                    }\n\
    \                    _ => panic!(\"Unexpected character\"),\n                }\n\
    \            }\n            max_depth\n        })\n        .collect()\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822100
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut stack = Vec::new();\n    let mut answer = Vec::new();\n\
    \    let mut count = 0;\n    for c in paren_string.chars() {\n        if c ==\
    \ '(' {\n            stack.push(c);\n            count += 1;\n        } else if\
    \ c == ')' {\n            stack.pop();\n            count -= 1;\n        } else\
    \ if c == ' ' {\n            answer.push(count);\n            count = 0;\n   \
    \     }\n    }\n    answer.push(count);\n    answer\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpzueihsn3.rs:26:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822100
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_paren_level = 0;\n    let mut paren_level =\
    \ 0;\n    let mut results = Vec::new();\n\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                paren_level += 1;\n\
    \                if paren_level > max_paren_level {\n                    max_paren_level\
    \ = paren_level;\n                }\n            }\n            ')' => {\n   \
    \             paren_level -= 1;\n            }\n            ' ' => {\n       \
    \         results.push(max_paren_level);\n                max_paren_level = 0;\n\
    \                paren_level = 0;\n            }\n            _ => {}\n      \
    \  }\n    }\n    results.push(max_paren_level);\n    results\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822100
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut deepest_levels = Vec::new();\n    let mut level\
    \ = 0;\n    let mut deepest_level = 0;\n    let chars: Vec<char> = paren_string.chars().collect();\n\
    \    for i in 0..chars.len() {\n        if chars[i] == '(' {\n            level\
    \ += 1;\n            if level > deepest_level {\n                deepest_level\
    \ = level;\n            }\n        } else if chars[i] == ')' {\n            level\
    \ -= 1;\n        } else if chars[i] == ' ' {\n            deepest_levels.push(deepest_level);\n\
    \            deepest_level = 0;\n            level = 0;\n        }\n    }\n  \
    \  deepest_levels.push(deepest_level);\n    deepest_levels\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822100
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    // TODO: Implement this.\n    let mut result = Vec::new();\n\
    \    let mut str = String::new();\n    let mut stack = Vec::new();\n    let mut\
    \ deepest = 0;\n    let mut current = 0;\n    for (index, ch) in paren_string.chars().enumerate()\
    \ {\n        if ch == '(' {\n            current += 1;\n            if current\
    \ > deepest {\n                deepest = current;\n            }\n           \
    \ stack.push(index);\n        } else if ch == ')' {\n            current -= 1;\n\
    \            if current == 0 {\n                let (start, _) = stack.pop().unwrap();\n\
    \                if index - start > 0 {\n                    str = paren_string[start..=index].to_string();\n\
    \                    result.push(parse_nested_parens_helper(str));\n         \
    \       }\n            }\n        }\n    }\n    for n in result {\n        if\
    \ n == deepest {\n            println!(\"{}\", n);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `parse_nested_parens_helper` in this\
    \ scope\n  --> /tmp/tmp9k077sj4.rs:24:33\n   |\n24 |                     result.push(parse_nested_parens_helper(str));\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9k077sj4.rs:21:21\n\
    \   |\n21 |                 let (start, _) = stack.pop().unwrap();\n   |     \
    \                ^^^^^^^^^^   -------------------- this expression has type `usize`\n\
    \   |                     |\n   |                     expected `usize`, found\
    \ tuple\n   |\n   = note: expected type `usize`\n             found tuple `(_,\
    \ _)`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659822100
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut levels: Vec<isize> = Vec::new();\n    let mut current_level\
    \ = 0;\n    let mut max_level = 0;\n    for c in paren_string.chars() {\n    \
    \    if c == '(' {\n            current_level += 1;\n            if current_level\
    \ > max_level {\n                max_level = current_level;\n            }\n \
    \       } else if c == ')' {\n            current_level -= 1;\n        } else\
    \ if c == ' ' {\n            levels.push(max_level);\n            max_level =\
    \ 0;\n            current_level = 0;\n        }\n    }\n    levels.push(max_level);\n\
    \    levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822098
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    // Accumulate results in a vector.\n    let mut result\
    \ = Vec::new();\n\n    // Accumulate current depth of nesting.\n    let mut depth\
    \ = 0;\n\n    // Check each character in the string.\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => depth += 1,\n            ')' => depth\
    \ -= 1,\n            ' ' => {\n                result.push(depth);\n         \
    \       depth = 0;\n            }\n            _ => {}\n        }\n    }\n\n \
    \   result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpluasjcwd.rs:29:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822100
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut stack = vec![];\n    let mut res = vec![];\n  \
    \  let mut max_depth = 0;\n    for c in paren_string.chars() {\n        if c ==\
    \ '(' {\n            stack.push(c);\n            max_depth += 1;\n        } else\
    \ if c == ')' {\n            if stack.pop().is_none() {\n                panic!(\"\
    Dangling closing paren!\");\n            }\n            max_depth -= 1;\n    \
    \    } else if c == ' ' {\n            res.push(max_depth);\n            max_depth\
    \ = 0;\n        } else {\n            panic!(\"Invalid paren string!\");\n   \
    \     }\n    }\n    res.push(max_depth);\n    res\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpd7v1dns4.rs:30:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822100
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut stack = vec![];\n    let mut result = vec![];\n\
    \    for c in paren_string.chars() {\n        if c == '(' {\n            stack.push(c);\n\
    \        } else if c == ')' {\n            let mut paren_count = 0;\n        \
    \    while stack.last().unwrap() != &'(' {\n                paren_count += 1;\n\
    \                stack.pop();\n            }\n            stack.pop();\n     \
    \       stack.push(paren_count);\n        } else if c == ' ' {\n            let\
    \ mut paren_count = 0;\n            while stack.last().unwrap() > &'(' {\n   \
    \             paren_count += stack.pop().unwrap();\n            }\n          \
    \  result.push(paren_count);\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdfpg6mfo.rs:17:24\n   |\n\
    17 |             stack.push(paren_count);\n   |                        ^^^^^^^^^^^\
    \ expected `char`, found integer\n\nerror[E0277]: cannot add-assign `char` to\
    \ `{integer}`\n  --> /tmp/tmpdfpg6mfo.rs:21:29\n   |\n21 |                 paren_count\
    \ += stack.pop().unwrap();\n   |                             ^^ no implementation\
    \ for `{integer} += char`\n   |\n   = help: the trait `AddAssign<char>` is not\
    \ implemented for `{integer}`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822100
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    // Parse the input string into a vector of space separated\
    \ strings.\n    let mut paren_vector: Vec<&str> = paren_string.split_whitespace().collect();\n\
    \n    let mut paren_depth_vector: Vec<isize> = Vec::new();\n\n    for paren_substring\
    \ in paren_vector {\n        // Iterate over the group of nested parentheses.\n\
    \        let mut paren_depth = 0;\n\n        for ch in paren_substring.chars()\
    \ {\n            if ch == '(' {\n                paren_depth += 1;\n         \
    \   } else if ch == ')' {\n                paren_depth -= 1;\n            }\n\
    \        }\n\n        paren_depth_vector.push(paren_depth);\n    }\n\n    paren_depth_vector\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpbtyqk3eo.rs:30:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822100
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    /// Parse a single group of nested parentheses. This is\
    \ the core function to perform the actual\n    /// calculation.\n    /// The function\
    \ is designed to be a FSM.\n    /// The state is either `None` when we have not\
    \ encountered any parenthesis,\n    /// `Some(0)` when we have only encountered\
    \ the left parenthesis,\n    /// or `Some(n)` for `n > 0` when we have only encountered\
    \ the left parenthesis and `n` right\n    /// parentheses.\n    /// The initial\
    \ state is `None`.\n    /// When `None`, any left parenthesis we met will change\
    \ the state to `Some(0)`.\n    /// When `Some(0)`, any left parenthesis we met\
    \ will increase the depth by 1 and change the state\n    /// to `Some(1)`.\n \
    \   /// When `Some(n)`, any left parenthesis we met will increase the depth by\
    \ 1 and change the state\n    /// to `Some(n + 1)`.\n    /// Any right parenthesis\
    \ will decrease the state by 1.\n    /// The output is the maximum depth when\
    \ the state is `Some(n)`.\n    fn parse_single_group(input: &[char]) -> isize\
    \ {\n        let mut max_level = 0;\n        let mut current_level = None;\n \
    \       for &ch in input {\n            match ch {\n                '(' => {\n\
    \                    match current_level {\n                        None => current_level\
    \ = Some(0),\n                        Some(n) => {\n                         \
    \   current_level = Some(n + 1);\n                            max_level = max_level.max(n\
    \ + 1);\n                        }\n                    }\n                }\n\
    \                ')' => {\n                    match current_level {\n       \
    \                 None => {\n                            panic!(\"Unexpected ')'\"\
    );\n                        }\n                        Some(n) => {\n        \
    \                    current_level = Some(n - 1);\n                        }\n\
    \                    }\n                }\n                _ => {}\n         \
    \   }\n        }\n        match current_level {\n            None => max_level,\n\
    \            Some(n) => {\n                if n == 0 {\n                    max_level\n\
    \                } else {\n                    panic!(\"Unbalanced parentheses\"\
    );\n                }\n            }\n        }\n    }\n\n\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp_nfzte6y.rs:4:49\n  |\n4 |\
    \ fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659822100
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_levels: Vec<isize> = Vec::new();\n    let mut\
    \ current_level: isize = 0;\n    let mut running_max: isize = 0;\n    for c in\
    \ paren_string.chars() {\n        match c {\n            '(' => {\n          \
    \      current_level += 1;\n                if current_level > running_max {\n\
    \                    running_max = current_level;\n                }\n       \
    \     }\n            ')' => {\n                current_level -= 1;\n         \
    \   }\n            _ => {\n                max_levels.push(running_max);\n   \
    \             running_max = 0;\n                current_level = 0;\n         \
    \   }\n        }\n    }\n    max_levels.push(running_max);\n    max_levels\n}\n\
    \nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822100
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut depth = 0;\n    let mut max_depth = 0;\n    let\
    \ mut results = Vec::new();\n\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            depth += 1;\n            if depth > max_depth {\n  \
    \              max_depth = depth;\n            }\n        } else if c == ')' {\n\
    \            depth -= 1;\n        } else if c == ' ' {\n            results.push(max_depth);\n\
    \            max_depth = 0;\n            depth = 0;\n        }\n    }\n\n    results.push(max_depth);\n\
    \    results\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n   \
    \ assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822100
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let max_nested_paren_levels: Vec<isize> = paren_string\n\
    \        .split_whitespace()\n        .map(|group| {\n            let mut paren_stack:\
    \ Vec<isize> = Vec::new();\n            let mut max_level = 0;\n            let\
    \ mut level = 0;\n            for paren in group.chars() {\n                match\
    \ paren {\n                    '(' => {\n                        paren_stack.push(1);\n\
    \                        level += 1;\n                        if level > max_level\
    \ {\n                            max_level = level;\n                        }\n\
    \                    }\n                    ')' => {\n                       \
    \ match paren_stack.pop() {\n                            Some(_) => level -= 1,\n\
    \                            None => println!(\"Mismatched parens\"),\n      \
    \                  }\n                    }\n                    _ => println!(\"\
    Unexpected character in input\"),\n                }\n            }\n        \
    \    if !paren_stack.is_empty() {\n                println!(\"Mismatched parens\"\
    );\n            }\n            max_level\n        })\n        .collect();\n  \
    \  max_nested_paren_levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822100
