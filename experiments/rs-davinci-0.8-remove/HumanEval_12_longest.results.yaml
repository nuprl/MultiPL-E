language: rs
name: HumanEval_12_longest
results:
- exit_code: 101
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    match strings.len() {\n        0 => None,\n        1 => Some(strings[0].clone()),\n\
    \        _ => Some(strings.iter().max_by_key(|s| s.len()).unwrap().clone()),\n\
    \    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpxyamj1az.rs:14:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest_string\
    \ = &strings[0];\n    for string in &strings {\n        if string.len() > longest_string.len()\
    \ {\n            longest_string = string;\n        }\n    }\n\n    Some(longest_string.to_string())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut acc = None;\n    for s in strings {\n        if acc.is_none() ||\
    \ s.len() > acc.unwrap().len() {\n            acc = Some(s);\n        }\n    }\n\
    \    acc\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Option<T>`\n --> /tmp/tmplx9ym89n.rs:6:43\n\
    \  |\n4 |     let mut acc = None;\n  |         ------- consider giving `acc` the\
    \ explicit type `Option<T>`, where the type parameter `T` is specified\n5 |  \
    \   for s in strings {\n6 |         if acc.is_none() || s.len() > acc.unwrap().len()\
    \ {\n  |                                           ^^^^^^ cannot infer type for\
    \ type parameter `T`\n  |\n  = note: type must be known at this point\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659822485
- exit_code: 101
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let longest =\
    \ strings.iter().fold(strings[0].clone(), |a, b| {\n        if a.len() > b.len()\
    \ {\n            a\n        } else {\n            b.clone()\n        }\n    });\n\
    \n    Some(longest)\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpz7nqhkvl.rs:22:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822485
- exit_code: 101
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    match strings.len() {\n        0 => None,\n        _ => Some(strings.iter().max_by_key(|string|\
    \ string.len()).unwrap().to_string()),\n    }\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpt8u4969e.rs:13:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut max_len = 0;\n    let mut max_str = None;\n    for s in strings {\n\
    \        if s.len() > max_len {\n            max_len = s.len();\n            max_str\
    \ = Some(s);\n        }\n    }\n    max_str\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 101
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut strings\
    \ = strings;\n    strings.sort_by(|a, b| a.len().cmp(&b.len()));\n    let longest\
    \ = strings.pop().unwrap();\n    Some(longest)\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmp4y9r5va3.rs:17:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = String::new();\n    for string in strings {\n        if string.len() > longest.len()\
    \ {\n            longest = string;\n        }\n    }\n\n    Some(longest)\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest_so_far = None;\n    for s in strings {\n        longest_so_far\
    \ = match longest_so_far {\n            None => Some(s),\n            Some(x)\
    \ => {\n                if s.len() > x.len() {\n                    Some(s)\n\
    \                } else {\n                    Some(x)\n                }\n  \
    \          }\n        }\n    }\n    longest_so_far\n}\n\nfn main() {\n    let\
    \ candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut result = String::new();\n    for (i, s) in strings.iter().enumerate()\
    \ {\n        if s.len() > result.len() {\n            result = s.clone();\n  \
    \      }\n    }\n    match result.len() {\n        0 => None,\n        _ => Some(result),\n\
    \    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut best = None;\n    for s in strings {\n        best = match best {\n\
    \            None => Some(s),\n            Some(old) => if s.len() > old.len()\
    \ { Some(s) } else { Some(old) },\n        };\n    }\n    best\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut max_len = 0;\n    let mut longest_string = None;\n    for string\
    \ in strings {\n        if string.len() > max_len {\n            max_len = string.len();\n\
    \            longest_string = Some(string);\n        }\n    }\n    longest_string\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    strings.into_iter().max_by_key(|x| x.len()).cloned()\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `cloned` exists for enum `Option<String>`, but\
    \ its trait bounds were not satisfied\n   --> /tmp/tmpitwlll7a.rs:4:49\n    |\n\
    4   |       strings.into_iter().max_by_key(|x| x.len()).cloned()\n    |      \
    \                                             ^^^^^^ method cannot be called on\
    \ `Option<String>` due to unsatisfied trait bounds\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Option<String>: Iterator`\n \
    \           which is required by `&mut Option<String>: Iterator`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659822485
- exit_code: 101
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    match strings.len() {\n        0 => None,\n        _ => Some(strings.iter().max_by_key(|x|\
    \ x.len()).unwrap().to_string()),\n    }\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmp0etdg5uz.rs:13:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822485
- exit_code: 101
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    strings.iter().max_by_key(|s|\
    \ s.len()).cloned()\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmprykeuyt7.rs:14:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut max_len = 0;\n    let mut longest_string = None;\n    for x in strings\
    \ {\n        if x.len() > max_len {\n            max_len = x.len();\n        \
    \    longest_string = Some(x);\n        }\n    }\n    longest_string\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    strings.into_iter().fold(None, |longest, s| {\n        match longest {\n\
    \            None => Some(s),\n            Some(ref l) => if s.len() > l.len()\
    \ { Some(s) } else { longest }\n        }\n    })\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest_str\
    \ = &strings[0];\n    for s in &strings {\n        if s.len() > longest_str.len()\
    \ {\n            longest_str = s;\n        }\n    }\n\n    Some(longest_str.to_string())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 101
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    // TODO: Implement an algorithm to find the longest string in a list of strings.\n\
    \    None\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(\"x\")`', /tmp/tmpzekm32h1.rs:11:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    // We know that\
    \ the input list is not empty here.\n    let mut longest = &strings[0];\n    for\
    \ string in &strings {\n        if string.len() > longest.len() {\n          \
    \  longest = string;\n        }\n    }\n\n    Some(longest.to_string())\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 101
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    // NOTE: We use Option in order to express that the operation is only defined\
    \ for non-empty\n    // lists.\n    strings.into_iter().max_by_key(|s| s.len())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpp0ru_rp_.rs:12:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest_len = 0;\n    let mut longest_string = None;\n    for string\
    \ in strings {\n        if string.len() > longest_len {\n            longest_len\
    \ = string.len();\n            longest_string = Some(string);\n        }\n   \
    \ }\n    longest_string\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest_string\
    \ = &strings[0];\n    for s in &strings {\n        if s.len() > longest_string.len()\
    \ {\n            longest_string = s;\n        }\n    }\n\n    Some(longest_string.to_string())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut result = None;\n    let mut longest_len = 0;\n    for string in strings\
    \ {\n        if string.len() > longest_len {\n            result = Some(string);\n\
    \            longest_len = string.len();\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `string`\n --> /tmp/tmpjtbu1e9i.rs:9:27\n\
    \  |\n6 |     for string in strings {\n  |         ------ move occurs because\
    \ `string` has type `String`, which does not implement the `Copy` trait\n7 | \
    \        if string.len() > longest_len {\n8 |             result = Some(string);\n\
    \  |                           ------ value moved here\n9 |             longest_len\
    \ = string.len();\n  |                           ^^^^^^ value borrowed here after\
    \ move\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut strings_iter = strings.iter();\n    let mut max_len = 0;\n    let\
    \ mut max_string = None;\n    while let Some(string) = strings_iter.next() {\n\
    \        if string.len() > max_len {\n            max_len = string.len();\n  \
    \          max_string = Some(string.clone());\n        }\n    }\n    max_string\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut max_length = 0;\n    let mut max_string = None;\n    for str in strings\
    \ {\n        if str.len() > max_length {\n            max_length = str.len();\n\
    \            max_string = Some(str);\n        }\n    }\n    max_string\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 101
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    // String implements Ord so we can use the max function.\n    strings.into_iter().max()\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpx1gphtz3.rs:11:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut max_len\
    \ = strings[0].len();\n    let mut max_str = strings[0].clone();\n\n    for s\
    \ in strings {\n        if s.len() > max_len {\n            max_len = s.len();\n\
    \            max_str = s;\n        }\n    }\n\n    Some(max_str)\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut max_length = 0;\n    let mut result = None;\n    for s in strings\
    \ {\n        if s.len() > max_length {\n            max_length = s.len();\n  \
    \          result = Some(s);\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 101
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    strings.into_iter().fold(None, |a, b| match a {\n        None => Some(b),\n\
    \        Some(x) => if x.len() > b.len() {\n            Some(x)\n        } else\
    \ {\n            Some(b)\n        },\n    })\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmplif5ev07.rs:17:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822485
- exit_code: 101
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    match strings.is_empty() {\n        true => None,\n        false => {\n \
    \           Some(strings.iter().max_by_key(|string| string.len()).unwrap().to_string())\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpxyzou9mw.rs:15:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n\n    Some(longest)\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for str_val in strings {\n        match longest\
    \ {\n            None => longest = Some(str_val),\n            Some(ref mut lng)\
    \ => {\n                if str_val.len() > lng.len() {\n                    *lng\
    \ = str_val;\n                }\n            }\n        }\n    }\n    longest\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    match strings.len() {\n        0 => None,\n        1 => Some(strings[0].clone()),\n\
    \        _ => {\n            let mut max = strings[0].clone();\n            for\
    \ s in strings.iter() {\n                if s.len() > max.len() {\n          \
    \          max = s.clone();\n                }\n            }\n            Some(max)\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest_so_far = None;\n    for string in strings {\n        longest_so_far\
    \ = match longest_so_far {\n            None => Some(string),\n            Some(ref\
    \ existing) => {\n                let new_len = string.len();\n              \
    \  let existing_len = existing.len();\n                Some(if new_len > existing_len\
    \ {\n                    string\n                } else {\n                  \
    \  existing.clone()\n                })\n            }\n        }\n    }\n   \
    \ longest_so_far\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref mut old)\
    \ => {\n                if string.len() > old.len() {\n                    *old\
    \ = string;\n                }\n            }\n        }\n    }\n    longest\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for str in strings {\n        if str.len() > longest.len()\
    \ {\n            longest = str;\n        }\n    }\n\n    Some(longest)\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = String::new();\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n\n    Some(longest)\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest_index\
    \ = 0;\n    let mut longest_len = 0;\n    for (index, string) in strings.iter().enumerate()\
    \ {\n        if string.len() > longest_len {\n            longest_index = index;\n\
    \            longest_len = string.len();\n        }\n    }\n\n    Some(strings[longest_index].clone())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    strings.into_iter().max_by_key(|s| s.len()).cloned()\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `cloned` exists for enum `Option<String>`, but\
    \ its trait bounds were not satisfied\n   --> /tmp/tmp9fkrkvxj.rs:4:49\n    |\n\
    4   |       strings.into_iter().max_by_key(|s| s.len()).cloned()\n    |      \
    \                                             ^^^^^^ method cannot be called on\
    \ `Option<String>` due to unsatisfied trait bounds\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Option<String>: Iterator`\n \
    \           which is required by `&mut Option<String>: Iterator`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    match strings.is_empty() {\n        true => None,\n        false => {\n \
    \           let mut max_string = String::new();\n            for string in strings\
    \ {\n                if string.len() > max_string.len() {\n                  \
    \  max_string = string;\n                }\n            }\n            Some(max_string)\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    strings.into_iter().fold(None, |acc, string| {\n        match acc {\n   \
    \         None => Some(string),\n            Some(acc_string) => {\n         \
    \       if acc_string.len() < string.len() {\n                    Some(string)\n\
    \                } else {\n                    Some(acc_string)\n            \
    \    }\n            }\n        }\n    })\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 101
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    // None indicates an error\n    strings.into_iter().max_by_key(|s| s.len()).clone()\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmp2kw1siyg.rs:11:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    match strings.len() {\n        0 => None,\n        1 => Some(strings[0].clone()),\n\
    \        _ => {\n            let mut longest = strings[0].clone();\n         \
    \   for string in strings {\n                if string.len() > longest.len() {\n\
    \                    longest = string;\n                }\n            }\n   \
    \         Some(longest)\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut res =\
    \ &strings[0];\n    for s in &strings {\n        if s.len() > res.len() {\n  \
    \          res = s;\n        }\n    }\n\n    Some(res.to_string())\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest_string = None;\n    let mut longest_length = 0;\n    for\
    \ s in strings {\n        if s.len() > longest_length {\n            longest_string\
    \ = Some(s);\n            longest_length = s.len();\n        }\n    }\n    longest_string\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n --> /tmp/tmpawgovarj.rs:9:30\n\
    \  |\n6 |     for s in strings {\n  |         - move occurs because `s` has type\
    \ `String`, which does not implement the `Copy` trait\n7 |         if s.len()\
    \ > longest_length {\n8 |             longest_string = Some(s);\n  |         \
    \                          - value moved here\n9 |             longest_length\
    \ = s.len();\n  |                              ^ value borrowed here after move\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822485
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    strings.into_iter().fold(None, |acc, cur| {\n        acc.map(|x| if x.len()\
    \ >= cur.len() { x } else { cur }).or(Some(cur))\n    })\n}\n\nfn main() {\n \
    \   let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `cur`\n --> /tmp/tmplgsipbnx.rs:5:73\n\
    \  |\n4 |     strings.into_iter().fold(None, |acc, cur| {\n  |               \
    \                           --- move occurs because `cur` has type `String`, which\
    \ does not implement the `Copy` trait\n5 |         acc.map(|x| if x.len() >= cur.len()\
    \ { x } else { cur }).or(Some(cur))\n  |                 ---                 \
    \                     ---            ^^^ value used here after move\n  |     \
    \            |                                        |\n  |                 value\
    \ moved into closure here            variable moved due to use in closure\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest_string\
    \ = strings[0].clone();\n    for string in strings.iter() {\n        if string.len()\
    \ > longest_string.len() {\n            longest_string = string.clone();\n   \
    \     }\n    }\n\n    Some(longest_string)\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822486
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    strings.into_iter().fold(None, |current, candidate| {\n        if current.is_none()\
    \ || candidate.len() > current.unwrap().len() {\n            Some(candidate)\n\
    \        } else {\n            current\n        }\n    })\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `current`\n   --> /tmp/tmpfts5_8mq.rs:8:13\n\
    \    |\n4   |     strings.into_iter().fold(None, |current, candidate| {\n    |\
    \                                     ------- move occurs because `current` has\
    \ type `Option<String>`, which does not implement the `Copy` trait\n5   |    \
    \     if current.is_none() || candidate.len() > current.unwrap().len() {\n   \
    \ |                                                           -------- `current`\
    \ moved due to this method call\n...\n8   |             current\n    |       \
    \      ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `current`\nhelp: consider calling `.as_ref()`\
    \ to borrow the type's contents\n    |\n5   |         if current.is_none() ||\
    \ candidate.len() > current.as_ref().unwrap().len() {\n    |                 \
    \                                          +++++++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    match strings.len() {\n        0 => None,\n        1 => Some(strings[0].clone()),\n\
    \        _ => {\n            let mut max_len = 0;\n            let mut longest\
    \ = strings[0].clone();\n            for s in strings {\n                if s.len()\
    \ > max_len {\n                    max_len = s.len();\n                    longest\
    \ = s;\n                }\n            }\n            Some(longest)\n        }\n\
    \    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822486
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for s in strings {\n        match longest {\n\
    \            None => longest = Some(s),\n            Some(ref l) => if s.len()\
    \ > l.len() {\n                longest = Some(s);\n            },\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822486
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut max_len = 0;\n    let mut max_len_idx = 0;\n    for (idx, string)\
    \ in strings.iter().enumerate() {\n        if string.len() > max_len {\n     \
    \       max_len = string.len();\n            max_len_idx = idx;\n        }\n \
    \   }\n    if max_len == 0 {\n        None\n    } else {\n        Some(strings[max_len_idx].clone())\n\
    \    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822486
- exit_code: 101
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    match strings.len() {\n        0 => None,\n        _ => Some(strings.iter().max_by_key(|s|\
    \ s.len()).unwrap().to_string()),\n    }\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmp5m9l7tzt.rs:13:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822486
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        if longest.is_none()\
    \ || longest.as_ref().unwrap().len() < string.len() {\n            longest = Some(string);\n\
    \        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Option<T>`\n --> /tmp/tmpskkn51f5.rs:6:41\n\
    \  |\n4 |     let mut longest = None;\n  |         ----------- consider giving\
    \ `longest` the explicit type `Option<T>`, where the type parameter `T` is specified\n\
    5 |     for string in strings {\n6 |         if longest.is_none() || longest.as_ref().unwrap().len()\
    \ < string.len() {\n  |                                         ^^^^^^ cannot\
    \ infer type for type parameter `T`\n  |\n  = note: type must be known at this\
    \ point\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659822486
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = &strings[0];\n    for s in &strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n\n    Some(longest.to_string())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822486
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    // Declare a variable to store the longest string in it.\n    let mut longest\
    \ = None;\n\n    // For each string in the list\n    for s in strings {\n    \
    \    // Calculate the length of the current string\n        let cur_len = s.len();\n\
    \n        // Calculate the length of the longest string\n        let mut max_len\
    \ = match longest {\n            Some(s) => s.len(),\n            None => 0,\n\
    \        };\n\n        // If the current string length is longer, then we have\
    \ a new longest string!\n        if cur_len > max_len {\n            longest =\
    \ Some(s);\n        }\n    }\n\n    // Return the longest string.\n    longest\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Option<T>`\n  --> /tmp/tmp79yt7mpk.rs:14:24\n\
    \   |\n5  |     let mut longest = None;\n   |         ----------- consider giving\
    \ `longest` the explicit type `Option<T>`, with the type parameters specified\n\
    ...\n14 |             Some(s) => s.len(),\n   |                        ^ cannot\
    \ infer type\n   |\n   = note: type must be known at this point\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0282`.\n"
  stdout: ''
  timestamp: 1659822486
- exit_code: 101
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    match strings.len() {\n        0 => None,\n        _ => Some(strings.iter().max_by_key(|s|\
    \ s.len()).unwrap().to_string()),\n    }\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmp5m9l7tzt.rs:13:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822486
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822486
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut result = None;\n    for s in strings {\n        match result {\n\
    \            None => result = Some(s),\n            Some(rs) => if s.len() > rs.len()\
    \ {\n                result = Some(s);\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value\n --> /tmp/tmp6w5a5u0l.rs:8:18\n  |\n\
    8 |             Some(rs) => if s.len() > rs.len() {\n  |                  ^^ value\
    \ moved here, in previous iteration of loop\n  |\nnote: these 2 reinitializations\
    \ might get skipped\n --> /tmp/tmp6w5a5u0l.rs:7:21\n  |\n7 |             None\
    \ => result = Some(s),\n  |                     ^^^^^^\n8 |             Some(rs)\
    \ => if s.len() > rs.len() {\n9 |                 result = Some(s);\n  |     \
    \            ^^^^^^\n  = note: move occurs because value has type `String`, which\
    \ does not implement the `Copy` trait\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822486
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut result = None;\n    let mut longest_length = 0;\n    for s in strings\
    \ {\n        if s.len() > longest_length {\n            result = Some(s);\n  \
    \          longest_length = s.len();\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n --> /tmp/tmp6qovl54v.rs:9:30\n\
    \  |\n6 |     for s in strings {\n  |         - move occurs because `s` has type\
    \ `String`, which does not implement the `Copy` trait\n7 |         if s.len()\
    \ > longest_length {\n8 |             result = Some(s);\n  |                 \
    \          - value moved here\n9 |             longest_length = s.len();\n  |\
    \                              ^ value borrowed here after move\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659822486
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    match strings.len() {\n        0 => None,\n        1 => Some(strings[0].clone()),\n\
    \        _ => {\n            let mut longest = &strings[0];\n            for s\
    \ in &strings[1..] {\n                if s.len() > longest.len() {\n         \
    \           longest = s;\n                }\n            }\n            Some(longest.clone())\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822486
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut result = None;\n    let mut max_length = 0;\n    for s in strings\
    \ {\n        if s.len() > max_length {\n            max_length = s.len();\n  \
    \          result = Some(s);\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822486
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref longest_str)\
    \ => if string.len() > longest_str.len() {\n                longest = Some(string);\n\
    \            }\n        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822486
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longuest = String::new();\n    for s in strings {\n        if s.len()\
    \ > longuest.len() {\n            longuest = s;\n        }\n    }\n    if longuest.is_empty()\
    \ {\n        None\n    } else {\n        Some(longuest)\n    }\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822486
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    strings.into_iter().max_by_key(|s| s.len()).cloned()\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `cloned` exists for enum `Option<String>`, but\
    \ its trait bounds were not satisfied\n   --> /tmp/tmp9fkrkvxj.rs:4:49\n    |\n\
    4   |       strings.into_iter().max_by_key(|s| s.len()).cloned()\n    |      \
    \                                             ^^^^^^ method cannot be called on\
    \ `Option<String>` due to unsatisfied trait bounds\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Option<String>: Iterator`\n \
    \           which is required by `&mut Option<String>: Iterator`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659822485
- exit_code: 101
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    // You can use `if let` like in C.\n    if let Some(result) = strings.iter().max_by_key(|s|\
    \ s.len()) {\n        Some(result.to_string())\n    } else {\n        None\n \
    \   }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpnvbvxn6f.rs:15:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822486
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest_string = None;\n    let mut longest_string_len = 0;\n   \
    \ for string in strings {\n        if string.len() > longest_string_len {\n  \
    \          longest_string = Some(string);\n            longest_string_len = string.len();\n\
    \        }\n    }\n    longest_string\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `string`\n --> /tmp/tmp_7mi91d2.rs:9:34\n\
    \  |\n6 |     for string in strings {\n  |         ------ move occurs because\
    \ `string` has type `String`, which does not implement the `Copy` trait\n7 | \
    \        if string.len() > longest_string_len {\n8 |             longest_string\
    \ = Some(string);\n  |                                   ------ value moved here\n\
    9 |             longest_string_len = string.len();\n  |                      \
    \            ^^^^^^ value borrowed here after move\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822486
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut first = true;\n    let mut longest = String::new();\n    for s in\
    \ strings {\n        if first {\n            longest = s;\n            first =\
    \ false;\n        } else if s.len() > longest.len() {\n            longest = s;\n\
    \        }\n    }\n    if first {\n        None\n    } else {\n        Some(longest)\n\
    \    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822486
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest_string\
    \ = &strings[0];\n    for string in &strings {\n        if string.len() > longest_string.len()\
    \ {\n            longest_string = string;\n        }\n    }\n\n    Some(longest_string.to_string())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for s in strings {\n        match longest {\n\
    \            None => longest = Some(s),\n            Some(old) => if s.len() >\
    \ old.len() {\n                longest = Some(s);\n            }\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value\n --> /tmp/tmp81jccwfj.rs:8:18\n  |\n\
    8 |             Some(old) => if s.len() > old.len() {\n  |                  ^^^\
    \ value moved here, in previous iteration of loop\n  |\nnote: these 2 reinitializations\
    \ might get skipped\n --> /tmp/tmp81jccwfj.rs:7:21\n  |\n7 |             None\
    \ => longest = Some(s),\n  |                     ^^^^^^^\n8 |             Some(old)\
    \ => if s.len() > old.len() {\n9 |                 longest = Some(s);\n  |   \
    \              ^^^^^^^\n  = note: move occurs because value has type `String`,\
    \ which does not implement the `Copy` trait\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822486
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut result\
    \ = strings[0].clone();\n    for s in strings.iter() {\n        if s.len() > result.len()\
    \ {\n            result = s.clone();\n        }\n    }\n\n    Some(result)\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822486
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    // TODO: find\
    \ the longest string\n    let mut longest_len = 0;\n    let mut longest_string\
    \ = String::new();\n    for word in strings {\n        if word.len() > longest_len\
    \ {\n            longest_len = word.len();\n            longest_string = word;\n\
    \        }\n    }\n    Some(longest_string)\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822486
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    match strings.len() {\n        0 => None,\n        1 => Some(strings[0].clone()),\n\
    \        _ => {\n            let mut longest = String::new();\n            for\
    \ s in strings {\n                if s.len() > longest.len() {\n             \
    \       longest = s;\n                }\n            }\n            Some(longest)\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822486
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for item in strings {\n        match longest\
    \ {\n            None => longest = Some(item),\n            Some(ref mut x) =>\
    \ {\n                if item.len() > x.len() {\n                    *x = item;\n\
    \                }\n            }\n        }\n    }\n    longest\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822486
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    strings.into_iter().max_by_key(|s| s.len()).cloned()\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `cloned` exists for enum `Option<String>`, but\
    \ its trait bounds were not satisfied\n   --> /tmp/tmp9fkrkvxj.rs:4:49\n    |\n\
    4   |       strings.into_iter().max_by_key(|s| s.len()).cloned()\n    |      \
    \                                             ^^^^^^ method cannot be called on\
    \ `Option<String>` due to unsatisfied trait bounds\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Option<String>: Iterator`\n \
    \           which is required by `&mut Option<String>: Iterator`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut max = 0;\n    let mut longest = None;\n    for s in strings {\n \
    \       if s.len() > max {\n            max = s.len();\n            longest =\
    \ Some(s);\n        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822486
- exit_code: 101
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    //TODO: Implement this\n    None\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(\"x\")`', /tmp/tmptrqy3i69.rs:11:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822486
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    // TODO: it's possible to rewrite this using fold()\n    // let opt_max_string\
    \ = strings.iter().fold(None, |acc, s| {\n    //     match acc {\n    //     \
    \    None => Some(s),\n    //         Some(acc_s) => {\n    //             if\
    \ acc_s.len() < s.len() {\n    //                 Some(s)\n    //            \
    \ } else {\n    //                 Some(acc_s)\n    //             }\n    // \
    \        }\n    //     }\n    // });\n    // opt_max_string.map(|s| s.to_string())\n\
    \n    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest_string\
    \ = &strings[0];\n    for s in &strings {\n        if s.len() > longest_string.len()\
    \ {\n            longest_string = s;\n        }\n    }\n    Some(longest_string.to_string())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822486
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut max_length = 0;\n    let mut max_index = 0;\n    for (index, string)\
    \ in strings.iter().enumerate() {\n        if string.len() > max_length {\n  \
    \          max_length = string.len();\n            max_index = index;\n      \
    \  }\n    }\n    match strings.get(max_index) {\n        Some(string) => Some(string.to_string()),\n\
    \        None => None,\n    }\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822486
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    match strings.len() {\n        0 => None,\n        _ => {\n            let\
    \ mut strings = strings;\n            strings.sort_by(|a, b| b.len().cmp(&a.len()));\n\
    \            Some(strings[0].clone())\n        }\n    }\n}\n\nfn main() {\n  \
    \  let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822486
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        if let Some(ref\
    \ long) = longest {\n            if string.len() > long.len() {\n            \
    \    longest = Some(string);\n            }\n        } else {\n            longest\
    \ = Some(string);\n        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Option<T>`\n --> /tmp/tmpryw1gf4s.rs:6:16\n\
    \  |\n4 |     let mut longest = None;\n  |         ----------- consider giving\
    \ `longest` the explicit type `Option<T>`, where the type parameter `T` is specified\n\
    5 |     for string in strings {\n6 |         if let Some(ref long) = longest {\n\
    \  |                ^^^^^^^^^^^^^^ cannot infer type for type parameter `T` declared\
    \ on the enum `Option`\n  |\n  = note: type must be known at this point\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659822486
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let lengths = strings.iter().map(|s| s.len()).collect::<Vec<usize>>();\n\
    \    let mut max_len = 0;\n    for &l in lengths.iter() {\n        if l > max_len\
    \ {\n            max_len = l;\n        }\n    }\n    let mut idx = 0;\n    for\
    \ i in 0..strings.len() {\n        if lengths[i] == max_len {\n            idx\
    \ = i;\n            break;\n        }\n    }\n    if strings.len() > 0 {\n   \
    \     Some(strings[idx].clone())\n    } else {\n        None\n    }\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822486
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    strings.into_iter().max_by_key(|s| s.len()).cloned()\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `cloned` exists for enum `Option<String>`, but\
    \ its trait bounds were not satisfied\n   --> /tmp/tmp9fkrkvxj.rs:4:49\n    |\n\
    4   |       strings.into_iter().max_by_key(|s| s.len()).cloned()\n    |      \
    \                                             ^^^^^^ method cannot be called on\
    \ `Option<String>` due to unsatisfied trait bounds\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Option<String>: Iterator`\n \
    \           which is required by `&mut Option<String>: Iterator`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let longest_string_length = strings.iter().map(|x| x.len()).max();\n    match\
    \ longest_string_length {\n        Some(len) => {\n            // Find the first\
    \ item with the longest length.\n            match strings.iter().position(|x|\
    \ x.len() == len) {\n                Some(idx) => Some(strings[idx].clone()),\n\
    \                None => None,\n            }\n        }\n        None => None,\n\
    \    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822486
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let longest = strings.iter().fold(0, |acc, x| cmp::max(acc, x.len()));\n\
    \    match strings.iter().find(|x| x.len() == longest) {\n        Some(l) => Some(l.to_string()),\n\
    \        None => None,\n    }\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \ --> /tmp/tmpuu1cd98q.rs:4:51\n  |\n4 |     let longest = strings.iter().fold(0,\
    \ |acc, x| cmp::max(acc, x.len()));\n  |                                     \
    \              ^^^ use of undeclared crate or module `cmp`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659822486
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest_word\
    \ = strings[0].clone();\n    for i in 1..strings.len() {\n        if strings[i].len()\
    \ > longest_word.len() {\n            longest_word = strings[i].clone();\n   \
    \     }\n    }\n\n    Some(longest_word)\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822486
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest_string: Option<String> = None;\n    for string in strings\
    \ {\n        if longest_string.is_none() || string.len() > longest_string.as_ref().unwrap().len()\
    \ {\n            longest_string = Some(string);\n        }\n    }\n    longest_string\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822486
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest_str\
    \ = &strings[0];\n    for s in &strings {\n        if s.len() > longest_str.len()\
    \ {\n            longest_str = s;\n        }\n    }\n\n    Some(longest_str.to_string())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 101
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    match strings.len() {\n        0 => None,\n        _ => Some(strings.iter().max_by_key(|s|\
    \ s.len()).unwrap().to_string()),\n    }\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmp5m9l7tzt.rs:13:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822486
- exit_code: 101
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    strings.into_iter().max_by_key(|s| s.len()).clone()\n}\n\nfn main() {\n \
    \   let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpu8gp7huy.rs:10:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822486
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = String::new();\n    for i in 0..strings.len() {\n        if strings[i].len()\
    \ > longest.len() {\n            longest = strings[i].clone();\n        }\n  \
    \  }\n\n    Some(longest)\n}\n\nfn main() {\n    let candidate = longest;\n  \
    \  assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822486
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    match strings.is_empty() {\n        true => None,\n        false => {\n \
    \           let mut max_len = 0;\n            let mut index_longest = 0;\n   \
    \         for (index, string) in strings.iter().enumerate() {\n              \
    \  if string.len() > max_len {\n                    max_len = string.len();\n\
    \                    index_longest = index;\n                }\n            }\n\
    \            Some(strings[index_longest].clone())\n        }\n    }\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822486
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut strings = strings;\n    strings.sort_by(|a, b| b.len().cmp(&a.len()));\n\
    \    strings.first().cloned()\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822486
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(l) => {\n \
    \               if string.len() > l.len() {\n                    longest = Some(string);\n\
    \                }\n            }\n        }\n    }\n    longest\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value\n  --> /tmp/tmp3e6nof56.rs:8:18\n   |\n\
    8  |             Some(l) => {\n   |                  ^ value moved here, in previous\
    \ iteration of loop\n   |\nnote: these 2 reinitializations might get skipped\n\
    \  --> /tmp/tmp3e6nof56.rs:7:21\n   |\n7  |             None => longest = Some(string),\n\
    \   |                     ^^^^^^^\n...\n10 |                     longest = Some(string);\n\
    \   |                     ^^^^^^^\n   = note: move occurs because value has type\
    \ `String`, which does not implement the `Copy` trait\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659822486
- exit_code: 101
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut strings = strings;\n    strings.sort_by(|a, b| a.len().cmp(&b.len()));\n\
    \    strings.pop()\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmp36u4de63.rs:12:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822486
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest_str = String::new();\n    for string in strings {\n     \
    \   if string.len() > longest_str.len() {\n            longest_str = string;\n\
    \        }\n    }\n    match longest_str.len() {\n        0 => None,\n       \
    \ _ => Some(longest_str),\n    }\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822486
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let longest =\
    \ strings\n        .iter()\n        .fold(strings[0].clone(), |acc, x| {\n   \
    \         if x.len() > acc.len() {\n                x.clone()\n            } else\
    \ {\n                acc\n            }\n        });\n\n    Some(longest)\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822486
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    strings.into_iter().max_by_key(|s| s.len()).cloned()\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `cloned` exists for enum `Option<String>`, but\
    \ its trait bounds were not satisfied\n   --> /tmp/tmp9fkrkvxj.rs:4:49\n    |\n\
    4   |       strings.into_iter().max_by_key(|s| s.len()).cloned()\n    |      \
    \                                             ^^^^^^ method cannot be called on\
    \ `Option<String>` due to unsatisfied trait bounds\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Option<String>: Iterator`\n \
    \           which is required by `&mut Option<String>: Iterator`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest_string\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > longest_string.len()\
    \ {\n            longest_string = s;\n        }\n    }\n\n    Some(longest_string)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822486
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings.iter() {\n        if s.len() > longest.len()\
    \ {\n            longest = s.clone();\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822486
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    strings.into_iter().fold(None, |acc, s| {\n        match acc {\n        \
    \    None => Some(s),\n            Some(acc) => {\n                if s.len()\
    \ > acc.len() {\n                    Some(s)\n                } else {\n     \
    \               Some(acc)\n                }\n            }\n        }\n    })\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822486
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut max_index\
    \ = 0;\n    let mut max_len = 0;\n    for (index, value) in strings.iter().enumerate()\
    \ {\n        if value.len() > max_len {\n            max_index = index;\n    \
    \        max_len = value.len();\n        }\n    }\n\n    Some(strings[max_index].clone())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822486
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut out: Option<String> = None;\n    for s in strings {\n        if out.is_none()\
    \ || s.len() > out.as_ref().unwrap().len() {\n            out = Some(s);\n   \
    \     }\n    }\n    out\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822486
- exit_code: 101
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    strings.into_iter().max_by_key(|s| s.len()).map(String::from)\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpqxgctecx.rs:10:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822486
- exit_code: 101
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    strings.into_iter().max_by_key(|s| s.len()).map(|s| s.to_string())\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpvy9pzmv0.rs:10:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822486
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = 0;\n    let mut index = 0;\n    for (i, s) in strings.iter().enumerate() {\n\
    \        if s.len() > longest {\n            longest = s.len();\n            index\
    \ = i;\n        }\n    }\n\n    return Some(strings[index].clone());\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822487
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut result = None;\n    for string in strings {\n        result = match\
    \ result {\n            None => Some(string),\n            Some(ref s) => {\n\
    \                if string.len() > s.len() {\n                    Some(string)\n\
    \                } else {\n                    Some(s.clone())\n             \
    \   }\n            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822486
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings.iter() {\n        if s.len() > longest.len()\
    \ {\n            longest = s.clone();\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822486
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = String::new();\n    for string in strings {\n        if\
    \ string.len() > longest.len() {\n            longest = string;\n        }\n \
    \   }\n    if !longest.is_empty() {\n        Some(longest)\n    } else {\n   \
    \     None\n    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822486
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    strings.into_iter().fold(None, |acc, item| {\n        match acc {\n     \
    \       None => Some(item),\n            Some(acc_item) => {\n               \
    \ if acc_item.len() < item.len() {\n                    Some(item)\n         \
    \       } else {\n                    Some(acc_item)\n                }\n    \
    \        }\n        }\n    })\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822487
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut acc =\
    \ strings[0].clone();\n    for s in strings {\n        if s.len() > acc.len()\
    \ {\n            acc = s;\n        }\n    }\n\n    Some(acc)\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822487
- exit_code: 101
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    match strings.len() {\n        0 => None,\n        _ => Some(strings.iter().max_by_key(|x|\
    \ x.len()).unwrap().to_string()),\n    }\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmp0etdg5uz.rs:13:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822485
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut result = None;\n    for s in strings {\n        match result {\n\
    \            None => result = Some(s),\n            Some(rs) => {\n          \
    \      if s.len() > rs.len() {\n                    result = Some(s);\n      \
    \          }\n            }\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value\n  --> /tmp/tmpf_8vcoko.rs:8:18\n   |\n\
    8  |             Some(rs) => {\n   |                  ^^ value moved here, in\
    \ previous iteration of loop\n   |\nnote: these 2 reinitializations might get\
    \ skipped\n  --> /tmp/tmpf_8vcoko.rs:7:21\n   |\n7  |             None => result\
    \ = Some(s),\n   |                     ^^^^^^\n...\n10 |                     result\
    \ = Some(s);\n   |                     ^^^^^^\n   = note: move occurs because\
    \ value has type `String`, which does not implement the `Copy` trait\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822486
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    match strings.len() {\n        0 => None,\n        _ => {\n            let\
    \ mut longest_str = &strings[0];\n            for s in &strings {\n          \
    \      if s.len() > longest_str.len() {\n                    longest_str = s;\n\
    \                }\n            }\n            Some(longest_str.to_string())\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822487
- exit_code: 101
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    strings.into_iter().fold(None, |a,b| match a {\n        None => Some(b),\n\
    \        Some(a) => Some(if a.len() > b.len() { a } else { b })\n    })\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmp7_i97r76.rs:13:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822487
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    match strings.len() {\n        0 => None,\n        1 => Some(strings[0].clone()),\n\
    \        _ => {\n            let mut longest_str = strings[0].clone();\n     \
    \       for str in strings.iter() {\n                if str.len() > longest_str.len()\
    \ {\n                    longest_str = str.clone();\n                }\n     \
    \       }\n            Some(longest_str)\n        }\n    }\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822487
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    match strings.len() {\n        0 => None,\n        _ => {\n            let\
    \ mut longest_string = strings[0].clone();\n            for s in strings {\n \
    \               if s.len() > longest_string.len() {\n                    longest_string\
    \ = s;\n                }\n            }\n            Some(longest_string)\n \
    \       }\n    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822487
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    strings.into_iter().max_by_key(|s| s.len()).cloned()\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `cloned` exists for enum `Option<String>`, but\
    \ its trait bounds were not satisfied\n   --> /tmp/tmp9fkrkvxj.rs:4:49\n    |\n\
    4   |       strings.into_iter().max_by_key(|s| s.len()).cloned()\n    |      \
    \                                             ^^^^^^ method cannot be called on\
    \ `Option<String>` due to unsatisfied trait bounds\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Option<String>: Iterator`\n \
    \           which is required by `&mut Option<String>: Iterator`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut max =\
    \ &strings[0];\n    for string in &strings {\n        if string.len() > max.len()\
    \ {\n            max = string;\n        }\n    }\n\n    Some(max.clone())\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822487
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest_so_far = None;\n    for s in strings {\n        if longest_so_far.as_ref().map_or(true,\
    \ |curr| s.len() > curr.len()) {\n            longest_so_far = Some(s);\n    \
    \    }\n    }\n    longest_so_far\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `&T`\n --> /tmp/tmpgsla_eks.rs:6:50\n\
    \  |\n6 |         if longest_so_far.as_ref().map_or(true, |curr| s.len() > curr.len())\
    \ {\n  |                                                  ^^^^ consider giving\
    \ this closure parameter the explicit type `&T`, where the type parameter `T`\
    \ is specified\n  |\n  = note: type must be known at this point\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0282`.\n"
  stdout: ''
  timestamp: 1659822487
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for s in strings {\n        if longest.is_none()\
    \ || longest.as_ref().unwrap().len() < s.len() {\n            longest = Some(s);\n\
    \        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Option<T>`\n --> /tmp/tmpknfd8inq.rs:6:41\n\
    \  |\n4 |     let mut longest = None;\n  |         ----------- consider giving\
    \ `longest` the explicit type `Option<T>`, where the type parameter `T` is specified\n\
    5 |     for s in strings {\n6 |         if longest.is_none() || longest.as_ref().unwrap().len()\
    \ < s.len() {\n  |                                         ^^^^^^ cannot infer\
    \ type for type parameter `T`\n  |\n  = note: type must be known at this point\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659822487
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    match strings.is_empty() {\n        true => None,\n        false => {\n \
    \           let mut longest_string = &strings[0];\n            for i in 0..strings.len()\
    \ {\n                if strings[i].len() > longest_string.len() {\n          \
    \          longest_string = &strings[i];\n                }\n            }\n \
    \           Some(longest_string.to_string())\n        }\n    }\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822487
- exit_code: 101
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    match strings.len() {\n        0 => None,\n        _ => Some(strings.iter().max_by_key(|s|\
    \ s.len()).unwrap().to_string()),\n    }\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmp5m9l7tzt.rs:13:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822486
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut iterator\
    \ = strings.iter();\n    let mut longest = iterator.next().unwrap();\n\n    for\
    \ string in iterator {\n        if string.len() > longest.len() {\n          \
    \  longest = string;\n        }\n    }\n\n    Some(longest.to_string())\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822487
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut max_index\
    \ = 0;\n    let mut max_length = 0;\n    for (index, string) in strings.iter().enumerate()\
    \ {\n        if string.len() > max_length {\n            max_index = index;\n\
    \            max_length = string.len();\n        }\n    }\n\n    Some(strings[max_index].clone())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822487
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings.iter() {\n        if string.len()\
    \ > longest.len() {\n            longest = string.clone();\n        }\n    }\n\
    \n    Some(longest)\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822487
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    match strings.len() {\n        0 => None,\n        _ => {\n            let\
    \ mut max_len = 0;\n            let mut max_str: Option<String> = None;\n    \
    \        for str in strings {\n                if str.len() > max_len {\n    \
    \                max_len = str.len();\n                    max_str = Some(str);\n\
    \                }\n            }\n            max_str\n        }\n    }\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822487
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822486
- exit_code: 101
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    strings.into_iter().max_by_key(|s| s.len()).map(|s| s.to_string())\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpvy9pzmv0.rs:10:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822486
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for s in strings {\n        match longest {\n\
    \            None => longest = Some(s),\n            Some(ref l) => if s.len()\
    \ > l.len() {\n                longest = Some(s);\n            },\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822486
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    match strings.len() {\n        0 => None,\n        _ => {\n            let\
    \ mut longest_string = &strings[0];\n            for string in &strings {\n  \
    \              if string.len() > longest_string.len() {\n                    longest_string\
    \ = string;\n                }\n            }\n            Some(longest_string.to_string())\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822487
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for s in strings {\n        if longest.is_none()\
    \ || longest.as_ref().unwrap().len() < s.len() {\n            longest = Some(s);\n\
    \        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Option<T>`\n --> /tmp/tmpknfd8inq.rs:6:41\n\
    \  |\n4 |     let mut longest = None;\n  |         ----------- consider giving\
    \ `longest` the explicit type `Option<T>`, where the type parameter `T` is specified\n\
    5 |     for s in strings {\n6 |         if longest.is_none() || longest.as_ref().unwrap().len()\
    \ < s.len() {\n  |                                         ^^^^^^ cannot infer\
    \ type for type parameter `T`\n  |\n  = note: type must be known at this point\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659822487
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut max = 0;\n    let mut longest = None;\n    for string in strings\
    \ {\n        if string.len() > max {\n            max = string.len();\n      \
    \      longest = Some(string);\n        }\n    }\n    longest\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822487
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    match strings.len() {\n        0 => None,\n        _ => {\n            let\
    \ mut longest = String::new();\n            for item in strings {\n          \
    \      if item.len() > longest.len() {\n                    longest = item\n \
    \               }\n            }\n            Some(longest)\n        }\n    }\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822487
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut result = None;\n    for string in strings {\n        if let Some(ref\
    \ mut current) = result {\n            if string.len() > current.len() {\n   \
    \             *current = string;\n            }\n        } else {\n          \
    \  result = Some(string);\n        }\n    }\n    result\n}\n\nfn main() {\n  \
    \  let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Option<T>`\n --> /tmp/tmp735g8y7p.rs:6:16\n\
    \  |\n4 |     let mut result = None;\n  |         ---------- consider giving `result`\
    \ the explicit type `Option<T>`, where the type parameter `T` is specified\n5\
    \ |     for string in strings {\n6 |         if let Some(ref mut current) = result\
    \ {\n  |                ^^^^^^^^^^^^^^^^^^^^^ cannot infer type for type parameter\
    \ `T` declared on the enum `Option`\n  |\n  = note: type must be known at this\
    \ point\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659822487
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    strings.iter().fold(strings[0].clone(),\
    \ |acc, val| {\n        if acc.len() > val.len() {\n            acc\n        }\
    \ else {\n            val.clone()\n        }\n    })\n}\n\nfn main() {\n    let\
    \ candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp1xikj4ds.rs:8:25\n  |\n8 |\
    \     strings.iter().fold(strings[0].clone(), |acc, val| {\n  |              \
    \           ^^^^^^^^^^^^^^^^^^\n  |                         |\n  |           \
    \              expected enum `Option`, found struct `String`\n  |            \
    \             help: try using a variant of the expected enum: `Some(strings[0].clone())`\n\
    \  |\n  = note: expected enum `Option<String>`\n           found struct `String`\n\
    \nerror[E0599]: no method named `len` found for enum `Option` in the current scope\n\
    \ --> /tmp/tmp1xikj4ds.rs:9:16\n  |\n9 |         if acc.len() > val.len() {\n\
    \  |                ^^^ method not found in `Option<String>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1xikj4ds.rs:12:13\n   |\n12 |             val.clone()\n\
    \   |             ^^^^^^^^^^^\n   |             |\n   |             expected enum\
    \ `Option`, found struct `String`\n   |             help: try using a variant\
    \ of the expected enum: `Some(val.clone())`\n   |\n   = note: expected enum `Option<String>`\n\
    \            found struct `String`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659822487
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest_string\
    \ = String::new();\n    for string in strings {\n        if string.len() > longest_string.len()\
    \ {\n            longest_string = string;\n        }\n    }\n\n    Some(longest_string)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822487
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = String::new();\n    for string in strings {\n        if\
    \ string.len() > longest.len() {\n            longest = string;\n        }\n \
    \   }\n    if longest.is_empty() {\n        None\n    } else {\n        Some(longest)\n\
    \    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822487
- exit_code: 101
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    strings.into_iter().fold(None, |a, v| {\n        match a {\n            None\
    \ => Some(v),\n            Some(a) => if a.len() > v.len() {\n               \
    \ Some(a)\n            } else {\n                Some(v)\n            }\n    \
    \    }\n    })\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpddhc5p5v.rs:19:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822487
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest_string = None;\n    for string in strings {\n        match\
    \ longest_string {\n            None => longest_string = Some(string),\n     \
    \       Some(ref s) => {\n                if string.len() > s.len() {\n      \
    \              longest_string = Some(string);\n                }\n           \
    \ }\n        }\n    }\n    longest_string\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822487
- exit_code: 101
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut strings = strings;\n    strings.sort_by(|a, b| a.len().cmp(&b.len()));\n\
    \    strings.pop()\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmp36u4de63.rs:12:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822486
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut max_len = 0;\n    let mut longest_str = None;\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    longest_str = Some(s);\n        }\n    }\n    longest_str\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822487
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest_string\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest_string.len() {\n            longest_string = string;\n        }\n\
    \    }\n\n    Some(longest_string)\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822487
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    match strings.len() {\n        0 => None,\n        _ => {\n            let\
    \ mut longest = strings[0].clone();\n            for s in strings {\n        \
    \        if s.len() > longest.len() {\n                    longest = s;\n    \
    \            }\n            }\n            Some(longest)\n        }\n    }\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822487
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for s in strings {\n        if let Some(longest_string)\
    \ = longest {\n            if s.len() > longest_string.len() {\n             \
    \   longest = Some(s);\n            }\n        } else {\n            longest =\
    \ Some(s);\n        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Option<T>`\n --> /tmp/tmpy0m7mty1.rs:7:26\n\
    \  |\n4 |     let mut longest = None;\n  |         ----------- consider giving\
    \ `longest` the explicit type `Option<T>`, with the type parameters specified\n\
    ...\n7 |             if s.len() > longest_string.len() {\n  |                \
    \          ^^^^^^^^^^^^^^ cannot infer type\n  |\n  = note: type must be known\
    \ at this point\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659822487
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    strings.into_iter().max_by_key(|s| s.len()).cloned()\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `cloned` exists for enum `Option<String>`, but\
    \ its trait bounds were not satisfied\n   --> /tmp/tmp9fkrkvxj.rs:4:49\n    |\n\
    4   |       strings.into_iter().max_by_key(|s| s.len()).cloned()\n    |      \
    \                                             ^^^^^^ method cannot be called on\
    \ `Option<String>` due to unsatisfied trait bounds\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Option<String>: Iterator`\n \
    \           which is required by `&mut Option<String>: Iterator`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659822485
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest_so_far = None;\n    for string in strings {\n        match\
    \ longest_so_far {\n            None => longest_so_far = Some(string),\n     \
    \       Some(longest) => if string.len() > longest.len() {\n                longest_so_far\
    \ = Some(string);\n            }\n        }\n    }\n    longest_so_far\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value\n --> /tmp/tmp1lr8u2yl.rs:8:18\n  |\n\
    8 |             Some(longest) => if string.len() > longest.len() {\n  |      \
    \            ^^^^^^^ value moved here, in previous iteration of loop\n  |\nnote:\
    \ these 2 reinitializations might get skipped\n --> /tmp/tmp1lr8u2yl.rs:7:21\n\
    \  |\n7 |             None => longest_so_far = Some(string),\n  |            \
    \         ^^^^^^^^^^^^^^\n8 |             Some(longest) => if string.len() > longest.len()\
    \ {\n9 |                 longest_so_far = Some(string);\n  |                 ^^^^^^^^^^^^^^\n\
    \  = note: move occurs because value has type `String`, which does not implement\
    \ the `Copy` trait\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822487
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    match strings.is_empty() {\n        true => None,\n        false => {\n \
    \           let mut max_length = 0;\n            let mut index = 0;\n        \
    \    for (i, s) in strings.iter().enumerate() {\n                if s.len() >\
    \ max_length {\n                    max_length = s.len();\n                  \
    \  index = i;\n                }\n            }\n            Some(strings[index].clone())\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822487
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest_word = String::new();\n    for word in strings {\n      \
    \  if word.len() > longest_word.len() {\n            longest_word = word;\n  \
    \      }\n    }\n    match longest_word.len() {\n        0 => None,\n        _\
    \ => Some(longest_word),\n    }\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822487
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest_string\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > longest_string.len()\
    \ {\n            longest_string = s;\n        }\n    }\n\n    Some(longest_string)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822486
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest_string = None;\n    let mut longest_length = 0;\n    for\
    \ string in strings {\n        if string.len() > longest_length {\n          \
    \  longest_string = Some(string);\n            longest_length = string.len();\n\
    \        }\n    }\n    longest_string\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `string`\n --> /tmp/tmpj7t59y8v.rs:9:30\n\
    \  |\n6 |     for string in strings {\n  |         ------ move occurs because\
    \ `string` has type `String`, which does not implement the `Copy` trait\n7 | \
    \        if string.len() > longest_length {\n8 |             longest_string =\
    \ Some(string);\n  |                                   ------ value moved here\n\
    9 |             longest_length = string.len();\n  |                          \
    \    ^^^^^^ value borrowed here after move\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822487
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest_string\
    \ = String::new();\n    for string in strings {\n        if string.len() > longest_string.len()\
    \ {\n            longest_string = string;\n        }\n    }\n\n    Some(longest_string)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822487
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    strings.into_iter().fold(None, |longest, string| {\n        match longest\
    \ {\n            None => Some(string),\n            Some(longest) => {\n     \
    \           if string.len() > longest.len() {\n                    Some(string)\n\
    \                } else {\n                    Some(longest)\n               \
    \ }\n            }\n        }\n    })\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822487
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    match strings.len() {\n        0 => None,\n        1 => Some(strings[0].clone()),\n\
    \        _ => {\n            let mut max_len = 0;\n            let mut longest_string\
    \ = String::new();\n            for s in strings {\n                if s.len()\
    \ > max_len {\n                    max_len = s.len();\n                    longest_string\
    \ = s;\n                }\n            }\n            Some(longest_string)\n \
    \       }\n    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822487
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    strings.iter().fold(None,\
    \ |acc, s| {\n        match acc {\n            None => Some(s.clone()),\n    \
    \        Some(p) => if s.len() > p.len() {\n                Some(s.clone())\n\
    \            } else {\n                Some(p)\n            }\n        }\n   \
    \ })\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822487
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    strings.into_iter().max_by_key(|string| string.len()).cloned()\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `cloned` exists for enum `Option<String>`, but\
    \ its trait bounds were not satisfied\n   --> /tmp/tmp8mfwv2cn.rs:4:59\n    |\n\
    4   |       strings.into_iter().max_by_key(|string| string.len()).cloned()\n \
    \   |                                                             ^^^^^^ method\
    \ cannot be called on `Option<String>` due to unsatisfied trait bounds\n    |\n\
    \    = note: the following trait bounds were not satisfied:\n            `Option<String>:\
    \ Iterator`\n            which is required by `&mut Option<String>: Iterator`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659822487
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut max_length\
    \ = 0;\n    let mut result: Option<String> = None;\n\n    for s in strings {\n\
    \        if s.len() > max_length {\n            max_length = s.len();\n      \
    \      result = Some(s);\n        }\n    }\n\n    result\n}\n\nfn main() {\n \
    \   let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822487
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    // Special case: No strings to compare\n    if strings.is_empty() {\n   \
    \     return None;\n    }\n\n    // Special case: Only one string to compare\n\
    \    if strings.len() == 1 {\n        return Some(strings[0].clone());\n    }\n\
    \n    // General case: Compare all strings to find the longest\n    let mut longest\
    \ = 0;\n    let mut longest_index = 0;\n    for (index, string) in strings.iter().enumerate()\
    \ {\n        if string.len() > longest {\n            longest = string.len();\n\
    \            longest_index = index;\n        }\n    }\n\n    Some(strings[longest_index].clone())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822487
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for s in strings {\n        match longest {\n\
    \            None => longest = Some(s),\n            Some(ref l) => if s.len()\
    \ > l.len() {\n                longest = Some(s);\n            },\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822486
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = &strings[0];\n    for s in &strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n\n    Some(longest.to_string())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822486
- exit_code: 101
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    match strings.iter().max_by_key(|string| string.len()) {\n        Some(string)\
    \ => Some(string.to_string()),\n        None => None,\n    }\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpasrowkk8.rs:13:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822487
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut max_length = 0;\n    let mut result = None;\n    for string in strings\
    \ {\n        if string.len() > max_length {\n            max_length = string.len();\n\
    \            result = Some(string);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822487
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut length = 0;\n    let mut result = None;\n    for string in strings\
    \ {\n        if string.len() > length {\n            length = string.len();\n\
    \            result = Some(string);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822488
- exit_code: 101
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    strings.into_iter().fold(None, |a, b| {\n        match a {\n            None\
    \ => Some(b),\n            Some(a) => Some(if a.len() > b.len() { a } else { b\
    \ }),\n        }\n    })\n}\n\nfn main() {\n    let candidate = longest;\n   \
    \ assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmp3cqjot3k.rs:15:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822488
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    match strings.is_empty() {\n        true => None,\n        false => {\n \
    \           let mut longest_string = strings[0].clone();\n            for string\
    \ in strings.iter() {\n                if string.len() > longest_string.len()\
    \ {\n                    longest_string = string.clone();\n                }\n\
    \            }\n            Some(longest_string)\n        }\n    }\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822488
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        if let Some(current_longest)\
    \ = longest {\n            if string.len() > current_longest.len() {\n       \
    \         longest = Some(string);\n            }\n        } else {\n         \
    \   longest = Some(string);\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Option<T>`\n --> /tmp/tmpepf09t6r.rs:7:31\n\
    \  |\n4 |     let mut longest = None;\n  |         ----------- consider giving\
    \ `longest` the explicit type `Option<T>`, with the type parameters specified\n\
    ...\n7 |             if string.len() > current_longest.len() {\n  |          \
    \                     ^^^^^^^^^^^^^^^ cannot infer type\n  |\n  = note: type must\
    \ be known at this point\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659822487
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n\n    Some(longest)\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut cur_longest = None;\n    for s in strings {\n        match cur_longest\
    \ {\n            None => cur_longest = Some(s),\n            Some(longest) =>\
    \ {\n                if s.len() > longest.len() {\n                    cur_longest\
    \ = Some(s);\n                }\n            }\n        }\n    }\n    cur_longest\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value\n  --> /tmp/tmpnf2a9how.rs:8:18\n   |\n\
    8  |             Some(longest) => {\n   |                  ^^^^^^^ value moved\
    \ here, in previous iteration of loop\n   |\nnote: these 2 reinitializations might\
    \ get skipped\n  --> /tmp/tmpnf2a9how.rs:7:21\n   |\n7  |             None =>\
    \ cur_longest = Some(s),\n   |                     ^^^^^^^^^^^\n...\n10 |    \
    \                 cur_longest = Some(s);\n   |                     ^^^^^^^^^^^\n\
    \   = note: move occurs because value has type `String`, which does not implement\
    \ the `Copy` trait\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822487
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(s) => if string.len()\
    \ > s.len() {\n                longest = Some(string);\n            }\n      \
    \  }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n   \
    \ assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value\n --> /tmp/tmpz7h523jm.rs:8:18\n  |\n\
    8 |             Some(s) => if string.len() > s.len() {\n  |                  ^\
    \ value moved here, in previous iteration of loop\n  |\nnote: these 2 reinitializations\
    \ might get skipped\n --> /tmp/tmpz7h523jm.rs:7:21\n  |\n7 |             None\
    \ => longest = Some(string),\n  |                     ^^^^^^^\n8 |           \
    \  Some(s) => if string.len() > s.len() {\n9 |                 longest = Some(string);\n\
    \  |                 ^^^^^^^\n  = note: move occurs because value has type `String`,\
    \ which does not implement the `Copy` trait\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822487
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822486
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut result = None;\n    for s in strings {\n        if let Some(m) =\
    \ result {\n            if s.len() > m.len() {\n                result = Some(s);\n\
    \            }\n        } else {\n            result = Some(s);\n        }\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Option<T>`\n --> /tmp/tmpwqrcfneh.rs:7:26\n\
    \  |\n4 |     let mut result = None;\n  |         ---------- consider giving `result`\
    \ the explicit type `Option<T>`, with the type parameters specified\n...\n7 |\
    \             if s.len() > m.len() {\n  |                          ^ cannot infer\
    \ type\n  |\n  = note: type must be known at this point\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0282`.\n"
  stdout: ''
  timestamp: 1659822487
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = String::new();\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n\n    Some(longest)\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    // use Option::map to transform the value wrapped in Option\n    // to the\
    \ value wrapped in the Result\n    strings.into_iter().fold(None, |acc, s| match\
    \ acc {\n        Some(ref a) if a.len() >= s.len() => acc,\n        _ => Some(s),\n\
    \    })\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822488
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    match strings.len() {\n        0 => None,\n        _ => {\n            let\
    \ mut longest = &strings[0];\n            for string in &strings {\n         \
    \       if string.len() > longest.len() {\n                    longest = string;\n\
    \                }\n            }\n            Some(longest.to_string())\n   \
    \     }\n    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822488
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest_string\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest_string.len() {\n            longest_string = string;\n        }\n\
    \    }\n\n    Some(longest_string)\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822487
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut max =\
    \ &strings[0];\n    for s in &strings {\n        if s.len() > max.len() {\n  \
    \          max = s;\n        }\n    }\n\n    Some(max.clone())\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822488
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings.iter() {\n        if string.len()\
    \ > longest.len() {\n            longest = string.clone();\n        }\n    }\n\
    \n    Some(longest)\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822487
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    strings.into_iter().fold(None, |acc, s| {\n        match acc {\n        \
    \    None => Some(s),\n            Some(current) => {\n                if s.len()\
    \ > current.len() {\n                    Some(s)\n                } else {\n \
    \                   Some(current)\n                }\n            }\n        }\n\
    \    })\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822488
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest_str = None;\n    for string in strings {\n        if let\
    \ Some(ref longest) = longest_str {\n            if string.len() > longest.len()\
    \ {\n                longest_str = Some(string);\n            }\n        } else\
    \ {\n            longest_str = Some(string);\n        }\n    }\n    longest_str\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Option<T>`\n --> /tmp/tmpomdwh0oq.rs:6:16\n\
    \  |\n4 |     let mut longest_str = None;\n  |         --------------- consider\
    \ giving `longest_str` the explicit type `Option<T>`, where the type parameter\
    \ `T` is specified\n5 |     for string in strings {\n6 |         if let Some(ref\
    \ longest) = longest_str {\n  |                ^^^^^^^^^^^^^^^^^ cannot infer\
    \ type for type parameter `T` declared on the enum `Option`\n  |\n  = note: type\
    \ must be known at this point\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659822487
- exit_code: 101
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    match strings.len() {\n        0 => None,\n        _ => Some(strings.iter().max_by_key(|s|\
    \ s.len()).unwrap().to_string()),\n    }\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmp5m9l7tzt.rs:13:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822486
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    strings.into_iter().max_by_key(|s| s.len()).cloned()\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `cloned` exists for enum `Option<String>`, but\
    \ its trait bounds were not satisfied\n   --> /tmp/tmp9fkrkvxj.rs:4:49\n    |\n\
    4   |       strings.into_iter().max_by_key(|s| s.len()).cloned()\n    |      \
    \                                             ^^^^^^ method cannot be called on\
    \ `Option<String>` due to unsatisfied trait bounds\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Option<String>: Iterator`\n \
    \           which is required by `&mut Option<String>: Iterator`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822486
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut max_length\
    \ = 0;\n    let mut res = None;\n    for string in strings {\n        if string.len()\
    \ > max_length {\n            max_length = string.len();\n            res = Some(string);\n\
    \        }\n    }\n\n    res\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822488
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n\n    Some(longest)\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    match strings.len() {\n        0 => None,\n        1 => Some(strings[0].clone()),\n\
    \        _ => {\n            let mut max_length = 0;\n            let mut max_length_string\
    \ = &strings[0];\n            for s in &strings {\n                if s.len()\
    \ > max_length {\n                    max_length = s.len();\n                \
    \    max_length_string = s;\n                }\n            }\n            Some(max_length_string.clone())\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822488
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings.iter() {\n        if string.len()\
    \ > longest.len() {\n            longest = string.clone();\n        }\n    }\n\
    \n    Some(longest)\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822487
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest_string\
    \ = strings[0].clone();\n    for item in strings {\n        if item.len() > longest_string.len()\
    \ {\n            longest_string = item;\n        }\n    }\n\n    Some(longest_string)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822488
- exit_code: 101
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    strings.into_iter().max_by_key(|s| s.len()).map(|s| s.to_string())\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpvy9pzmv0.rs:10:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822486
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut max =\
    \ strings[0].clone();\n    for string in strings {\n        if string.len() >\
    \ max.len() {\n            max = string;\n        }\n    }\n\n    Some(max)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822488
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    match strings.len() {\n        0 => None,\n        1 => Some(strings[0].clone()),\n\
    \        _ => {\n            let mut max = strings[0].clone();\n            for\
    \ s in strings.iter() {\n                if s.len() > max.len() {\n          \
    \          max = s.clone();\n                }\n            }\n            Some(max)\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 101
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    match strings.iter().max_by_key(|s| s.len()) {\n        Some(str) => Some(str.to_string()),\n\
    \        None => None,\n    }\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpa6i2dbns.rs:13:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822488
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut longest = None;\n    for s in strings {\n        longest = match\
    \ longest {\n            None => Some(s),\n            Some(ls) => if s.len()\
    \ > ls.len() { Some(s) } else { Some(ls) },\n        };\n    }\n    longest\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822488
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut result = None;\n    for s in strings {\n        match result {\n\
    \            None => result = Some(s),\n            Some(s1) => if s.len() > s1.len()\
    \ {\n                result = Some(s);\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value\n --> /tmp/tmptqz356ov.rs:8:18\n  |\n\
    8 |             Some(s1) => if s.len() > s1.len() {\n  |                  ^^ value\
    \ moved here, in previous iteration of loop\n  |\nnote: these 2 reinitializations\
    \ might get skipped\n --> /tmp/tmptqz356ov.rs:7:21\n  |\n7 |             None\
    \ => result = Some(s),\n  |                     ^^^^^^\n8 |             Some(s1)\
    \ => if s.len() > s1.len() {\n9 |                 result = Some(s);\n  |     \
    \            ^^^^^^\n  = note: move occurs because value has type `String`, which\
    \ does not implement the `Copy` trait\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822487
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822486
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest_string\
    \ = &strings[0];\n    for i in 1..strings.len() {\n        if strings[i].len()\
    \ > longest_string.len() {\n            longest_string = &strings[i];\n      \
    \  }\n    }\n\n    Some(longest_string.to_string())\n}\n\nfn main() {\n    let\
    \ candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822488
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    // NOTE: \"partial_cmp\" option in \"derive\" is needed to allow \"max\"\
    \ to be used\n    let mut opt_longest = None;\n    let mut longest_len = 0;\n\
    \    for s in strings {\n        if s.len() > longest_len {\n            opt_longest\
    \ = Some(s);\n            longest_len = s.len();\n        }\n    }\n    opt_longest\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpic599kaw.rs:10:27\n\
    \   |\n7  |     for s in strings {\n   |         - move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n8  |         if s.len()\
    \ > longest_len {\n9  |             opt_longest = Some(s);\n   |             \
    \                   - value moved here\n10 |             longest_len = s.len();\n\
    \   |                           ^ value borrowed here after move\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659822487
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    strings.into_iter().fold(None, |longest, curr| {\n        match longest {\n\
    \            None => Some(curr),\n            Some(old) => {\n               \
    \ if curr.len() > old.len() {\n                    Some(curr)\n              \
    \  } else {\n                    Some(old)\n                }\n            }\n\
    \        }\n    })\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822488
- exit_code: 101
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    let mut strings = strings;\n    if strings.is_empty() {\n        return None;\n\
    \    }\n    strings.sort_by(|a, b| a.len().cmp(&b.len()));\n    strings.reverse();\n\
    \    Some(strings[0].clone())\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmp7oileazr.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822488
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    if strings.is_empty() {\n        return None;\n    }\n\n    let mut max_length\
    \ = 0;\n    let mut result = strings[0].clone();\n\n    for string in strings\
    \ {\n        if string.len() > max_length {\n            max_length = string.len();\n\
    \            result = string;\n        }\n    }\n\n    Some(result)\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822488
- exit_code: 101
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\nfn longest(strings: Vec<String>) -> Option<String> {\n\
    \    strings.into_iter().fold(None, |acc, x| match acc {\n        None => Some(x),\n\
    \        Some(acc) => if acc.len() > x.len() {\n            Some(acc)\n      \
    \  } else {\n            Some(x)\n        },\n    })\n}\n\nfn main() {\n    let\
    \ candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpq0ocs55r.rs:17:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822488
