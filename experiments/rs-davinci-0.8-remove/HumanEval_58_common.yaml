name: HumanEval_58_common
language: rs
prompt: "/// Return sorted unique common elements for two lists.\nfn common(l1: Vec<isize>,\
  \ l2: Vec<isize>) -> Vec<isize> {\n"
tests: "}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
  \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
  \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
  \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
  \ Vec::<isize>::new());\n}\n"
completions: ["    let l1_set: HashSet<isize> = l1.into_iter().collect();\n    let\
    \ l2_set: HashSet<isize> = l2.into_iter().collect();\n    let inter: HashSet<isize>\
    \ = l1_set.intersection(&l2_set).cloned().collect();\n    inter.into_iter().collect()",
  "    let mut l = l1.clone();\n    l.extend(l2.clone());\n    l.sort();\n    l.dedup();\n\
    \    let mut out = Vec::new();\n    for e in l {\n        if l1.contains(&e) &&\
    \ l2.contains(&e) {\n            out.push(e);\n        }\n    }\n    out", " \
    \   let mut m1 = HashMap::new();\n    let mut m2 = HashMap::new();\n    let mut\
    \ u = Vec::new();\n\n    for e in l1 {\n        let i = m1.entry(e).or_insert(0);\n\
    \        *i += 1;\n    }\n\n    for e in l2 {\n        let i = m2.entry(e).or_insert(0);\n\
    \        *i += 1;\n    }\n\n    for (k, v) in m1 {\n        if m2.contains_key(&k)\
    \ {\n            for _ in 0..cmp::min(v, m2[&k]) {\n                u.push(k);\n\
    \            }\n        }\n    }\n\n    u.sort();\n    u", "    let mut res =\
    \ l1.clone();\n    res.sort();\n    res.dedup();\n    res.iter().filter(|&i| l2.contains(i)).cloned().collect()",
  "    let mut commons = l1.clone();\n    commons.extend(l2.clone());\n    commons.sort();\n\
    \    commons.dedup();\n    commons", "    let mut l1 = l1;\n    let mut l2 = l2;\n\
    \    l1.sort();\n    l2.sort();\n    let m = l1.len();\n    let n = l2.len();\n\
    \    let mut i = 0;\n    let mut j = 0;\n    let mut common = Vec::new();\n  \
    \  while i < m && j < n {\n        if l1[i] == l2[j] {\n            common.push(l1[i]);\n\
    \            i += 1;\n            j += 1;\n        } else if l1[i] < l2[j] {\n\
    \            i += 1;\n        } else {\n            j += 1;\n        }\n    }\n\
    \    common", "    let mut result = Vec::new();\n    let mut l1 = l1.clone();\n\
    \    let mut l2 = l2.clone();\n    l1.sort();\n    l2.sort();\n    for i in 0..l1.len()\
    \ {\n        if l1[i] == l2[i] {\n            result.push(l1[i]);\n        }\n\
    \    }\n    result", "    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n\
    \    l2.sort();\n    l1.retain(|x| l2.contains(x));\n    l1.dedup();\n    l1",
  "    let l1 = l1.iter().cloned().collect::<HashSet<isize>>();\n    let l2 = l2.iter().cloned().collect::<HashSet<isize>>();\n\
    \    let common = l1.intersection(&l2).cloned().collect::<Vec<isize>>();\n   \
    \ common.sort();\n    common", "    let mut res = Vec::new();\n    let (mut x,\
    \ mut y) = (0, 0);\n    let (mut len1, mut len2) = (l1.len(), l2.len());\n   \
    \ while x < len1 && y < len2 {\n        if l1[x] < l2[y] {\n            x += 1;\n\
    \        } else if l1[x] > l2[y] {\n            y += 1;\n        } else {\n  \
    \          res.push(l1[x]);\n            x += 1;\n            y += 1;\n      \
    \  }\n    }\n    res", "    let mut a = l1.clone();\n    let mut b = l2.clone();\n\
    \    a.sort();\n    b.sort();\n    let mut ai = 0;\n    let mut bi = 0;\n    let\
    \ mut result = Vec::new();\n    while ai < a.len() && bi < b.len() {\n       \
    \ if a[ai] == b[bi] {\n            result.push(a[ai]);\n            ai += 1;\n\
    \            bi += 1;\n        } else if a[ai] < b[bi] {\n            ai += 1;\n\
    \        } else {\n            bi += 1;\n        }\n    }\n    result", "    let\
    \ mut map = HashMap::new();\n    for x in l1 {\n        *map.entry(x).or_insert(0)\
    \ += 1;\n    }\n    let mut result = Vec::new();\n    for x in l2 {\n        if\
    \ let Some(y) = map.get_mut(&x) {\n            if *y > 0 {\n                result.push(x);\n\
    \                *y -= 1;\n            }\n        }\n    }\n    result.sort();\n\
    \    result", '    l1.into_iter().filter(|x| l2.contains(x)).collect()', "   \
    \ let mut res = Vec::new();\n    for i in l1 {\n        if l2.contains(&i) {\n\
    \            res.push(i);\n        }\n    }\n    res.sort();\n    res.dedup();\n\
    \    res", "    let mut v = l1.clone();\n    v.append(&mut l2.clone());\n    let\
    \ mut v = v.clone();\n    v.sort();\n    v.dedup();\n    v", "    let mut res\
    \ = Vec::new();\n    for v in l1 {\n        if l2.contains(&v) {\n           \
    \ res.push(v);\n        }\n    }\n    res.sort();\n    res.dedup();\n    res",
  "    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n  \
    \  let mut nl1 = l1.clone();\n    let mut nl2 = l2.clone();\n    nl1.dedup();\n\
    \    nl2.dedup();\n    if nl1.len() > nl2.len() {\n        for i in nl2.iter()\
    \ {\n            l1.retain(|&x| x != *i);\n        }\n        l1\n    } else {\n\
    \        for i in nl1.iter() {\n            l2.retain(|&x| x != *i);\n       \
    \ }\n        l2\n    }", "    let mut l1: Vec<isize> = l1.clone();\n    let mut\
    \ l2: Vec<isize> = l2.clone();\n    l1.sort();\n    l2.sort();\n    // TODO is\
    \ this really necessary?\n    l1.dedup();\n    l2.dedup();\n    l1.iter().filter(|x|\
    \ l2.contains(x)).cloned().collect()", "    let mut v = Vec::new();\n    let mut\
    \ i1 = 0;\n    let mut i2 = 0;\n    while i1 < l1.len() && i2 < l2.len() {\n \
    \       if l1[i1] < l2[i2] {\n            i1 += 1;\n        } else if l1[i1] >\
    \ l2[i2] {\n            i2 += 1;\n        } else {\n            v.push(l1[i1]);\n\
    \            i1 += 1;\n            i2 += 1;\n        }\n    }\n    v", "    let\
    \ mut s1 = l1.clone();\n    let mut s2 = l2.clone();\n    s1.sort();\n    s2.sort();\n\
    \    s1.dedup();\n    s2.dedup();\n    let mut res = Vec::new();\n    let mut\
    \ i1 = 0;\n    let mut i2 = 0;\n    while i1 < s1.len() && i2 < s2.len() {\n \
    \       if s1[i1] == s2[i2] {\n            res.push(s1[i1]);\n            i1 +=\
    \ 1;\n            i2 += 1;\n        } else if s1[i1] < s2[i2] {\n            i1\
    \ += 1;\n        } else {\n            i2 += 1;\n        }\n    }\n    res", " \
    \   let mut uniq: HashSet<isize> = HashSet::new();\n    let mut sorted: Vec<isize>\
    \ = Vec::new();\n\n    // Sort lists\n    let mut l1 = l1;\n    let mut l2 = l2;\n\
    \    l1.sort();\n    l2.sort();\n\n    // Look for common elements\n    let mut\
    \ i1 = 0;\n    let mut i2 = 0;\n    loop {\n        if i1 >= l1.len() || i2 >=\
    \ l2.len() {\n            break;\n        }\n\n        let e1 = l1[i1];\n    \
    \    let e2 = l2[i2];\n\n        if e1 == e2 {\n            uniq.insert(e1);\n\
    \            i1 += 1;\n            i2 += 1;\n        } else if e1 < e2 {\n   \
    \         i1 += 1;\n        } else {\n            i2 += 1;\n        }\n    }\n\
    \n    // Sort and return\n    for e in uniq {\n        sorted.push(e);\n    }\n\
    \    sorted.sort();\n    sorted", "    let mut l1 = l1;\n    let mut l2 = l2;\n\
    \    l1.sort();\n    l2.sort();\n    let mut it1 = l1.iter();\n    let mut it2\
    \ = l2.iter();\n    let mut res = Vec::new();\n    let mut e1 = it1.next();\n\
    \    let mut e2 = it2.next();\n    loop {\n        match (e1, e2) {\n        \
    \    (Some(v1), Some(v2)) => {\n                if v1 < v2 {\n               \
    \     e1 = it1.next();\n                } else if v1 > v2 {\n                \
    \    e2 = it2.next();\n                } else {\n                    res.push(*v1);\n\
    \                    e1 = it1.next();\n                    e2 = it2.next();\n\
    \                }\n            }\n            _ => break,\n        }\n    }\n\
    \    res", "    let v = merge(l1, l2);\n    return Box::new(v.into_iter().unique()).into_vec();",
  "    let mut common: Vec<isize> = Vec::new();\n    let mut idx1 = 0;\n    let mut\
    \ idx2 = 0;\n    while idx1 < l1.len() && idx2 < l2.len() {\n        if l1[idx1]\
    \ == l2[idx2] {\n            common.push(l1[idx1]);\n            idx1 += 1;\n\
    \            idx2 += 1;\n        } else if l1[idx1] < l2[idx2] {\n           \
    \ idx1 += 1;\n        } else {\n            idx2 += 1;\n        }\n    }\n   \
    \ common", "    let mut s1 = l1.clone();\n    let mut s2 = l2.clone();\n    s1.sort();\n\
    \    s2.sort();\n    s1.dedup();\n    s2.dedup();\n    let mut com = vec![];\n\
    \    let mut i1 = 0;\n    let mut i2 = 0;\n    while i1 < s1.len() && i2 < s2.len()\
    \ {\n        if s1[i1] == s2[i2] {\n            com.push(s1[i1]);\n          \
    \  i1 += 1;\n            i2 += 1;\n        } else if s1[i1] < s2[i2] {\n     \
    \       i1 += 1;\n        } else {\n            i2 += 1;\n        }\n    }\n \
    \   com", "    let mut v1 = l1.clone();\n    let mut v2 = l2.clone();\n    v1.sort();\n\
    \    v2.sort();\n    v1.dedup();\n    v2.dedup();\n    v1.iter().filter(|x| v2.contains(x)).cloned().collect()",
  "    let mut c = HashSet::new();\n    for i in l1 {\n        if l2.contains(&i)\
    \ {\n            c.insert(i);\n        }\n    }\n    let mut vec: Vec<isize> =\
    \ c.into_iter().collect();\n    vec.sort();\n    vec", "    let mut res = vec![];\n\
    \    let (mut i1, mut i2) = (0, 0);\n    while i1 < l1.len() && i2 < l2.len()\
    \ {\n        if l1[i1] == l2[i2] {\n            res.push(l1[i1]);\n          \
    \  i1 += 1;\n            i2 += 1;\n        } else if l1[i1] < l2[i2] {\n     \
    \       i1 += 1;\n        } else {\n            i2 += 1;\n        }\n    }\n \
    \   res", "    let mut common = l1.clone();\n    common.sort();\n    common.dedup();\n\
    \    let mut elements: Vec<isize> = Vec::new();\n    for n in l2 {\n        if\
    \ common.binary_search(&n).is_ok() {\n            elements.push(n);\n        }\n\
    \    }\n    elements.sort();\n    elements.dedup();\n    elements", '    l1.iter().filter(|x|
    l2.contains(x)).cloned().collect::<Vec<isize>>()', "    let mut l3 = l1.clone();\n\
    \    l3.extend(l2.clone());\n    l3.sort();\n    l3.dedup();\n    return l3;",
  '    l1.into_iter().filter(|e| l2.contains(e)).collect()', "    let mut l1 = l1;\n\
    \    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    l1.iter().filter(|&x|\
    \ l2.binary_search(x).is_ok()).cloned().collect()", "    let mut result = vec![];\n\
    \    let mut index = 0;\n    for x in l1 {\n        if index == l2.len() {\n \
    \           break;\n        }\n        if x == l2[index] {\n            result.push(x);\n\
    \            index += 1;\n        } else if x > l2[index] {\n            index\
    \ += 1;\n        }\n    }\n    result", "    let l1_set: HashSet<isize> = l1.iter().cloned().collect();\n\
    \    let l2_set: HashSet<isize> = l2.iter().cloned().collect();\n    let intersect\
    \ = l1_set.intersection(&l2_set);\n    let mut vec: Vec<isize> = intersect.cloned().collect();\n\
    \    vec.sort();\n    vec", '    l1.iter().filter(|&a| l2.contains(a)).cloned().collect()',
  "    let mut common: Vec<isize> = l1.into_iter().filter(|x| l2.contains(x)).collect();\n\
    \    common.sort();\n    common.dedup();\n    common", "    let mut l1 = l1;\n\
    \    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    l1.iter().filter(|x|\
    \ l2.binary_search(x).is_ok()).map(|x| *x).collect()", "    let mut c = Vec::new();\n\
    \    for e in l1 {\n        if l2.contains(&e) {\n            c.push(e);\n   \
    \     }\n    }\n    return c;", "    let mut com = Vec::new();\n    let mut i1\
    \ = 0;\n    let mut i2 = 0;\n    while i1 < l1.len() && i2 < l2.len() {\n    \
    \    let c1 = l1[i1];\n        let c2 = l2[i2];\n        if c1 == c2 {\n     \
    \       if com.is_empty() || com.last().unwrap() != &c1 {\n                com.push(c1);\n\
    \            }\n            i1 += 1;\n            i2 += 1;\n        } else if\
    \ c1 < c2 {\n            i1 += 1;\n        } else {\n            i2 += 1;\n  \
    \      }\n    }\n    com", "    let mut ll1 = l1.clone();\n    let mut ll2 = l2.clone();\n\
    \    ll1.sort();\n    ll2.sort();\n    let mut i1 = 0;\n    let mut i2 = 0;\n\
    \    let mut acc = Vec::new();\n    while i1 < ll1.len() && i2 < ll2.len() {\n\
    \        if ll1[i1] == ll2[i2] {\n            acc.push(ll1[i1]);\n           \
    \ i1 += 1;\n            i2 += 1;\n        } else if ll1[i1] < ll2[i2] {\n    \
    \        i1 += 1;\n        } else {\n            i2 += 1;\n        }\n    }\n\
    \    acc", "    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n\
    \    l1.iter().filter(|x| l2.contains(x)).cloned().collect()", "    // So far\
    \ the only way I found to do this elegantly is using a hashtable\n    // (HashSet).\n\
    \n    let mut h = HashSet::new();\n    let mut result = Vec::new();\n\n    for\
    \ i in l1 {\n        h.insert(i);\n    }\n\n    for i in l2 {\n        if h.contains(&i)\
    \ {\n            result.push(i);\n        }\n    }\n\n    result.sort();\n   \
    \ result", "    let mut v = vec![];\n    if l1.len() > l2.len() {\n        let\
    \ mut l = l1.clone();\n        l.sort();\n        l.dedup();\n        for i in\
    \ l2 {\n            if l.binary_search(&i).is_ok() {\n                v.push(i);\n\
    \            }\n        }\n    } else {\n        let mut l = l2.clone();\n   \
    \     l.sort();\n        l.dedup();\n        for i in l1 {\n            if l.binary_search(&i).is_ok()\
    \ {\n                v.push(i);\n            }\n        }\n    }\n    v", "  \
    \  let mut res = Vec::new();\n    for n in l1 {\n        if l2.contains(&n) {\n\
    \            res.push(n);\n        }\n    }\n    res.sort();\n    res.dedup();\n\
    \    res", "    let mut set = BTreeSet::new();\n    for x in l1 {\n        if\
    \ l2.contains(&x) {\n            set.insert(x);\n        }\n    }\n    set.into_iter().collect()",
  "    let s1: HashSet<isize> = l1.into_iter().collect();\n    let s2: HashSet<isize>\
    \ = l2.into_iter().collect();\n    let c: HashSet<isize> = s1.intersection(&s2).cloned().collect();\n\
    \    let mut v: Vec<isize> = c.into_iter().collect();\n    v.sort();\n    v",
  '    return intersect_sorted(sort_uniq(l1), sort_uniq(l2));', "    // Concatenate\
    \ lists and sort.\n    let mut v = [l1, l2].concat();\n    v.sort();\n\n    //\
    \ Find unique elements.\n    v.dedup();\n\n    v", "    let mut l1 = l1;\n   \
    \ let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    l1.iter().filter(|n| l2.binary_search(n).is_ok()).cloned().collect()",
  "    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n  \
    \  l1.dedup();\n    l2.dedup();\n    l1.into_iter().filter(|x| l2.contains(x)).collect()",
  "    let mut unique_common = Vec::new();\n    l1.iter().for_each(|&item| {\n   \
    \     if l2.contains(&item) && !unique_common.contains(&item) {\n            unique_common.push(item);\n\
    \        }\n    });\n    unique_common.sort();\n    unique_common", "    let mut\
    \ set1 = HashSet::new();\n    for &i in &l1 {\n        set1.insert(i);\n    }\n\
    \    let mut set2 = HashSet::new();\n    for &i in &l2 {\n        set2.insert(i);\n\
    \    }\n    let mut common = set1.intersection(&set2).cloned().collect::<Vec<isize>>();\n\
    \    common.sort();\n    common", "    let mut cl: Vec<isize> = vec![];\n    for\
    \ e in l1 {\n        if l2.contains(&e) {\n            cl.push(e);\n        }\n\
    \    }\n    cl.sort();\n    cl.dedup();\n    cl", "    let mut l1 = l1;\n    let\
    \ mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    l1.iter().filter(|x| l2.contains(x)).map(|x|\
    \ *x).collect()", "    let mut l1: Vec<isize> = l1.into_iter().collect();\n  \
    \  let mut l2: Vec<isize> = l2.into_iter().collect();\n    l1.sort();\n    l2.sort();\n\
    \    l1.retain(|x| l2.contains(x));\n    l1.dedup();\n    l1", "    let mut sorted\
    \ = l1.clone();\n    sorted.extend(l2.clone());\n    sorted.sort();\n    sorted.dedup();\n\
    \    sorted", "    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n  \
    \  l2.sort();\n    l1.dedup();\n    l2.dedup();\n    l1.iter().filter(|&x| l2.contains(x)).cloned().collect()",
  "    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n  \
    \  l1.dedup();\n    l2.dedup();\n    let mut vec = Vec::new();\n    let mut i1\
    \ = 0;\n    let mut i2 = 0;\n    while i1 < l1.len() && i2 < l2.len() {\n    \
    \    if l1[i1] < l2[i2] {\n            i1 += 1;\n        } else if l1[i1] > l2[i2]\
    \ {\n            i2 += 1;\n        } else {\n            vec.push(l1[i1]);\n \
    \           i1 += 1;\n            i2 += 1;\n        }\n    }\n    vec", "    let\
    \ mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    let\
    \ mut common = Vec::new();\n    let mut i1 = 0;\n    let mut i2 = 0;\n    while\
    \ i1 < l1.len() && i2 < l2.len() {\n        if l1[i1] == l2[i2] {\n          \
    \  common.push(l1[i1]);\n            i1 += 1;\n            i2 += 1;\n        }\
    \ else if l1[i1] < l2[i2] {\n            i1 += 1;\n        } else {\n        \
    \    i2 += 1;\n        }\n    }\n    common", "    let mut common = l1.clone();\n\
    \    common.sort();\n    common.dedup();\n    let mut common2 = l2.clone();\n\
    \    common2.sort();\n    common2.dedup();\n    let mut result = Vec::new();\n\
    \    for v in common {\n        if common2.contains(&v) {\n            result.push(v);\n\
    \        }\n    }\n    result", "    if l1.len() > l2.len() {\n        common(l2,\
    \ l1)\n    } else {\n        l1.into_iter().filter(|&x| l2.contains(&x)).collect()\n\
    \    }", "    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n\
    \    l1.dedup();\n    l2.dedup();\n    l1.into_iter().filter(|x| l2.contains(x)).collect()",
  "    let mut common = Vec::new();\n    let mut l1_sorted = l1.clone();\n    let\
    \ mut l2_sorted = l2.clone();\n    l1_sorted.sort();\n    l2_sorted.sort();\n\
    \    let mut l1_it = l1_sorted.iter();\n    let mut l2_it = l2_sorted.iter();\n\
    \    let mut first = l1_it.next();\n    let mut second = l2_it.next();\n    loop\
    \ {\n        match (first, second) {\n            (Some(x), Some(y)) => {\n  \
    \              if x < y {\n                    first = l1_it.next();\n       \
    \         } else if x > y {\n                    second = l2_it.next();\n    \
    \            } else {\n                    common.push(*x);\n                \
    \    first = l1_it.next();\n                    second = l2_it.next();\n     \
    \           }\n            }\n            _ => break,\n        }\n    }\n    common",
  "    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n  \
    \  l1.iter().filter(|x| l2.contains(x)).cloned().collect()", "    let mut result\
    \ = Vec::new();\n    for el1 in l1 {\n        for el2 in l2.iter() {\n       \
    \     if el1 == *el2 {\n                result.push(el1);\n            }\n   \
    \     }\n    }\n    result.sort();\n    result.dedup();\n    result", "    let\
    \ mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    let\
    \ mut ret = Vec::new();\n    let mut i1 = 0;\n    let mut i2 = 0;\n    while i1\
    \ < l1.len() && i2 < l2.len() {\n        if l1[i1] == l2[i2] {\n            ret.push(l1[i1]);\n\
    \            i1 += 1;\n            i2 += 1;\n        } else if l1[i1] < l2[i2]\
    \ {\n            i1 += 1;\n        } else {\n            i2 += 1;\n        }\n\
    \    }\n    ret", "    let mut common = Vec::new();\n    let mut iter1 = l1.iter();\n\
    \    let mut iter2 = l2.iter();\n    let mut cur1 = iter1.next();\n    let mut\
    \ cur2 = iter2.next();\n    while cur1.is_some() && cur2.is_some() {\n       \
    \ let t1 = cur1.unwrap();\n        let t2 = cur2.unwrap();\n        if t1 == t2\
    \ {\n            common.push(*t1);\n            cur1 = iter1.next();\n       \
    \     cur2 = iter2.next();\n        } else if t1 < t2 {\n            cur1 = iter1.next();\n\
    \        } else {\n            cur2 = iter2.next();\n        }\n    }\n    common",
  "    let mut common: Vec<isize> = Vec::new();\n    let mut l1 = l1.clone();\n  \
    \  let mut l2 = l2.clone();\n    l1.sort();\n    l2.sort();\n    let mut i1 =\
    \ 0;\n    let mut i2 = 0;\n    loop {\n        if i1 >= l1.len() || i2 >= l2.len()\
    \ {\n            break;\n        }\n        if l1[i1] == l2[i2] {\n          \
    \  common.push(l1[i1]);\n            i1 += 1;\n            i2 += 1;\n        }\
    \ else if l1[i1] < l2[i2] {\n            i1 += 1;\n        } else {\n        \
    \    i2 += 1;\n        }\n    }\n    common", "    let mut uniq1 = l1.clone();\n\
    \    uniq1.sort();\n    uniq1.dedup();\n    let mut uniq2 = l2.clone();\n    uniq2.sort();\n\
    \    uniq2.dedup();\n    uniq1.into_iter().filter(|e| uniq2.contains(e)).collect()",
  "    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n  \
    \  let mut common = Vec::new();\n    let mut l1_index = 0;\n    let mut l2_index\
    \ = 0;\n    while l1_index < l1.len() && l2_index < l2.len() {\n        if l1[l1_index]\
    \ < l2[l2_index] {\n            l1_index += 1;\n        } else if l1[l1_index]\
    \ > l2[l2_index] {\n            l2_index += 1;\n        } else {\n           \
    \ common.push(l1[l1_index]);\n            l1_index += 1;\n            l2_index\
    \ += 1;\n        }\n    }\n    common", "    let mut l1 = l1;\n    let mut l2\
    \ = l2;\n    l1.sort();\n    l2.sort();\n    l1.retain(|&x| l2.contains(&x));\n\
    \    l1.dedup();\n    l1", "    let mut l3 = l1.clone();\n    l3.extend_from_slice(&l2);\n\
    \    l3.sort();\n    l3.dedup();\n    l3", "    let mut l1 = l1;\n    let mut\
    \ l2 = l2;\n    l1.sort();\n    l2.sort();\n    l1.iter().filter(|&x| l2.binary_search(x).is_ok()).cloned().collect()",
  "    let mut buf = l1.clone();\n    buf.extend(l2.clone());\n    let mut ans = buf.clone();\n\
    \    ans.sort();\n    ans.dedup();\n    return ans;", "    let mut common: Vec<isize>\
    \ = Vec::new();\n    let mut i1 = 0;\n    let mut i2 = 0;\n    while i1 < l1.len()\
    \ && i2 < l2.len() {\n        if l1[i1] < l2[i2] {\n            i1 += 1;\n   \
    \     } else if l1[i1] > l2[i2] {\n            i2 += 1;\n        } else {\n  \
    \          common.push(l1[i1]);\n            i1 += 1;\n            i2 += 1;\n\
    \        }\n    }\n    common", "    let mut l1 = l1;\n    let mut l2 = l2;\n\
    \    l1.sort();\n    l2.sort();\n    l1.iter().filter(|a| l2.binary_search(a).is_ok()).map(|a|\
    \ *a).collect()", "    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n\
    \    l2.sort();\n    l1.retain(|&x| l2.contains(&x));\n    l1.dedup();\n    l1",
  "    fn reduce(x: Vec<isize>, y: Vec<isize>) -> Vec<isize> {\n        let mut v\
    \ = x.clone();\n        for e in y {\n            if !v.contains(&e) {\n     \
    \           v.push(e);\n            }\n        }\n        v\n    }\n    fn intersection(x:\
    \ Vec<isize>, y: Vec<isize>) -> Vec<isize> {\n        let mut v = Vec::new();\n\
    \        for e in x {\n            if y.contains(&e) {\n                v.push(e);\n\
    \            }\n        }\n        v\n    }\n    fn sort(mut v: Vec<isize>) ->\
    \ Vec<isize> {\n        v.sort();\n        v\n    }\n    let mut v = reduce(l1,\
    \ l2);\n    v = intersection(l1, v);\n    v = intersection(l2, v);\n    sort(v)",
  "    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n  \
    \  let mut common = Vec::new();\n    let mut i1 = 0;\n    let mut i2 = 0;\n  \
    \  while i1 < l1.len() && i2 < l2.len() {\n        if l1[i1] == l2[i2] {\n   \
    \         common.push(l1[i1]);\n            i1 += 1;\n            i2 += 1;\n \
    \       } else if l1[i1] < l2[i2] {\n            i1 += 1;\n        } else {\n\
    \            i2 += 1;\n        }\n    }\n    common", "    let mut l1 = l1;\n\
    \    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    l1.dedup();\n    l2.dedup();\n\
    \    let mut res = Vec::new();\n    let mut i1 = 0;\n    let mut i2 = 0;\n   \
    \ while i1 < l1.len() && i2 < l2.len() {\n        if l1[i1] == l2[i2] {\n    \
    \        res.push(l1[i1]);\n            i1 += 1;\n            i2 += 1;\n     \
    \   } else if l1[i1] < l2[i2] {\n            i1 += 1;\n        } else {\n    \
    \        i2 += 1;\n        }\n    }\n    res", "    let mut list = l1.clone();\n\
    \    list.extend(l2.clone());\n    let mut sorted = list.clone();\n    sorted.sort();\n\
    \    sorted.dedup();\n    sorted", "    let mut result = Vec::new();\n    let\
    \ mut i1 = 0;\n    let mut i2 = 0;\n    while i1 < l1.len() && i2 < l2.len() {\n\
    \        if l1[i1] == l2[i2] {\n            result.push(l1[i1]);\n           \
    \ i1 += 1;\n            i2 += 1;\n        } else if l1[i1] < l2[i2] {\n      \
    \      i1 += 1;\n        } else {\n            i2 += 1;\n        }\n    }\n  \
    \  result", "    if l1.len() > l2.len() {\n        common(l2, l1)\n    } else\
    \ {\n        // Binary search.\n        let mut result = Vec::new();\n       \
    \ for elt in l1 {\n            let mut lo = 0;\n            let mut hi = l2.len();\n\
    \            while lo < hi {\n                let mid = (lo + hi) / 2;\n     \
    \           if l2[mid] < elt {\n                    lo = mid + 1;\n          \
    \      } else {\n                    hi = mid;\n                }\n          \
    \  }\n            if lo < l2.len() && l2[lo] == elt {\n                result.push(elt);\n\
    \            }\n        }\n        result\n    }", "    let mut common = HashSet::new();\n\
    \    let mut unique = HashSet::new();\n    for x in l1 {\n        unique.insert(x);\n\
    \    }\n    for x in l2 {\n        if unique.contains(&x) {\n            common.insert(x);\n\
    \        }\n    }\n    let mut sorted = common.into_iter().collect::<Vec<isize>>();\n\
    \    sorted.sort();\n    sorted", "    let mut a1 = l1.clone();\n    let mut a2\
    \ = l2.clone();\n    a1.sort();\n    a2.sort();\n    a1.into_iter().filter(|&x|\
    \ a2.contains(&x)).collect()", "    let mut x1 = l1.iter();\n    let mut x2 =\
    \ l2.iter();\n    let mut v = Vec::new();\n    loop {\n        match (x1.next(),\
    \ x2.next()) {\n            (Some(a), Some(b)) => {\n                match a.cmp(b)\
    \ {\n                    Ordering::Less => {\n                        x2.next();\n\
    \                    }\n                    Ordering::Greater => {\n         \
    \               x1.next();\n                    }\n                    Ordering::Equal\
    \ => {\n                        v.push(*a);\n                    }\n         \
    \       }\n            }\n            (None, _) => break,\n            (_, None)\
    \ => break,\n        }\n    }\n    v", "    let mut v1 = l1.clone();\n    let\
    \ mut v2 = l2.clone();\n    v1.sort();\n    v2.sort();\n    v1.dedup();\n    v2.dedup();\n\
    \    let mut result = Vec::new();\n    for i in v1 {\n        if v2.contains(&i)\
    \ {\n            result.push(i);\n        }\n    }\n    result", "    let mut\
    \ l = vec![];\n    let mut p1 = 0;\n    let mut p2 = 0;\n    let mut prev = None;\n\
    \    loop {\n        let mut v1 = None;\n        let mut v2 = None;\n        if\
    \ p1 < l1.len() {\n            v1 = Some(l1[p1]);\n        }\n        if p2 <\
    \ l2.len() {\n            v2 = Some(l2[p2]);\n        }\n        if v1.is_none()\
    \ && v2.is_none() {\n            break;\n        }\n        let v = match (v1,\
    \ v2) {\n            (Some(v1), Some(v2)) => std::cmp::min(v1, v2),\n        \
    \    (Some(v1), None) => v1,\n            (None, Some(v2)) => v2,\n          \
    \  (None, None) => unreachable!(),\n        };\n        if v == l1[p1] {\n   \
    \         p1 += 1;\n        }\n        if v == l2[p2] {\n            p2 += 1;\n\
    \        }\n        if prev.is_none() || prev.unwrap() != v {\n            l.push(v);\n\
    \            prev = Some(v);\n        }\n    }\n    l", "    let l1 = radix_sort(l1);\n\
    \    let l2 = radix_sort(l2);\n    let mut l3 = Vec::new();\n    let mut i = 0;\n\
    \    let mut j = 0;\n    while i < l1.len() && j < l2.len() {\n        if l1[i]\
    \ < l2[j] {\n            i += 1;\n        } else if l1[i] > l2[j] {\n        \
    \    j += 1;\n        } else {\n            if l3.len() == 0 || l3[l3.len() -\
    \ 1] != l1[i] {\n                l3.push(l1[i]);\n            }\n            i\
    \ += 1;\n            j += 1;\n        }\n    }\n    l3", '    l1.iter().filter(|&n|
    l2.contains(n)).cloned().collect()', "    let mut common = Vec::new();\n    for\
    \ item in l1 {\n        if l2.contains(&item) {\n            common.push(item);\n\
    \        }\n    }\n    common.sort();\n    common.dedup();\n    common", "   \
    \ let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n   \
    \ l1.iter().filter(|n| l2.contains(n)).cloned().collect()", "    let (s1, s2)\
    \ = (l1.len(), l2.len());\n    let (mut idx1, mut idx2) = (0, 0);\n    let mut\
    \ common = Vec::new();\n    while idx1 < s1 && idx2 < s2 {\n        let (n1, n2)\
    \ = (l1[idx1], l2[idx2]);\n        if n1 < n2 {\n            idx1 += 1;\n    \
    \    } else if n1 > n2 {\n            idx2 += 1;\n        } else {\n         \
    \   common.push(n1);\n            idx1 += 1;\n            idx2 += 1;\n       \
    \ }\n    }\n    common", "    let mut res = l1.iter().filter(|&x| l2.contains(x)).cloned().collect::<Vec<isize>>();\n\
    \    res.sort();\n    res.dedup();\n    res", '    common_by(l1, l2, |a, b| a
    == b)', "    let mut l3 = l1.clone();\n    let mut l4 = l2.clone();\n    l3.sort();\n\
    \    l4.sort();\n    l3.dedup();\n    l4.dedup();\n    let mut c = Vec::new();\n\
    \    for i in l3 {\n        if l4.contains(&i) {\n            c.push(i);\n   \
    \     }\n    }\n    c", "    let mut v1 = l1.clone();\n    let mut v2 = l2.clone();\n\
    \    v1.sort();\n    v2.sort();\n    v1.retain(|&x| v2.contains(&x));\n    v1.dedup();\n\
    \    v1", "    let mut common = l1.intersect(&l2).cloned().collect::<Vec<isize>>();\n\
    \    common.sort();\n    common.dedup();\n    common", "    let mut ret: Vec<isize>\
    \ = Vec::new();\n    for i in l1 {\n        if l2.contains(&i) {\n           \
    \ ret.push(i);\n        }\n    }\n    ret.sort();\n    ret.dedup();\n    ret",
  "    let mut t1 = l1.clone();\n    let mut t2 = l2.clone();\n    t1.sort();\n  \
    \  t2.sort();\n    let mut i1 = 0;\n    let mut i2 = 0;\n    let mut ret = Vec::new();\n\
    \    while i1 < t1.len() && i2 < t2.len() {\n        let v1 = t1[i1];\n      \
    \  let v2 = t2[i2];\n        if v1 == v2 {\n            ret.push(v1);\n      \
    \      i1 += 1;\n            i2 += 1;\n        } else if v1 < v2 {\n         \
    \   i1 += 1;\n        } else {\n            i2 += 1;\n        }\n    }\n    ret",
  "    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n  \
    \  l1.dedup();\n    l2.dedup();\n    let mut idx1 = 0;\n    let mut idx2 = 0;\n\
    \    let mut result = Vec::new();\n    while idx1 < l1.len() && idx2 < l2.len()\
    \ {\n        if l1[idx1] < l2[idx2] {\n            idx1 += 1;\n        } else\
    \ if l1[idx1] > l2[idx2] {\n            idx2 += 1;\n        } else {\n       \
    \     result.push(l1[idx1]);\n            idx1 += 1;\n            idx2 += 1;\n\
    \        }\n    }\n    result", "    let mut common = Vec::new();\n    let mut\
    \ i1 = 0;\n    let mut i2 = 0;\n    while i1 < l1.len() && i2 < l2.len() {\n \
    \       if l1[i1] == l2[i2] {\n            common.push(l1[i1]);\n            i1\
    \ += 1;\n            i2 += 1;\n        } else if l1[i1] < l2[i2] {\n         \
    \   i1 += 1;\n        } else {\n            i2 += 1;\n        }\n    }\n    common",
  "    let m = BTreeSet::from_iter(l1);\n    let n = BTreeSet::from_iter(l2);\n  \
    \  m.intersection(&n).cloned().collect()", "    let mut v1 = l1.iter().cloned().collect::<HashSet<isize>>();\n\
    \    let mut v2 = l2.iter().cloned().collect::<HashSet<isize>>();\n    v1.retain(|x|\
    \ v2.contains(x));\n    v1.into_iter().collect::<Vec<isize>>()", "    // Vectors\
    \ must be sorted in order to use `is_sorted` and `binary_search`.\n    let mut\
    \ v1 = l1;\n    let mut v2 = l2;\n    v1.sort();\n    v2.sort();\n\n    let mut\
    \ common = Vec::new();\n    for i in v1 {\n        if v2.binary_search(&i).is_ok()\
    \ {\n            common.push(i);\n        }\n    }\n    common.sort();\n    common.dedup();\n\
    \    common", "    let mut res = l1.clone();\n    res.retain(|e| l2.contains(e));\n\
    \    res.sort();\n    res.dedup();\n    res", '    l1.iter().cloned().filter(|v|
    l2.contains(v)).collect()', "    let mut res = vec![];\n    let mut i = 0;\n \
    \   let mut j = 0;\n    while i < l1.len() && j < l2.len() {\n        if l1[i]\
    \ == l2[j] {\n            res.push(l1[i]);\n            i += 1;\n            j\
    \ += 1;\n        } else if l1[i] < l2[j] {\n            i += 1;\n        } else\
    \ {\n            j += 1;\n        }\n    }\n    res", "    let mut l1: HashSet<isize>\
    \ = l1.into_iter().collect();\n    let mut l2: HashSet<isize> = l2.into_iter().collect();\n\
    \    l1.retain(|x| l2.contains(x));\n    let mut l: Vec<isize> = l1.into_iter().collect();\n\
    \    l.sort();\n    l", "    let mut u1 = l1.clone();\n    let mut u2 = l2.clone();\n\
    \    u1.sort();\n    u2.sort();\n    u1.dedup();\n    u2.dedup();\n    let mut\
    \ ret = Vec::new();\n    let mut s1 = u1.into_iter();\n    let mut s2 = u2.into_iter();\n\
    \    let mut e1 = s1.next();\n    let mut e2 = s2.next();\n    while e1.is_some()\
    \ && e2.is_some() {\n        let c1 = e1.unwrap();\n        let c2 = e2.unwrap();\n\
    \        if c1 == c2 {\n            ret.push(c1);\n            e1 = s1.next();\n\
    \            e2 = s2.next();\n        } else if c1 < c2 {\n            e1 = s1.next();\n\
    \        } else {\n            e2 = s2.next();\n        }\n    }\n    ret", " \
    \   let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n \
    \   l1.iter().zip(l2.iter()).filter(|&(x, y)| x == y).map(|(x, _)| *x).collect()",
  "    let mut set = HashSet::new();\n    let mut res = Vec::new();\n    for i in\
    \ l1 {\n        set.insert(i);\n    }\n    for i in l2 {\n        if set.contains(&i)\
    \ {\n            res.push(i);\n        }\n    }\n    res.sort();\n    res", " \
    \   let mut c = Vec::new();\n    let mut i1 = 0;\n    let mut i2 = 0;\n    while\
    \ i1 < l1.len() && i2 < l2.len() {\n        let v1 = l1[i1];\n        let v2 =\
    \ l2[i2];\n        if v1 < v2 {\n            i1 += 1;\n        } else if v1 >\
    \ v2 {\n            i2 += 1;\n        } else {\n            c.push(v1);\n    \
    \        i1 += 1;\n            i2 += 1;\n        }\n    }\n    c", "    let mut\
    \ c: Vec<isize> = vec![];\n    for i in l1 {\n        if !c.contains(&i) && l2.contains(&i)\
    \ {\n            c.push(i);\n        }\n    }\n    c.sort();\n    c", "    let\
    \ mut set1 = HashSet::new();\n    let mut set2 = HashSet::new();\n    for i in\
    \ l1 {\n        set1.insert(i);\n    }\n    for i in l2 {\n        set2.insert(i);\n\
    \    }\n    let mut common = vec![];\n    for i in set1.intersection(&set2) {\n\
    \        common.push(*i);\n    }\n    common.sort();\n    common", "    let mut\
    \ s1 = l1.clone();\n    let mut s2 = l2.clone();\n    s1.sort();\n    s2.sort();\n\
    \    s1.retain(|x| s2.contains(x));\n    s1.dedup();\n    s1", "    let mut common\
    \ = Vec::new();\n    let mut i1 = 0;\n    let mut i2 = 0;\n    while i1 < l1.len()\
    \ && i2 < l2.len() {\n        if l1[i1] == l2[i2] {\n            common.push(l1[i1]);\n\
    \            i1 += 1;\n            i2 += 1;\n        } else if l1[i1] < l2[i2]\
    \ {\n            i1 += 1;\n        } else {\n            i2 += 1;\n        }\n\
    \    }\n    common", "    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n\
    \    l2.sort();\n    let mut iter1 = l1.iter();\n    let mut iter2 = l2.iter();\n\
    \    let mut val1 = iter1.next();\n    let mut val2 = iter2.next();\n    let mut\
    \ out = Vec::new();\n    while val1.is_some() && val2.is_some() {\n        if\
    \ val1 == val2 {\n            out.push(*val1.unwrap());\n            val1 = iter1.next();\n\
    \            val2 = iter2.next();\n        } else if val1 < val2 {\n         \
    \   val1 = iter1.next();\n        } else {\n            val2 = iter2.next();\n\
    \        }\n    }\n    out", "    let mut l1 = l1;\n    let mut l2 = l2;\n   \
    \ l1.sort();\n    l2.sort();\n    l1.retain(|x| l2.contains(x));\n    l1.dedup();\n\
    \    l1", "    let s1: HashSet<isize> = l1.into_iter().collect();\n    let s2:\
    \ HashSet<isize> = l2.into_iter().collect();\n    let intersection: HashSet<_>\
    \ = s1.intersection(&s2).collect();\n    let mut intersection: Vec<isize> = intersection.into_iter().collect();\n\
    \    intersection.sort();\n    intersection", "    let mut l3 = Vec::new();\n\
    \    let mut i1 = 0;\n    let mut i2 = 0;\n    let mut l1s = l1.len();\n    let\
    \ mut l2s = l2.len();\n    while i1 < l1s && i2 < l2s {\n        if l1[i1] < l2[i2]\
    \ {\n            i1 += 1;\n        } else if l1[i1] > l2[i2] {\n            i2\
    \ += 1;\n        } else {\n            l3.push(l1[i1]);\n            i1 += 1;\n\
    \            i2 += 1;\n        }\n    }\n    l3", "    let mut result = vec![];\n\
    \    let mut sl1 = l1.clone();\n    let mut sl2 = l2.clone();\n    sl1.sort();\n\
    \    sl2.sort();\n    let mut iter1 = sl1.iter();\n    let mut iter2 = sl2.iter();\n\
    \    let mut a = iter1.next();\n    let mut b = iter2.next();\n    while a.is_some()\
    \ && b.is_some() {\n        let x = a.unwrap();\n        let y = b.unwrap();\n\
    \        if x < y {\n            a = iter1.next();\n        } else if x > y {\n\
    \            b = iter2.next();\n        } else {\n            result.push(*x);\n\
    \            a = iter1.next();\n            b = iter2.next();\n        }\n   \
    \ }\n    result", "    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n\
    \    l2.sort();\n    let mut i1 = 0;\n    let mut i2 = 0;\n    let mut common\
    \ = Vec::new();\n    loop {\n        if i1 >= l1.len() || i2 >= l2.len() {\n \
    \           break;\n        }\n        let v1 = l1[i1];\n        let v2 = l2[i2];\n\
    \        if v1 == v2 {\n            common.push(v1);\n            i1 += 1;\n \
    \           i2 += 1;\n        } else if v1 < v2 {\n            i1 += 1;\n    \
    \    } else {\n            i2 += 1;\n        }\n    }\n    common", "    let mut\
    \ unique: Vec<isize> = Vec::new();\n    for e in l1 {\n        if l2.contains(&e)\
    \ && !unique.contains(&e) {\n            unique.push(e);\n        }\n    }\n \
    \   unique.sort();\n    unique", "    let mut out = vec![];\n    let mut r = 0;\n\
    \    for e in l1 {\n        let mut l = 0;\n        let mut r = r;\n        while\
    \ l != r {\n            let m = (l + r) / 2;\n            if l2[m] < e {\n   \
    \             l = m + 1;\n            } else {\n                r = m;\n     \
    \       }\n        }\n        if l != l2.len() && l2[l] == e {\n            out.push(e);\n\
    \            r = l + 1;\n        }\n    }\n    out", "    let mut l1 = l1;\n \
    \   let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    l1.dedup();\n    l2.dedup();\n\
    \    l1.iter().filter(|x| l2.contains(x)).cloned().collect()", "    let mut res\
    \ = Vec::new();\n    let l1_size = l1.len();\n    let l2_size = l2.len();\n  \
    \  let mut i = 0;\n    let mut j = 0;\n    while i < l1_size && j < l2_size {\n\
    \        let (a, b) = (l1[i], l2[j]);\n        if a == b {\n            res.push(a);\n\
    \            i += 1;\n            j += 1;\n        } else if a < b {\n       \
    \     i += 1;\n        } else {\n            j += 1;\n        }\n    }\n    res",
  "    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n  \
    \  let mut r = Vec::new();\n    let mut i1 = 0;\n    let mut i2 = 0;\n    while\
    \ i1 < l1.len() && i2 < l2.len() {\n        if l1[i1] == l2[i2] {\n          \
    \  r.push(l1[i1]);\n            i1 += 1;\n            i2 += 1;\n        } else\
    \ if l1[i1] < l2[i2] {\n            i1 += 1;\n        } else {\n            i2\
    \ += 1;\n        }\n    }\n    r", "    let mut result = Vec::new();\n    let\
    \ mut l1 = l1.clone();\n    let mut l2 = l2.clone();\n    l1.sort();\n    l2.sort();\n\
    \    let mut a = l1.iter();\n    let mut b = l2.iter();\n    let mut an = a.next();\n\
    \    let mut bn = b.next();\n    loop {\n        match (an, bn) {\n          \
    \  (Some(ai), Some(bi)) => {\n                if ai == bi {\n                \
    \    result.push(*ai);\n                    an = a.next();\n                 \
    \   bn = b.next();\n                } else if ai < bi {\n                    an\
    \ = a.next();\n                } else {\n                    bn = b.next();\n\
    \                }\n            }\n            _ => break,\n        }\n    }\n\
    \    result", "    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n  \
    \  l2.sort();\n    l1.into_iter().filter(|&x| l2.binary_search(&x).is_ok()).collect()",
  "    let mut v = Vec::new();\n    for &x in l1.iter() {\n        if l2.contains(&x)\
    \ {\n            v.push(x);\n        }\n    }\n    v.sort();\n    v.dedup();\n\
    \    v", "    let mut v = Vec::new();\n    let mut li1 = l1.clone();\n    let\
    \ mut li2 = l2.clone();\n    li1.sort();\n    li2.sort();\n    // println!(\"\
    {:?}\", li1);\n    // println!(\"{:?}\", li2);\n    let mut i1 = 0;\n    let mut\
    \ i2 = 0;\n    while i1 < li1.len() && i2 < li2.len() {\n        // println!(\"\
    Comparing {} to {}\", li1[i1], li2[i2]);\n        if li1[i1] == li2[i2] {\n  \
    \          // println!(\"Match\");\n            v.push(li1[i1]);\n           \
    \ i1 += 1;\n            i2 += 1;\n        } else if li1[i1] < li2[i2] {\n    \
    \        i1 += 1;\n        } else {\n            i2 += 1;\n        }\n    }\n\
    \    return v;", "    let set1: HashSet<isize> = l1.into_iter().collect();\n \
    \   let set2: HashSet<isize> = l2.into_iter().collect();\n    let intersection:\
    \ HashSet<isize> = set1.intersection(&set2).map(|&x| x).collect();\n    let mut\
    \ common: Vec<isize> = intersection.into_iter().collect();\n    common.sort();\n\
    \    common", "    let mut res = vec![];\n    let mut i = 0;\n    let mut j =\
    \ 0;\n    while i < l1.len() && j < l2.len() {\n        if l1[i] == l2[j] {\n\
    \            res.push(l1[i]);\n            i += 1;\n            j += 1;\n    \
    \    } else if l1[i] < l2[j] {\n            i += 1;\n        } else {\n      \
    \      j += 1;\n        }\n    }\n    res", "    let mut l3 = l1.clone();\n  \
    \  let mut l4 = l2.clone();\n    l3.sort();\n    l4.sort();\n    l3.dedup();\n\
    \    l4.dedup();\n    l3.retain(|&x| l4.contains(&x));\n    l3", "    let mut\
    \ result = HashSet::new();\n    for e in l1 {\n        if l2.contains(&e) {\n\
    \            result.insert(e);\n        }\n    }\n    result.into_iter().collect()",
  "    let mut common = Vec::new();\n    let mut l1 = l1.clone();\n    let mut l2\
    \ = l2.clone();\n    l1.sort();\n    l2.sort();\n    let mut p1 = 0;\n    let\
    \ mut p2 = 0;\n    loop {\n        if p1 >= l1.len() || p2 >= l2.len() {\n   \
    \         break;\n        }\n        if l1[p1] == l2[p2] {\n            common.push(l1[p1]);\n\
    \            p1 += 1;\n            p2 += 1;\n        } else if l1[p1] < l2[p2]\
    \ {\n            p1 += 1;\n        } else {\n            p2 += 1;\n        }\n\
    \    }\n    common", "    let l1 = l1.iter().cloned().collect::<HashSet<isize>>();\n\
    \    let l2 = l2.iter().cloned().collect::<HashSet<isize>>();\n    l1.intersection(&l2).cloned().collect::<Vec<isize>>()",
  "    let mut common: Vec<isize> = l1.iter().filter(|x| l2.contains(x)).cloned().collect();\n\
    \    common.sort();\n    common.dedup();\n    common", "    let mut l1 = l1;\n\
    \    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    l1.dedup();\n    l2.dedup();\n\
    \    l1.into_iter().filter(|&x| l2.contains(&x)).collect()", "    let mut l1 =\
    \ l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    l1.dedup();\n\
    \    l2.dedup();\n    l1.iter().filter(|&x| l2.contains(x)).cloned().collect()",
  "    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n  \
    \  l1.dedup();\n    l2.dedup();\n    l1.into_iter().filter(|i| l2.contains(i)).collect()",
  "    let mut res = Vec::new();\n    let mut l1 = l1.clone();\n    let mut l2 = l2.clone();\n\
    \    l1.sort();\n    l2.sort();\n    l1.dedup();\n    l2.dedup();\n    let mut\
    \ l1 = l1.into_iter();\n    let mut l2 = l2.into_iter();\n    let mut v1 = l1.next();\n\
    \    let mut v2 = l2.next();\n    while v1.is_some() && v2.is_some() {\n     \
    \   if v1 == v2 {\n            res.push(v1.unwrap());\n            v1 = l1.next();\n\
    \            v2 = l2.next();\n        } else if v1 < v2 {\n            v1 = l1.next();\n\
    \        } else {\n            v2 = l2.next();\n        }\n    }\n    res", " \
    \   let mut new_list = Vec::new();\n    for item in l1 {\n        if l2.contains(&item)\
    \ {\n            new_list.push(item);\n        }\n    }\n    new_list.sort();\n\
    \    new_list.dedup();\n    new_list", "    let mut xs = Vec::new();\n    for\
    \ l in l1.into_iter() {\n        for r in l2.into_iter() {\n            if l ==\
    \ r {\n                xs.push(l);\n            }\n        }\n    }\n    xs.sort();\n\
    \    xs.dedup();\n    xs", "    let mut l = vec![];\n    let mut h = HashSet::new();\n\
    \    for &v in &l1 {\n        h.insert(v);\n    }\n    for &v in &l2 {\n     \
    \   if h.contains(&v) {\n            l.push(v);\n        }\n    }\n    l.sort();\n\
    \    l.dedup();\n    l", "    let mut l1: Vec<isize> = l1.into_iter().sorted().collect();\n\
    \    let mut l2: Vec<isize> = l2.into_iter().sorted().collect();\n    let mut\
    \ res = Vec::new();\n    let mut i = 0;\n    let mut j = 0;\n    loop {\n    \
    \    if i >= l1.len() || j >= l2.len() {\n            break;\n        }\n    \
    \    let e1 = l1[i];\n        let e2 = l2[j];\n        if e1 == e2 {\n       \
    \     res.push(e1);\n            i += 1;\n            j += 1;\n        } else\
    \ if e1 < e2 {\n            i += 1;\n        } else {\n            j += 1;\n \
    \       }\n    }\n    res", '    l1.into_iter().filter(|&x| l2.contains(&x)).collect()',
  "    let mut out = Vec::new();\n    let (mut i1, mut i2) = (0, 0);\n    while i1\
    \ < l1.len() && i2 < l2.len() {\n        if l1[i1] == l2[i2] {\n            out.push(l1[i1]);\n\
    \            i1 += 1;\n            i2 += 1;\n        } else if l1[i1] < l2[i2]\
    \ {\n            i1 += 1;\n        } else {\n            i2 += 1;\n        }\n\
    \    }\n    out", "    let mut unique = l1.iter().filter(|x| l2.contains(x)).cloned().collect::<Vec<isize>>();\n\
    \    unique.sort();\n    unique.dedup();\n    unique", "    let mut l1 = l1;\n\
    \    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    let l1s = l1.clone();\n\
    \    let l2s = l2.clone();\n    let mut c: Vec<isize> = vec![];\n    let (mut\
    \ i1, mut i2) = (0, 0);\n    while i1 < l1s.len() && i2 < l2s.len() {\n      \
    \  if l1s[i1] == l2s[i2] {\n            c.push(l1s[i1]);\n            i1 += 1;\n\
    \            i2 += 1;\n        } else if l1s[i1] < l2s[i2] {\n            i1 +=\
    \ 1;\n        } else {\n            i2 += 1;\n        }\n    }\n    return c;",
  "    let mut l1: HashSet<isize> = l1.into_iter().collect();\n    let mut l2: HashSet<isize>\
    \ = l2.into_iter().collect();\n    l1.retain(|x| l2.contains(x));\n    let mut\
    \ l: Vec<isize> = l1.into_iter().collect();\n    l.sort();\n    l", "    let mut\
    \ res = vec![];\n    let mut l1 = l1.clone();\n    let mut l2 = l2.clone();\n\
    \    l1.sort();\n    l2.sort();\n    let mut i = 0;\n    let mut j = 0;\n    while\
    \ i < l1.len() && j < l2.len() {\n        if l1[i] == l2[j] {\n            res.push(l1[i]);\n\
    \            i += 1;\n            j += 1;\n        } else if l1[i] < l2[j] {\n\
    \            i += 1;\n        } else {\n            j += 1;\n        }\n    }\n\
    \    res", "    // Merge sort\n    let mut merged = Vec::new();\n    let mut i1\
    \ = 0;\n    let mut i2 = 0;\n    while i1 < l1.len() && i2 < l2.len() {\n    \
    \    if l1[i1] == l2[i2] {\n            merged.push(l1[i1]);\n            i1 +=\
    \ 1;\n            i2 += 1;\n        } else if l1[i1] < l2[i2] {\n            i1\
    \ += 1;\n        } else {\n            i2 += 1;\n        }\n    }\n    // Sort\
    \ and remove duplicates\n    let mut unique = merged.clone();\n    unique.sort();\n\
    \    unique.dedup();\n    unique", "    let mut n1 = 0;\n    let mut n2 = 0;\n\
    \    let mut res = Vec::new();\n    loop {\n        match (l1.get(n1), l2.get(n2))\
    \ {\n            (Some(v1), Some(v2)) => {\n                if v1 < v2 {\n   \
    \                 n1 += 1;\n                } else if v1 > v2 {\n            \
    \        n2 += 1;\n                } else {\n                    res.push(*v1);\n\
    \                    n1 += 1;\n                    n2 += 1;\n                }\n\
    \            }\n            (None, _) | (_, None) => break,\n        }\n    }\n\
    \    res", "    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n\
    \    l1.retain(|&x| l2.contains(&x));\n    l1.dedup();\n    l1", "    let mut\
    \ l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    let mut\
    \ commons = vec![];\n    let mut i1 = 0;\n    let mut i2 = 0;\n    loop {\n  \
    \      match (l1.get(i1), l2.get(i2)) {\n            (Some(x), Some(y)) => {\n\
    \                if x < y {\n                    i1 += 1;\n                } else\
    \ if x > y {\n                    i2 += 1;\n                } else {\n       \
    \             commons.push(*x);\n                    i1 += 1;\n              \
    \      i2 += 1;\n                }\n            }\n            _ => break,\n \
    \       }\n    }\n    commons", "    let mut set: HashSet<isize> = HashSet::new();\n\
    \    let mut common: Vec<isize> = Vec::new();\n\n    for &i in l1.iter() {\n \
    \       set.insert(i);\n    }\n\n    for &i in l2.iter() {\n        if set.contains(&i)\
    \ {\n            common.push(i);\n        }\n    }\n\n    common.sort();\n   \
    \ common.dedup();\n    common", '    l1.iter().chain(l2.iter()).cloned().collect::<HashSet<isize>>().iter().cloned().collect::<Vec<isize>>()',
  "    let mut list1 = l1.clone();\n    let mut list2 = l2.clone();\n    list1.sort();\n\
    \    list2.sort();\n    list1.retain(|&x| list2.contains(&x));\n    list1.dedup();\n\
    \    list1", "    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n   \
    \ l2.sort();\n    l1.dedup();\n    l2.dedup();\n    l1.into_iter().filter(|x|\
    \ l2.contains(x)).collect()", "    let mut inter: Vec<isize> = Vec::new();\n \
    \   let mut i = 0;\n    let mut j = 0;\n    while i < l1.len() && j < l2.len()\
    \ {\n        if l1[i] == l2[j] {\n            inter.push(l1[i]);\n           \
    \ i += 1;\n            j += 1;\n        } else if l1[i] < l2[j] {\n          \
    \  i += 1;\n        } else {\n            j += 1;\n        }\n    }\n    inter",
  "    let mut common = Vec::new();\n    for i in l1 {\n        if l2.contains(&i)\
    \ {\n            common.push(i);\n        }\n    }\n    common.sort();\n    common.dedup();\n\
    \    common", "    let mut set = HashSet::new();\n    set.extend(l1);\n    set.extend(l2);\n\
    \    let mut result = set.into_iter().collect::<Vec<isize>>();\n    result.sort();\n\
    \    result", "    // Return sorted and deduplicated list of elements.\n    //\
    \ l1 and l2 are both sorted.\n    let mut r = Vec::new();\n    let mut i1 = 0;\n\
    \    let mut i2 = 0;\n    while i1 < l1.len() && i2 < l2.len() {\n        if l1[i1]\
    \ == l2[i2] {\n            if r.len() == 0 || r[r.len() - 1] != l1[i1] {\n   \
    \             r.push(l1[i1]);\n            }\n            i1 += 1;\n         \
    \   i2 += 1;\n        } else if l1[i1] < l2[i2] {\n            i1 += 1;\n    \
    \    } else {\n            i2 += 1;\n        }\n    }\n    r", "    let mut result\
    \ = vec![];\n    for i in l1 {\n        for j in l2.iter() {\n            if i\
    \ == *j {\n                result.push(i);\n            }\n        }\n    }\n\
    \    result.sort();\n    result.dedup();\n    result", "    let mut common = Vec::new();\n\
    \    for elt in l1 {\n        if l2.contains(&elt) {\n            common.push(elt);\n\
    \        }\n    }\n    common.sort();\n    common.dedup();\n    common", "   \
    \ let mut common = vec![];\n    // Sort lists and attempt to find mutual elements.\n\
    \    let mut list1 = l1.clone();\n    let mut list2 = l2.clone();\n    list1.sort();\n\
    \    list2.sort();\n    let mut i = 0;\n    let mut j = 0;\n    while i < list1.len()\
    \ && j < list2.len() {\n        match list1[i].cmp(&list2[j]) {\n            Equal\
    \ => {\n                common.push(list1[i]);\n                i += 1;\n    \
    \            j += 1;\n            }\n            Less => {\n                i\
    \ += 1;\n            }\n            Greater => {\n                j += 1;\n  \
    \          }\n        }\n    }\n    common", "    let mut l1 = l1;\n    let mut\
    \ l2 = l2;\n    l1.sort();\n    l2.sort();\n    l1.into_iter().filter(|&n| l2.contains(&n)).collect()",
  "    let mut s = BTreeSet::new();\n    for e in l1 {\n        s.insert(e);\n   \
    \ }\n    let mut res = vec![];\n    for e in l2 {\n        if s.contains(&e) {\n\
    \            res.push(e);\n        }\n    }\n    res.sort();\n    res", "    let\
    \ mut first = l1.iter().map(|x| *x).collect::<BTreeSet<isize>>();\n    let second\
    \ = l2.iter().map(|x| *x).collect::<BTreeSet<isize>>();\n    first.retain(|&x|\
    \ second.contains(&x));\n    first.into_iter().collect()", "    let mut l1: Vec<isize>\
    \ = l1.clone();\n    let mut l2: Vec<isize> = l2.clone();\n    l1.sort();\n  \
    \  l2.sort();\n    let mut l = Vec::new();\n    let mut i1 = 0;\n    let mut i2\
    \ = 0;\n    loop {\n        if i1 == l1.len() || i2 == l2.len() {\n          \
    \  break;\n        }\n        let v1 = l1[i1];\n        let v2 = l2[i2];\n   \
    \     if v1 == v2 {\n            l.push(v1);\n            i1 += 1;\n         \
    \   i2 += 1;\n        } else if v1 < v2 {\n            i1 += 1;\n        } else\
    \ {\n            i2 += 1;\n        }\n    }\n    l", "    let mut l1 = l1;\n \
    \   let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    let mut uniq = l1.iter().peekable();\n\
    \    let mut uniq_vec = Vec::new();\n    while let Some(u) = uniq.next() {\n \
    \       if let Some(peek) = uniq.peek() {\n            if u == peek {\n      \
    \          continue;\n            }\n        }\n        if l2.contains(u) {\n\
    \            uniq_vec.push(*u);\n        }\n    }\n    uniq_vec", "    let mut\
    \ result = vec![];\n    if l1.len() > l2.len() {\n        for item in l1 {\n \
    \           if l2.contains(&item) {\n                result.push(item);\n    \
    \        }\n        }\n    } else {\n        for item in l2 {\n            if\
    \ l1.contains(&item) {\n                result.push(item);\n            }\n  \
    \      }\n    }\n    result.sort();\n    result.dedup();\n    result", "    let\
    \ mut c1 = l1.clone();\n    let mut c2 = l2.clone();\n    c1.sort();\n    c2.sort();\n\
    \    let mut common = Vec::new();\n    let mut n1 = 0;\n    let mut n2 = 0;\n\
    \    while n1 < c1.len() && n2 < c2.len() {\n        if c1[n1] == c2[n2] {\n \
    \           common.push(c1[n1]);\n            n1 += 1;\n            n2 += 1;\n\
    \        } else if c1[n1] < c2[n2] {\n            n1 += 1;\n        } else {\n\
    \            n2 += 1;\n        }\n    }\n    common", "    let mut l1: Vec<isize>\
    \ = l1.clone();\n    let mut l2: Vec<isize> = l2.clone();\n    l1.sort();\n  \
    \  l2.sort();\n    l1.retain(|x| l2.contains(x));\n    l1.dedup();\n    l1", " \
    \   let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n \
    \   let mut res = Vec::new();\n    let mut i1 = 0;\n    let mut i2 = 0;\n    while\
    \ i1 < l1.len() && i2 < l2.len() {\n        if l1[i1] == l2[i2] {\n          \
    \  res.push(l1[i1]);\n            i1 += 1;\n            i2 += 1;\n        } else\
    \ if l1[i1] < l2[i2] {\n            i1 += 1;\n        } else {\n            i2\
    \ += 1;\n        }\n    }\n    res", "    let mut l1 = l1;\n    let mut l2 = l2;\n\
    \    l1.sort();\n    l2.sort();\n    l1.dedup();\n    l2.dedup();\n    let mut\
    \ result = Vec::new();\n    let mut i1 = 0;\n    let mut i2 = 0;\n    while i1\
    \ < l1.len() && i2 < l2.len() {\n        let e1 = l1[i1];\n        let e2 = l2[i2];\n\
    \        if e1 == e2 {\n            result.push(e1);\n            i1 += 1;\n \
    \           i2 += 1;\n        } else if e1 < e2 {\n            i1 += 1;\n    \
    \    } else {\n            i2 += 1;\n        }\n    }\n    result", "    let mut\
    \ ret = Vec::new();\n    let mut iter1 = l1.iter();\n    let mut iter2 = l2.iter();\n\
    \    let mut i1 = iter1.next();\n    let mut i2 = iter2.next();\n    while i1.is_some()\
    \ && i2.is_some() {\n        if *i1.unwrap() < *i2.unwrap() {\n            i1\
    \ = iter1.next();\n        } else if *i1.unwrap() > *i2.unwrap() {\n         \
    \   i2 = iter2.next();\n        } else {\n            ret.push(*i1.unwrap());\n\
    \            i1 = iter1.next();\n            i2 = iter2.next();\n        }\n \
    \   }\n    ret", "    let mut res = Vec::new();\n    for item in l1 {\n      \
    \  if l2.contains(&item) {\n            res.push(item);\n        }\n    }\n  \
    \  res.sort();\n    res.dedup();\n    res", "    let mut res = vec![];\n    let\
    \ mut idx1 = 0;\n    let mut idx2 = 0;\n    let mut elem1 = isize::min_value();\n\
    \    let mut elem2 = isize::min_value();\n    let mut finished = false;\n    loop\
    \ {\n        if idx1 >= l1.len() || idx2 >= l2.len() {\n            finished =\
    \ true;\n        }\n        if elem1 != isize::min_value() && elem2 != isize::min_value()\
    \ {\n            if elem1 == elem2 {\n                res.push(elem1);\n     \
    \           elem1 = isize::min_value();\n                elem2 = isize::min_value();\n\
    \            } else if elem1 < elem2 {\n                elem1 = isize::min_value();\n\
    \            } else {\n                elem2 = isize::min_value();\n         \
    \   }\n        }\n        if elem1 == isize::min_value() && idx1 < l1.len() {\n\
    \            elem1 = l1[idx1];\n            idx1 += 1;\n        }\n        if\
    \ elem2 == isize::min_value() && idx2 < l2.len() {\n            elem2 = l2[idx2];\n\
    \            idx2 += 1;\n        }\n        if finished {\n            break;\n\
    \        }\n    }\n    res", "    let mut l1 = l1;\n    let mut l2 = l2;\n   \
    \ l1.sort();\n    l2.sort();\n    l1.retain(|&x| l2.contains(&x));\n    l1.dedup();\n\
    \    l1", "    l1.into_iter().fold(\n        l2.into_iter().collect::<Vec<isize>>(),\n\
    \        |mut l, i| {\n            if l.contains(&i) {\n                l.retain(|&x|\
    \ x != i);\n                l.push(i);\n            }\n            l\n       \
    \ },\n    )", "    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n  \
    \  l2.sort();\n    let mut l3 = Vec::new();\n    let mut i1 = 0;\n    let mut\
    \ i2 = 0;\n    while i1 < l1.len() && i2 < l2.len() {\n        if l1[i1] == l2[i2]\
    \ {\n            if i1 == 0 || l1[i1] != l1[i1 - 1] {\n                l3.push(l1[i1]);\n\
    \            }\n            i1 += 1;\n            i2 += 1;\n        } else if\
    \ l1[i1] < l2[i2] {\n            i1 += 1;\n        } else {\n            i2 +=\
    \ 1;\n        }\n    }\n    l3", "    let mut a1 = l1.clone();\n    let mut a2\
    \ = l2.clone();\n    a1.sort();\n    a2.sort();\n    let mut result = Vec::new();\n\
    \    let mut a = a1.iter();\n    let mut b = a2.iter();\n    let mut va = a.next();\n\
    \    let mut vb = b.next();\n    loop {\n        if va == None || vb == None {\n\
    \            break;\n        }\n        let va1 = va.unwrap();\n        let vb1\
    \ = vb.unwrap();\n        match va1.cmp(vb1) {\n            Ordering::Equal =>\
    \ {\n                result.push(*va1);\n                va = a.next();\n    \
    \            vb = b.next();\n            }\n            Ordering::Less => {\n\
    \                va = a.next();\n            }\n            Ordering::Greater\
    \ => {\n                vb = b.next();\n            }\n        }\n    }\n    result",
  "    let l1: HashSet<isize> = l1.into_iter().collect();\n    let l2: HashSet<isize>\
    \ = l2.into_iter().collect();\n    let common = l1.intersection(&l2);\n    let\
    \ common: Vec<isize> = common.map(|&i| i).collect();\n    common.into_iter().sorted().collect()",
  "    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n  \
    \  l1.into_iter().filter(|i| l2.binary_search(i).is_ok()).collect()", "    let\
    \ mut out = l1.iter().cloned().collect::<Vec<isize>>();\n    out.extend(l2.iter().cloned());\n\
    \    out.sort();\n    out.dedup();\n    out", "    let (mut n1, mut n2) = (l1.len(),\
    \ l2.len());\n    let (mut i1, mut i2) = (0usize, 0usize);\n    let mut l3 = Vec::new();\n\
    \    while i1 < n1 && i2 < n2 {\n        let c = l1[i1].cmp(&l2[i2]);\n      \
    \  match c {\n            Ordering::Less => i1 += 1,\n            Ordering::Greater\
    \ => i2 += 1,\n            Ordering::Equal => {\n                l3.push(l1[i1]);\n\
    \                i1 += 1;\n                i2 += 1;\n            }\n        }\n\
    \    }\n    l3", "    // TODO: find better way to get unique elements from list.\n\
    \    let mut set: HashSet<isize> = HashSet::new();\n    for i in l1 {\n      \
    \  set.insert(i);\n    }\n    for i in l2 {\n        set.insert(i);\n    }\n \
    \   let mut ret: Vec<isize> = Vec::new();\n    for i in set {\n        ret.push(i);\n\
    \    }\n    ret.sort();\n    ret", "    let mut set: HashSet<isize> = HashSet::new();\n\
    \    let mut common: Vec<isize> = Vec::new();\n\n    // Add all elements from\
    \ `l1` in set.\n    for i in &l1 {\n        set.insert(*i);\n    }\n\n    // If\
    \ element from `l2` is in `set`, add it to `common`.\n    for i in &l2 {\n   \
    \     if set.contains(i) {\n            common.push(*i);\n        }\n    }\n\n\
    \    common.sort();\n    common", "    let mut l1 = l1;\n    let mut l2 = l2;\n\
    \    l1.sort();\n    l2.sort();\n    let mut common: Vec<isize> = Vec::new();\n\
    \    let mut i1 = 0;\n    let mut i2 = 0;\n    while i1 < l1.len() && i2 < l2.len()\
    \ {\n        if l1[i1] == l2[i2] {\n            common.push(l1[i1]);\n       \
    \     i1 += 1;\n            i2 += 1;\n        } else if l1[i1] < l2[i2] {\n  \
    \          i1 += 1;\n        } else {\n            i2 += 1;\n        }\n    }\n\
    \    common", "    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n  \
    \  l2.sort();\n    l1.dedup();\n    l2.dedup();\n    l1.iter().filter(|x| l2.contains(x)).map(|x|\
    \ *x).collect()", "    let mut l = Vec::new();\n    let mut tmp = Vec::new();\n\
    \    for i in 0..l1.len() {\n        tmp.push(l1[i]);\n    }\n    for i in 0..l2.len()\
    \ {\n        if tmp.contains(&l2[i]) {\n            l.push(l2[i]);\n        }\n\
    \    }\n    l.sort();\n    l.dedup();\n    l", "    let mut common = l1.intersect(&l2).collect::<Vec<&isize>>();\n\
    \    common.sort();\n    common.dedup();\n    common.iter().map(|x| **x).collect()",
  '    l1.iter().chain(l2.iter()).filter(|x| l1.contains(x) && l2.contains(x)).cloned().collect()',
  "    if l1.len() == 0 || l2.len() == 0 {\n        return Vec::new();\n    }\n  \
    \  let mut l1_set = l1.iter().map(|x| *x).collect::<HashSet<isize>>();\n    let\
    \ mut l2_set = l2.iter().map(|x| *x).collect::<HashSet<isize>>();\n    l1_set.retain(|x|\
    \ l2_set.contains(x));\n    let mut ret = l1_set.into_iter().collect::<Vec<isize>>();\n\
    \    ret.sort();\n    ret", "    let set1: HashSet<isize> = l1.into_iter().collect();\n\
    \    let set2: HashSet<isize> = l2.into_iter().collect();\n    let mut common:\
    \ Vec<isize> = set1.intersection(&set2).cloned().collect();\n    common.sort();\n\
    \    common", "    let uniq1 = l1.iter().cloned().collect::<HashSet<isize>>();\n\
    \    let uniq2 = l2.iter().cloned().collect::<HashSet<isize>>();\n    let common\
    \ = uniq1.intersection(&uniq2).cloned().collect::<Vec<isize>>();\n    common.sort();\n\
    \    common"]
stop_tokens:
- "\n}"
