name: HumanEval_151_double_the_difference
language: rs
prompt: "/// Given a list of numbers, return the sum of squares of the numbers\n///\
  \ in the list that are odd. Ignore numbers that are negative or not integers.\n\
  /// If the input list is empty, return 0.\nfn double_the_difference(lst: Vec<isize>)\
  \ -> isize {\n"
tests: "}\n\nfn main() {\n    let candidate = double_the_difference;\n    assert_eq!(candidate(Vec::<isize>::new()),\
  \ 0);\n    assert_eq!(candidate(vec![5, 4]), 25);\n    assert_eq!(candidate(vec![0.1,\
  \ 0.2, 0.3]), 0);\n    assert_eq!(candidate(vec![-10, -20, -30]), 0);\n    assert_eq!(candidate(vec![-1,\
  \ -2, 8]), 0);\n    assert_eq!(candidate(vec![0.2, 3, 5]), 34);\n    assert_eq!(candidate(vec![-9,\
  \ -7, -5, -3, -1, 1, 3, 5, 7, 9]), 165);\n}\n"
completions: ["    let mut lst1 = lst.clone();\n    lst1.sort();\n    let mut lst2\
    \ = lst.clone();\n    lst2.sort_by(|a, b| b.cmp(a));\n    if lst1.len() > 1 {\n\
    \        (lst1[0] - lst2[0]) * 2\n    } else {\n        0\n    }", "  // Complete\
    \ this function\n  let mut i: isize = 0;\n  let mut max: isize = 0;\n  let mut\
    \ min: isize = 0;\n  for x in lst {\n    if x > max {\n      max = x;\n    }\n\
    \    if x < min {\n      min = x;\n    }\n  }\n  2 * (max - min)", '    (sum_square_odd(lst)
    - sum_square_even(lst)) * 2', "  let mut sum = 0;\n  for item in lst {\n    if\
    \ item < 0 {\n      continue;\n    }\n    if item % 2 == 0 {\n      continue;\n\
    \    }\n    sum += item * item;\n  }\n  return sum;", '    unimplemented!()',
  "    // TODO\n    0", "    let mut even_sum = 0;\n    let mut odd_sum = 0;\n   \
    \ for num in lst {\n        if num % 2 == 0 {\n            even_sum += num;\n\
    \        } else {\n            odd_sum += num;\n        }\n    }\n    2 * (even_sum\
    \ - odd_sum)", "    if lst.len() == 0 {\n        return 0;\n    }\n\n    let mut\
    \ tup = (0, 0);\n    for n in lst {\n        if n % 2 == 0 {\n            tup.0\
    \ += n;\n        } else {\n            tup.1 += n;\n        }\n    }\n\n    2\
    \ * (tup.1 - tup.0)", "    let l = lst.into_iter().filter(|&x| x % 2 == 1).map(|x|\
    \ x * x).sum();\n    l", "    let mut l: Vec<isize> = lst.clone();\n    l.sort();\n\
    \    // Args: enum Ordering { Less, Equal, Greater }\n    match l.len() {\n  \
    \      0 => 0,\n        1 => 0,\n        _ => {\n            let smallest = l[0];\n\
    \            let biggest = l[l.len() - 1];\n            let diff = biggest - smallest;\n\
    \            2 * diff\n        }\n    }", "    let mut sum = 0;\n    for i in\
    \ lst {\n        if i < 0 {\n            continue;\n        }\n        if i %\
    \ 2 == 1 {\n            sum += i * i;\n        }\n    }\n    sum", '    unimplemented!()',
  "    // TODO\n    0", '    unimplemented!()', "    // TODO: implement this function\n\
    \    unimplemented!();", '    unimplemented!();', "    let mut sum = 0;\n    for\
    \ i in lst {\n        if i > 0 && i % 2 == 1 {\n            sum += i * i;\n  \
    \      }\n    }\n    sum", "    let mut x = 0;\n    let mut y = 0;\n    for i\
    \ in lst {\n        if i > 0 && i%2 == 1 {\n            x += i*i;\n        }\n\
    \        if i > 0 && i%2 == 0 {\n            y += i*i;\n        }\n    }\n   \
    \ return 2*(x-y);", "    let mut diff = 0;\n    for num in lst {\n        if num\
    \ % 2 == 1 {\n            diff += num * num;\n        }\n    }\n    return diff;",
  "    let mut count = 0;\n    for elem in lst {\n        if elem % 2 == 1 {\n   \
    \         count += elem * elem;\n        }\n    }\n    count", '    unimplemented!();',
  "    match lst.split_first() {\n        None => 0,\n        Some((&first, rest))\
    \ => {\n            let rest_sum = double_the_difference(rest.to_vec());\n   \
    \         first.pow(2) + rest_sum\n        }\n    }", '    unimplemented!()',
  "    let mut sum = 0;\n    for i in lst {\n        if i.is_positive() && i % 2 ==\
    \ 1 {\n            sum += i*i;\n        }\n    }\n    sum", '    unimplemented!()',
  "    // TODO: implement me!\n    0", "    // TODO: implement this function.\n  \
    \  unimplemented!();", '    return 0;', "    let a = lst\n        .iter()\n  \
    \      .filter(|&x| x % 2 == 1)\n        .fold(0, |acc, x| acc + x * x);\n   \
    \ a * 2", "    let even = lst.iter().filter(|x| **x % 2 == 0).fold(0, |acc, x|\
    \ acc + x);\n    let odd = lst.iter().filter(|x| **x % 2 != 0).fold(0, |acc, x|\
    \ acc + x);\n    even - odd", "    let mut s = 0;\n    let mut c = 0;\n    for\
    \ i in lst {\n        if i.is_positive() && i.is_whole() {\n            s += i.pow(2);\n\
    \            c += 1;\n        }\n    }\n    2 * (s - c)", "    // TODO: implement\
    \ me!\n    unimplemented!()", "    let sum_of_squares_of_odd_numbers = sum_of_squares_of_odd_numbers(lst);\n\
    \    double_the_value(sum_of_squares_of_odd_numbers)", "    // TODO: Implement\
    \ the body of this function.\n    return 0;", "    let mut sum = 0;\n    for x\
    \ in lst {\n        if x < 0 {\n            sum += x;\n        }\n    }\n    sum",
  "    // Student code goes here.\n    0", '    unimplemented!();', "    let mut squares\
    \ = vec![];\n    for num in lst {\n        if num > 0 && num % 2 == 1 {\n    \
    \        squares.push(num * num);\n        }\n    }\n    return squares.iter().sum();",
  '    unimplemented!();', "    // TODO: Write code here\n    0", "    let mut return_value\
    \ = 0;\n    for i in lst {\n        if i % 2 == 1 && i > 0 {\n            return_value\
    \ += i * i;\n        }\n    }\n    return_value", "    // TODO: add code here\n\
    \    unimplemented!();", '    unimplemented!();', "    let mut lst_of_diff = Vec::new();\n\
    \    for num in lst {\n        let mut diff = num - 6;\n        if diff < 0 {\n\
    \            diff = 0;\n        }\n        lst_of_diff.push(diff);\n    }\n  \
    \  let mut double_sum = 0;\n    for num in lst_of_diff {\n        double_sum +=\
    \ 2 * num;\n    }\n    double_sum", "    // TODO\n    // There are more tests\
    \ for this function in `tests/test.rs`\n    unimplemented!()", "    // No provided\
    \ code, but putting the answer here as I didn't notice a\n    // *hint* section\
    \ in the website.\n    //\n    // So, we want to double the difference between\
    \ the odd and even numbers\n    // in the list.\n    //\n    // First, split the\
    \ input list into odd and even lists, then find the\n    // difference between\
    \ their sums. I have no idea how to find the sum of a\n    // list, but I know\
    \ how to find the sum of two numbers, so map the list\n    // over the summing\
    \ function.\n    let odd = lst.iter().filter(|n| **n % 2 == 1).map(|n| *n).collect::<Vec<isize>>();\n\
    \    let even = lst.iter().filter(|n| **n % 2 == 0).map(|n| *n).collect::<Vec<isize>>();\n\
    \    let odd_sum = odd.iter().fold(0, |sum, x| sum + x);\n    let even_sum = even.iter().fold(0,\
    \ |sum, x| sum + x);\n    let diff = odd_sum - even_sum;\n    2 * diff", '    unimplemented!()',
  "    match lst.iter().fold((0, 0), |acc, &i| {\n        if i % 2 == 0 {\n      \
    \      (acc.0 + i * i, acc.1)\n        } else {\n            (acc.0, acc.1 + i\
    \ * i)\n        }\n    }) {\n        (a, b) => 2 * (a - b),\n    }", "    let\
    \ s: isize = lst.iter().filter(|x| x.is_odd()).sum();\n    s.pow(2)", "    let\
    \ mut sum: isize = 0;\n    for i in lst {\n        if i % 2 != 0 {\n         \
    \   sum += i.pow(2);\n        }\n    }\n    sum", "    let mut lst_odd: Vec<isize>\
    \ = Vec::new();\n    let mut lst_even: Vec<isize> = Vec::new();\n    for n in\
    \ lst {\n        if n.is_odd() {\n            lst_odd.push(n)\n        } else\
    \ {\n            lst_even.push(n)\n        }\n    }\n    let mut odd_sum = 0;\n\
    \    let mut even_sum = 0;\n    for n in lst_odd {\n        odd_sum += n;\n  \
    \  }\n    for n in lst_even {\n        even_sum += n;\n    }\n    let difference\
    \ = odd_sum - even_sum;\n    difference * 2", "    let mut sum: isize = 0;\n \
    \   for num in lst {\n        sum += num * num;\n    }\n    return sum;", "  \
    \  // Unimplemented!();\n    // let mut sum = 0;\n    // for x in lst {\n    //\
    \     if x % 2 == 1 {\n    //         sum += x*x;\n    //     }\n    // }\n  \
    \  // sum\n    unimplemented!();", "    // TODO\n    unimplemented!();", "   \
    \ let mut max = None;\n    let mut min = None;\n    for el in lst {\n        match\
    \ max {\n            None => max = Some(el),\n            Some(max_) => if el\
    \ > max_ { max = Some(el) }\n        }\n        match min {\n            None\
    \ => min = Some(el),\n            Some(min_) => if el < min_ { min = Some(el)\
    \ }\n        }\n    }\n    let max_ = max.unwrap();\n    let min_ = min.unwrap();\n\
    \    2 * (max_ - min_)", "    let mut sum = 0;\n    for i in lst {\n        if\
    \ i > 0 && i % 2 == 1 {\n            sum += i * i;\n        }\n    }\n    return\
    \ sum;", "    let mut sum = 0;\n    for &x in &lst {\n        if x.is_odd() {\n\
    \            sum += x * x;\n        }\n    }\n    sum", "    let sum: isize =\
    \ lst.iter().map(|x| x.pow(2)).sum();\n    sum * 2", '    unimplemented!()', " \
    \   // TODO\n    unimplemented!();", '    0', "    // TODO: compute the difference\n\
    \    let mut total = 0;\n    for i in lst {\n        if i % 2 == 1 {\n       \
    \     total += i*i;\n        }\n    }\n    return total;", "    // TODO\n    if\
    \ lst.len() < 1 {\n        return 0;\n    }\n    let mut total: isize = 0;\n \
    \   for i in lst {\n        if i > 0 && i%2 != 0 {\n            total += i*i;\n\
    \        }\n    }\n    return total;", "    let mut sum = 0;\n    for num in lst\
    \ {\n        if num % 2 == 1 {\n            sum += num * num;\n        }\n   \
    \ }\n    sum", "    let mut res = 0;\n    for i in lst {\n        if i.is_positive()\
    \ && i % 2 == 1 {\n            res += i*i;\n        }\n    }\n    res", '    lst.iter().filter(|&n|
    (n % 2) == 1).map(|&n| n*n).sum()', "    let mut sum = 0;\n    for num in lst\
    \ {\n        if num.is_odd() {\n            sum += num * num;\n        }\n   \
    \ }\n    sum", "    let mut result = 0;\n    for item in lst {\n        if item\
    \ > 0 && item % 2 == 1 {\n            result += item * item;\n        }\n    }\n\
    \    result", "    // YOUR CODE HERE\n    0", "    // Define a function is_odd\
    \ that takes a number n and returns\n    // whether n is odd\n    fn is_odd(n:\
    \ isize) -> bool {\n        n % 2 == 1\n    }\n\n    // Define a function square\
    \ that takes a number n and returns\n    // n squared\n    fn square(n: isize)\
    \ -> isize {\n        n * n\n    }\n\n    // Define a function is_valid that takes\
    \ a number n and returns\n    // whether n is a valid integer (i.e. not negative\
    \ and an integer)\n    fn is_valid(n: isize) -> bool {\n        if n < 0 {\n \
    \           return false;\n        }\n        // Check if n is an integer by converting\
    \ it to a float and checking\n        // if the floor of the float is equal to\
    \ the float (i.e. it has no\n        // decimal part)\n        n as f64 == (n\
    \ as f64).floor()\n    }\n\n    // Use filter to get a new list of all numbers\
    \ in lst that are odd,\n    // valid and positive\n    let lst: Vec<isize> = lst\n\
    \        .into_iter()\n        .filter(|n| is_odd(*n) && is_valid(*n))\n     \
    \   .collect();\n\n    // Sum up the squares of all numbers in lst using fold\
    \ and square\n    lst.into_iter().fold(0, |a, b| a + square(b))", "    let mut\
    \ result = 0;\n    for num in lst {\n        if num % 2 == 1 {\n            result\
    \ += num * num;\n        }\n    }\n    result", "    // the `0` is just a placeholder\
    \ for when the list is empty\n    // The `unwrap` is required because all the\
    \ elements must be of the same type,\n    // but we don't know what type it is\
    \ yet.\n    let max = lst.iter().max().unwrap();\n    let min = lst.iter().min().unwrap();\n\
    \    2 * (max - min)", "    // let mut result = 0;\n    // for x in lst {\n  \
    \  //     if x % 2 == 1 {\n    //         result += x * x;\n    //     }\n   \
    \ // }\n    // result\n    lst.iter()\n        .filter(|x| x % 2 == 1)\n     \
    \   .map(|x| x * x)\n        .sum()", "    // TODO: implement the function here\n\
    \    unimplemented!();", "    // you can use this function if you'd like, but\
    \ it's optional\n    fn is_odd(x: isize) -> bool {\n        x % 2 == 1\n    }\n\
    \n    // ANSWER\n    let sum_of_squares = lst.iter().filter(|&x| is_odd(*x)).fold(0,\
    \ |sum, &x| sum + x*x);\n    sum_of_squares", "    let mut sum = 0;\n    for element\
    \ in lst {\n        if element % 2 == 1 {\n            sum += element * element;\n\
    \        }\n    }\n    sum", '    sum_of_squares_of_odd_numbers(lst)', "    //\
    \ TODO Complete this function to pass the test!\n    0", "    let mut sum = 0;\n\
    \    for num in lst {\n        if num.is_odd() {\n            sum += num * num;\n\
    \        }\n    }\n    sum", '    unimplemented!();', "    let mut sum_squares:\
    \ isize = 0;\n    for i in lst {\n        if i % 2 != 0 && i > 0 {\n         \
    \   sum_squares += i * i;\n        }\n    }\n    return sum_squares;", '    lst.iter().map(|x|
    x*x).filter(|x| x%2 == 1).sum()', '    unimplemented!();', "    let mut lst2 =\
    \ lst.clone();\n    lst2.reverse();\n    let mut result = 0;\n    for i in 0..lst.len()\
    \ {\n        if lst[i] % 2 == 1 {\n            result += lst[i] * lst[i];\n  \
    \      }\n        if lst2[i] % 2 == 1 {\n            result += lst2[i] * lst2[i];\n\
    \        }\n    }\n    result", "    // Copied from solution.\n    let summed_odds\
    \ = sum_odd_squares(lst);\n    let summed_evens = sum_even_squares(lst);\n   \
    \ let diff = summed_odds - summed_evens;\n    diff * 2", "    let mut diff: isize\
    \ = 0;\n    for item in lst {\n        if item % 2 == 1 {\n            diff +=\
    \ item * item;\n        }\n    }\n    return diff;", "    let mut even = 0;\n\
    \    let mut odd = 0;\n    for i in lst {\n        if i % 2 == 0 {\n         \
    \   even += i;\n        } else {\n            odd += i;\n        }\n    }\n  \
    \  2 * (odd - even)", "    let mut evens = 0;\n    let mut odds = 0;\n    for\
    \ elem in lst {\n        if elem % 2 == 0 {\n            evens += elem;\n    \
    \    } else {\n            odds += elem;\n        }\n    }\n    (evens - odds)\
    \ * 2", '    unimplemented!()', "    // Start your code here.\n    0", "    //\
    \ Create a vector consisting of all positive and negative elements of lst\n  \
    \  let pos_and_neg: Vec<isize> = lst.iter().filter(|&x| x > &0 || x < &0).map(|&x|\
    \ x).collect();\n    // Create a vector consisting of all the odd numbers in the\
    \ lst\n    let odd_nums: Vec<isize> = lst.iter().filter(|&x| (x & 1) == 1).map(|&x|\
    \ x).collect();\n    // Create a vector consisting of all the even numbers in\
    \ the lst\n    let even_nums: Vec<isize> = lst.iter().filter(|&x| (x & 1) == 0).map(|&x|\
    \ x).collect();\n    // Sum all of the positive elements in the pos_and_neg vector\n\
    \    let sum_pos: isize = pos_and_neg.iter().filter(|&x| x > &0).fold(0, |sum,\
    \ x| sum + x);\n    // Sum all of the negative elements in the pos_and_neg vector\n\
    \    let sum_neg: isize = pos_and_neg.iter().filter(|&x| x < &0).fold(0, |sum,\
    \ x| sum + x);\n    // Sum all of the odd elements in the odd_nums vector\n  \
    \  let sum_odd: isize = odd_nums.iter().fold(0, |sum, x| sum + x);\n    // Sum\
    \ all of the even elements in the even_nums vector\n    let sum_even: isize =\
    \ even_nums.iter().fold(0, |sum, x| sum + x);\n    // Double the difference of\
    \ the sum of the positive elements and sum of the\n    // negative elements in\
    \ the pos_and_neg vector\n    (sum_pos - sum_neg) * 2", "    let mut vec1 = Vec::new();\n\
    \    let mut vec2 = Vec::new();\n    let mut result = 0;\n    for i in lst {\n\
    \        if i < 0 {\n            continue;\n        }\n        if i % 2 == 0 {\n\
    \            vec1.push(i);\n        } else {\n            vec2.push(i);\n    \
    \    }\n    }\n    for i in vec1 {\n        result += i * i;\n    }\n    for i\
    \ in vec2 {\n        result -= i * i;\n    }\n    result * 2", '    unimplemented!()',
  '    sum_of_squares_of_odds(lst) * 2', '    unimplemented!();', '    unimplemented!();',
  '    unimplemented!()', '    unimplemented!();', "    // TODO\n    0", "    // TODO:\
    \ Implement me!\n    unimplemented!();", "    let sum_of_evens = lst.iter().filter(|&x|\
    \ x % 2 == 0).sum();\n    let sum_of_odds = lst.iter().filter(|&x| x % 2 != 0).sum();\n\
    \    let diff = (sum_of_evens - sum_of_odds).abs();\n    diff * 2", "    let mut\
    \ sum: isize = 0;\n    for n in lst {\n        if n > 0 && n % 2 == 1 {\n    \
    \        sum += n * n;\n        }\n    }\n    sum", "    // Complete me!\n   \
    \ lst.iter().filter(|n| *n > &0).fold(0, |acc, n| acc + n * n)", '    unimplemented!();',
  "    // TODO: Return the correct value.\n    unimplemented!();", "    let mut sum\
    \ = 0;\n    for i in lst {\n        if i % 2 == 1 {\n            sum += i * i;\n\
    \        }\n    }\n    sum", '    unimplemented!()', "    //unimplemented!()\n\
    \    let mut sum = 0;\n    for num in lst {\n        if num % 2 == 1 {\n     \
    \       sum += num * num;\n        }\n    }\n    sum", "    let mut even_sum =\
    \ 0;\n    let mut odd_sum = 0;\n    for x in lst {\n        if x % 2 == 0 {\n\
    \            even_sum += x;\n        } else {\n            odd_sum += x;\n   \
    \     }\n    }\n    odd_sum - even_sum", "    if lst.len() == 0 {\n        return\
    \ 0;\n    }\n    lst.iter().filter(|&x| x % 2 == 1).map(|x| x * x).sum()", " \
    \   let mut ans = 0;\n    for i in 0..lst.len() {\n        ans += (lst[i] - lst[lst.len()\
    \ - i - 1]).pow(2);\n    }\n    ans", "    // Write a body for this function\n\
    \    let mut sum = 0;\n    for i in lst {\n        if i % 2 == 1 {\n         \
    \   sum += i * i;\n        }\n    }\n    sum", "    let r: Vec<isize> = lst.into_iter().map(|x|x*x).filter(|x|x%2==1).collect();\n\
    \    let s = r.into_iter().fold(0, |sum, a| sum + a);\n    return s;", "    let\
    \ mut sum = 0;\n    for i in lst {\n        if i % 2 == 1 {\n            sum +=\
    \ i * i;\n        }\n    }\n    sum", "    let (pos, neg) = split_pos_neg(lst);\n\
    \    let product = pos.iter().product::<isize>();\n    let sum = neg.iter().sum::<isize>();\n\
    \    let diff = sum - product;\n    diff * 2", "    let sum: isize = lst.iter().filter(|&x|\
    \ x%2==1).map(|&x| x*x).sum();\n    return sum;", '    unimplemented!();', '    lst.iter().filter(|x|
    *x % 2 == 1).map(|x| x * x).sum()', "    match (lst.get(0), lst.get(1)) {\n  \
    \      (Some(x), Some(y)) => (x - y).abs() * 2,\n        _ => 0,\n    }", '    unimplemented!()',
  "    let mut sum = 0;\n    for x in lst {\n        if x >= 0 && x % 2 == 1 {\n \
    \           sum += x*x;\n        }\n    }\n    sum", "    let sum: isize = lst.iter().filter(|&x|\
    \ x % 2 == 1).map(|x| x * x).sum();\n    sum", "    let mut acc: isize = 0;\n\
    \    for elem in lst {\n        if elem % 2 == 1 {\n            acc += elem *\
    \ elem;\n        }\n    }\n    acc", "    let filtered = lst.iter().filter(|&&x|\
    \ x > 1).collect::<Vec<_>>();\n    let mut sum = 0;\n    for i in filtered {\n\
    \        sum += i * i;\n    }\n    sum", "    // TODO\n    let mut result = 0;\n\
    \    for i in lst {\n        if i % 2 != 0 {\n            result += i * i;\n \
    \       }\n    }\n    result", "    //unimplemented!()\n    let mut sum: isize\
    \ = 0;\n    for i in lst.iter() {\n        if *i % 2 != 0 {\n            sum +=\
    \ i * i;\n        }\n    }\n    sum", "    let sum = lst.iter().fold(0, |sum,\
    \ &x| {\n        if x.is_positive() && x.is_odd() {\n            sum + x * x\n\
    \        } else {\n            sum\n        }\n    });\n    sum", "    // Your\
    \ code here\n    0", "    let mut sum = 0;\n    for i in lst {\n        if i %\
    \ 2 == 1 {\n            sum += i * i;\n        }\n    }\n    return sum;", '    lst.iter().map(|x|
    x*x).filter(|x| x % 2 == 1).sum()', "    // TODO: Implement Me!\n    unimplemented!();",
  "    let mut diff = 0;\n    let mut negative = true;\n    for i in lst {\n     \
    \   if i.is_positive() {\n            negative = false;\n            break;\n\
    \        }\n    }\n    if negative {\n        return 0;\n    }\n\n    for i in\
    \ lst {\n        if i < 0 {\n            continue;\n        }\n        if i %\
    \ 2 == 0 {\n            diff += i;\n        } else {\n            diff -= i;\n\
    \        }\n    }\n    diff * 2", '    unimplemented!()', "    if lst.len() >\
    \ 0 {\n        let mut max = lst[0];\n        let mut min = lst[0];\n        for\
    \ i in 0..lst.len() {\n            if lst[i] > max {\n                max = lst[i];\n\
    \            }\n            if lst[i] < min {\n                min = lst[i];\n\
    \            }\n        }\n        (max - min) * 2\n    } else {\n        0\n\
    \    }", "    // YOUR CODE HERE\n    let mut max = 0;\n    let mut min = 0;\n\
    \    let mut first = true;\n    for x in lst {\n        if first {\n         \
    \   max = x;\n            min = x;\n            first = false;\n        } else\
    \ {\n            if x > max {\n                max = x;\n            }\n     \
    \       if x < min {\n                min = x;\n            }\n        }\n   \
    \ }\n    (max - min) * 2", '    unimplemented!()', "    let sum_of_squares = lst.iter().filter(|&x|\
    \ x.is_positive() && x.is_integer()).map(|x| x * x).sum();\n    let sum = lst.iter().filter(|&x|\
    \ x.is_positive() && x.is_integer()).sum();\n    (sum_of_squares * 2) - (sum *\
    \ sum)", "    let mut sum = 0;\n    for i in lst {\n        if i % 2 == 1 {\n\
    \            sum += i * i;\n        }\n    }\n    sum", '    unimplemented!()',
  "    // TODO\n    0", "    return lst.iter().fold(0, |acc, x| {\n        if *x %\
    \ 2 == 1 {\n            acc + x.pow(2)\n        } else {\n            acc\n  \
    \      }\n    });", '    unimplemented!();', "    let mut sum = 0;\n    for i\
    \ in lst {\n        if i > 0 && i % 2 == 1 {\n            sum += i*i;\n      \
    \  }\n    }\n    sum", "    let mut sum = 0;\n    for &item in lst.iter() {\n\
    \        if item % 2 == 1 {\n            sum += item * item;\n        }\n    }\n\
    \    sum", "    let sum_of_squares = lst.iter().filter(|&x| x % 2 == 1).fold(0,\
    \ |a, b| a + b * b);\n    return sum_of_squares;", "    let mut lst = lst;\n \
    \   lst.sort();\n    (lst[lst.len() - 1] - lst[0]) * 2", "    let mut sum = 0;\n\
    \    for i in lst {\n        if i % 2 == 1 {\n            sum += i * i;\n    \
    \    }\n    }\n    sum", "    let sum = lst.iter().filter(|x| x.is_positive()\
    \ && x.is_integer()).map(|x| x.pow(2)).sum();\n    return 2 * sum;", "    // unimplemented!(\"\
    double the difference of {:?}\", lst)\n    // let odd_sqr = lst.iter().filter(|&x|\
    \ x % 2 == 1)\n    //                  .map(|x| x * x)\n    //               \
    \   .sum();\n    // let sqr_sum = lst.iter().map(|x| x * x).sum();\n    // sqr_sum\
    \ - 2 * odd_sqr\n    let sum: isize = lst.iter().map(|x| x.pow(2)).sum();\n  \
    \  let odd_sum: isize = lst.iter().filter(|&x| x % 2 == 1).map(|x| x.pow(2)).sum();\n\
    \    sum - 2 * odd_sum", "    let mut sum_of_squares = 0;\n    for num in lst\
    \ {\n        if num > 0 && num % 2 == 1 {\n            sum_of_squares += num *\
    \ num;\n        }\n    }\n    return sum_of_squares;", "    // The type of this\
    \ value might seem complicated, but it's just an\n    // iterator.\n    let mut\
    \ lst = lst.into_iter();\n\n    // As a habit, you should always match on `Option`s\
    \ that come from `next()`.\n    // This will ensure that your iterator is being\
    \ used properly.\n    let a = match lst.next() {\n        Some(x) => x,\n    \
    \    None => return 0,\n    };\n\n    let b = match lst.next() {\n        Some(x)\
    \ => x,\n        None => return 0,\n    };\n\n    // The double-difference is\
    \ `a - b` times two, so `(a - b) * 2`.\n    (a - b) * 2", '    panic!("Unimplemented");',
  "    if lst.len() > 0 {\n        (sum_odd_squares(lst) - sum_even_squares(lst))\
    \ * 2\n    } else {\n        0\n    }", "    // ....\n    unimplemented!();",
  "    let mut sum_odd_squares = 0;\n    for n in lst {\n        if n > 0 && n % 2\
    \ == 1 {\n            sum_odd_squares += n * n;\n        }\n    }\n    sum_odd_squares",
  "    let mut nums_to_add = Vec::new();\n    for i in lst {\n        if i % 2 !=\
    \ 0 && i > 0 {\n            nums_to_add.push(i);\n        }\n    }\n    nums_to_add.iter().map(|x|\
    \ x * x).sum()", "    // TODO\n    0", "    // YOUR CODE HERE!\n    if lst.len()\
    \ == 0 {\n        return 0;\n    }\n    let mut sum = 0;\n    for i in lst {\n\
    \        if i > 0 && i % 2 == 1 {\n            sum += i * i;\n        }\n    }\n\
    \    sum", '    lst.iter().fold(0, |a, b| a + b * b)', "    let (even, odd) =\
    \ partition(lst);\n    sum_of_squares(odd) - sum_of_squares(even)", "    let mut\
    \ sum: isize = 0;\n    let mut prod: isize = 1;\n    for num in lst {\n      \
    \  if num % 2 == 1 {\n            sum += num * num;\n        }\n        if num\
    \ >= 0 {\n            prod *= num;\n        }\n    }\n    2 * (prod - sum)", " \
    \   if lst.len() == 0 {\n        return 0;\n    }\n\n    let even_sum = lst.iter().filter(|x|\
    \ x % 2 == 0).fold(0, |acc, x| acc + x);\n    let odd_sum = lst.iter().filter(|x|\
    \ x % 2 != 0).fold(0, |acc, x| acc + x);\n\n    return 2 * (odd_sum - even_sum);",
  "    let mut square = 0;\n    for x in lst {\n        if x % 2 != 0 && x > 0 {\n\
    \            square += x * x;\n        }\n    }\n    square", "    let mut odds:\
    \ Vec<isize> = Vec::new();\n    let mut sum: isize = 0;\n    for num in lst {\n\
    \        if num % 2 != 0 {\n            odds.push(num);\n        }\n    }\n  \
    \  for num in odds {\n        sum += num * num;\n    }\n    sum", "  let sum_of_squares_odds\
    \ = sum_squares_odds(lst);\n  let sum_of_squares_evens = sum_squares_evens(lst);\n\
    \  let difference = sum_of_squares_odds - sum_of_squares_evens;\n  return difference\
    \ * 2;", "    // YOUR CODE HERE\n    let mut total: isize = 0;\n    for i in lst\
    \ {\n        if i % 2 != 0 {\n            total += i * i;\n        }\n    }\n\
    \    total", "    // implement this function\n    let mut odd_lst: Vec<isize>\
    \ = vec![];\n    for item in lst {\n        if item % 2 != 0 {\n            odd_lst.push(item\
    \ * item);\n        }\n    }\n    let mut result: isize = 0;\n    for item in\
    \ odd_lst {\n        result += item;\n    }\n    result", "    if lst.len() ==\
    \ 0 {\n        return 0;\n    }\n    let sum_of_squares_of_odds = sum_of_squares_of_odds(lst);\n\
    \    let sum_of_odds = sum_of_odds(lst);\n    2 * (sum_of_squares_of_odds - sum_of_odds)",
  "    let mut sum = 0;\n    for i in lst {\n        if i.is_positive() && i.is_integer()\
    \ {\n            sum += i.pow(2);\n        }\n    }\n    sum * 2", "    let mut\
    \ result = 0;\n    for i in lst {\n        if i > 10 {\n            result +=\
    \ i;\n        }\n    }\n    result", "    if lst.len() == 0 {\n        return\
    \ 0;\n    }\n    let mut result = 0;\n    for (index, value) in lst.iter().enumerate()\
    \ {\n        if index % 2 == 0 {\n            result += value * value;\n     \
    \   }\n    }\n    result", "    // TODO: Implement the function here\n    unimplemented!();",
  "    let mut sum_of_squares = 0;\n    for &num in lst.iter() {\n        if num %\
    \ 2 == 1 {\n            sum_of_squares += num * num;\n        }\n    }\n    sum_of_squares",
  "    match lst.first() {\n        Some(x) => match lst.last() {\n            Some(y)\
    \ => 2 * (*x - *y),\n            None => 0,\n        },\n        None => 0,\n\
    \    }", "    if lst.len() == 0 {\n        return 0;\n    }\n\n    let n = lst.len()\
    \ as isize;\n    let max = lst.iter().fold(std::isize::MIN, |a, b| a.max(*b));\n\
    \    let min = lst.iter().fold(std::isize::MAX, |a, b| a.min(*b));\n\n    2 *\
    \ (max - min)", "    let first_int = 0;\n    let second_int = 0;\n    let difference\
    \ = 0;\n    let doubled_difference = 0;\n    difference * 2", '    unimplemented!()',
  "    if lst.len() == 0 {\n        return 0;\n    }\n\n    let sum = lst.iter().map(|&x|\
    \ x * x).fold(0, |a, b| a + b);\n    sum * 2", "    let mut total = 0;\n    for\
    \ i in lst {\n        if i.is_odd() {\n            total += i.pow(2);\n      \
    \  }\n    }\n    total", '    unimplemented!()', "    // YOUR CODE HERE\n    0",
  "    if lst.len() < 2 {\n        0\n    } else {\n        let (x, y) = (lst[0],\
    \ lst[1]);\n        (x - y).abs() * 2\n    }", "    let mut total = 0;\n    for\
    \ num in lst {\n        if num < 0 {\n            continue;\n        }\n     \
    \   if num % 2 == 0 {\n            continue;\n        }\n        total += num\
    \ * num;\n    }\n    total", "    match lst.first() {\n        Some(first) =>\
    \ {\n            let first_double = 2 * first;\n            let rest_difference\
    \ = double_the_difference(lst[1..].to_vec());\n            first_double - rest_difference\n\
    \        }\n        None => 0,\n    }", "    // let mut nums = lst.clone();\n\
    \    // let mut sum = 0;\n    // let mut number = 0;\n    // let mut double =\
    \ 0;\n    // let length = nums.len();\n    // for x in 0..length {\n    //   \
    \  number = nums[x];\n    //     if number > 0 {\n    //         if number % 2\
    \ == 1 {\n    //             sum += number;\n    //         }\n    //     }\n\
    \    // }\n    // double = sum*2;\n    // double\n    lst.into_iter().filter(|x|\
    \ x > &0).filter(|x| x % 2 == 1).fold(0, |a, b| a + b) * 2", "    let sum: isize\
    \ = lst.iter().fold(0, |acc, x| {\n        if x < &0 {\n            acc\n    \
    \    } else {\n            acc + x * x\n        }\n    });\n    return sum;",
  "    let mut tot = 0;\n    for n in lst {\n        if n % 2 == 1 {\n           \
    \ tot += n * n;\n        }\n    }\n    tot", '    unimplemented!()', '    unimplemented!();',
  "    // type_here\n    0", "    let sum_of_squares_of_odd_ints = sum_of_squares_of_odd_ints(lst);\n\
    \    // TODO: Calculate the sum of squares of the even ints in lst.\n    // TODO:\
    \ Then, double the difference between those two numbers.\n    // let sum_of_squares_of_even_ints\
    \ = ...;\n    // let diff = sum_of_squares_of_odd_ints - sum_of_squares_of_even_ints;\n\
    \    // return 2 * diff;\n    unimplemented!();", "    let even_sum: isize = lst.iter().filter(|&n|\
    \ n % 2 == 0).sum();\n    let odd_sum: isize = lst.iter().filter(|&n| n % 2 !=\
    \ 0).sum();\n    let difference = odd_sum - even_sum;\n    difference * 2", '    unimplemented!()',
  "    let mut sum_odd_squares = 0;\n    for x in lst {\n        if is_odd(x) {\n\
    \            sum_odd_squares += x * x;\n        }\n    }\n    sum_odd_squares",
  "    // TODO: implement\n    let mut difference:isize = 0;\n    let mut sum_of_squares:isize\
    \ = 0;\n    let mut sum:isize = 0;\n    let mut total:isize = 0;\n    for i in\
    \ lst {\n        if i % 2 != 0 {\n            sum_of_squares += i * i;\n     \
    \   }\n        if i > 0 {\n            sum += i;\n        }\n    }\n    difference\
    \ = sum - sum_of_squares;\n    total = difference * 2;\n    return total;", " \
    \   // find the sum of the squares of odd numbers in the list\n    let mut sum\
    \ = 0;\n    for item in lst {\n        if item.is_positive() && item.is_odd()\
    \ {\n            sum += item.pow(2);\n        }\n    }\n\n    // double the result\n\
    \    sum * 2", '    unimplemented!();', '    0', '    lst.iter().fold(0, |acc,
    &x| acc + x.pow(2))', "    let mut temp: Vec<isize> = Vec::new();\n    for item\
    \ in lst {\n        if item > 0 && item % 2 == 1 {\n            temp.push(item\
    \ * item);\n        }\n    }\n    let mut sum = 0;\n    for item in temp {\n \
    \       sum += item;\n    }\n    sum"]
stop_tokens:
- "\n}"
