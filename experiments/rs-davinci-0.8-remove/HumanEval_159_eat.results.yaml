language: rs
name: HumanEval_159_eat
results:
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ remaining = if remaining < need {\n        0\n    } else {\n        remaining\
    \ - need\n    };\n    vec![number + need, remaining]\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[13, 0]`,\n right: `[7, 0]`', /tmp/tmp_l33nwqd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822566
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + remaining;\n    let mut eaten = number;\n    if total <\
    \ need {\n        eaten = total;\n        total = 0;\n    } else {\n        total\
    \ -= need;\n        eaten += need;\n    }\n    vec![eaten, total]\n}\n\nfn main()\
    \ {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 9]`,\n right: `[11, 4]`', /tmp/tmpd24itc71.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822566
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ remain = remaining - number;\n    if remain >= need {\n        vec![number +\
    \ need, remain - need]\n    } else {\n        vec![number + remain, 0]\n    }\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmprwjmqm95.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822566
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if number\
    \ + remaining < need {\n        vec![number + remaining, 0]\n    } else {\n  \
    \      vec![need, number + remaining - need]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp03raw6ir.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822566
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ eaten = number + if remaining >= need { need } else { remaining };\n    vec![eaten,\
    \ remaining - (eaten - number)]\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822566
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = 0;\n    let carrots = remaining + number;\n    if need >= carrots\
    \ {\n        eaten = carrots;\n    } else {\n        eaten = number + need;\n\
    \    }\n    vec![eaten, carrots - eaten]\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822566
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if number\
    \ < 0 || need < 0 || remaining < 0 {\n        vec![-1, -1]\n    } else if need\
    \ <= remaining {\n        vec![number + need, remaining - need]\n    } else {\n\
    \        vec![number + remaining, 0]\n    }\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822566
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if number\
    \ + remaining < need {\n        vec![number + remaining, 0]\n    } else {\n  \
    \      vec![need, number + remaining - need]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp03raw6ir.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822566
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ carrots_left: isize = if remaining < need {\n        0\n    } else {\n     \
    \   remaining - need\n    };\n    vec![number + need, carrots_left]\n}\n\nfn main()\
    \ {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[13, 0]`,\n right: `[7, 0]`', /tmp/tmpchwhi_ps.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822566
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ left = remaining - need;\n    if left < 0 {\n        vec![number + remaining,\
    \ 0]\n    } else {\n        vec![number + need, left]\n    }\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822566
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    vec![need\
    \ - std::cmp::min(need, remaining) + number, remaining - std::cmp::min(need, remaining)]\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 4]`,\n right: `[11, 4]`', /tmp/tmpiq5esaxr.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822566
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ sum = number + remaining;\n    if need <= sum {\n        return vec![need, sum\
    \ - need];\n    }\n    vec![sum, 0]\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmprupvgghg.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822566
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ carrots = number + remaining;\n    let eaten = if carrots > need { need } else\
    \ { carrots };\n    vec![eaten, carrots - eaten]\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpa5lahg7a.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822566
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut number = number;\n    let mut need = need;\n    let mut result = vec![];\n\
    \    if remaining > 0 {\n        need = need - remaining;\n        if need <=\
    \ 0 {\n            result.push(number + remaining);\n            result.push(0);\n\
    \        } else {\n            result.push(number + remaining);\n            result.push(need);\n\
    \        }\n    } else {\n        result.push(number);\n        result.push(need);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 0]`,\n right: `[11, 4]`', /tmp/tmpcitqlk90.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822566
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ value = (number + remaining).min(need);\n    let remaining = remaining - value\
    \ + number;\n    vec![value, remaining]\n}\n\nfn main() {\n    let candidate =\
    \ eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmplkpxh9nz.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822566
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut num: isize = number;\n    let mut rem: isize = remaining;\n    let mut need_eat:\
    \ isize = need;\n    let mut eaten: isize = 0;\n    let mut result: Vec<isize>\
    \ = Vec::new();\n\n    if num > 0 && num <= 1000 && need > 0 && need <= 1000 &&\
    \ remaining > 0 && remaining <= 1000 {\n        while num < need_eat {\n     \
    \       num += 1;\n            rem -= 1;\n            eaten += 1;\n          \
    \  if rem == 0 {\n                break;\n            }\n        }\n        if\
    \ rem == 0 {\n            result.push(num);\n            result.push(rem);\n \
    \       } else {\n            result.push(need_eat);\n            result.push(rem);\n\
    \        }\n    } else {\n        result.push(0);\n        result.push(0);\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpks9lsu8o.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822566
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut required = need;\n    let mut left = remaining;\n\
    \    if eaten + left < required {\n        eaten += left;\n        left = 0;\n\
    \    } else {\n        left = eaten + left - required;\n        eaten = required;\n\
    \    }\n    vec![eaten, left]\n}\n\nfn main() {\n    let candidate = eat;\n  \
    \  assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpvljfrir8.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822566
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total_carrots_eaten = number;\n    let mut remaining_carrots = remaining;\n\
    \    if need > remaining {\n        total_carrots_eaten += remaining;\n      \
    \  remaining_carrots = 0;\n    } else {\n        total_carrots_eaten += need;\n\
    \        remaining_carrots -= need;\n    }\n    vec![total_carrots_eaten, remaining_carrots]\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822566
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut answer = vec![number];\n    if remaining > need - number {\n        answer.push(remaining\
    \ - (need - number));\n    } else {\n        answer.push(0);\n    }\n    answer\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 9]`,\n right: `[11, 4]`', /tmp/tmpjlupn5uz.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822566
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ eaten = if number + remaining >= need {\n        need\n    } else {\n      \
    \  number + remaining\n    };\n    let remaining = if number + remaining >= need\
    \ {\n        0\n    } else {\n        need - (number + remaining)\n    };\n  \
    \  vec![eaten, remaining]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 0]`,\n right: `[11, 4]`', /tmp/tmpt13rb3uv.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822566
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut remaining = remaining;\n    let mut number = number;\n    for _ in 0..need\
    \ {\n        if remaining > 0 {\n            remaining -= 1;\n            number\
    \ += 1;\n        }\n    }\n    vec![number, remaining]\n}\n\nfn main() {\n   \
    \ let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n  \
    \  assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10,\
    \ 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822566
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut remains = remaining;\n    let eaten_now = if\
    \ need >= remains {\n        remains\n    } else {\n        need\n    };\n   \
    \ eaten += eaten_now;\n    remains -= eaten_now;\n    vec![eaten, remains]\n}\n\
    \nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822566
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + remaining;\n    if total >= need {\n        total = need;\n\
    \    }\n    let remaining = remaining - (need - number);\n    vec![total, remaining]\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp0fyloxkq.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822566
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = Vec::new();\n    let mut temp = number + remaining;\n    if need\
    \ >= temp {\n        result.push(temp);\n        result.push(0);\n    } else {\n\
    \        result.push(need);\n        result.push(temp - need);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp8sn3v_41.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822566
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![number, need];\n    let mut missing = 0;\n    if result[0]\
    \ < result[1] {\n        missing = result[1] - result[0];\n        if missing\
    \ <= remaining {\n            result[0] += missing;\n            result[1] -=\
    \ missing;\n        } else {\n            result[0] += remaining;\n          \
    \  result[1] -= remaining;\n        }\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 5]`,\n right: `[11, 4]`', /tmp/tmpdsfbdoli.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822567
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    // your\
    \ code here\n    if remaining >= number + need {\n        vec![number + need,\
    \ remaining - number - need]\n    } else {\n        vec![remaining, 0]\n    }\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmpdpme23t2.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822567
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if number\
    \ >= need {\n        return vec![number, 0];\n    }\n    if number + remaining\
    \ >= need {\n        return vec![need, number + remaining - need];\n    }\n  \
    \  vec![number + remaining, 0]\n}\n\nfn main() {\n    let candidate = eat;\n \
    \   assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpl3ozq_3d.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822567
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ number_after_eat = number + need;\n    let remaining_after_eat = if number_after_eat\
    \ >= remaining {\n        0\n    } else {\n        remaining - number_after_eat\n\
    \    };\n    vec![number_after_eat, remaining_after_eat]\n}\n\nfn main() {\n \
    \   let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 0]`,\n right: `[11, 4]`', /tmp/tmph2gzp9xh.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822567
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if need\
    \ == 0 {\n        return vec![number, remaining];\n    }\n\n    let remaining_after_eating\
    \ = remaining - need;\n    if remaining_after_eating < 0 {\n        return vec![number\
    \ + remaining, 0];\n    }\n\n    vec![number + need, remaining_after_eating]\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822567
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if number\
    \ + remaining >= need {\n        return vec![need, number + remaining - need];\n\
    \    }\n    vec![number + remaining, 0]\n}\n\nfn main() {\n    let candidate =\
    \ eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpyqh604rm.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822567
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ carrots_eaten = std::cmp::min(remaining, need);\n    let total_eaten = carrots_eaten\
    \ + number;\n    let carrots_left = remaining - carrots_eaten;\n    vec![total_eaten,\
    \ carrots_left]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822567
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ eaten = if need >= remaining { remaining } else { number + remaining - need\
    \ };\n    vec![eaten, remaining - eaten]\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[9, 1]`,\n right: `[11, 4]`', /tmp/tmpld_fe2nv.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822567
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ eaten = if need < remaining {\n        number + need\n    } else {\n       \
    \ number + remaining\n    };\n    let carrots_left = if need < remaining {\n \
    \       remaining - need\n    } else {\n        0\n    };\n    vec![eaten, carrots_left]\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822567
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut remaining = remaining;\n    while eaten < need\
    \ && remaining > 0 {\n        eaten += 1;\n        remaining -= 1;\n    }\n  \
    \  vec![eaten, remaining]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpdlomoq0z.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822567
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + remaining;\n    if total >= need {\n        total = need;\n\
    \    }\n    vec![total, total - need]\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 0]`,\n right: `[11, 4]`', /tmp/tmpq_fta07k.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822567
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut a = number + remaining;\n    if a >= need {\n        a = need;\n    }\n\
    \    vec![a, need - a]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 0]`,\n right: `[11, 4]`', /tmp/tmprrirdhg5.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822567
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if need\
    \ > remaining {\n        return vec![number + remaining, 0];\n    } else {\n \
    \       return vec![number + need, remaining - need];\n    }\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822567
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ (mut result, mut left) = (number, remaining);\n    if need > remaining {\n \
    \       result += remaining;\n        left = 0;\n    } else {\n        result\
    \ += need;\n        left -= need;\n    }\n    vec![result, left]\n}\n\nfn main()\
    \ {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822567
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if number\
    \ + remaining >= need {\n        vec![need, number + remaining - need]\n    }\
    \ else {\n        vec![number + remaining, 0]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpksqkivgp.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822567
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ eaten = if need > remaining { remaining } else { need };\n    vec![number +\
    \ eaten, remaining - eaten]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822567
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ total_need = number + need;\n    if total_need <= remaining {\n        vec![total_need,\
    \ remaining - total_need]\n    } else {\n        vec![remaining, 0]\n    }\n}\n\
    \nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmpmv03y0xz.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822567
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if need\
    \ > remaining {\n        vec![\n            number + remaining,\n            0,\n\
    \        ]\n    } else {\n        vec![\n            number + need,\n        \
    \    remaining - need,\n        ]\n    }\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822567
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut rem = remaining - need;\n    let mut num = number + need;\n    if rem <\
    \ 0 {\n        rem = 0;\n        num = number + remaining;\n    }\n    vec![num,\
    \ rem]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822567
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    if remaining <= eaten {\n        eaten += remaining;\n\
    \    } else {\n        eaten += need;\n    }\n    vec![eaten, remaining - need]\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[13, -6]`,\n right: `[7, 0]`', /tmp/tmpoj572cpz.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822567
- exit_code: 1
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    vec![\n\
    \        cmp::min(number + remaining, need),\n        cmp::max(remaining - (need\
    \ - number), 0),\n    ]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmpmxxk9o_0.rs:21:9\n   |\n21 |         cmp::min(number + remaining,\
    \ need),\n   |         ^^^ use of undeclared crate or module `cmp`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `cmp`\n  --> /tmp/tmpmxxk9o_0.rs:22:9\n\
    \   |\n22 |         cmp::max(remaining - (need - number), 0),\n   |         ^^^\
    \ use of undeclared crate or module `cmp`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659822566
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    // your\
    \ code here\n    let mut eaten = number;\n    let mut rem = remaining;\n    let\
    \ mut need = need;\n    while rem > 0 && need > 0 {\n        eaten += 1;\n   \
    \     rem -= 1;\n        need -= 1;\n    }\n    vec![eaten, rem]\n}\n\nfn main()\
    \ {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822567
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if number\
    \ + remaining >= need {\n        vec![need, number + remaining - need]\n    }\
    \ else {\n        vec![number + remaining, 0]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpksqkivgp.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822567
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = Vec::new();\n    let mut total = number + remaining;\n    let mut\
    \ left = need - total;\n    if total >= need {\n        result.push(need);\n \
    \       left = remaining - left;\n    } else {\n        result.push(total);\n\
    \    }\n    result.push(left);\n    result\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 19]`,\n right: `[11, 4]`', /tmp/tmpuslpyzjk.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822567
- exit_code: 1
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ eaten = cmp::min(number + remaining, need);\n    let left = cmp::max(remaining\
    \ - (need - number), 0);\n    vec![eaten, left]\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmpt6oif7hs.rs:20:17\n   |\n20 |     let eaten = cmp::min(number +\
    \ remaining, need);\n   |                 ^^^ use of undeclared crate or module\
    \ `cmp`\n\nerror[E0433]: failed to resolve: use of undeclared crate or module\
    \ `cmp`\n  --> /tmp/tmpt6oif7hs.rs:21:16\n   |\n21 |     let left = cmp::max(remaining\
    \ - (need - number), 0);\n   |                ^^^ use of undeclared crate or module\
    \ `cmp`\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659822567
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if need\
    \ <= number {\n        return vec![number, 0];\n    }\n    if remaining <= 0 {\n\
    \        return vec![number, need - number];\n    }\n    let eaten = number +\
    \ remaining;\n    if eaten >= need {\n        return vec![eaten, eaten - need];\n\
    \    }\n    vec![eaten, 0]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 9]`,\n right: `[11, 4]`', /tmp/tmpthawe1hi.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822567
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut n = number;\n    let mut r = remaining;\n    let mut vec = Vec::new();\n\
    \    if number >= need {\n        vec.push(number);\n        vec.push(remaining);\n\
    \    } else {\n        if remaining >= need {\n            n += need;\n      \
    \      r -= need;\n            vec.push(n);\n            vec.push(r);\n      \
    \  } else {\n            n += remaining;\n            r -= remaining;\n      \
    \      vec.push(n);\n            vec.push(r);\n        }\n    }\n    vec\n}\n\n\
    fn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822567
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ carrots_needed = number + need;\n    if carrots_needed <= remaining {\n    \
    \    return vec![carrots_needed, remaining - carrots_needed];\n    }\n    vec![remaining,\
    \ 0]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmp3dsp_n74.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822567
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if need\
    \ > remaining {\n        vec![remaining + number, 0]\n    } else {\n        vec![need\
    \ + number, remaining - need]\n    }\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822567
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let new_remaining = if remaining < need {\n       \
    \ eaten += remaining;\n        0\n    } else {\n        eaten += need;\n     \
    \   remaining - need\n    };\n    vec![eaten, new_remaining]\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822567
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if remaining\
    \ + number >= need {\n        vec![need, remaining + number - need]\n    } else\
    \ {\n        vec![remaining + number, 0]\n    }\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpdahrx3yp.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822567
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ eaten = if number + remaining < need {\n        number + remaining\n    } else\
    \ {\n        need\n    };\n    vec![eaten, remaining - (eaten - number)]\n}\n\n\
    fn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpibvj_6ya.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822567
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ eaten = if remaining < need {\n        remaining\n    } else {\n        need\n\
    \    };\n    let mut left = remaining - eaten;\n    if left < 0 {\n        left\
    \ = 0;\n    }\n    return vec![number + eaten, left];\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822567
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if number\
    \ + remaining >= need {\n        vec![need, (number + remaining) - need]\n   \
    \ } else {\n        vec![number + remaining, 0]\n    }\n}\n\nfn main() {\n   \
    \ let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n  \
    \  assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10,\
    \ 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpe1dczb4o.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822567
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ total = remaining + number;\n    if total > need {\n        vec![need, total\
    \ - need]\n    } else {\n        vec![total, 0]\n    }\n}\n\nfn main() {\n   \
    \ let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n  \
    \  assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10,\
    \ 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpvvchhyva.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822567
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eat = number;\n    if eat >= remaining {\n        return vec![eat, 0];\n\
    \    }\n    if eat + need >= remaining {\n        eat += remaining;\n        return\
    \ vec![eat, 0];\n    }\n    eat += need;\n    return vec![eat, remaining - eat];\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 0]`,\n right: `[11, 4]`', /tmp/tmp74y46qb2.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822567
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut remain = remaining - number;\n    let mut eaten = 0;\n    if remain >= need\
    \ {\n        eaten = need;\n        remain -= need;\n    } else {\n        eaten\
    \ = remain;\n        remain = 0;\n    }\n    vec![eaten, remain]\n}\n\nfn main()\
    \ {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 0]`,\n right: `[11, 4]`', /tmp/tmp5ebtso56.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822567
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ left = remaining - need;\n    if left >= 0 {\n        return vec![number + need,\
    \ left];\n    } else {\n        return vec![number + remaining, 0];\n    }\n}\n\
    \nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822567
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    vec![number+remaining.min(need),\
    \ (remaining-need).max(0)]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822567
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    let carrots = if need > remaining {\n        result.push(remaining\
    \ + number);\n        result.push(0);\n        0\n    } else {\n        need\n\
    \    };\n    result.push(carrots + number);\n    result.push(remaining - carrots);\n\
    \    result\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, 0, 2, 5]`,\n right: `[7, 0]`', /tmp/tmp9hwedchq.rs:38:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822567
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ n = number + remaining;\n    if n >= need {\n        vec![n - need, 0]\n   \
    \ } else {\n        vec![n, 0]\n    }\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[9, 0]`,\n right: `[11, 4]`', /tmp/tmpokk1x01k.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822567
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ eaten = if remaining >= need {\n        number + need\n    } else {\n      \
    \  number + remaining\n    };\n    vec![eaten, std::cmp::max(0, remaining - need)]\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822567
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut num = number + remaining;\n    let mut need = need - remaining;\n    if\
    \ num < need {\n        need = num;\n    }\n    vec![need, num - need]\n}\n\n\
    fn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-4, 19]`,\n right: `[11, 4]`', /tmp/tmpf9ocu560.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822567
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ x = number + need;\n    if x < remaining {\n        vec![x, remaining - x]\n\
    \    } else {\n        vec![remaining, 0]\n    }\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmpwqkub2mq.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822567
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    // complete\
    \ the function\n    let mut result: Vec<isize> = Vec::new();\n    if remaining\
    \ < need {\n        result.push(number + remaining);\n        result.push(0);\n\
    \    } else {\n        result.push(number + need);\n        result.push(remaining\
    \ - need);\n    }\n    result\n}\n\nfn main() {\n    let candidate = eat;\n  \
    \  assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822567
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![number, 0];\n    if remaining >= need {\n        result[0]\
    \ += need;\n        result[1] = remaining - need;\n    } else {\n        result[0]\
    \ += remaining;\n        result[1] = 0;\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822567
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if number\
    \ + remaining >= need {\n        return vec![need, remaining - (need - number)];\n\
    \    } else {\n        return vec![number + remaining, 0];\n    }\n}\n\nfn main()\
    \ {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpicanmc_v.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822567
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = Vec::new();\n    if remaining < need - number {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    } else {\n        result.push(number\
    \ + need);\n        result.push(remaining - need);\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[9, -4]`,\n right: `[5, 0]`', /tmp/tmpvx7nkxel.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822567
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + remaining;\n    let mut left = 0;\n    if total >= need\
    \ {\n        total = need;\n        left = total - need;\n    } else {\n     \
    \   left = 0;\n    }\n    vec![total, left]\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 0]`,\n right: `[11, 4]`', /tmp/tmp30ky9bjf.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822568
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if number\
    \ > remaining {\n        vec![remaining, 0]\n    } else if number + need > remaining\
    \ {\n        vec![remaining, 0]\n    } else {\n        vec![number + need, remaining\
    \ - number - need]\n    }\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmp3srbhy_x.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822568
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    vec![number\
    \ + (need.min(remaining)), remaining - (need.min(remaining))]\n}\n\nfn main()\
    \ {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822568
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![number];\n    if need <= remaining {\n        result.push(remaining\
    \ - need);\n    } else {\n        result.push(0);\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 4]`,\n right: `[11, 4]`', /tmp/tmptfwbdy_8.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822568
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ (mut number, mut need, mut remaining) = (number, need, remaining);\n    let\
    \ mut result = vec![];\n    if remaining <= need {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    } else {\n        result.push(number\
    \ + need);\n        result.push(remaining - need);\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822568
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    vec![\n\
    \        number + std::cmp::min(need, remaining),\n        remaining - std::cmp::min(need,\
    \ remaining),\n    ]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822568
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut res = Vec::new();\n    let mut num = 0;\n    let mut rem = 0;\n    let mut\
    \ eat_num = 0;\n    if remaining > number {\n        num = number;\n        eat_num\
    \ = need - number;\n        rem = remaining - eat_num;\n    } else {\n       \
    \ num = remaining;\n        eat_num = remaining - number;\n        rem = 0;\n\
    \    }\n    res.push(num);\n    res.push(rem);\n    res\n}\n\nfn main() {\n  \
    \  let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n \
    \   assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 9]`,\n right: `[11, 4]`', /tmp/tmp_s_4uqec.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822568
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ eaten = if number + remaining >= need {\n        need\n    } else {\n      \
    \  number + remaining\n    };\n    vec![eaten, remaining - (eaten - number)]\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpr6dm42xf.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822568
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ x = remaining - need;\n    if x < 0 {\n        return vec![number + remaining,\
    \ 0];\n    } else {\n        return vec![number + need, x];\n    }\n}\n\nfn main()\
    \ {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822568
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if number\
    \ + remaining >= need {\n        return vec![need, remaining - (need - number)];\n\
    \    }\n    vec![number + remaining, 0]\n}\n\nfn main() {\n    let candidate =\
    \ eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpxd4x4_pn.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822568
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    // your\
    \ code\n    let mut total = number + remaining;\n    let mut result = vec![];\n\
    \    if total >= need {\n        result.push(need);\n        result.push(total\
    \ - need);\n    } else {\n        result.push(total);\n        result.push(0);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp59y16r_5.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822568
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if number\
    \ + remaining < need {\n        vec![number + remaining, 0]\n    } else {\n  \
    \      vec![need, number + remaining - need]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp03raw6ir.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822566
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if remaining\
    \ >= need {\n        vec![number + need, remaining - need]\n    } else {\n   \
    \     vec![number + remaining, 0]\n    }\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822568
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if need\
    \ <= remaining {\n        vec![number + need, remaining - need]\n    } else {\n\
    \        vec![number + remaining, 0]\n    }\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822568
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut i = 0;\n    let mut r = remaining;\n    while i < need {\n        if r <=\
    \ 0 {\n            return vec![number + i, r];\n        }\n        r -= 1;\n \
    \       i += 1;\n    }\n    vec![number + i, r]\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822568
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ eaten = std::cmp::min(number + remaining, need);\n    vec![eaten, std::cmp::max(remaining\
    \ - (need - number), 0)]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp9vxvavgx.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822568
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut number = number;\n    let mut need = need;\n    let mut remaining = remaining;\n\
    \    if number >= need {\n        return vec![number, remaining];\n    }\n   \
    \ if remaining < need {\n        let tmp = remaining;\n        remaining = 0;\n\
    \        number += tmp;\n        need -= tmp;\n    } else {\n        let tmp =\
    \ need;\n        remaining -= tmp;\n        number += tmp;\n        need = 0;\n\
    \    }\n    return vec![number, remaining];\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822568
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut remaining = remaining;\n    let mut number = number;\n    for _ in 0..need\
    \ {\n        if remaining > 0 {\n            number += 1;\n            remaining\
    \ -= 1;\n        }\n    }\n    vec![number, remaining]\n}\n\nfn main() {\n   \
    \ let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n  \
    \  assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10,\
    \ 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822568
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    //get\
    \ the min between remaining carrots and need\n    let min = isize::min(remaining,\
    \ need);\n    //get the max between min and 0\n    let min = isize::max(min, 0);\n\
    \    //return the tuple (number + min, remaining - min)\n    vec![number + min,\
    \ remaining - min]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822568
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut leftover = 0;\n    if eaten + remaining >=\
    \ need {\n        eaten += need;\n        leftover = remaining - need;\n    }\
    \ else {\n        eaten += remaining;\n        leftover = 0;\n    }\n    vec![eaten,\
    \ leftover]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[9, -4]`,\n right: `[5, 0]`', /tmp/tmpm6ct6zf5.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822568
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if number\
    \ + remaining >= need {\n        vec![need, number + remaining - need]\n    }\
    \ else {\n        vec![number + remaining, 0]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpksqkivgp.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822567
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ eaten = if remaining > number + need {\n        number + need\n    } else {\n\
    \        remaining\n    };\n    let left = if remaining > number + need {\n  \
    \      remaining - (number + need)\n    } else {\n        0\n    };\n    vec![eaten,\
    \ left]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmp8o_ilm_t.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822568
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut n = number;\n    let mut remain = remaining;\n    let mut eaten = 0;\n \
    \   while n < need && remain > 0 {\n        eaten += 1;\n        n += 1;\n   \
    \     remain -= 1;\n    }\n    vec![n, remain]\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpkb3vc5jr.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822568
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut ate = Vec::new();\n    if number < 0 || need < 0 || remaining < 0 {\n  \
    \      ate.push(0);\n        ate.push(remaining);\n        return ate;\n    }\n\
    \    let left = remaining - need;\n    let mut res = 0;\n    if left < 0 {\n \
    \       res = remaining;\n    } else {\n        res = need;\n    }\n    ate.push(number\
    \ + res);\n    ate.push(remaining - res);\n    ate\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822568
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + remaining;\n    let left = if total >= need {\n       \
    \ total - need\n    } else {\n        total = need;\n        0\n    };\n    vec![total,\
    \ left]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 9]`,\n right: `[11, 4]`', /tmp/tmpfzd_5t4z.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822568
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if need\
    \ <= remaining {\n        vec![number + need, remaining - need]\n    } else {\n\
    \        vec![number + remaining, 0]\n    }\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822568
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ eaten = if remaining < need { remaining } else { need };\n    let left = if\
    \ remaining < need { 0 } else { remaining - need };\n    vec![number + eaten,\
    \ left]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822568
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![number, remaining];\n    if number + remaining < need {\n\
    \        result[0] += remaining;\n        result[1] = 0;\n    } else {\n     \
    \   result[0] += need;\n        result[1] -= need;\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[9, -4]`,\n right: `[5, 0]`', /tmp/tmpmo_xhyfw.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822568
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ left = (number + remaining).saturating_sub(need);\n    let eaten = (number +\
    \ remaining).saturating_sub(left);\n    vec![eaten, left]\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpr1c621eo.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822568
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut vec = Vec::new();\n    if number > 0 && need > 0 && remaining > 0 {\n  \
    \      if number + remaining >= need {\n            vec.push(need);\n        \
    \    vec.push(remaining - (need - number));\n        } else {\n            vec.push(number\
    \ + remaining);\n            vec.push(0);\n        }\n    }\n    vec\n}\n\nfn\
    \ main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpkhiy_hb_.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822568
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut result = vec![0, 0];\n    if remaining >= (number\
    \ + need) {\n        eaten += need;\n        result[0] = eaten;\n        result[1]\
    \ = remaining - eaten;\n    } else {\n        eaten += remaining;\n        result[0]\
    \ = eaten;\n        result[1] = 0;\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 0]`,\n right: `[11, 4]`', /tmp/tmp517ne3am.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822569
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten: isize = number;\n    let mut left: isize = remaining;\n    if need\
    \ + number <= remaining {\n        eaten += need;\n        left -= need;\n   \
    \ } else {\n        eaten += remaining;\n        left = 0;\n    }\n    return\
    \ vec![eaten, left];\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 0]`,\n right: `[11, 4]`', /tmp/tmpxqvsdnsq.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822569
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ result = number + remaining;\n    if result >= need {\n        vec![need, result\
    \ - need]\n    } else {\n        vec![result, 0]\n    }\n}\n\nfn main() {\n  \
    \  let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n \
    \   assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp_6yxgmsh.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822569
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = Vec::new();\n    if number + remaining > need {\n        result.push(need);\n\
    \        result.push(number + remaining - need);\n    } else {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpiee0tt5p.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822569
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ eaten = if number + remaining >= need {\n        need\n    } else {\n      \
    \  number + remaining\n    };\n    vec![eaten, remaining - (eaten - number)]\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpr6dm42xf.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822568
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if number\
    \ >= need {\n        return vec![number, 0];\n    }\n    if need - number > remaining\
    \ {\n        return vec![number + remaining, 0];\n    }\n    vec![number + need,\
    \ remaining - need]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[9, -4]`,\n right: `[5, 0]`', /tmp/tmprz957coa.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822569
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    // TODO:\
    \ find a more performant solution\n    let mut actual_need = need;\n    if need\
    \ <= remaining {\n        actual_need = need;\n    } else {\n        actual_need\
    \ = remaining;\n    }\n    let amount_eaten = number + actual_need;\n    let amount_left\
    \ = remaining - actual_need;\n    vec![amount_eaten, amount_left]\n}\n\nfn main()\
    \ {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822569
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![number];\n    result.push(remaining - need);\n    if remaining\
    \ > need {\n        result[0] += need;\n    } else {\n        result[0] += remaining;\n\
    \        result[1] = 0;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822569
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ eaten = if need > remaining { remaining } else { need };\n    vec![number +\
    \ eaten, remaining - eaten]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822567
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ total = number + std::cmp::min(need, remaining);\n    let left = std::cmp::max(0,\
    \ (remaining - need));\n    vec![total, left]\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822569
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut left = remaining;\n    for _ in 0..need {\n\
    \        if left > 0 {\n            eaten += 1;\n            left -= 1;\n    \
    \    }\n    }\n    vec![eaten, left]\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822569
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if remaining\
    \ > need {\n        return vec![number + need, remaining - need];\n    } else\
    \ {\n        return vec![number + remaining, 0];\n    }\n}\n\nfn main() {\n  \
    \  let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n \
    \   assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822569
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ eaten = if number + remaining >= need {\n        need\n    } else {\n      \
    \  number + remaining\n    };\n    vec![eaten, remaining - (eaten - number)]\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpr6dm42xf.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822568
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if need\
    \ == 0 {\n        return vec![number, remaining];\n    }\n    let mut new_number\
    \ = number;\n    let mut new_remaining = remaining;\n    if new_remaining > 0\
    \ {\n        new_number += 1;\n        new_remaining -= 1;\n    }\n    eat(new_number,\
    \ need - 1, new_remaining)\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822569
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ total = number + remaining;\n    let remaining = std::cmp::max(total - need,\
    \ 0);\n    vec![total - remaining, remaining]\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpxaifrq1k.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822569
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut x = 0;\n    let mut y = 0;\n    if need <= remaining {\n        x = number\
    \ + need;\n        y = remaining - need;\n    } else {\n        x = number + remaining;\n\
    \        y = 0;\n    }\n    vec![x, y]\n}\n\nfn main() {\n    let candidate =\
    \ eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822569
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut need = need;\n    let mut remaining = remaining;\n\
    \    while need > 0 && remaining > 0 {\n        eaten += 1;\n        need -= 1;\n\
    \        remaining -= 1;\n    }\n    vec![eaten, remaining]\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822569
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ total = number + need;\n    let remaining = if total > remaining {\n       \
    \ remaining\n    } else {\n        remaining - total\n    };\n    vec![total,\
    \ remaining]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 10]`,\n right: `[11, 4]`', /tmp/tmp13qno102.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822569
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + need;\n    if total > remaining {\n        total = remaining;\n\
    \    }\n    vec![total, remaining - total]\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmp79c1avwc.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822569
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = 0;\n    let mut remaining = remaining;\n    while eaten < need &&\
    \ remaining > 0 {\n        eaten += 1;\n        remaining -= 1;\n    }\n    if\
    \ eaten < need {\n        vec![eaten, 0]\n    } else {\n        vec![eaten, remaining]\n\
    \    }\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 4]`,\n right: `[11, 4]`', /tmp/tmpfxzqxh_s.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822569
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![number];\n    if need >= remaining {\n        result.push(remaining);\n\
    \        result.push(need - remaining);\n    } else {\n        result.push(need);\n\
    \        result.push(0);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 6, 0]`,\n right: `[11, 4]`', /tmp/tmp49sykhg5.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822569
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if need\
    \ >= remaining {\n        return vec![number + remaining, 0];\n    }\n    vec![number\
    \ + need, remaining - need]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822569
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    if remaining <= 0 {\n        return vec![eaten, 0];\n\
    \    }\n    if need <= 0 {\n        return vec![eaten, remaining];\n    }\n  \
    \  if remaining < need {\n        eaten += remaining;\n        return vec![eaten,\
    \ 0];\n    }\n    eaten += need;\n    return vec![eaten, remaining - need];\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822569
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ eaten = number + remaining;\n    let left = if eaten < need { 0 } else { eaten\
    \ - need };\n    vec![eaten, left]\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 9]`,\n right: `[11, 4]`', /tmp/tmprpcli_ed.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822569
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut carrots_eaten = number;\n    let mut carrots_remaining = remaining;\n  \
    \  while carrots_eaten < need && carrots_remaining > 0 {\n        carrots_eaten\
    \ += 1;\n        carrots_remaining -= 1;\n    }\n    vec![carrots_eaten, carrots_remaining]\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp168kxhmt.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822569
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = Vec::new();\n    let mut eaten = number;\n    let mut stock = remaining;\n\
    \    while eaten < need && stock > 0 {\n        eaten += 1;\n        stock -=\
    \ 1;\n    }\n    result.push(eaten);\n    result.push(stock);\n    result\n}\n\
    \nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpbqfcvjxk.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822569
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut left = remaining - need;\n    let mut new_number = number + need;\n    if\
    \ left < 0 {\n        new_number += left;\n        left = 0;\n    }\n    vec![new_number,\
    \ left]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822569
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut number = number + remaining;\n    let mut remaining = 0;\n    if number\
    \ >= need {\n        number -= need;\n        remaining = number;\n    }\n   \
    \ vec![need, remaining]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmptw7np6e5.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822569
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ result: Vec<isize> = if number + remaining >= need {\n        vec![need, number\
    \ + remaining - need]\n    } else {\n        vec![number + remaining, 0]\n   \
    \ };\n    result\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp2kl1bo4z.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822569
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ total = number + remaining;\n    if total > need {\n        vec![need, total\
    \ - need]\n    } else {\n        vec![total, 0]\n    }\n}\n\nfn main() {\n   \
    \ let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n  \
    \  assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10,\
    \ 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpksdn0o6p.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822569
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut number = number;\n    let mut need = need;\n    let mut remaining = remaining;\n\
    \    if number + remaining < need {\n        let temp = number + remaining;\n\
    \        number = temp;\n        need = need - temp;\n        remaining = 0;\n\
    \    } else {\n        number = number + need;\n        remaining = remaining\
    \ - need;\n        need = 0;\n    }\n    vec![number, need, remaining]\n}\n\n\
    fn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 0, 4]`,\n right: `[11, 4]`', /tmp/tmp3hwmmao4.rs:38:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822569
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut answer = vec![];\n    if remaining >= need {\n        answer.push(number\
    \ + need);\n        answer.push(remaining - need);\n    } else {\n        answer.push(number\
    \ + remaining);\n        answer.push(0);\n    }\n    answer\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822569
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if number\
    \ + remaining >= need {\n        vec![need, remaining - (need - number)]\n   \
    \ } else {\n        vec![number + remaining, 0]\n    }\n}\n\nfn main() {\n   \
    \ let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n  \
    \  assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10,\
    \ 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpc_ioxktx.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822569
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![number, remaining];\n    result[0] += std::cmp::min(need,\
    \ remaining);\n    result[1] -= std::cmp::min(need, remaining);\n    result\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822569
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ (x, y) = (number + remaining, need - remaining);\n    if y <= 0 {\n        vec![number\
    \ + remaining, 0]\n    } else {\n        vec![x, y]\n    }\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 0]`,\n right: `[11, 4]`', /tmp/tmpocultpvf.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822569
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = 0;\n    let mut carrots = remaining;\n    if number >= need {\n\
    \        return vec![number, remaining];\n    } else {\n        eaten = need -\
    \ number;\n        if eaten > carrots {\n            eaten = carrots;\n      \
    \      carrots = 0;\n        } else {\n            carrots -= eaten;\n       \
    \ }\n    }\n    vec![number + eaten, carrots]\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp4q_ffwxh.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822570
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if remaining\
    \ + number >= need {\n        vec![number + need, remaining + number - need]\n\
    \    } else {\n        vec![remaining + number, 0]\n    }\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 9]`,\n right: `[11, 4]`', /tmp/tmpiux0nlnv.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822570
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if remaining\
    \ < (need - number) {\n        vec![number + remaining, 0]\n    } else {\n   \
    \     vec![number + need, remaining - need]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[9, -4]`,\n right: `[5, 0]`', /tmp/tmpa2vwv6iv.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822570
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ total_carrots = number + remaining;\n    if need >= total_carrots {\n      \
    \  vec![total_carrots, 0]\n    } else {\n        vec![need, total_carrots - need]\n\
    \    }\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmps5u7gtzv.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822570
- exit_code: 1
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    vec![\n\
    \        number + (remaining > need).max(need),\n        (remaining - need).max(0),\n\
    \    ]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcai7lcyd.rs:21:41\n   |\n\
    21 |         number + (remaining > need).max(need),\n   |                    \
    \                     ^^^^ expected `bool`, found `isize`\n\nerror[E0277]: cannot\
    \ add `bool` to `isize`\n  --> /tmp/tmpcai7lcyd.rs:21:16\n   |\n21 |         number\
    \ + (remaining > need).max(need),\n   |                ^ no implementation for\
    \ `isize + bool`\n   |\n   = help: the trait `Add<bool>` is not implemented for\
    \ `isize`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822569
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ eaten = std::cmp::min(number + remaining, need);\n    let left = remaining -\
    \ (eaten - number);\n    vec![eaten, left]\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmplg3hxvml.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822570
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if number\
    \ >= need {\n        vec![number, remaining]\n    } else if remaining >= need\
    \ - number {\n        vec![need, remaining - (need - number)]\n    } else {\n\
    \        vec![remaining + number, 0]\n    }\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpv2q34mik.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822570
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ eaten = if remaining < number + need {\n        remaining\n    } else {\n  \
    \      number + need\n    };\n    let left = if remaining < number + need {\n\
    \        0\n    } else {\n        remaining - eaten\n    };\n    vec![eaten, left]\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmp1ru7p8as.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822570
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut num = number;\n    let need = need;\n    let mut remaining = remaining;\n\
    \    let mut eat: Vec<isize> = Vec::new();\n    if need > remaining {\n      \
    \  eat.push(num + remaining);\n        eat.push(0);\n    } else {\n        eat.push(num\
    \ + need);\n        eat.push(remaining - need);\n    }\n    eat\n}\n\nfn main()\
    \ {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822570
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten: Vec<isize> = Vec::new();\n    if remaining < need {\n        eaten.push(number\
    \ + remaining);\n        eaten.push(0);\n    } else {\n        eaten.push(number\
    \ + need);\n        eaten.push(remaining - need);\n    }\n    eaten\n}\n\nfn main()\
    \ {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822570
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut all_carrots = number + remaining;\n    let mut all_need = need;\n    if\
    \ all_carrots > all_need {\n        all_carrots -= all_need;\n        all_need\
    \ = 0;\n    } else {\n        all_need -= all_carrots;\n        all_carrots =\
    \ 0;\n    }\n    vec![all_need, all_carrots]\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 9]`,\n right: `[11, 4]`', /tmp/tmpag8qf85q.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822570
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut remaining = remaining;\n    let number = number + std::cmp::min(need, remaining);\n\
    \    remaining -= std::cmp::min(need, remaining);\n    vec![number, remaining]\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822570
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    let mut total = number + remaining;\n    if total\
    \ >= need {\n        result.push(need);\n        result.push(total - need);\n\
    \    } else {\n        result.push(total);\n        result.push(0);\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpkpjaqq_f.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822570
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut ans: Vec<isize> = Vec::new();\n    let mut rem: isize = remaining - number;\n\
    \    if need > rem {\n        ans.push(remaining);\n        ans.push(0);\n   \
    \ } else {\n        ans.push(number + need);\n        ans.push(rem);\n    }\n\
    \    ans\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmp0skd01k0.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822570
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if remaining\
    \ + number >= need {\n        vec![need, remaining + number - need]\n    } else\
    \ {\n        vec![remaining + number, 0]\n    }\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpdahrx3yp.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822567
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if need\
    \ >= remaining + number {\n        vec![remaining + number, 0]\n    } else {\n\
    \        vec![number + need, remaining - need]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822570
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if need\
    \ >= remaining {\n        return vec![number + remaining, 0];\n    }\n    vec![number\
    \ + need, remaining - need]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822569
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ eaten_carrots = if remaining >= number + need {\n        number + need\n   \
    \ } else {\n        remaining\n    };\n    let left_carrots = remaining - eaten_carrots;\n\
    \    vec![eaten_carrots, left_carrots]\n}\n\nfn main() {\n    let candidate =\
    \ eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmpi5_1tmnz.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822570
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = 0;\n    if number < need {\n        if remaining > 0 {\n       \
    \     if remaining >= need - number {\n                eaten = need - number;\n\
    \            } else {\n                eaten = remaining;\n            }\n   \
    \     }\n    }\n    vec![number + eaten, remaining - eaten]\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmppcpasjuh.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822570
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if number\
    \ + remaining >= need {\n        vec![need, number + remaining - need]\n    }\
    \ else {\n        vec![number + remaining, 0]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpksqkivgp.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822567
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ total = number + remaining;\n    if total >= need {\n        vec![need, total\
    \ - need]\n    } else {\n        vec![total, 0]\n    }\n}\n\nfn main() {\n   \
    \ let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n  \
    \  assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10,\
    \ 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpfrcekoly.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822570
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total_num = 0;\n    let mut remainder = 0;\n    if need < remaining {\n\
    \        total_num = number + need;\n        remainder = remaining - need;\n \
    \   } else {\n        total_num = number + remaining;\n        remainder = 0;\n\
    \    }\n    vec![total_num, remainder]\n}\n\nfn main() {\n    let candidate =\
    \ eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822570
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut need = need;\n    if remaining <= 0 {\n        return vec![number, -1];\n\
    \    }\n    if need > remaining {\n        need = remaining;\n    }\n    return\
    \ vec![number + need, remaining - need];\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822570
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if number\
    \ + remaining >= need {\n        vec![need, (number + remaining) - need]\n   \
    \ } else {\n        vec![number + remaining, 0]\n    }\n}\n\nfn main() {\n   \
    \ let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n  \
    \  assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10,\
    \ 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpe1dczb4o.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822567
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + remaining;\n    let mut rest = 0;\n    if total < need\
    \ {\n        total = total;\n        rest = 0;\n    } else {\n        total =\
    \ need;\n        rest = total - need;\n    }\n    vec![total, rest]\n}\n\nfn main()\
    \ {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 0]`,\n right: `[11, 4]`', /tmp/tmpit415r9o.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822570
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ total = number + remaining;\n    if total >= need {\n        vec![need, total\
    \ - need]\n    } else {\n        vec![total, 0]\n    }\n}\n\nfn main() {\n   \
    \ let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n  \
    \  assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10,\
    \ 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpfrcekoly.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822570
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if remaining\
    \ + number < need {\n        return vec![remaining + number, 0];\n    }\n    vec![need,\
    \ remaining + number - need]\n}\n\nfn main() {\n    let candidate = eat;\n   \
    \ assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8,\
    \ 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp6g3rr2ah.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822570
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if need\
    \ >= remaining {\n        vec![number + remaining, 0]\n    } else {\n        vec![number\
    \ + need, remaining - need]\n    }\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822570
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    let sum = number + remaining;\n    if sum < need {\n\
    \        result.push(sum);\n        result.push(0);\n    } else {\n        result.push(need);\n\
    \        result.push(sum - need);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpnhvizj3i.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822570
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    vec![\n\
    \        std::cmp::min(number + remaining, need),\n        std::cmp::max(0, need\
    \ - number - remaining),\n    ]\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 0]`,\n right: `[11, 4]`', /tmp/tmpd8lm049y.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822570
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut number: isize = number + (remaining - number - need).max(0);\n    vec![number,\
    \ remaining - number]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 5]`,\n right: `[11, 4]`', /tmp/tmp1c2mb5h7.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822570
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut first_arr = Vec::new();\n    let mut second_arr = Vec::new();\n    if need\
    \ > number && need < remaining {\n        first_arr.push(number + need);\n   \
    \     first_arr.push(remaining - need);\n    } else if need > number && need >\
    \ remaining {\n        second_arr.push(number + remaining);\n        second_arr.push(0);\n\
    \    } else {\n        first_arr.push(number);\n        first_arr.push(remaining);\n\
    \    }\n    first_arr\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 10]`,\n right: `[11, 0]`', /tmp/tmpyp2qu4v6.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822570
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = Vec::new();\n    if need <= remaining {\n        result.push(number\
    \ + need);\n        result.push(remaining - need);\n    } else {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822570
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut number = number;\n    let mut need = need;\n    let mut remaining = remaining;\n\
    \    if number + remaining < need {\n        let result = vec![number + remaining,\
    \ 0];\n        return result;\n    } else {\n        number += need;\n       \
    \ remaining -= need;\n        let result = vec![number, remaining];\n        return\
    \ result;\n    }\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[9, -4]`,\n right: `[5, 0]`', /tmp/tmpns5n440d.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822570
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ total = number + remaining;\n    let eaten = if need <= total { need } else\
    \ { total };\n    vec![eaten, total - eaten]\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpvm_jhygi.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822570
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ total_needed = number + need;\n    let carrots_eaten = if total_needed < remaining\
    \ {\n        total_needed\n    } else {\n        remaining\n    };\n    vec![carrots_eaten,\
    \ remaining - carrots_eaten]\n}\n\nfn main() {\n    let candidate = eat;\n   \
    \ assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8,\
    \ 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmpf9g85inl.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822570
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ carrots_consumed = if need <= remaining {\n        number + need\n    } else\
    \ {\n        number + remaining\n    };\n    let carrots_left = remaining - need;\n\
    \    vec![carrots_consumed, carrots_left]\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, -6]`,\n right: `[7, 0]`', /tmp/tmpbnncpz4b.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822570
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + remaining;\n    if total < need {\n        total = remaining;\n\
    \    } else {\n        total -= need;\n    }\n    vec![number + remaining - total,\
    \ total]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpgiupa9bu.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822570
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    vec![number\
    \ + std::cmp::min(need, remaining), std::cmp::max(0, remaining - need)]\n}\n\n\
    fn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822570
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = Vec::new();\n    let mut eaten = number;\n    if remaining <= need\
    \ {\n        eaten += remaining;\n        result.push(eaten);\n        result.push(0);\n\
    \    } else {\n        eaten += need;\n        result.push(eaten);\n        result.push(remaining\
    \ - need);\n    }\n    result\n}\n\nfn main() {\n    let candidate = eat;\n  \
    \  assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822570
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ eaten = remaining.min(number + need);\n    vec![eaten, remaining - eaten]\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmp0j08j655.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822570
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ eaten = if need > remaining {\n        remaining\n    } else {\n        remaining\
    \ - need\n    };\n    vec![number + eaten, need - eaten]\n}\n\nfn main() {\n \
    \   let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[9, 2]`,\n right: `[11, 4]`', /tmp/tmp_x0squ5u.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822571
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ eaten = number + remaining.min(need);\n    vec![eaten, remaining - need.min(remaining)]\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822571
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ (mut eaten, mut left) = (number, remaining);\n    if left < need {\n       \
    \ eaten += left;\n        left = 0;\n    } else {\n        eaten += need;\n  \
    \      left -= need;\n    }\n    vec![eaten, left]\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822571
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ eaten_carrots = match number + remaining >= need {\n        true => need,\n\
    \        false => number + remaining,\n    };\n    let left_carrots = match number\
    \ + remaining >= need {\n        true => remaining - (need - number),\n      \
    \  false => 0,\n    };\n    vec![eaten_carrots, left_carrots]\n}\n\nfn main()\
    \ {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp132a61rf.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822571
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut s = number;\n    let mut d = remaining;\n    for _ in 0..need {\n      \
    \  if d > 0 {\n            s += 1;\n            d -= 1;\n        }\n    }\n  \
    \  vec![s, d]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822571
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if remaining\
    \ + number >= need {\n        vec![number + need, remaining + number - need]\n\
    \    } else {\n        vec![remaining + number, 0]\n    }\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 9]`,\n right: `[11, 4]`', /tmp/tmpiux0nlnv.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822570
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut number = number;\n    let mut remaining = remaining;\n    while number <\
    \ need && remaining > 0 {\n        number += 1;\n        remaining -= 1;\n   \
    \ }\n    vec![number, remaining]\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpoaqg2pz6.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822571
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ (mut eaten, mut left) = (number, remaining);\n    if need > 0 {\n        if\
    \ left > 0 {\n            if need <= left {\n                eaten += need;\n\
    \                left -= need;\n            } else {\n                eaten +=\
    \ left;\n                left = 0;\n            }\n        }\n    }\n\n    vec![eaten,\
    \ left]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822571
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut left = remaining;\n    let mut hungry = false;\n\
    \    while eaten < need {\n        if left > 0 {\n            eaten += 1;\n  \
    \          left -= 1;\n        } else {\n            hungry = true;\n        \
    \    break;\n        }\n    }\n    vec![eaten, left, hungry as isize]\n}\n\nfn\
    \ main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9, 0]`,\n right: `[11, 4]`', /tmp/tmpnjpjjd01.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822571
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if remaining\
    \ >= need {\n        vec![number + need, remaining - need]\n    } else {\n   \
    \     vec![number + remaining, 0]\n    }\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822568
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut left = remaining;\n    if left <= need {\n\
    \        eaten += left;\n        left = 0;\n    } else {\n        eaten += need;\n\
    \        left -= need;\n    }\n    vec![eaten, left]\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822571
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ x = std::cmp::min(remaining, need - number);\n    let y = std::cmp::max(0, remaining\
    \ - (need - number));\n    vec![number + x, y]\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpkgtrt05x.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822571
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ total = number + remaining;\n    if need > total {\n        vec![total, 0]\n\
    \    } else {\n        vec![need, total - need]\n    }\n}\n\nfn main() {\n   \
    \ let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n  \
    \  assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10,\
    \ 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpaexb_8fw.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822571
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ m = number + need;\n    let n = m - remaining;\n    if n > 0 {\n        return\
    \ vec![m, 0];\n    } else {\n        return vec![m, n.abs()];\n    }\n}\n\nfn\
    \ main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 0]`,\n right: `[11, 4]`', /tmp/tmp51kfd24k.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822571
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ total = number + remaining;\n    if total >= need {\n        return vec![need,\
    \ total - need];\n    } else {\n        return vec![total, 0];\n    }\n}\n\nfn\
    \ main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpzyxhntja.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822571
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut number = number;\n    let mut remaining = remaining;\n    let mut need =\
    \ need;\n    let mut eaten = Vec::new();\n    while need > 0 {\n        if remaining\
    \ > 0 {\n            number += 1;\n            remaining -= 1;\n            need\
    \ -= 1;\n        } else {\n            need -= 1;\n        }\n    }\n    eaten.push(number);\n\
    \    eaten.push(remaining);\n    eaten\n}\n\nfn main() {\n    let candidate =\
    \ eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822571
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut not_eaten = remaining;\n    let mut hungry\
    \ = false;\n    if eaten + remaining < need {\n        eaten += remaining;\n \
    \       not_eaten = 0;\n        hungry = true;\n    } else {\n        eaten +=\
    \ need;\n        not_eaten -= need;\n    }\n    vec![eaten, not_eaten, hungry\
    \ as isize]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 4, 0]`,\n right: `[11, 4]`', /tmp/tmpvxsia2i9.rs:36:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822571
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut n = number;\n    let mut r = remaining;\n    if number + remaining < need\
    \ {\n        n += r;\n        r = 0;\n    } else {\n        n += need;\n     \
    \   r -= need;\n    }\n    vec![n, r]\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[9, -4]`,\n right: `[5, 0]`', /tmp/tmp6jdt5y70.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822571
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    if number\
    \ < 0 || need < 0 || remaining < 0 {\n        vec![0, 0]\n    } else {\n     \
    \   let mut total = number + remaining;\n        let mut eat = total - need;\n\
    \        if eat < 0 {\n            eat = 0;\n        }\n        total -= eat;\n\
    \        vec![eat, total]\n    }\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[9, 6]`,\n right: `[11, 4]`', /tmp/tmp332_8i6i.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822571
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut res = Vec::with_capacity(2);\n    if need < remaining {\n        res.push(number\
    \ + need);\n        res.push(remaining - need);\n    } else {\n        res.push(number\
    \ + remaining);\n        res.push(0);\n    }\n    res\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822571
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    return\
    \ vec![number + std::cmp::min(need, remaining), std::cmp::max(0, remaining - need)];\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822571
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// Variables:\n/// @number : integer\n/// the\
    \ number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ sum = number + remaining;\n    if sum >= need {\n        vec![need, sum - need]\n\
    \    } else {\n        vec![sum, 0]\n    }\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmphusy2qqp.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822571
