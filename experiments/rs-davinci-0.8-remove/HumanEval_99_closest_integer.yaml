name: HumanEval_99_closest_integer
language: rs
prompt: "/// Create a function that takes a value (string) representing a number\n\
  /// and returns the closest integer to it. If the number is equidistant\n/// from\
  \ two integers, round it away from zero.\n/// Examples\n/// Note:\n/// Rounding\
  \ away from zero means that if the given number is equidistant\n/// from two integers,\
  \ the one you should return is the one that is the\n/// farthest from zero. For\
  \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
  -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n"
tests: "}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
  10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
  -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
  0\")), 0);\n}\n"
completions: ["    if value.starts_with('-') {\n        let num: f64 = value.trim_start_matches('-').parse().unwrap();\n\
    \        return (-(num.round() as isize));\n    } else {\n        let num: f64\
    \ = value.parse().unwrap();\n        return (num.round() as isize);\n    }", " \
    \   let v: f64 = value.parse().unwrap();\n    if v.round() == v {\n        return\
    \ v as isize;\n    }\n\n    if v.fract() < 0.5 {\n        return v.floor() as\
    \ isize;\n    }\n\n    v.ceil() as isize", "    let v = value.parse::<f64>().unwrap();\n\
    \    if v.abs() - v.abs().floor() < 0.5 {\n        v.round() as isize\n    } else\
    \ {\n        (v.round() + 1f64) as isize\n    }", "    let float_val = value.parse::<f64>().unwrap();\n\
    \    float_val.round() as isize", "    let mut result = value.parse::<f64>().unwrap().round()\
    \ as isize;\n    result", "    let val: f64 = value.parse().unwrap();\n    if\
    \ val > 0.0 {\n        val.ceil() as isize\n    } else {\n        val.floor()\
    \ as isize\n    }", "    // Convert to number.\n    let number: f64 = value.parse().unwrap();\n\
    \n    // Get absolute value of number.\n    let abs_number = number.abs();\n\n\
    \    // Get integer part of number.\n    let integer_part = abs_number.floor();\n\
    \n    // Get decimal part of number.\n    let decimal_part = abs_number - integer_part;\n\
    \n    // Compare integer and decimal parts of number,\n    // return smallest\
    \ integer greater than the number.\n    if decimal_part < 0.5 {\n        number.floor()\
    \ as isize\n    } else {\n        number.ceil() as isize\n    }", '    value.parse::<f64>().unwrap().round()
    as isize', "    let mut value = value.parse::<f64>().unwrap();\n    if value >\
    \ 0.0 {\n        value.ceil() as isize\n    } else {\n        value.floor() as\
    \ isize\n    }", "    let split = value.split(\".\");\n    let split: Vec<&str>\
    \ = split.collect();\n    let val: f64 = value.parse().unwrap();\n    if val ==\
    \ 0.0 {\n        return 0;\n    }\n    if split.len() == 1 {\n        return val.round()\
    \ as isize;\n    }\n    let int_part = split[0].parse::<isize>().unwrap();\n \
    \   let dec_part = split[1].parse::<f64>().unwrap();\n    if dec_part == 0.0 {\n\
    \        return int_part;\n    }\n    let last_d = split[1].chars().last().unwrap().to_digit(10).unwrap();\n\
    \    if last_d < 5 {\n        return int_part;\n    }\n    if int_part > 0 {\n\
    \        return int_part + 1;\n    }\n    return int_part - 1;", "    let v: f64\
    \ = value.parse().unwrap();\n    if (v - v.floor()).abs() > (v - v.ceil()).abs()\
    \ {\n        v.ceil() as isize\n    } else {\n        v.floor() as isize\n   \
    \ }", "    let i = value.parse::<f64>().unwrap();\n    if i < 0.0 {\n        ((i\
    \ - 0.5).ceil()) as isize\n    } else {\n        ((i + 0.5).floor()) as isize\n\
    \    }", "    let num: f64 = value.parse().unwrap();\n    let num_int = num.trunc()\
    \ as isize;\n    let num_dec = num - num_int as f64;\n    if num_dec > 0.5 {\n\
    \        num_int + 1\n    } else if num_dec < -0.5 {\n        num_int - 1\n  \
    \  } else {\n        num_int\n    }", "    let n = value.parse::<f64>().unwrap();\n\
    \    n.round() as isize", "    let sign = if value.starts_with('-') { -1 } else\
    \ { 1 };\n    let value = value.trim_start_matches('-').parse::<f64>().unwrap();\n\
    \    if value == value.floor() {\n        return value as isize;\n    }\n    let\
    \ f = value.floor();\n    let c = value.ceil();\n    if (value - f).abs() <= (value\
    \ - c).abs() {\n        f as isize * sign\n    } else {\n        c as isize *\
    \ sign\n    }", "    let float_str = value.parse::<f64>().unwrap();\n    if (float_str\
    \ - float_str.floor()) > 0.5 {\n        return (float_str + 1.0).round() as isize;\n\
    \    }\n    if (float_str - float_str.floor()) < 0.5 {\n        return float_str.floor()\
    \ as isize;\n    }\n    if float_str < 0.0 {\n        return (float_str - 1.0).round()\
    \ as isize;\n    }\n    return float_str.round() as isize;", "    match value.parse::<f64>()\
    \ {\n        Ok(val) => {\n            if val.fract() >= 0.5 {\n             \
    \   val.ceil() as isize\n            } else {\n                val.floor() as\
    \ isize\n            }\n        }\n        Err(_) => 0,\n    }", "    let value\
    \ = value.parse::<f64>().unwrap();\n    let (a, b) = (value.floor(), value.ceil());\n\
    \    if (value - a).abs() < (value - b).abs() {\n        a as isize\n    } else\
    \ {\n        b as isize\n    }", "    let value: f64 = value.parse().unwrap();\n\
    \    let closest = value.round();\n    closest as isize", "    let mut num_float:\
    \ f64 = value.parse().unwrap();\n    if num_float.is_sign_negative() {\n     \
    \   num_float = num_float.abs();\n        -((num_float.ceil() - num_float).abs().min(num_float.floor()\
    \ - num_float).abs() as isize)\n    } else {\n        (num_float.ceil() - num_float).abs().min(num_float.floor()\
    \ - num_float).abs() as isize\n    }", "    let mut value: f64 = value.parse().unwrap();\n\
    \    if value.fract() == 0.5 {\n        value.floor() as isize + 1\n    } else\
    \ {\n        value.round() as isize\n    }", '    value.parse::<f64>().unwrap().round()
    as isize', "    let value: f64 = value.parse().unwrap();\n    if value > 0.0 {\n\
    \        value.ceil() as isize\n    } else {\n        value.floor() as isize\n\
    \    }", "    let float_value = value.parse::<f64>().unwrap();\n    let mut integer_value\
    \ = float_value.round() as isize;\n    if integer_value == 0 {\n        integer_value\
    \ = if float_value.signum() > 0.0 { 1 } else { -1 };\n    }\n    integer_value",
  "    let fvalue: f64 = value.parse().unwrap();\n    if fvalue < 0.0 {\n        (fvalue\
    \ - 0.5).ceil() as isize\n    } else {\n        (fvalue + 0.5).floor() as isize\n\
    \    }", "    let mut sign = 1;\n    let mut num = value.trim().replace(\" \"\
    , \"\");\n    if num.starts_with(\"-\") {\n        sign = -1;\n        num = num.trim_start_matches(\"\
    -\").to_string();\n    }\n    let mut pos = 0;\n    for (i, _) in num.chars().enumerate()\
    \ {\n        if num.chars().nth(i).unwrap() == '.' {\n            pos = i;\n \
    \           break;\n        }\n    }\n    let len = num.len();\n    let left =\
    \ if pos == 0 {\n        0\n    } else {\n        num[0..pos].parse::<isize>().unwrap()\n\
    \    };\n    let right = if pos == len - 1 {\n        0\n    } else {\n      \
    \  num[pos + 1..len].parse::<isize>().unwrap()\n    };\n    if right == 0 {\n\
    \        return left * sign;\n    }\n    let a = left * sign;\n    let b = (left\
    \ + 1) * sign;\n    if (b - num.parse::<isize>().unwrap()).abs() < (a - num.parse::<isize>().unwrap()).abs()\
    \ {\n        return b;\n    }\n    a", "    if value.len() > 0 {\n        let\
    \ num = value.parse::<f64>().unwrap();\n        (num + 0.5).trunc() as isize\n\
    \    } else {\n        0\n    }", "    let val = value.parse::<f64>().unwrap();\n\
    \    let round = val.round();\n    let ceil = val.ceil();\n    let floor = val.floor();\n\
    \    if (round - val).abs() < (ceil - val).abs() {\n        round as isize\n \
    \   } else if (round - val).abs() > (ceil - val).abs() {\n        ceil as isize\n\
    \    } else {\n        if round > 0.0 {\n            ceil as isize\n        }\
    \ else {\n            floor as isize\n        }\n    }", "    let value: f64 =\
    \ value.parse().unwrap();\n    let below = value.floor() as isize;\n    let above\
    \ = value.ceil() as isize;\n    if (value - below as f64).abs() < (value - above\
    \ as f64).abs() {\n        below\n    } else {\n        above\n    }", "    let\
    \ v = value.parse::<f64>().unwrap();\n    if v.fract() > 0.5 {\n        (v + 1.0).round()\
    \ as isize\n    } else {\n        v.round() as isize\n    }", "    let mut v:\
    \ f64 = value.parse().unwrap();\n    if v.abs() == (v.abs()).floor() {\n     \
    \   v as isize\n    } else {\n        let r: isize = (v + 0.5).round() as isize;\n\
    \        if r > 0 {\n            r - 1\n        } else {\n            r + 1\n\
    \        }\n    }", "    let number: f64 = value.parse().unwrap();\n    if number\
    \ >= 0.0 {\n        (number + 0.5).floor() as isize\n    } else {\n        (number\
    \ - 0.5).ceil() as isize\n    }", "    let digits: Vec<char> = value.chars().collect();\n\
    \    let mut f_point = digits.len();\n    for i in 0..digits.len() {\n       \
    \ if digits[i] == '.' {\n            f_point = i;\n            break;\n      \
    \  }\n    }\n    let d1: isize = value[..f_point].parse().unwrap();\n    let d2:\
    \ isize = value[f_point + 1..].parse().unwrap();\n    let r1 = isize::abs(value[..f_point].parse().unwrap());\n\
    \    let r2 = isize::abs(value[f_point + 1..].parse().unwrap());\n    let z1 =\
    \ value[..f_point].parse::<isize>().unwrap();\n    let z2 = value[f_point + 1..].parse::<isize>().unwrap();\n\
    \    let point = format!(\"{}.{}\", r1, r2);\n    let point_num: f64 = point.parse().unwrap();\n\
    \    if d1 > 0 && d2 > 0 {\n        if z1 > z2 {\n            if z1 - z2 == 0\
    \ {\n                return z1;\n            } else {\n                return\
    \ z1 + 1;\n            }\n        } else {\n            if z1 - z2 == 0 {\n  \
    \              return z1;\n            } else {\n                return z1;\n\
    \            }\n        }\n    } else if d1 < 0 && d2 < 0 {\n        if z1 > z2\
    \ {\n            if z1 - z2 == 0 {\n                return z1;\n            }\
    \ else {\n                return z1;\n            }\n        } else {\n      \
    \      if z1 - z2 == 0 {\n                return z1;\n            } else {\n \
    \               return z1 - 1;\n            }\n        }\n    } else if d1 < 0\
    \ && d2 > 0 {\n        if z1 > z2 {\n            if z1 - z2 == 0 {\n         \
    \       return z1;\n            } else {\n                return z1;\n       \
    \     }\n        } else {\n            if z1 - z2 == 0 {\n                return\
    \ z", "    let num: f64 = value.parse().unwrap();\n    return num.round() as isize;",
  "    let num = value.parse::<f64>().unwrap();\n    let c_int = num.round() as isize;\n\
    \    return c_int;", '    value.parse::<f64>().unwrap().round() as isize', " \
    \   let num = value.parse::<f64>().unwrap();\n    if num < 0.0 {\n        num.ceil()\
    \ as isize\n    } else {\n        num.floor() as isize\n    }", '    value.parse::<f64>().unwrap().round()
    as isize', "    // This can be implemented using the round function in the standard\n\
    \    // library. However, this is not possible to do in mbed, so\n    // we need\
    \ a more portable solution.\n    if value.contains(\".\") {\n        let mut list:\
    \ Vec<&str> = value.split(\".\").collect();\n        if let Some(x) = list.pop()\
    \ {\n            let last_digit = x.chars().next().unwrap_or('0');\n         \
    \   if last_digit >= '5' {\n                return (list.join(\".\").parse::<isize>().unwrap()\
    \ + 1);\n            }\n        }\n    }\n    value.parse::<isize>().unwrap()",
  "    let x = value.parse::<f64>().unwrap();\n    let n = x.trunc();\n    if x -\
    \ n == 0.5 {\n        if x > 0.0 {\n            return (n + 1.0) as isize;\n \
    \       } else {\n            return (n - 1.0) as isize;\n        }\n    }\n \
    \   if x - n > 0.5 {\n        return (n + 1.0) as isize;\n    }\n    n as isize",
  "    // Write your code here\n    let fvalue: f64 = value.parse().unwrap();\n  \
    \  if (fvalue - fvalue.floor()) < 0.5 {\n        fvalue.floor() as isize\n   \
    \ } else {\n        fvalue.ceil() as isize\n    }", "    let v: f64 = value.parse().unwrap();\n\
    \    return v.round() as isize;", "    let value = value.parse::<f64>().unwrap();\n\
    \    let left_int = value.floor() as isize;\n    let right_int = value.ceil()\
    \ as isize;\n    if value - left_int as f64 > right_int as f64 - value {\n   \
    \     right_int\n    } else {\n        left_int\n    }", "    let number: f64\
    \ = value.parse().unwrap();\n    if number > 0.0 {\n        (number + 0.5).floor()\
    \ as isize\n    } else {\n        (number - 0.5).ceil() as isize\n    }", "  \
    \  let mut result = value.parse::<f64>().unwrap();\n    if (result - result.floor())\
    \ > 0.5 {\n        result = result.ceil();\n    } else {\n        result = result.floor();\n\
    \    }\n    result as isize", "    let f: f64 = value.parse().unwrap();\n    if\
    \ f > 0.0 {\n        return (f + 0.5).floor() as isize;\n    }\n    return (f\
    \ - 0.5).ceil() as isize;", "    let value: f64 = value.parse().unwrap();\n  \
    \  let rounded_value = value.round();\n    if rounded_value == value {\n     \
    \   return rounded_value as isize;\n    }\n    if value.abs() - rounded_value.abs()\
    \ > 0.5 {\n        if value < 0.0 {\n            rounded_value.ceil() as isize\n\
    \        } else {\n            rounded_value.floor() as isize\n        }\n   \
    \ } else {\n        if value < 0.0 {\n            rounded_value.floor() as isize\n\
    \        } else {\n            rounded_value.ceil() as isize\n        }\n    }",
  "    let num: f64 = value.parse().unwrap();\n    num.round() as isize", '    value.parse::<f64>().unwrap().round()
    as isize', "    // let value: f64 = value.parse().unwrap();\n    // let mut int_value\
    \ = value.round() as isize;\n    // if int_value as f64 - value.abs() == 0.5 {\n\
    \    //     if int_value > 0 {\n    //         int_value -= 1;\n    //     } else\
    \ {\n    //         int_value += 1;\n    //     }\n    // }\n    // int_value\n\
    \    value.parse::<f64>().unwrap().round() as isize", '    value.parse::<f64>().unwrap().round()
    as isize', "    let float = value.parse::<f64>().unwrap();\n    float.round()\
    \ as isize", "    let num: f64 = value.parse().unwrap();\n    let int = num.round()\
    \ as isize;\n    let mut lower = int - 1;\n    let mut upper = int + 1;\n    if\
    \ abs(num) - int as f64 <= 0.5 {\n        if num < 0.0 {\n            return lower;\n\
    \        }\n        return int;\n    }\n    if num < 0.0 {\n        return upper;\n\
    \    }\n    return upper;", "    let input = value.parse::<f64>().unwrap();\n\
    \    let diff_abs = |x| (input - x).abs();\n    let mut closest_int = input.trunc();\n\
    \    if diff_abs(closest_int) > diff_abs(closest_int + 1.0) {\n        closest_int\
    \ += 1.0;\n    }\n    if input < 0.0 && diff_abs(closest_int) > diff_abs(closest_int\
    \ - 1.0) {\n        closest_int -= 1.0;\n    }\n    closest_int as isize", " \
    \   let num = value.parse::<f64>().unwrap();\n    let closest_number = num.round();\n\
    \    closest_number as isize", "    let n = value.parse::<f64>().unwrap();\n \
    \   if n > 0.0 {\n        n.ceil() as isize\n    } else {\n        n.floor() as\
    \ isize\n    }", '    value.parse::<f64>().unwrap().round() as isize', "    let\
    \ num: f64 = value.parse().unwrap();\n    let floor = num.floor();\n    let ceil\
    \ = num.ceil();\n    if num - floor > ceil - num {\n        ceil as isize\n  \
    \  } else {\n        floor as isize\n    }", "    let mut number: f64 = value.parse().unwrap();\n\
    \    if number >= 0.0 {\n        number.ceil() as isize\n    } else {\n      \
    \  number.floor() as isize\n    }", "    let num = value.parse::<f64>().unwrap();\n\
    \    if num > 0.0 {\n        num.ceil() as isize\n    } else {\n        num.floor()\
    \ as isize\n    }", '    value.parse::<f64>().unwrap().round() as isize', "  \
    \  // TODO: Implement the function\n    unimplemented!();", "    let x = value.parse::<f64>().unwrap();\n\
    \    if x < 0.0 {\n        (x - 0.5).ceil() as isize\n    } else {\n        (x\
    \ + 0.5).floor() as isize\n    }", "    let res = value.parse::<f64>().unwrap();\n\
    \    res.round() as isize", "    let mut v = value.parse::<f64>().unwrap();\n\
    \    if v > 0.0 {\n        v += 0.5;\n    } else {\n        v -= 0.5;\n    }\n\
    \    v as isize", "    let float = value.parse::<f64>().unwrap();\n    let positive\
    \ = (float * 10_f64.powi(15)).ceil() / 10_f64.powi(15);\n    let negative = (float\
    \ * 10_f64.powi(15)).floor() / 10_f64.powi(15);\n    let abs_pos = (float - positive).abs();\n\
    \    let abs_neg = (float - negative).abs();\n    if abs_pos == abs_neg {\n  \
    \      if positive > 0.0 {\n            positive as isize\n        } else {\n\
    \            negative as isize\n        }\n    } else if abs_pos < abs_neg {\n\
    \        positive as isize\n    } else {\n        negative as isize\n    }", " \
    \   let float_value = value.parse::<f64>().unwrap();\n    let integer_value =\
    \ float_value.round() as isize;\n    if float_value.abs() > integer_value.abs()\
    \ {\n        if float_value > 0.0 {\n            integer_value + 1\n        }\
    \ else {\n            integer_value - 1\n        }\n    } else {\n        integer_value\n\
    \    }", "    let value = value.parse::<f64>().unwrap();\n    (value + (value.signum()\
    \ * 0.5)) as isize", "    let float_val = value.parse::<f64>().unwrap();\n   \
    \ if float_val < 0.0 {\n        let val = float_val.ceil();\n        if val ==\
    \ float_val {\n            return val as isize - 1;\n        }\n        return\
    \ val as isize;\n    } else {\n        let val = float_val.floor();\n        if\
    \ val == float_val {\n            return val as isize + 1;\n        }\n      \
    \  return val as isize;\n    }", "    let float = value.parse::<f64>().unwrap();\n\
    \    float.round() as isize", '    value.parse::<f64>().unwrap().round() as isize',
  "    let num: f64 = value.parse().unwrap();\n    let num: isize = num.round() as\
    \ isize;\n    num", '    value.parse::<f64>().unwrap().round() as isize', "  \
    \  let parsed_value = value.parse::<f64>().unwrap();\n    return parsed_value.round()\
    \ as isize;", "    if let Ok(v) = value.parse::<f64>() {\n        let neg = v\
    \ < 0.0;\n        let mut v = v.abs();\n        let int = v.floor() as isize;\n\
    \        v -= int as f64;\n        if v == 0.5 {\n            if neg { int - 1\
    \ } else { int + 1 }\n        } else if v > 0.5 {\n            if neg { int -\
    \ 1 } else { int + 1 }\n        } else {\n            if neg { int } else { int\
    \ }\n        }\n    } else {\n        0\n    }", "    let num = value.parse::<f64>().unwrap();\n\
    \    if num >= 0.0 {\n        (num + 0.5).floor() as isize\n    } else {\n   \
    \     (num - 0.5).ceil() as isize\n    }", "    let value = value.parse::<f64>().unwrap();\n\
    \    if value.abs() - value.abs().floor() < 0.5 {\n        value.floor() as isize\n\
    \    } else {\n        value.ceil() as isize\n    }", "    let value: f64 = value.parse().unwrap();\n\
    \    if value < 0.0 {\n        return (value - 0.5).floor() as isize;\n    }\n\
    \    (value + 0.5).floor() as isize", "    let num: f64 = value.parse().unwrap();\n\
    \    num.round() as isize", "    let f: f64 = value.parse().unwrap();\n    let\
    \ rounded = f.round();\n    rounded as isize", "    let number: f64 = value.parse().unwrap();\n\
    \    if number.is_sign_positive() {\n        (number + 0.5).floor() as isize\n\
    \    } else {\n        (number - 0.5).ceil() as isize\n    }", "    let d_value:\
    \ f64 = value.parse().unwrap();\n    let res = d_value.round() as isize;\n   \
    \ res", "    // TODO: code here\n    value.parse::<f64>().unwrap().round() as\
    \ isize", "    let v = value.parse::<f64>().unwrap();\n    if v - v.floor() >\
    \ 0.5 {\n        v.ceil() as isize\n    } else {\n        v.floor() as isize\n\
    \    }", "    let number: f64 = value.parse().unwrap();\n    let above = (number\
    \ + 0.5).floor();\n    let below = (number - 0.5).ceil();\n    if above - number\
    \ < 0.5 {\n        above as isize\n    } else {\n        below as isize\n    }",
  "    let v = value.parse::<f64>().unwrap();\n    if v - v.floor() < 0.5 {\n    \
    \    v.floor() as isize\n    } else {\n        v.ceil() as isize\n    }", "  \
    \  let float = value.parse::<f64>().unwrap();\n    if float < 0.0 {\n        (float\
    \ - 0.5).ceil() as isize\n    } else {\n        (float + 0.5).floor() as isize\n\
    \    }", "    let val: f64 = value.parse().unwrap();\n    let val_integral = val.trunc();\n\
    \    let val_decimal = val - val_integral;\n    if val_decimal < 0.5 {\n     \
    \   val_integral as isize\n    } else {\n        (val_integral + 1.0) as isize\n\
    \    }", "    let mut curr_val: f64 = value.parse().unwrap();\n    let remainder\
    \ = curr_val % 1.0;\n    if remainder > 0.5 {\n        curr_val += 1.0;\n    }\
    \ else if remainder < -0.5 {\n        curr_val -= 1.0;\n    }\n    curr_val as\
    \ isize", "    let value: f64 = value.parse().unwrap();\n    if value.abs() -\
    \ value.round().abs() >= 0.5 {\n        value.ceil() as isize\n    } else {\n\
    \        value.floor() as isize\n    }", "    let parsed = value.parse::<f64>().unwrap();\n\
    \    if parsed.fract() < 0.5 {\n        parsed.floor() as isize\n    } else {\n\
    \        parsed.ceil() as isize\n    }", "    let value: f64 = value.parse().unwrap();\n\
    \    let rounded = value.round();\n    if rounded >= 0.0 {\n        rounded as\
    \ isize\n    } else {\n        rounded.ceil() as isize\n    }", "    let value:\
    \ f64 = value.parse().unwrap();\n    (value + 0.5).trunc() as isize", "    let\
    \ num: f64 = value.parse().unwrap();\n    let n = num.round() as isize;\n    n",
  "    let f: f64 = value.parse().unwrap();\n    let n = f.round() as isize;\n   \
    \ if n >= 0 {\n        n\n    } else {\n        n - 1\n    }", "    let num =\
    \ value.parse::<f64>().unwrap();\n    if num > 0.0 {\n        num.ceil() as isize\n\
    \    } else {\n        num.floor() as isize\n    }", "    let val: f64 = value.parse().unwrap();\n\
    \    if val >= 0.0 {\n        (val + 0.5).floor() as isize\n    } else {\n   \
    \     (val - 0.5).ceil() as isize\n    }", "    let mut num = value.parse::<f64>().unwrap();\n\
    \    num = if num < 0.0 {\n        num - 0.5\n    } else {\n        num + 0.5\n\
    \    };\n    num as isize", '    value.parse::<f64>().unwrap().round() as isize',
  "    let value: f64 = value.parse().unwrap();\n    if value >= 0.0 {\n        return\
    \ value.ceil() as isize;\n    }\n    return value.floor() as isize;", "    let\
    \ v: f64 = value.parse().unwrap();\n    let (below, above) = (v.floor(), v.ceil());\n\
    \    let t = v - below;\n    if t <= 0.5 {\n        below as isize\n    } else\
    \ {\n        above as isize\n    }", "    match value.parse::<f64>() {\n     \
    \   Ok(n) => (n + 0.5).floor() as isize,\n        Err(_) => 0\n    }", "    let\
    \ num: f64 = value.parse().unwrap();\n    if num.fract() >= 0.5 {\n        return\
    \ (num + 1.0).round() as isize;\n    } else {\n        return num.round() as isize;\n\
    \    }", "    let v: f64 = value.parse().unwrap();\n    if v >= 0.0 {\n      \
    \  (v + 0.5).floor() as isize\n    } else {\n        (v - 0.5).ceil() as isize\n\
    \    }", "    let value = value.parse::<f64>().unwrap();\n    if value - value.floor()\
    \ < 0.5 {\n        value.floor() as isize\n    } else {\n        value.ceil()\
    \ as isize\n    }", "    let value: f64 = value.parse().unwrap();\n    let nearest\
    \ = value.round();\n    nearest as isize", "    let i_value = value.parse::<f64>().unwrap();\n\
    \    if (i_value.fract() - 0.5).abs() < f64::EPSILON {\n        if i_value > 0.0\
    \ {\n            (i_value + 1.0).ceil() as isize\n        } else {\n         \
    \   (i_value - 1.0).floor() as isize\n        }\n    } else {\n        i_value.round()\
    \ as isize\n    }", "    let float_value = value.parse::<f64>().unwrap();\n  \
    \  float_value.round() as isize", "    let float_value = value.parse::<f64>().unwrap();\n\
    \    float_value.round() as isize", "    let mut num = value.parse::<f64>().unwrap();\n\
    \    if num.is_sign_negative() {\n        num = num.abs();\n        num.round()\
    \ as isize * -1\n    } else {\n        num.round() as isize\n    }", "    // TODO\n\
    \    unimplemented!()", "    let float = value.parse::<f64>().unwrap();\n    if\
    \ float.fract() < 0.5 {\n        float.floor() as isize\n    } else {\n      \
    \  float.ceil() as isize\n    }", "    let number: f64 = value.parse().unwrap();\n\
    \    (number + 0.5).trunc() as isize", "    let number: f64 = value.parse().unwrap();\n\
    \    if number.fract() < 0.5 {\n        number.floor() as isize\n    } else {\n\
    \        number.ceil() as isize\n    }", "    let value = value.parse::<f64>().unwrap();\n\
    \    if value > 0.0 {\n        value.ceil() as isize\n    } else {\n        value.floor()\
    \ as isize\n    }", "    let val = value.parse::<f64>().unwrap();\n    if val\
    \ >= 0.0 {\n        return val.ceil() as isize;\n    } else {\n        return\
    \ val.floor() as isize;\n    }", "    let value: f64 = value.parse().unwrap();\n\
    \    if value.fract() > 0.5 {\n        value.ceil() as isize\n    } else {\n \
    \       value.floor() as isize\n    }", "    let float_value = value.parse::<f64>().unwrap();\n\
    \    float_value.round() as isize", "    let num = value.parse::<f64>().unwrap();\n\
    \    let floor = num.floor();\n    let ceil = num.ceil();\n    if num - floor\
    \ < ceil - num {\n        floor as isize\n    } else {\n        ceil as isize\n\
    \    }", "    let num: f64 = value.parse().unwrap();\n    let diff: f64 = (num.fract()\
    \ * 10.0).round() / 10.0;\n    if num.is_sign_positive() {\n        (num + diff).round()\
    \ as isize\n    } else {\n        (num - diff).round() as isize\n    }", "   \
    \ let value: f64 = value.parse().unwrap();\n    if value.fract() < 0.5 {\n   \
    \     value.floor() as isize\n    } else {\n        value.ceil() as isize\n  \
    \  }", "    let parsed = value.parse::<f64>().unwrap();\n    if parsed.trunc()\
    \ == parsed {\n        return parsed as isize;\n    }\n    if parsed < 0.0 {\n\
    \        return (parsed.ceil()) as isize;\n    }\n    return (parsed.floor())\
    \ as isize;", "    let value: f64 = value.parse().unwrap();\n    value.round()\
    \ as isize", "    let num: f64 = value.parse().unwrap();\n    let l = num.floor()\
    \ as isize;\n    let r = num.ceil() as isize;\n    if r - num as isize == num\
    \ as isize - l {\n        if l < 0 {\n            l\n        } else {\n      \
    \      r\n        }\n    } else if r - num as isize < num as isize - l {\n   \
    \     r\n    } else {\n        l\n    }", "    let value: f64 = value.parse().unwrap();\n\
    \    value.round() as isize", "    let number: f64 = value.parse().unwrap();\n\
    \    let floor: isize = number.floor() as isize;\n    let ceil: isize = number.ceil()\
    \ as isize;\n    let floor_val: f64 = (number - floor as f64).abs();\n    let\
    \ ceil_val: f64 = (number - ceil as f64).abs();\n    if floor_val < ceil_val {\n\
    \        floor\n    } else {\n        ceil\n    }", "    let num = match value.parse::<f64>()\
    \ {\n        Ok(num) => num,\n        Err(_) => 0_f64,\n    };\n    let ipart\
    \ = num.floor();\n    let fpart = num.fract();\n    if fpart >= 0.5 {\n      \
    \  (ipart + 1.0) as isize\n    } else {\n        ipart as isize\n    }", "   \
    \ let val = value.parse::<f64>().unwrap();\n    if val > 0.0 {\n        return\
    \ val.ceil() as isize;\n    }\n    val.floor() as isize", '    value.parse::<f64>().map(|x|
    x.round() as isize).unwrap()', "    let val: f64 = value.parse().unwrap();\n \
    \   if val > val.floor() {\n        return val.ceil() as isize;\n    } else {\n\
    \        return val.floor() as isize;\n    }", "    let number: f64 = value.parse().unwrap();\n\
    \    number.round() as isize", "    match value.parse::<f64>() {\n        Ok(v)\
    \ => {\n            let r: f64 = v.round();\n            if r > v {\n        \
    \        r as isize - 1\n            } else {\n                r as isize\n  \
    \          }\n        }\n        Err(_) => 0,\n    }", "    let mut my_int: isize\
    \ = value.parse().unwrap();\n    let my_float: f64 = value.parse().unwrap();\n\
    \    if my_float.round() > my_float {\n        my_int += 1;\n    }\n    my_int",
  "    let f: f64 = value.parse().unwrap();\n    let int = f.round() as isize;\n \
    \   if int.abs() < f.abs() {\n        int.signum()\n    } else {\n        int\n\
    \    }", '    value.parse::<f64>().unwrap().round() as isize', '    value.parse::<f64>().unwrap().round()
    as isize', "    let value: f64 = value.parse().unwrap();\n    if value - value.floor()\
    \ < 0.5 {\n        value.floor() as isize\n    } else {\n        value.ceil()\
    \ as isize\n    }", "    let num: f64 = value.parse().unwrap();\n    if num <\
    \ 0.0 {\n        return (num - 0.5).floor() as isize;\n    }\n    (num + 0.5).floor()\
    \ as isize", "    let f: f64 = value.parse().unwrap();\n    if f < 0.0 {\n   \
    \     return (f - 0.5).floor() as isize;\n    }\n    (f + 0.5).floor() as isize",
  '    value.parse::<f64>().unwrap().round() as isize', "    let val = value.parse::<f64>().unwrap();\n\
    \    if val > val.floor() {\n        val.ceil() as isize\n    } else {\n     \
    \   val.floor() as isize\n    }", '    value.parse::<f64>().unwrap().round() as
    isize', "    let number: f64 = value.parse().unwrap();\n    let int_num = number.round()\
    \ as isize;\n    let abs_num = (number.abs() - int_num as f64).abs();\n    if\
    \ abs_num == 0.5 && number.is_sign_positive() {\n        int_num + 1\n    } else\
    \ if abs_num == 0.5 && number.is_sign_negative() {\n        int_num - 1\n    }\
    \ else {\n        int_num\n    }", "    let f: f64 = value.parse().unwrap();\n\
    \    if f > 0.0 {\n        (f + 0.5).floor() as isize\n    } else {\n        (f\
    \ - 0.5).ceil() as isize\n    }", "    if value.contains('.') {\n        let mut\
    \ v = value.replace(\".\", \"\");\n        if v.chars().nth(0).unwrap() == '-'\
    \ {\n            let mut number = v.replace(\"-\", \"\").parse::<f64>().unwrap();\n\
    \            number += 0.5;\n            return (-1 as isize) * number as isize;\n\
    \        } else {\n            let mut number = v.parse::<f64>().unwrap();\n \
    \           number += 0.5;\n            return number as isize;\n        }\n \
    \   } else {\n        let mut number = value.parse::<f64>().unwrap();\n      \
    \  number += 0.5;\n        return number as isize;\n    }", "    let n: f64 =\
    \ value.parse().unwrap();\n    if n - n.floor() >= 0.5 {\n        n.ceil() as\
    \ isize\n    } else {\n        n.floor() as isize\n    }", "    let v: f64 = value.parse().unwrap();\n\
    \    let rounded = v.round();\n    if rounded < v {\n        rounded as isize\
    \ + 1\n    } else {\n        rounded as isize\n    }", "    let float_value =\
    \ value.parse::<f64>().unwrap();\n    float_value.round() as isize", "    if value.starts_with('-')\
    \ {\n        let num = value.replace(\"-\", \"\").parse::<f64>().unwrap();\n \
    \       (num - 0.5).floor() as isize * -1\n    } else {\n        let num = value.parse::<f64>().unwrap();\n\
    \        (num + 0.5).floor() as isize\n    }", '    value.parse::<f64>().unwrap().round()
    as isize', "    let number: f64 = value.parse().unwrap();\n    if number.fract()\
    \ >= 0.5 {\n        (number + 1.0).trunc() as isize\n    } else {\n        number.trunc()\
    \ as isize\n    }", '    value.parse::<f64>().unwrap().round() as isize', "  \
    \  let val: f64 = value.parse().unwrap();\n    let sign = val.signum();\n    let\
    \ mut val = val.abs().round();\n    if val.floor() == val.ceil() {\n        return\
    \ (val.ceil() * sign as f64) as isize;\n    } else {\n        val = val.ceil();\n\
    \        if val.floor() < val.ceil() {\n            return (val.ceil() * sign\
    \ as f64) as isize;\n        } else {\n            return (val.floor() * sign\
    \ as f64) as isize;\n        }\n    }", "    let value: f64 = value.parse().unwrap();\n\
    \    (value + 0.5).trunc() as isize", '    value.parse::<f64>().unwrap().round()
    as isize', "    let f_value: f64 = value.parse().unwrap();\n    let mut delta:\
    \ f64 = f_value.abs();\n    let mut closest: isize = 0;\n    for i in -10..10\
    \ {\n        let new_delta = (f_value - i as f64).abs();\n        if new_delta\
    \ < delta {\n            delta = new_delta;\n            closest = i;\n      \
    \  }\n    }\n    return closest;", "    let number: f64 = value.parse().unwrap();\n\
    \    let rounded_number = number.round();\n    rounded_number as isize", "   \
    \ let dec_val = value.parse::<f64>().unwrap();\n    let dec_floor = dec_val.floor();\n\
    \    let dec_ceil = dec_val.ceil();\n    let floor_abs = dec_floor.abs();\n  \
    \  let ceil_abs = dec_ceil.abs();\n    match dec_val.partial_cmp(&0.0).unwrap()\
    \ {\n        Ordering::Equal => 0,\n        Ordering::Less => if floor_abs <=\
    \ ceil_abs { dec_floor } else { dec_ceil },\n        Ordering::Greater => if floor_abs\
    \ < ceil_abs { dec_ceil } else { dec_floor },\n    }", "    let mut v: f64 = value.parse().unwrap();\n\
    \    if v < 0.0 {\n        v = v - 0.5;\n    } else {\n        v = v + 0.5;\n\
    \    }\n    v as isize", "    let num = value.parse::<f64>().unwrap();\n    if\
    \ num > 0.0 {\n        return (num + 0.5).floor() as isize;\n    } else {\n  \
    \      return (num - 0.5).ceil() as isize;\n    }", '    value.parse::<f64>().unwrap().round()
    as isize', "    let value = value.parse::<f64>().unwrap();\n    if value.abs()\
    \ == (value.floor() + 0.5) {\n        if value < 0.0 {\n            return value.ceil()\
    \ as isize;\n        }\n        return value.floor() as isize;\n    }\n    return\
    \ value.round() as isize;", "    let mut result = value.parse::<f64>().unwrap();\n\
    \    if result < 0.0 {\n        result -= 0.5;\n    } else {\n        result +=\
    \ 0.5;\n    }\n    result as isize", "    let dec = value.parse::<f64>().unwrap();\n\
    \    if dec >= 0.0 {\n        (dec + 0.5).floor() as isize\n    } else {\n   \
    \     (dec - 0.5).ceil() as isize\n    }", "    let float_value = value.parse::<f64>().unwrap();\n\
    \    let closest_integer = float_value.round() as isize;\n    closest_integer",
  "    let value = value.parse::<f64>().unwrap();\n    if value < 0.0 {\n        value.ceil()\
    \ as isize\n    } else {\n        value.floor() as isize\n    }", "    let num:\
    \ f64 = value.parse().unwrap();\n    if num.fract() >= 0.5 {\n        return (num\
    \ + 1.0).round() as isize;\n    }\n    num.round() as isize", "    let float =\
    \ value.parse::<f64>().unwrap();\n    let integer = float.round() as isize;\n\
    \    if float == float.floor() {\n        integer - 1\n    } else {\n        integer\n\
    \    }", "    let mut result = value.parse::<f64>().unwrap().round() as isize;\n\
    \    if result == 0 && value.parse::<f64>().unwrap() < 0.0 {\n        result =\
    \ -1;\n    }\n    result", "    let val = value.parse::<f64>().unwrap();\n   \
    \ let v = val.round() as isize;\n    if val >= 0.0 {\n        v\n    } else {\n\
    \        v - 1\n    }", '    value.parse::<f64>().unwrap().round() as isize',
  "    // the logic here is simple. The number that is closest to 0 is the first number\n\
    \    // that is not 0. If this value is less than the number from the method value.parse::<f64>()\n\
    \    // then return the value on the left, otherwise return the value on the right\n\
    \n    let value: f64 = value.parse().unwrap();\n    let number = value.abs().round()\
    \ as isize;\n    let left = number - 1;\n    let right = number + 1;\n\n    if\
    \ value.abs() > value.round() as f64 {\n        if value > 0.0 {\n           \
    \ right\n        } else {\n            left\n        }\n    } else {\n       \
    \ if value > 0.0 {\n            number\n        } else {\n            -number\n\
    \        }\n    }", "    let num = value.parse::<f64>().unwrap();\n    let mut\
    \ lower_num = num;\n    while (lower_num - num).abs() > 0.000001 {\n        lower_num\
    \ -= 0.000001;\n    }\n    lower_num as isize", '    value.parse::<f64>().unwrap().round()
    as isize', "    let value: f64 = value.parse().unwrap();\n    value.round() as\
    \ isize", '    value.parse::<f64>().unwrap().round() as isize', "    let num =\
    \ value.parse::<f64>().unwrap();\n    let num_is_integer = num.fract() == 0.0;\n\
    \    if num_is_integer {\n        return num as isize;\n    }\n\n    let lower_bound\
    \ = num.trunc();\n    let upper_bound = lower_bound + 1.0;\n    let diff_from_lower\
    \ = (num - lower_bound).abs();\n    let diff_from_upper = (num - upper_bound).abs();\n\
    \n    if diff_from_lower < diff_from_upper {\n        return lower_bound as isize;\n\
    \    }\n\n    upper_bound as isize", "    let value = value.parse::<f64>().unwrap();\n\
    \    if value.fract() >= 0.5 {\n        (value + 0.5).floor() as isize\n    }\
    \ else {\n        (value - 0.5).ceil() as isize\n    }", "    let val = value.parse::<f64>().unwrap();\n\
    \    return val.round() as isize;", "    let v = value.parse::<f64>().unwrap();\n\
    \    if v > 0.0 {\n        return v.ceil() as isize;\n    }\n    v.floor() as\
    \ isize", "    let a = value.parse::<f64>().unwrap();\n    let b = a.round();\n\
    \    let c = b.to_string().parse::<isize>().unwrap();\n    c", "    let number:\
    \ f64 = value.parse().unwrap();\n    let round_up = number - (number % 1.0) +\
    \ 1.0;\n    let round_down = number - (number % 1.0);\n    if number - round_down\
    \ < round_up - number {\n        round_down as isize\n    } else {\n        round_up\
    \ as isize\n    }", '    value.parse::<f64>().unwrap().round() as isize', "  \
    \  // TODO: replace this line with your code\n    unimplemented!();", "    let\
    \ (integral, fractional) = value.split_at(value.find('.').unwrap_or(value.len()));\n\
    \    match fractional.get(1..2) {\n        Some(value) => {\n            let integral\
    \ = integral.parse::<isize>().unwrap();\n            let fractional = value.parse::<isize>().unwrap();\n\
    \            if fractional >= 5 {\n                integral + 1\n            }\
    \ else {\n                integral\n            }\n        }\n        None =>\
    \ integral.parse::<isize>().unwrap(),\n    }", "    match value.parse::<f64>()\
    \ {\n        Ok(f) => f.round() as isize,\n        Err(_) => 0,\n    }", "   \
    \ let parsed = value.parse::<f64>().unwrap();\n    let rounded = parsed.round();\n\
    \    rounded as isize", '    value.parse::<f64>().unwrap().round() as isize',
  "    let parsed_value = value.parse::<f64>().unwrap();\n    let integer_value =\
    \ parsed_value.round() as isize;\n    return integer_value;", "    let rounded\
    \ = value.parse::<f64>().unwrap().round();\n    rounded as isize", "    let float\
    \ = value.parse::<f64>().unwrap();\n    (float.trunc() + if float < 0.0 {\n  \
    \      -0.5\n    } else {\n        0.5\n    }).round() as isize", '    value.parse::<f64>().map(|v|
    v.round() as isize).unwrap()', "    let parsed_value = value.parse::<f64>().unwrap();\n\
    \    let rounded_value = parsed_value.round();\n    rounded_value as isize", " \
    \   // Cannot use String::parse_float() directly, it panics on\n    // invalid\
    \ input.\n    let flt = match FromStr::from_str(value.as_slice()) {\n        Some(f)\
    \ => f,\n        None => return 0,\n    };\n    if flt >= 0.0 {\n        flt.ceil()\
    \ as isize\n    } else {\n        flt.floor() as isize\n    }", "    let mut n:\
    \ isize = value.parse().unwrap();\n    if n >= 0.0 {\n        if n - n.floor()\
    \ < 0.5 {\n            n = n.floor();\n        } else {\n            n = n.ceil();\n\
    \        }\n    } else {\n        if n.floor() - n < 0.5 {\n            n = n.floor();\n\
    \        } else {\n            n = n.ceil();\n        }\n    }\n    n", "    let\
    \ real_number: f64 = value.parse().unwrap();\n    let int_number: isize = real_number.trunc()\
    \ as isize;\n    if real_number - real_number.trunc() < 0.5 {\n        int_number\n\
    \    } else {\n        int_number + 1\n    }", "    let num = value.parse::<f64>().unwrap();\n\
    \    let num_up = num.ceil();\n    let num_down = num.floor();\n    let abs_up\
    \ = num_up.abs();\n    let abs_down = num_down.abs();\n    if abs_up - num.abs()\
    \ <= num.abs() - abs_down {\n        num_up as isize\n    } else {\n        num_down\
    \ as isize\n    }", "    let parsed = value.parse::<f64>().unwrap();\n    parsed.round()\
    \ as isize", "    // let mut s = value.chars();\n    // let l: usize = s.by_ref().filter(|&c|\
    \ c == '.').count();\n    // match l {\n    //     0 => value.parse::<isize>().unwrap(),\n\
    \    //     1 => {\n    //         let left: Vec<char> = s.collect();\n    //\
    \         let mut right: Vec<char> = s.by_ref().skip(1).collect();\n    //   \
    \      if left[0] == '-' {\n    //             right.reverse();\n    //      \
    \       for r in right {\n    //                 if r == '0' {\n    //       \
    \              right.pop();\n    //                 } else {\n    //         \
    \            break;\n    //                 }\n    //             }\n    //  \
    \           if right.len() == 0 {\n    //                 left[1..].iter().collect::<String>().parse::<isize>().unwrap()\n\
    \    //             } else {\n    //                 let mut c = left[1..].iter().collect::<String>();\n\
    \    //                 c.push_str(&(right.iter().collect::<String>()));\n   \
    \ //                 c.parse::<isize>().unwrap()\n    //             }\n    //\
    \         } else {\n    //             for r in right {\n    //              \
    \   if r == '0' {\n    //                     right.pop();\n    //           \
    \      } else {\n    //                     break;\n    //                 }\n\
    \    //             }\n    //             if right.len() == 0 {\n    //      \
    \           left.iter().collect::<String>().parse::<isize>().unwrap()\n    //\
    \             } else {\n    //                 let mut c = left.iter().collect::<String>();\n\
    \    //                 c.push_str(&(right.iter().collect::<String>()));\n   \
    \ //                 c.parse::<isize>().unwrap()\n    //             }\n    //\
    \         }\n    //     }\n    //     _ => 0,\n    // }\n    if value.contains('.')\
    \ {\n        let mut s = value.chars();\n        let left: Vec<char> = s.", " \
    \   let value = value.parse::<f64>().unwrap();\n    if value >= 0.0 {\n      \
    \  value.ceil() as isize\n    } else {\n        value.floor() as isize\n    }"]
stop_tokens:
- "\n}"
