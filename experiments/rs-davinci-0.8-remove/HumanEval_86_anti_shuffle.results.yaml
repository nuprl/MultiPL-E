language: rs
name: HumanEval_86_anti_shuffle
results:
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut words: Vec<String> = Vec::new();\n    let mut\
    \ buffer = String::new();\n    for c in s.chars() {\n        if c == ' ' {\n \
    \           words.push(buffer);\n            buffer = String::new();\n       \
    \ } else {\n            buffer.push(c);\n        }\n    }\n    words.push(buffer);\n\
    \    for i in 0..words.len() {\n        let mut chars: Vec<char> = words[i].chars().collect();\n\
    \        chars.sort();\n        words[i] = chars.into_iter().collect();\n    }\n\
    \    words.join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut words: Vec<String> = s.split_whitespace().map(|s|\
    \ s.to_string()).collect();\n    for i in 0..words.len() {\n        let mut chars:\
    \ Vec<char> = words[i].chars().collect();\n        chars.sort();\n        words[i]\
    \ = chars.into_iter().collect();\n    }\n    words.join(\" \")\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut it = s.split_whitespace();\n    let first =\
    \ it.next().unwrap();\n    let mut ans = first.to_string();\n    for word in it\
    \ {\n        ans.push(' ');\n        ans.push_str(word);\n    }\n    ans\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hello\"`,\n right: `\"ehllo\"`', /tmp/tmpo7maqp84.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut v: Vec<String> = s.split_whitespace().map(|s|\
    \ s.to_string()).collect();\n    for word in &mut v {\n        let mut chars:\
    \ Vec<char> = word.chars().collect();\n        chars.sort();\n        *word =\
    \ chars.into_iter().collect();\n    }\n    v.join(\" \")\n}\n\nfn main() {\n \
    \   let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut res = String::new();\n    let mut curr = String::new();\n\
    \    for c in s.chars() {\n        if c != ' ' {\n            curr.push(c);\n\
    \        } else {\n            res.push_str(&anti_shuffle_word(curr));\n     \
    \       res.push(' ');\n            curr = String::new();\n        }\n    }\n\
    \    res.push_str(&anti_shuffle_word(curr));\n    res\n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `anti_shuffle_word` in this scope\n\
    \  --> /tmp/tmpzfod8j1d.rs:14:27\n   |\n14 |             res.push_str(&anti_shuffle_word(curr));\n\
    \   |                           ^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find function `anti_shuffle_word` in this scope\n  --> /tmp/tmpzfod8j1d.rs:19:19\n\
    \   |\n19 |     res.push_str(&anti_shuffle_word(curr));\n   |                \
    \   ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823240
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let v: Vec<&str> = s.split(\" \").collect();\n    v.iter().map(|&x|\
    \ -> String {\n        let mut a: Vec<char> = x.chars().collect();\n        a.sort();\n\
    \        a.into_iter().collect()\n    }).collect::<Vec<String>>().join(\" \")\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut new_string = String::new();\n    let mut word\
    \ = String::new();\n    for c in s.chars() {\n        if c == ' ' {\n        \
    \    let mut chars: Vec<char> = word.chars().collect();\n            chars.sort();\n\
    \            for c in chars {\n                new_string.push(c);\n         \
    \   }\n            new_string.push(' ');\n            word = String::new();\n\
    \        } else {\n            word.push(c);\n        }\n    }\n    let mut chars:\
    \ Vec<char> = word.chars().collect();\n    chars.sort();\n    for c in chars {\n\
    \        new_string.push(c);\n    }\n    new_string\n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut chars = s.chars().collect::<Vec<char>>();\n\
    \    let mut c = 0;\n    for i in 0..chars.len() {\n        if chars[i] == ' '\
    \ {\n            let mut chars_chunk = chars[c..i].clone();\n            chars_chunk.sort();\n\
    \            for j in 0..chars_chunk.len() {\n                chars[c + j] = chars_chunk[j];\n\
    \            }\n            c = i + 1;\n        }\n    }\n    chars.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `clone` found for slice `[char]` in the current\
    \ scope\n  --> /tmp/tmpmgg3zf1c.rs:12:47\n   |\n12 |             let mut chars_chunk\
    \ = chars[c..i].clone();\n   |                                               ^^^^^\
    \ method not found in `[char]`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    // Split the string into words, then sort\n    let\
    \ words: Vec<String> = s.split_whitespace().map(|word| {\n        let mut chars:\
    \ Vec<char> = word.chars().collect();\n        chars.sort();\n        chars.into_iter().collect()\n\
    \    }).collect();\n\n    // Rejoin the string\n    words.join(\" \")\n}\n\nfn\
    \ main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut words: Vec<String> = s.split_whitespace().map(|s|\
    \ s.to_string()).collect();\n    for word in words.iter_mut() {\n        let mut\
    \ chars: Vec<char> = word.chars().collect();\n        chars.sort();\n        *word\
    \ = chars.into_iter().collect();\n    }\n    return words.join(\" \");\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpy_3u_j4j.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823241
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmppx3ge1jq.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut chars = s.split_whitespace().map(|word| {\n\
    \        let mut chars: Vec<char> = word.chars().collect();\n        chars.sort();\n\
    \        chars\n    });\n    let mut out = String::new();\n    for chars in chars\
    \ {\n        let mut word = String::new();\n        for c in chars {\n       \
    \     word.push(c);\n        }\n        out.push_str(&word);\n        out.push('\
    \ ');\n    }\n    out.pop();\n    out\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut words: Vec<String> = s.split(\" \").map(|w|\
    \ w.to_string()).collect();\n    for mut word in &mut words {\n        let mut\
    \ chars: Vec<char> = word.chars().collect();\n        chars.sort();\n        word.clear();\n\
    \        for c in chars {\n            word.push(c);\n        }\n    }\n    words.join(\"\
    \ \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpy_3u_j4j.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    s.split_whitespace()\n        .map(|w| {\n        \
    \    let mut chars: Vec<char> = w.chars().collect();\n            chars.sort();\n\
    \            chars.into_iter().collect()\n        })\n        .collect::<Vec<String>>()\n\
    \        .join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n \
    \   assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    s.split_whitespace()\n        .map(|v| {\n        \
    \    let mut chars: Vec<char> = v.chars().collect();\n            chars.sort();\n\
    \            chars.into_iter().collect::<String>()\n        })\n        .collect::<Vec<String>>()\n\
    \        .join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n \
    \   assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    s.split_whitespace()\n        .map(|w| -> String {\n\
    \            let mut c: Vec<char> = w.chars().collect();\n            c.sort();\n\
    \            c.into_iter().collect()\n        })\n        .collect::<Vec<String>>()\n\
    \        .join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n \
    \   assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    s.split_whitespace()\n        .map(|word| {\n     \
    \       let mut chars: Vec<char> = word.chars().collect();\n            chars.sort();\n\
    \            chars.into_iter().collect()\n        })\n        .collect::<Vec<String>>()\n\
    \        .join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n \
    \   assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut words: Vec<String> = s.split_whitespace().map(|s|\
    \ s.to_string()).collect();\n    for word in words.iter_mut() {\n        word.push('\
    \ ');\n        let mut chars: Vec<char> = word.chars().collect();\n        chars.sort();\n\
    \        *word = chars.into_iter().collect::<String>();\n    }\n    words.join(\"\
    \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\" Hi\"`,\n right: `\"Hi\"`', /tmp/tmpzr1z0ied.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823241
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    s.split(' ')\n        .map(|word| word.chars().collect::<Vec<char>>())\n\
    \        .map(|chars| {\n            chars.sort_by(|a, b| a.cmp(b));\n       \
    \     chars.into_iter().collect::<String>()\n        })\n        .collect::<Vec<String>>()\n\
    \        .join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n \
    \   assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `chars` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmper870ww6.rs:11:13\n   |\n10 |         .map(|chars| {\n\
    \   |               ----- help: consider changing this to be mutable: `mut chars`\n\
    11 |             chars.sort_by(|a, b| a.cmp(b));\n   |             ^^^^^ cannot\
    \ borrow as mutable\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659823241
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut prev = ' ';\n    let mut new_str = String::new();\n\
    \    let mut temp_str = String::new();\n    for c in s.chars() {\n        if prev\
    \ == ' ' && c != ' ' {\n            new_str.push_str(&temp_str);\n           \
    \ temp_str = String::new();\n        }\n        if c == ' ' {\n            new_str.push(c);\n\
    \        } else {\n            temp_str.push(c);\n        }\n        prev = c;\n\
    \    }\n    new_str.push_str(&temp_str);\n    return new_str;\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hello\"`,\n right: `\"ehllo\"`', /tmp/tmp9nfycmha.rs:30:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    s.split_whitespace()\n        .map(|word| {\n     \
    \       let mut chars: Vec<char> = word.chars().collect();\n            chars.sort();\n\
    \            chars.into_iter().collect()\n        })\n        .collect::<Vec<String>>()\n\
    \        .join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n \
    \   assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut new_sentence = String::new();\n    let mut\
    \ words = s.split_whitespace();\n    while let Some(word) = words.next() {\n \
    \       let mut chars: Vec<char> = word.chars().collect();\n        chars.sort();\n\
    \        for c in chars {\n            new_sentence.push(c);\n        }\n    \
    \    new_sentence.push(' ');\n    }\n    new_sentence.pop();\n    new_sentence\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut words: Vec<&str> = s.split_whitespace().collect();\n\
    \    let mut s: String = String::new();\n    for word in words.iter_mut() {\n\
    \        *word = sort_characters(*word);\n    }\n    s.push_str(words.join(\"\
    \ \").as_str());\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sort_characters` in this scope\n  -->\
    \ /tmp/tmpsy6i2wf9.rs:11:17\n   |\n11 |         *word = sort_characters(*word);\n\
    \   |                 ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    s.split(' ')\n        .map(|word| {\n            let\
    \ mut chars: Vec<char> = word.chars().collect();\n            chars.sort();\n\
    \            chars.into_iter().collect()\n        })\n        .collect::<Vec<String>>()\n\
    \        .join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n \
    \   assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    s.split_whitespace()\n        .map(|word| {\n     \
    \       let mut chars: Vec<char> = word.chars().collect();\n            chars.sort();\n\
    \            chars.into_iter().collect()\n        })\n        .collect::<Vec<String>>()\n\
    \        .join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n \
    \   assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmppx3ge1jq.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut new_string = String::new();\n    let mut prev_char\
    \ = ' ';\n    for c in s.chars() {\n        match c {\n            ' ' => {\n\
    \                if prev_char != ' ' {\n                    new_string.push(c);\n\
    \                }\n            }\n            _ => {\n                new_string.push(c);\n\
    \            }\n        }\n        prev_char = c;\n    }\n    let mut result =\
    \ String::new();\n    let mut words: Vec<String> = Vec::new();\n    for word in\
    \ new_string.split(' ') {\n        let mut word_chars: Vec<char> = word.chars().collect();\n\
    \        word_chars.sort();\n        words.push(word_chars.into_iter().collect());\n\
    \    }\n    for word in words {\n        result.push_str(&word);\n        result.push('\
    \ ');\n    }\n    result.pop();\n    result\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut words: Vec<String> = s.split_whitespace().map(String::from).collect();\n\
    \    words.iter_mut().for_each(|s| s.make_ascii_lowercase());\n    words.iter_mut().for_each(|s|\
    \ s.sort_by(|a, b| a.cmp(b)));\n    let mut result = String::new();\n    for word\
    \ in words {\n        result.push_str(&word);\n        result.push(' ');\n   \
    \ }\n    result.pop();\n    result\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for mutable reference `&mut\
    \ String` in the current scope\n  --> /tmp/tmp3reggy3l.rs:10:37\n   |\n10 |  \
    \   words.iter_mut().for_each(|s| s.sort_by(|a, b| a.cmp(b)));\n   |         \
    \                            ^^^^^^^ method not found in `&mut String`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659823241
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut words: Vec<String> = s.split_whitespace().map(|w|\
    \ w.to_string()).collect();\n    words.sort_by(|a, b| a.chars().next().unwrap().cmp(&b.chars().next().unwrap()));\n\
    \    let mut result = String::new();\n    for word in words {\n        result\
    \ += &word + \" \";\n    }\n    result.trim().to_string()\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot add `&str` to `&String`\n  --> /tmp/tmpgvj9qorb.rs:12:25\n\
    \   |\n12 |         result += &word + \" \";\n   |                   ----- ^ ---\
    \ &str\n   |                   |     |\n   |                   |     `+` cannot\
    \ be used to concatenate two `&str` strings\n   |                   &String\n\
    \   |\nhelp: String concatenation appends the string on the right to the string\
    \ on the left and may require reallocation. This requires ownership of the string\
    \ on the left\n   |\n12 |         result += word + \" \";\n   |              \
    \     ~~~~\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659823241
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmppx3ge1jq.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    // println!(\"{}\", s);\n    let mut res: Vec<String>\
    \ = vec![];\n    for i in s.split_whitespace() {\n        let mut temp = i.chars().collect::<Vec<char>>();\n\
    \        temp.sort();\n        res.push(temp.into_iter().collect::<String>());\n\
    \    }\n    return res.join(\" \");\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823242
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    return s.chars().collect::<Vec<char>>().iter().map(|c|\
    \ *c).collect::<String>();\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hello\"`,\n right: `\"ehllo\"`', /tmp/tmpxmoqu7lg.rs:14:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823242
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut vec: Vec<String> = s.split(\" \").map(|x| String::from(x)).collect();\n\
    \    vec.iter_mut().for_each(|x| {\n        let mut chars: Vec<char> = x.chars().collect();\n\
    \        chars.sort();\n        *x = chars.into_iter().collect();\n    });\n \
    \   vec.join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n   \
    \ assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823242
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut res = Vec::new();\n    for word in s.split_whitespace()\
    \ {\n        let mut sorted_word = String::new();\n        for c in word.chars().collect::<Vec<char>>().iter().sorted()\
    \ {\n            sorted_word.push(*c);\n        }\n        res.push(sorted_word);\n\
    \    }\n    res.join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sorted` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmp20_f1_jc.rs:11:61\n   |\n11 |         for\
    \ c in word.chars().collect::<Vec<char>>().iter().sorted() {\n   |           \
    \                                                  ^^^^^^ method not found in\
    \ `std::slice::Iter<'_, char>`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659823242
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    s.split_whitespace()\n        .map(|s| {\n        \
    \    let mut chars: Vec<char> = s.chars().collect();\n            chars.sort();\n\
    \            chars.into_iter().collect()\n        })\n        .collect::<Vec<String>>()\n\
    \        .join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n \
    \   assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823242
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut sorted_words\
    \ = vec![];\n    for mut word in s.split_whitespace() {\n        word = word.chars().sorted().collect::<String>().as_str();\n\
    \        sorted_words.push(word);\n    }\n    result = sorted_words.join(\" \"\
    );\n    result\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sorted` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmpmsa3lrhz.rs:11:29\n   |\n11 |         word = word.chars().sorted().collect::<String>().as_str();\n\
    \   |                             ^^^^^^ method not found in `Chars<'_>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659823242
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmppx3ge1jq.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823241
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    s.split_whitespace()\n        .map(|w| {\n        \
    \    let mut bytes = w.bytes().collect::<Vec<_>>();\n            bytes.sort();\n\
    \            unsafe { std::str::from_utf8_unchecked(&bytes) }\n        })\n  \
    \      .collect::<Vec<_>>()\n        .join(\" \")\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0515]: cannot return value referencing local variable `bytes`\n\
    \  --> /tmp/tmp5jr25gts.rs:12:22\n   |\n12 |             unsafe { std::str::from_utf8_unchecked(&bytes)\
    \ }\n   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^------^\n   |   \
    \                   |                             |\n   |                    \
    \  |                             `bytes` is borrowed here\n   |              \
    \        returns a value referencing data owned by the current function\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0515`.\n"
  stdout: ''
  timestamp: 1659823241
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut tmp =\
    \ String::new();\n    for letter in s.chars() {\n        if letter != ' ' {\n\
    \            tmp.push(letter);\n        } else {\n            result.push_str(&sort_string(tmp.clone()));\n\
    \            result.push(letter);\n            tmp.clear();\n        }\n    }\n\
    \    result.push_str(&sort_string(tmp.clone()));\n    result\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sort_string` in this scope\n  --> /tmp/tmpj5yk5euh.rs:14:30\n\
    \   |\n14 |             result.push_str(&sort_string(tmp.clone()));\n   |    \
    \                          ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `sort_string` in this scope\n  --> /tmp/tmpj5yk5euh.rs:19:22\n\
    \   |\n19 |     result.push_str(&sort_string(tmp.clone()));\n   |            \
    \          ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823241
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut words: Vec<String> = Vec::new();\n    let mut\
    \ word = String::new();\n    for c in s.chars() {\n        if c.is_alphabetic()\
    \ {\n            word.push(c);\n        } else {\n            if !word.is_empty()\
    \ {\n                words.push(word);\n                word = String::new();\n\
    \            }\n            words.push(c.to_string());\n        }\n    }\n   \
    \ if !word.is_empty() {\n        words.push(word);\n    }\n    let mut new_words:\
    \ Vec<String> = Vec::new();\n    for word in words {\n        if word.len() >\
    \ 1 {\n            let mut chars: Vec<char> = word.chars().collect();\n      \
    \      chars.sort();\n            new_words.push(chars.into_iter().collect());\n\
    \        } else {\n            new_words.push(word);\n        }\n    }\n    new_words.join(\"\
    \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Hello Wdlor!!!\"`,\n right: `\"Hello !!!Wdlor\"`', /tmp/tmps2kcsdsk.rs:43:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823242
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmppx3ge1jq.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823241
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut v: Vec<String> = s.split_whitespace().map(|x|\
    \ x.to_string()).collect();\n    for (i, word) in v.iter_mut().enumerate() {\n\
    \        word.make_ascii_lowercase();\n        v[i] = word.chars().collect::<Vec<char>>().sort().iter().collect::<String>();\n\
    \    }\n    v.join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for unit type `()` in the current\
    \ scope\n  --> /tmp/tmplc9avzua.rs:11:59\n   |\n11 |         v[i] = word.chars().collect::<Vec<char>>().sort().iter().collect::<String>();\n\
    \   |                                                           ^^^^ method not\
    \ found in `()`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659823242
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    s.split_whitespace()\n        .map(|word| {\n     \
    \       let mut c: Vec<char> = word.chars().collect();\n            c.sort();\n\
    \            c.into_iter().collect()\n        })\n        .collect::<Vec<String>>()\n\
    \        .join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n \
    \   assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823242
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for word in s.split_whitespace()\
    \ {\n        let mut chars: Vec<char> = word.chars().collect();\n        chars.sort();\n\
    \        result.push_str(&String::from_iter(chars));\n        result.push(' ');\n\
    \    }\n    result.trim().to_string()\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no function or associated item named `from_iter` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmpn0stvvn1.rs:12:34\n   |\n\
    12 |         result.push_str(&String::from_iter(chars));\n   |               \
    \                   ^^^^^^^^^ function or associated item not found in `String`\n\
    \   |\n   = help: items from traits can only be used if the trait is in scope\n\
    help: the following trait is implemented but not in scope; perhaps add a `use`\
    \ for it:\n   |\n1  | use std::iter::FromIterator;\n   |\nhelp: there is an associated\
    \ function with a similar name\n   |\n12 |         result.push_str(&String::from_utf8(chars));\n\
    \   |                                  ~~~~~~~~~\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659823242
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmppx3ge1jq.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    s.split_whitespace()\n        .map(|word| {\n     \
    \       let mut chars: Vec<char> = word.chars().collect();\n            chars.sort();\n\
    \            chars.into_iter().collect()\n        })\n        .collect::<Vec<String>>()\n\
    \        .join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n \
    \   assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut input: Vec<char> = s.chars().collect();\n \
    \   let mut sorted_in: Vec<char> = input.clone();\n    let mut output: Vec<char>\
    \ = vec![];\n    for _ in 0..input.len() {\n        output.push(' ');\n    }\n\
    \    sorted_in.sort();\n    let mut cursor = 0;\n    let mut i = 0;\n    while\
    \ i < input.len() {\n        if input[i] == ' ' {\n            output[i] = ' ';\n\
    \            cursor = i + 1;\n        } else {\n            while output[cursor]\
    \ != ' ' {\n                cursor += 1;\n            }\n            output[cursor]\
    \ = sorted_in[i];\n        }\n        i += 1;\n    }\n    output.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"!!!H  dellloor\"`,\n right: `\"Hello !!!Wdlor\"`', /tmp/tmpea7yzf__.rs:38:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823242
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut res = String::new();\n    let mut temp = String::new();\n\
    \    for c in s.chars() {\n        if c != ' ' {\n            temp.push(c);\n\
    \        } else {\n            res.push_str(&sort_string(temp.clone()));\n   \
    \         res.push(' ');\n            temp.clear();\n        }\n    }\n    res.push_str(&sort_string(temp.clone()));\n\
    \    res\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sort_string` in this scope\n  --> /tmp/tmpejjvvgwb.rs:14:27\n\
    \   |\n14 |             res.push_str(&sort_string(temp.clone()));\n   |      \
    \                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `sort_string` in this scope\n  --> /tmp/tmpejjvvgwb.rs:19:19\n\
    \   |\n19 |     res.push_str(&sort_string(temp.clone()));\n   |              \
    \     ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    s.split_whitespace()\n        .map(|word| {\n     \
    \       let mut chars: Vec<char> = word.chars().collect();\n            chars.sort();\n\
    \            chars.into_iter().collect()\n        })\n        .collect::<Vec<String>>()\n\
    \        .join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n \
    \   assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    // replace every word with reverse.\n    s.split('\
    \ ')\n        .map(|s| {\n            let mut v: Vec<char> = s.chars().collect();\n\
    \            v.sort();\n            v.into_iter().collect()\n        })\n    \
    \    .collect::<Vec<String>>()\n        .join(\" \")\n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823242
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut words: Vec<String> = s.split_whitespace().map(|x|\
    \ x.to_string()).collect();\n    for word in words.iter_mut() {\n        let mut\
    \ chars: Vec<char> = word.chars().collect();\n        chars.sort();\n        *word\
    \ = chars.into_iter().collect();\n    }\n    words.join(\" \")\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823242
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut res = String::new();\n    let mut tmp = String::new();\n\
    \    for c in s.chars() {\n        if c == ' ' {\n            if !tmp.is_empty()\
    \ {\n                res.push_str(&sort_string(tmp));\n                tmp.clear();\n\
    \            }\n            res.push(' ');\n        } else {\n            tmp.push(c);\n\
    \        }\n    }\n    if !tmp.is_empty() {\n        res.push_str(&sort_string(tmp));\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sort_string` in this scope\n  --> /tmp/tmp0jjwvoun.rs:13:31\n\
    \   |\n13 |                 res.push_str(&sort_string(tmp));\n   |           \
    \                    ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `sort_string` in this scope\n  --> /tmp/tmp0jjwvoun.rs:22:23\n\
    \   |\n22 |         res.push_str(&sort_string(tmp));\n   |                   \
    \    ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let words: Vec<String> = s.split(\" \").map(|s| s.to_string()).collect();\n\
    \    let mut out = String::new();\n    for w in words {\n        let mut word\
    \ = String::new();\n        let mut chars: Vec<char> = w.chars().collect();\n\
    \        chars.sort();\n        for c in chars {\n            word.push(c);\n\
    \        }\n        out.push_str(&word);\n        out.push(' ');\n    }\n    out.pop();\n\
    \    out\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823242
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut previous_blank\
    \ = true;\n    for c in s.chars() {\n        if c.is_whitespace() {\n        \
    \    if !previous_blank {\n                result.push(c);\n            }\n  \
    \          previous_blank = true;\n        } else {\n            if previous_blank\
    \ {\n                result.push(c);\n            } else {\n                result.pop();\n\
    \                result.push(c);\n            }\n            previous_blank =\
    \ false;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"i\"`,\n right: `\"Hi\"`', /tmp/tmptv8t9fm3.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823242
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut words: Vec<_> = s.split_whitespace().collect();\n\
    \    for w in &mut words {\n        *w = w.chars().sorted().collect::<String>();\n\
    \    }\n    words.join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sorted` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmp4bnuqr_j.rs:10:24\n   |\n10 |         *w = w.chars().sorted().collect::<String>();\n\
    \   |                        ^^^^^^ method not found in `Chars<'_>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659823242
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut res = s.split_whitespace().map(|word| {\n \
    \       let mut chars: Vec<char> = word.chars().collect();\n        chars.sort();\n\
    \        chars.into_iter().collect::<String>()\n    });\n    res.collect::<Vec<String>>().join(\"\
    \ \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823242
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut res = String::new();\n    let mut temp = String::new();\n\
    \    for c in s.chars() {\n        if c != ' ' {\n            temp.push(c);\n\
    \        } else {\n            res.push_str(&sort(temp));\n            res.push('\
    \ ');\n            temp.clear();\n        }\n    }\n    res.push_str(&sort(temp));\n\
    \    res\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sort` in this scope\n  --> /tmp/tmp9bij5btp.rs:14:27\n\
    \   |\n14 |             res.push_str(&sort(temp));\n   |                     \
    \      ^^^^ not found in this scope\n\nerror[E0425]: cannot find function `sort`\
    \ in this scope\n  --> /tmp/tmp9bij5btp.rs:19:19\n   |\n19 |     res.push_str(&sort(temp));\n\
    \   |                   ^^^^ not found in this scope\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659823242
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut vector: Vec<&str> = s.split_whitespace().collect();\n\
    \    for word in vector.iter_mut() {\n        let mut chars: Vec<char> = word.chars().collect();\n\
    \        chars.sort();\n        *word = chars.into_iter().collect();\n    }\n\
    \    vector.join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `&str` cannot be built from an iterator over\
    \ elements of type `char`\n  --> /tmp/tmp1jwyan6t.rs:12:35\n   |\n12 |       \
    \  *word = chars.into_iter().collect();\n   |                                \
    \   ^^^^^^^ value of type `&str` cannot be built from `std::iter::Iterator<Item=char>`\n\
    \   |\n   = help: the trait `FromIterator<char>` is not implemented for `&str`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823242
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut words: Vec<_> = s.split_whitespace().collect();\n\
    \    words.sort_by_key(|&w| {\n        let mut chars: Vec<_> = w.chars().collect();\n\
    \        chars.sort();\n        chars\n    });\n    words.join(\" \")\n}\n\nfn\
    \ main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hello\"`,\n right: `\"ehllo\"`', /tmp/tmpjf_tyh9n.rs:20:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823242
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    s.split_whitespace()\n        .map(|s| {\n        \
    \    let mut s = s.chars().collect::<Vec<_>>();\n            s.sort();\n     \
    \       s.into_iter().collect::<String>()\n        })\n        .collect::<Vec<_>>()\n\
    \        .join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n \
    \   assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823242
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    // Map characters to word index\n    let mut word_counts\
    \ = HashMap::new();\n    // Map word to word-index\n    let mut words = HashMap::new();\n\
    \    // The value of space\n    let space = \" \".to_string();\n    let mut word_count\
    \ = 0;\n    let mut word = String::new();\n    let mut result = String::new();\n\
    \    let mut prev_char = space.clone();\n    let mut prev_word = space.clone();\n\
    \    for char in s.chars() {\n        if char == ' ' {\n            if prev_char\
    \ != space.clone() {\n                let count = word_counts.entry(word.clone()).or_insert(word_count);\n\
    \                *count = *count + 1;\n                word_count += 1;\n    \
    \            words.insert(word.clone(), *count);\n                word = String::new();\n\
    \            }\n            prev_char = space.clone();\n            if prev_word\
    \ != space.clone() {\n                result += \" \";\n            }\n      \
    \      prev_word = space.clone();\n        } else {\n            prev_char = char.to_string();\n\
    \            word.push(char);\n            prev_word = word.clone();\n       \
    \     result += word_counts.get(&word).unwrap_or(&word_count).to_string().as_str();\n\
    \        }\n    }\n    // If we ended in a word, process it\n    if prev_char\
    \ != space.clone() {\n        let count = word_counts.entry(word.clone()).or_insert(word_count);\n\
    \        *count = *count + 1;\n        word_count += 1;\n        words.insert(word.clone(),\
    \ *count);\n    }\n    // Now rebuild the string using the word-index (not character-index)\n\
    \    let mut result_sorted = String::new();\n    let mut prev_index = 0;\n   \
    \ for (index, char) in result.chars().enumerate() {\n        if char == ' ' {\n\
    \            prev_index = index;\n            result_sorted += \" \";\n      \
    \  } else {\n            result_sorted += &words.get(&result\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpnm0byo2a.rs:67:3\n\
    \   |\n7  | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n50 |     for (index, char) in result.chars().enumerate()\
    \ {\n   |                                                     - unclosed delimiter\n\
    ...\n54 |         } else {\n   |                - this delimiter might not be\
    \ properly closed...\n55 |             result_sorted += &words.get(&result\n56\
    \ | }\n   | - ...as it matches this but it has different indentation\n...\n67\
    \ | }\n   |   ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpnm0byo2a.rs:55:40\n\
    \   |\n7  | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - closing delimiter possibly meant for this\n...\n55 |     \
    \        result_sorted += &words.get(&result\n   |                           \
    \             ^ unclosed delimiter\n56 | }\n   | ^ mismatched closing delimiter\n\
    \nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n --> /tmp/tmpnm0byo2a.rs:9:27\n\
    \  |\n9 |     let mut word_counts = HashMap::new();\n  |                     \
    \      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashMap;\n  |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmpnm0byo2a.rs:11:21\n   |\n11\
    \ |     let mut words = HashMap::new();\n   |                     ^^^^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  |\
    \ use std::collections::HashMap;\n   |\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpnm0byo2a.rs:50:5\n   |\n7  |   fn anti_shuffle(s: String) -> String\
    \ {\n   |                                 ------ expected `String` because of\
    \ return type\n...\n50 | /     for (index, char) in result.chars().enumerate()\
    \ {\n51 | |         if char == ' ' {\n52 | |             prev_index = index;\n\
    53 | |             result_sorted += \" \";\n...  |\n66 | |     assert_eq!(candidate(String::from(\"\
    Hi. My name is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst\
    \ .Rboot How "
  stdout: ''
  timestamp: 1659823242
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut chars: Vec<_> = s.chars().collect();\n    let\
    \ mut words: Vec<_> = s.split_whitespace().collect();\n    for word in words.iter_mut()\
    \ {\n        let mut chars: Vec<_> = word.chars().collect();\n        chars.sort();\n\
    \        *word = chars.into_iter().collect();\n    }\n    words.join(\" \")\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `&str` cannot be built from an iterator over\
    \ elements of type `char`\n  --> /tmp/tmptjhiol0b.rs:13:35\n   |\n13 |       \
    \  *word = chars.into_iter().collect();\n   |                                \
    \   ^^^^^^^ value of type `&str` cannot be built from `std::iter::Iterator<Item=char>`\n\
    \   |\n   = help: the trait `FromIterator<char>` is not implemented for `&str`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823242
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut words: Vec<String> = s.split_whitespace().map(|w|\
    \ w.to_string()).collect();\n    words.sort_by(|a, b| {\n        let a: Vec<char>\
    \ = a.chars().collect();\n        let b: Vec<char> = b.chars().collect();\n  \
    \      let a_sorted: Vec<char> = a.clone();\n        let b_sorted: Vec<char> =\
    \ b.clone();\n        a_sorted.sort();\n        b_sorted.sort();\n        if a_sorted\
    \ == b_sorted {\n            a.cmp(&b)\n        } else {\n            a_sorted.cmp(&b_sorted)\n\
    \        }\n    });\n    words.join(\" \")\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `a_sorted` as mutable, as it is not declared\
    \ as mutable\n  --> /tmp/tmpbfre634t.rs:14:9\n   |\n12 |         let a_sorted:\
    \ Vec<char> = a.clone();\n   |             -------- help: consider changing this\
    \ to be mutable: `mut a_sorted`\n13 |         let b_sorted: Vec<char> = b.clone();\n\
    14 |         a_sorted.sort();\n   |         ^^^^^^^^ cannot borrow as mutable\n\
    \nerror[E0596]: cannot borrow `b_sorted` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpbfre634t.rs:15:9\n   |\n13 |         let b_sorted: Vec<char>\
    \ = b.clone();\n   |             -------- help: consider changing this to be mutable:\
    \ `mut b_sorted`\n14 |         a_sorted.sort();\n15 |         b_sorted.sort();\n\
    \   |         ^^^^^^^^ cannot borrow as mutable\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659823242
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let words: Vec<&str> = s.split(' ').collect();\n  \
    \  let mut result = Vec::new();\n    for w in words {\n        let mut chars:\
    \ Vec<char> = w.chars().collect();\n        chars.sort();\n        result.push(chars.into_iter().collect::<String>());\n\
    \    }\n    result.join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823242
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    // first, split into words and sort the individual\
    \ words\n    let words: Vec<String> = s.split_whitespace().map(|w| sort_chars(w)).collect();\n\
    \    // join them back up with a space in between\n    words.join(\" \")\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sort_chars` in this scope\n --> /tmp/tmpnge9jmnb.rs:9:59\n\
    \  |\n9 |     let words: Vec<String> = s.split_whitespace().map(|w| sort_chars(w)).collect();\n\
    \  |                                                           ^^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823242
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut out = String::new();\n    let mut splitted\
    \ = s.split(\" \");\n    loop {\n        let word = splitted.next();\n       \
    \ if word.is_none() {\n            break;\n        }\n        let word = word.unwrap();\n\
    \        let mut chars: Vec<char> = word.chars().collect();\n        chars.sort();\n\
    \        out.push_str(&chars.iter().collect::<String>());\n        out.push('\
    \ ');\n    }\n    out.pop();\n    out\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823242
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmppx3ge1jq.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823241
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    if s.is_empty() {\n        return s;\n    }\n    let\
    \ mut result = String::new();\n    let mut word = String::new();\n    for c in\
    \ s.chars() {\n        if c == ' ' {\n            if word.is_empty() {\n     \
    \           result.push(c);\n            } else {\n                result += &order_word(word);\n\
    \                result.push(c);\n                word.clear();\n            }\n\
    \        } else {\n            word.push(c);\n        }\n    }\n    if !word.is_empty()\
    \ {\n        result += &order_word(word);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `order_word` in this scope\n  --> /tmp/tmpd2mtjkh7.rs:18:28\n\
    \   |\n18 |                 result += &order_word(word);\n   |               \
    \             ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `order_word` in this scope\n  --> /tmp/tmpd2mtjkh7.rs:27:20\n   |\n\
    27 |         result += &order_word(word);\n   |                    ^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823242
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut words: Vec<String> = s.split(\" \").map(String::from).collect();\n\
    \    for word in words.iter_mut() {\n        let mut chars: Vec<char> = word.chars().collect();\n\
    \        chars.sort();\n        *word = chars.into_iter().collect();\n    }\n\
    \    words.join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823242
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let words: Vec<&str> = s.split_whitespace().collect();\n\
    \    let mut result = String::new();\n    for (i, word) in words.iter().enumerate()\
    \ {\n        if i == words.len() - 1 {\n            result += word;\n        }\
    \ else {\n            result += word;\n            result += \" \";\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hello\"`,\n right: `\"ehllo\"`', /tmp/tmpqjtwnhy4.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823242
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut v: Vec<&str> = s.split(\" \").collect();\n\
    \    v.sort_by(|a, b| {\n        let mut a_chars: Vec<char> = a.chars().collect();\n\
    \        let mut b_chars: Vec<char> = b.chars().collect();\n        a_chars.sort();\n\
    \        b_chars.sort();\n        a_chars.cmp(&b_chars)\n    });\n    let mut\
    \ result = String::new();\n    for word in v {\n        result += word;\n    \
    \    result += \" \";\n    }\n    result.trim().to_string()\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hello\"`,\n right: `\"ehllo\"`', /tmp/tmp2kp77_nj.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823243
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let words: Vec<String> = s.split_whitespace().map(|w|\
    \ w.to_string()).collect();\n    let mut res = String::with_capacity(s.len());\n\
    \    for w in words {\n        let mut chars: Vec<char> = w.chars().collect();\n\
    \        chars.sort();\n        for ch in chars {\n            res.push(ch);\n\
    \        }\n        res.push(' ');\n    }\n    res.pop();\n    res\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823243
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut words: Vec<_> = s.split_whitespace().collect();\n\
    \    for i in 0..words.len() {\n        let mut chars: Vec<_> = words[i].chars().collect();\n\
    \        chars.sort();\n        words[i] = chars.into_iter().collect();\n    }\n\
    \    words.join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `&str` cannot be built from an iterator over\
    \ elements of type `char`\n  --> /tmp/tmp2qz1exk2.rs:12:38\n   |\n12 |       \
    \  words[i] = chars.into_iter().collect();\n   |                             \
    \         ^^^^^^^ value of type `&str` cannot be built from `std::iter::Iterator<Item=char>`\n\
    \   |\n   = help: the trait `FromIterator<char>` is not implemented for `&str`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823242
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut words: Vec<String> = Vec::new();\n    let mut\
    \ current = String::new();\n    for c in s.chars() {\n        if c == ' ' {\n\
    \            words.push(current);\n            current = String::new();\n    \
    \    } else {\n            current.push(c);\n        }\n    }\n    words.push(current);\n\
    \    words.into_iter().map(|s| {\n        let mut chars: Vec<char> = s.chars().collect();\n\
    \        chars.sort();\n        chars.into_iter().collect()\n    }).collect::<Vec<String>>().join(\"\
    \ \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823243
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut sorted_words: Vec<String> = s\n        .split_whitespace()\n\
    \        .map(|word| {\n            let mut chars: Vec<char> = word.chars().collect();\n\
    \            chars.sort();\n            chars.into_iter().collect()\n        })\n\
    \        .collect();\n    sorted_words.join(\" \")\n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823243
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    s.split_whitespace()\n        .map(|s| {\n        \
    \    let mut chars: Vec<char> = s.chars().collect();\n            chars.sort();\n\
    \            chars.into_iter().collect()\n        })\n        .collect::<Vec<String>>()\n\
    \        .join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n \
    \   assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823242
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut split_s = s.split_whitespace();\n    let mut\
    \ result = String::new();\n    while let Some(word) = split_s.next() {\n     \
    \   let mut chars = word.chars().collect::<Vec<char>>();\n        chars.sort();\n\
    \        for c in chars {\n            result.push(c);\n        }\n        result.push('\
    \ ');\n    }\n    result.pop();\n    result\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823243
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut words: Vec<Vec<char>> = Vec::new();\n    let\
    \ mut word: Vec<char> = Vec::new();\n    for c in s.chars() {\n        if c ==\
    \ ' ' {\n            words.push(word);\n            word = Vec::new();\n     \
    \   } else {\n            word.push(c);\n        }\n    }\n    if !word.is_empty()\
    \ {\n        words.push(word);\n    }\n    let mut result = String::new();\n \
    \   for word in words {\n        result.push_str(&mut word.clone().into_iter().sort().collect::<String>());\n\
    \        result.push(' ');\n    }\n    result.pop();\n    result\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort` found for struct `std::vec::IntoIter`\
    \ in the current scope\n  --> /tmp/tmpaefnvio6.rs:23:55\n   |\n23 |         result.push_str(&mut\
    \ word.clone().into_iter().sort().collect::<String>());\n   |                \
    \                                       ^^^^ method not found in `std::vec::IntoIter<char>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659823242
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut out = String::new();\n    let mut word = String::new();\n\
    \    for c in s.chars() {\n        if c == ' ' {\n            out.push_str(&anti_shuffle_word(word));\n\
    \            out.push(' ');\n            word = String::new();\n        } else\
    \ {\n            word.push(c);\n        }\n    }\n    out.push_str(&anti_shuffle_word(word));\n\
    \    out\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `anti_shuffle_word` in this scope\n\
    \  --> /tmp/tmp0k_uw8_e.rs:12:27\n   |\n12 |             out.push_str(&anti_shuffle_word(word));\n\
    \   |                           ^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find function `anti_shuffle_word` in this scope\n  --> /tmp/tmp0k_uw8_e.rs:19:19\n\
    \   |\n19 |     out.push_str(&anti_shuffle_word(word));\n   |                \
    \   ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823242
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for word in s.split_whitespace()\
    \ {\n        result.push_str(&sort_word(word));\n        result.push(' ');\n \
    \   }\n    result.trim().to_string()\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sort_word` in this scope\n  --> /tmp/tmppx41tdjn.rs:10:26\n\
    \   |\n10 |         result.push_str(&sort_word(word));\n   |                 \
    \         ^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823242
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for word in s.split_whitespace()\
    \ {\n        result.push_str(&word.chars().sorted().collect::<String>());\n  \
    \      result.push(' ');\n    }\n    result.trim().to_string()\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sorted` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmp8l4u17e0.rs:10:39\n   |\n10 |         result.push_str(&word.chars().sorted().collect::<String>());\n\
    \   |                                       ^^^^^^ method not found in `Chars<'_>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659823242
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    s.split(' ')\n        .map(|s| {\n            let mut\
    \ tmp = s.chars().collect::<Vec<char>>();\n            tmp.sort();\n         \
    \   tmp.into_iter().collect::<String>()\n        })\n        .collect::<Vec<String>>()\n\
    \        .join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n \
    \   assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823243
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    // first split the string into words\n    let mut words:\
    \ Vec<String> = s.split(\" \").map(|s| s.to_string()).collect();\n    // sort\
    \ each word by character\n    for i in 0..words.len() {\n        words[i] = sort_string(words[i]);\n\
    \    }\n    words.join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sort_string` in this scope\n  --> /tmp/tmp8r_xhra9.rs:12:20\n\
    \   |\n12 |         words[i] = sort_string(words[i]);\n   |                  \
    \  ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823242
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut words: Vec<String> = s.split_whitespace().map(|x|\
    \ x.to_string()).collect();\n    for word in words.iter_mut() {\n        let chars:\
    \ Vec<char> = word.chars().collect();\n        let mut chars_sorted: Vec<char>\
    \ = chars.clone();\n        chars_sorted.sort();\n        for i in 0..chars.len()\
    \ {\n            word.replace_range(chars[i]..chars[i].next(), &chars_sorted[i].to_string());\n\
    \        }\n    }\n    words.join(\" \")\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `next` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp6l6ty4te.rs:14:51\n   |\n14 |             word.replace_range(chars[i]..chars[i].next(),\
    \ &chars_sorted[i].to_string());\n   |                                       \
    \            ^^^^ method not found in `char`\n\nerror[E0277]: the trait bound\
    \ `std::ops::Range<char>: RangeBounds<usize>` is not satisfied\n  --> /tmp/tmp6l6ty4te.rs:14:18\n\
    \   |\n14 |             word.replace_range(chars[i]..chars[i].next(), &chars_sorted[i].to_string());\n\
    \   |                  ^^^^^^^^^^^^^ the trait `RangeBounds<usize>` is not implemented\
    \ for `std::ops::Range<char>`\n   |\n   = help: the following implementations\
    \ were found:\n             <std::ops::Range<&T> as RangeBounds<T>>\n        \
    \     <std::ops::Range<T> as RangeBounds<T>>\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823242
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut words: Vec<String> = s.split_whitespace().map(|s|\
    \ s.to_string()).collect();\n    for word in words.iter_mut() {\n        let mut\
    \ chars: Vec<char> = word.chars().collect();\n        chars.sort();\n        *word\
    \ = chars.into_iter().collect();\n    }\n    words.join(\" \")\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823243
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut s: Vec<&str>\
    \ = s.split_whitespace().collect();\n    for i in 0..s.len() {\n        let word:\
    \ Vec<char> = s[i].chars().collect();\n        let mut ordered: Vec<char> = word.clone();\n\
    \        ordered.sort();\n        result.push_str(&ordered.iter().collect::<String>());\n\
    \        if i < s.len() - 1 {\n            result.push(' ');\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823243
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut result = vec![];\n    for word in s.split_whitespace()\
    \ {\n        let mut chars: Vec<char> = word.chars().collect();\n        chars.sort();\n\
    \        result.push(chars.into_iter().collect::<String>());\n    }\n    result.join(\"\
    \ \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823243
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    // Simple in-place sort based on the ascii value\n\
    \    fn sort_word(word: &mut String) {\n        let mut chars: Vec<char> = word.chars().collect();\n\
    \        chars.sort_by(|a, b| a.cmp(b));\n        *word = chars.into_iter().collect();\n\
    \    }\n\n    let mut words: Vec<String> = Vec::new();\n    let mut word = String::new();\n\
    \    for c in s.chars() {\n        if c.is_alphabetic() {\n            word.push(c);\n\
    \        } else {\n            if !word.is_empty() {\n                words.push(word);\n\
    \                word = String::new();\n            }\n            words.push(c.to_string());\n\
    \        }\n    }\n    if !word.is_empty() {\n        words.push(word);\n    }\n\
    \n    for w in words.iter_mut() {\n        if w.chars().any(|c| c.is_alphabetic())\
    \ {\n            sort_word(w);\n        }\n    }\n\n    words.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Hello Wdlor!!!\"`,\n right: `\"Hello !!!Wdlor\"`', /tmp/tmp2o4zc4zk.rs:47:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823243
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut words: Vec<&str> = s.split_whitespace().collect();\n\
    \    let mut sorted_words: Vec<String> = Vec::new();\n    for mut word in words\
    \ {\n        word = word.to_owned();\n        let mut chars: Vec<char> = word.chars().collect();\n\
    \        chars.sort();\n        sorted_words.push(chars.into_iter().collect());\n\
    \    }\n    sorted_words.join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk_5i3on4.rs:11:16\n   |\n\
    11 |         word = word.to_owned();\n   |                ^^^^^^^^^^^^^^^\n  \
    \ |                |\n   |                expected `&str`, found struct `String`\n\
    \   |                help: consider borrowing here: `&word.to_owned()`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659823242
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut words: Vec<String> = Vec::new();\n    let mut\
    \ word = String::new();\n    for c in s.chars() {\n        if c.is_whitespace()\
    \ {\n            if !word.is_empty() {\n                words.push(word);\n  \
    \              word = String::new();\n            }\n        } else {\n      \
    \      word.push(c);\n        }\n    }\n    if !word.is_empty() {\n        words.push(word);\n\
    \    }\n    let mut res = String::new();\n    for (i, word) in words.iter().enumerate()\
    \ {\n        let mut chars: Vec<char> = word.chars().collect();\n        chars.sort();\n\
    \        for c in chars {\n            res.push(c);\n        }\n        if i <\
    \ words.len() - 1 {\n            res.push(' ');\n        }\n    }\n    res\n}\n\
    \nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823243
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut new_s = s.clone();\n    let mut len = new_s.len();\n\
    \    let blank_space = ' ';\n    let start = new_s.find(blank_space).unwrap();\n\
    \    let mut splitted_word: Vec<String> = vec![];\n    let mut splitted_word_chars:\
    \ Vec<String> = vec![];\n    let mut splitted_string: Vec<String> = vec![];\n\
    \    let mut output = String::new();\n    while len != 0 {\n        if new_s.find(blank_space).is_some()\
    \ {\n            let end = new_s.find(blank_space).unwrap();\n            splitted_word.push(new_s[start..end].to_string());\n\
    \            let word_len = splitted_word[0].len();\n            for x in 0..word_len\
    \ {\n                splitted_word_chars.push(splitted_word[0][x..x + 1].to_string());\n\
    \            }\n            splitted_word_chars.sort();\n            let mut new_word\
    \ = String::new();\n            let splitted_word_chars_len = splitted_word_chars.len();\n\
    \            for x in 0..splitted_word_chars_len {\n                new_word.push_str(&splitted_word_chars[x]);\n\
    \            }\n            splitted_string.push(new_word);\n            splitted_word_chars.clear();\n\
    \            splitted_word.clear();\n            new_s = new_s[end + 1..].to_string();\n\
    \            len = new_s.len();\n        } else {\n            let mut new_word\
    \ = String::new();\n            for x in 0..len {\n                splitted_word_chars.push(new_s[x..x\
    \ + 1].to_string());\n            }\n            splitted_word_chars.sort();\n\
    \            let splitted_word_chars_len = splitted_word_chars.len();\n      \
    \      for x in 0..splitted_word_chars_len {\n                new_word.push_str(&splitted_\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpqhxnsdm7.rs:55:3\n\
    \   |\n7  | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n16 |     while len != 0 {\n   | \
    \                   - unclosed delimiter\n...\n35 |         } else {\n   |   \
    \             - unclosed delimiter\n...\n42 |             for x in 0..splitted_word_chars_len\
    \ {\n   |                                                 - this delimiter might\
    \ not be properly closed...\n43 |                 new_word.push_str(&splitted_\n\
    44 | }\n   | - ...as it matches this but it has different indentation\n...\n55\
    \ | }\n   |   ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpqhxnsdm7.rs:43:34\n\
    \   |\n7  | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - closing delimiter possibly meant for this\n...\n43 |     \
    \            new_word.push_str(&splitted_\n   |                              \
    \    ^ unclosed delimiter\n44 | }\n   | ^ mismatched closing delimiter\n\nerror[E0425]:\
    \ cannot find value `splitted_` in this scope\n  --> /tmp/tmpqhxnsdm7.rs:43:36\n\
    \   |\n43 |                 new_word.push_str(&splitted_\n   |               \
    \                     ^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqhxnsdm7.rs:16:5\n   |\n7  |   fn anti_shuffle(s: String)\
    \ -> String {\n   |                                 ------ expected `String` because\
    \ of return type\n...\n16 | /     while len != 0 {\n17 | |         if new_s.find(blank_space).is_some()\
    \ {\n18 | |             let end = new_s.find(blank_space).unwrap();\n19 | |  \
    \           splitted_word.push(new_s[start..end].to_string());\n...  |\n54 | |\
    \     assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How are\
    \ you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?...\n55 | | }\n\
    \   | |__^ expected struct `String`, found `()`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659823243
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    s.split_whitespace()\n        .map(|x| x.chars().collect::<Vec<_>>())\n\
    \        .map(|mut x| {\n            x.sort();\n            x.into_iter().collect::<String>()\n\
    \        })\n        .collect::<Vec<_>>()\n        .join(\" \")\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823243
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut sorted_words: Vec<String> = Vec::new();\n \
    \   for word in s.split(\" \") {\n        let mut chars: Vec<char> = word.chars().collect();\n\
    \        chars.sort();\n        sorted_words.push(chars.into_iter().collect());\n\
    \    }\n    sorted_words.join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823243
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut words: Vec<String> = s.split_whitespace().map(|s|\
    \ s.to_string()).collect();\n    for w in words.iter_mut() {\n        let mut\
    \ chars: Vec<char> = w.chars().collect();\n        chars.sort();\n        *w =\
    \ chars.into_iter().collect();\n    }\n    words.join(\" \")\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823243
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let words: Vec<&str> = s.split(' ').collect();\n  \
    \  let mut anti_shuffled_words: Vec<String> = Vec::new();\n    for word in words\
    \ {\n        let mut chars: Vec<char> = word.chars().collect();\n        chars.sort();\n\
    \        anti_shuffled_words.push(chars.into_iter().collect());\n    }\n    let\
    \ mut anti_shuffled_words_iter = anti_shuffled_words.iter();\n    let anti_shuffled_s:\
    \ String = s\n        .split(' ')\n        .map(|word| {\n            if word.is_empty()\
    \ {\n                \" \".to_string()\n            } else {\n               \
    \ anti_shuffled_words_iter.next().unwrap().to_string()\n            }\n      \
    \  })\n        .collect();\n    anti_shuffled_s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Hello!!!Wdlor\"`,\n right: `\"Hello !!!Wdlor\"`', /tmp/tmpc_62nhp_.rs:35:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823243
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let words: Vec<&str> = s.split(' ').collect();\n  \
    \  let mut sorted: Vec<String> = Vec::new();\n    for word in words {\n      \
    \  let mut chars: Vec<char> = word.chars().collect();\n        chars.sort();\n\
    \        sorted.push(chars.into_iter().collect());\n    }\n    sorted.join(\"\
    \ \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823243
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut buff = String::new();\n    let words: Vec<&str>\
    \ = s.split_whitespace().collect();\n    for i in 0..words.len() {\n        let\
    \ mut chars: Vec<char> = words[i].chars().collect();\n        chars.sort();\n\
    \        for c in chars {\n            buff.push(c);\n        }\n        if i\
    \ != words.len() - 1 {\n            buff.push(' ');\n        }\n    }\n    buff\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823243
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    // \"ab c\" -> \"a b c\" -> \"a b c\"\n    // \"a b\"\
    \ -> \"a b\" -> \"a b\"\n    // \"aa bb cc\" -> \"aa bb cc\" -> \"aa bb cc\"\n\
    \    // \"a\" -> \"a\" -> \"a\"\n    // \"abc\" -> \"abc\" -> \"abc\"\n    //\
    \ \"abcd efgh\" -> \"abcd efgh\" -> \"abcd efgh\"\n    // \"abc def ghi\" -> \"\
    abc def ghi\" -> \"abc def ghi\"\n    // \"q w e r t y u i o p a s d f g h j k\
    \ l z x c v b n m\" -> \"a e i o q s w y b d f h j l p t v x z c k m n r u\" ->\
    \ \"a e i o q s w y b d f h j l p t v x z c k m n r u\"\n    // \"z\" -> \"z\"\
    \ -> \"z\"\n    // \"zz\" -> \"zz\" -> \"zz\"\n    // \"zzz\" -> \"zzz\" -> \"\
    zzz\"\n    // \"zzz zzz\" -> \"zzz zzz\" -> \"zzz zzz\"\n    // \"zzz zzz zzz\"\
    \ -> \"zzz zzz zzz\" -> \"zzz zzz zzz\"\n    // \"ab cd ef gh ij kl mn op qr st\
    \ uv wx yz\" -> \"ab cd ef gh ij kl mn op qr st uv wx yz\" -> \"ab cd ef gh ij\
    \ kl mn op qr st uv wx yz\"\n    // \"a a a a a a a a a a a a a a a a a a a a\
    \ a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a\
    \ a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a\
    \ a a a a a a a a a a a a a a a a a a\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpbg221ntj.rs:7:31\n  |\n7 |\
    \ fn anti_shuffle(s: String) -> String {\n  |    ------------               ^^^^^^\
    \ expected struct `String`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659823243
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut ws: Vec<Vec<char>> = Vec::new();\n    let mut\
    \ w = Vec::new();\n    for c in s.chars() {\n        if c == ' ' {\n         \
    \   ws.push(w);\n            w = Vec::new();\n        } else {\n            w.push(c);\n\
    \        }\n    }\n    ws.push(w);\n    let mut res = String::new();\n    for\
    \ w in ws {\n        res.push_str(&format!(\"{} \", w.iter().sorted().collect::<String>()));\n\
    \    }\n    return res.trim().to_string();\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sorted` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmp1h3fqjz9.rs:21:47\n   |\n21 |         res.push_str(&format!(\"\
    {} \", w.iter().sorted().collect::<String>()));\n   |                        \
    \                       ^^^^^^ method not found in `std::slice::Iter<'_, char>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659823243
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut words: Vec<Vec<char>> = Vec::new();\n    let\
    \ mut word: Vec<char> = Vec::new();\n    for c in s.chars() {\n        if c ==\
    \ ' ' {\n            words.push(word);\n            word = Vec::new();\n     \
    \   } else {\n            word.push(c);\n        }\n    }\n    words.push(word);\n\
    \    words\n        .iter()\n        .map(|v| {\n            let mut v = v.clone();\n\
    \            v.sort();\n            v\n        })\n        .map(|v| v.iter().collect::<String>())\n\
    \        .collect::<Vec<String>>()\n        .join(\" \")\n}\n\nfn main() {\n \
    \   let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823243
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s2 = String::new();\n    for word in s.split_whitespace()\
    \ {\n        for c in word.chars().collect::<Vec<char>>().into_iter().sorted()\
    \ {\n            s2.push(c);\n        }\n        s2.push(' ');\n    }\n    s2.trim().to_string()\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sorted` found for struct `std::vec::IntoIter`\
    \ in the current scope\n  --> /tmp/tmpnezeeki7.rs:10:66\n   |\n10 |         for\
    \ c in word.chars().collect::<Vec<char>>().into_iter().sorted() {\n   |      \
    \                                                            ^^^^^^ method not\
    \ found in `std::vec::IntoIter<char>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659823243
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    s.split_whitespace()\n        .map(|w| {\n        \
    \    let mut w: Vec<_> = w.chars().collect();\n            w.sort();\n       \
    \     w.into_iter().collect()\n        })\n        .collect::<Vec<_>>()\n    \
    \    .join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n --> /tmp/tmp58z42k71.rs:9:10\n\
    \  |\n9 |         .map(|w| {\n  |          ^^^ cannot infer type for type parameter\
    \ `B` declared on the associated function `map`\n  |\nhelp: consider specifying\
    \ the type argument in the method call\n  |\n12|             w.into_iter().collect::<B>()\n\
    \  |                                  +++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659823243
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    // First we split the string into words\n    let mut\
    \ words: Vec<String> = s.split(\" \").map(String::from).collect();\n    // Then\
    \ we sort each word alphabetically\n    words.iter_mut().for_each(|word| {\n \
    \       word.as_mut_str().chars().sort_by(|a, b| a.cmp(b));\n    });\n    // Then\
    \ we join the words with a space\n    words.join(\" \")\n}\n\nfn main() {\n  \
    \  let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmpi6d8uyxw.rs:12:35\n   |\n12 |         word.as_mut_str().chars().sort_by(|a,\
    \ b| a.cmp(b));\n   |                                   ^^^^^^^ method not found\
    \ in `Chars<'_>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659823243
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    // Convert String to Vec<&str>\n    let mut str_vec:\
    \ Vec<&str> = s.split_whitespace().collect();\n    // For each item in the Vec\n\
    \    // Convert the string to Vec<char>\n    // Then sort the characters\n   \
    \ // Then join the characters back into a string\n    // Then push that string\
    \ to the original Vec\n    for i in 0..str_vec.len() {\n        str_vec[i] = str_vec[i].chars().collect::<Vec<char>>().sort().join(\"\
    \").as_str();\n    }\n    // Join the Vec<&str> back into a String\n    str_vec.join(\"\
    \ \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `join` found for unit type `()` in the current\
    \ scope\n  --> /tmp/tmppy8ood96.rs:16:71\n   |\n16 |         str_vec[i] = str_vec[i].chars().collect::<Vec<char>>().sort().join(\"\
    \").as_str();\n   |                                                          \
    \             ^^^^ method not found in `()`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659823243
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    s.split_whitespace()\n        .map(|x| {\n        \
    \    let mut chars: Vec<char> = x.chars().collect();\n            chars.sort();\n\
    \            chars.into_iter().collect::<String>()\n        })\n        .collect::<Vec<String>>()\n\
    \        .join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n \
    \   assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823243
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    s.split(' ')\n        .map(|word| {\n            let\
    \ mut chars: Vec<char> = word.chars().collect();\n            chars.sort();\n\
    \            chars.into_iter().collect()\n        })\n        .collect::<Vec<String>>()\n\
    \        .join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n \
    \   assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    s.split_whitespace()\n        .map(|w| {\n        \
    \    let mut c: Vec<char> = w.chars().collect();\n            c.sort();\n    \
    \        c.into_iter().collect()\n        })\n        .collect::<Vec<String>>()\n\
    \        .join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n \
    \   assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823243
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut v: Vec<_> = s.split_whitespace().collect();\n\
    \    for w in &mut v {\n        *w = w.chars().collect::<Vec<_>>().sort_by(|a,\
    \ b| a.cmp(b)).iter().collect();\n    }\n    v.join(\" \")\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for unit type `()` in the current\
    \ scope\n  --> /tmp/tmp4k88kmi7.rs:10:69\n   |\n10 |         *w = w.chars().collect::<Vec<_>>().sort_by(|a,\
    \ b| a.cmp(b)).iter().collect();\n   |                                       \
    \                              ^^^^ method not found in `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659823243
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut words: Vec<String> = Vec::new();\n    let mut\
    \ current_word = String::new();\n    for ch in s.chars() {\n        if ch.is_whitespace()\
    \ {\n            words.push(current_word);\n            current_word = String::new();\n\
    \        } else {\n            current_word.push(ch);\n        }\n    }\n    if\
    \ !current_word.is_empty() {\n        words.push(current_word);\n    }\n    let\
    \ mut anti_shuffled = String::new();\n    for word in words {\n        if !anti_shuffled.is_empty()\
    \ {\n            anti_shuffled.push(' ');\n        }\n        let mut chars: Vec<char>\
    \ = word.chars().collect();\n        chars.sort();\n        for ch in chars {\n\
    \            anti_shuffled.push(ch);\n        }\n    }\n    anti_shuffled\n}\n\
    \nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823243
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    unimplemented!(\"Please, implement anti_shuffle for\
    \ string: {:?}\", s)\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n  \
    \  assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: Please, implement anti_shuffle
    for string: "Hi"'', /tmp/tmpeyw2ipo_.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823243
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    s.split_whitespace()\n        .map(|s| {\n        \
    \    let mut chars: Vec<char> = s.chars().collect();\n            chars.sort();\n\
    \            chars.into_iter().collect()\n        })\n        .collect::<Vec<String>>()\n\
    \        .join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n \
    \   assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823242
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut r: Vec<String> = s.split_whitespace().map(|x|\
    \ x.to_string()).collect();\n    for i in 0..r.len() {\n        let t: Vec<char>\
    \ = r[i].chars().collect();\n        r[i] = t.into_iter().sorted().collect();\n\
    \    }\n    r.join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sorted` found for struct `std::vec::IntoIter`\
    \ in the current scope\n  --> /tmp/tmpb63ga6px.rs:11:30\n   |\n11 |         r[i]\
    \ = t.into_iter().sorted().collect();\n   |                              ^^^^^^\
    \ method not found in `std::vec::IntoIter<char>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659823243
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    s.split(' ')\n        .map(|s| {\n            let mut\
    \ s = s.chars().collect::<Vec<_>>();\n            s.sort();\n            s.into_iter().collect::<String>()\n\
    \        })\n        .collect::<Vec<_>>()\n        .join(\" \")\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    s.split(' ')\n        .map(|s| {\n            let mut\
    \ chars: Vec<char> = s.chars().collect();\n            chars.sort();\n       \
    \     chars.into_iter().collect()\n        })\n        .collect::<Vec<String>>()\n\
    \        .join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n \
    \   assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut strs: Vec<String> = s.split(\" \").map(|s|\
    \ s.to_string()).collect();\n    strs.iter_mut().for_each(|s| s.retain(|c| c !=\
    \ ' '));\n    strs.iter_mut().for_each(|s| s.chars().collect::<Vec<char>>().sort());\n\
    \    let mut result = String::new();\n    for i in 0..strs.len() - 1 {\n     \
    \   result.push_str(&strs[i]);\n        result.push(' ');\n    }\n    result.push_str(&strs[strs.len()\
    \ - 1]);\n    result\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n  \
    \  assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hello\"`,\n right: `\"ehllo\"`', /tmp/tmpkup_4rjt.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823244
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for word in s.split_whitespace()\
    \ {\n        let mut letters: Vec<char> = word.chars().collect();\n        letters.sort();\n\
    \        result.push_str(&letters.iter().collect::<String>());\n        result.push('\
    \ ');\n    }\n    let s_len = result.len();\n    result.truncate(s_len - 1);\n\
    \    result\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp0hjnqru1.rs:16:21

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let s: Vec<&str> = s.split(\" \").collect();\n    let\
    \ mut res = Vec::with_capacity(s.len());\n    for word in s {\n        let word\
    \ = word.chars().collect::<Vec<char>>();\n        let mut sorted = word.clone();\n\
    \        sorted.sort();\n        if word != sorted {\n            res.push(sorted.iter().collect::<String>());\n\
    \        } else {\n            res.push(word.iter().collect::<String>());\n  \
    \      }\n    }\n    res.join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut splitted: Vec<String> = s.split(\" \").map(|x|\
    \ x.to_string()).collect();\n    for i in 0..splitted.len() {\n        let mut\
    \ chars: Vec<char> = splitted[i].chars().collect();\n        chars.sort();\n \
    \       splitted[i] = chars.into_iter().collect();\n    }\n    splitted.join(\"\
    \ \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut letters = s.chars().collect::<Vec<char>>();\n\
    \    let mut result = vec![];\n    let mut word = vec![];\n    while let Some(ch)\
    \ = letters.pop() {\n        match ch {\n            ' ' => {\n              \
    \  result.push(ch);\n                result.append(&mut word);\n             \
    \   word = vec![];\n            }\n            _ => word.push(ch),\n        }\n\
    \    }\n    result.append(&mut word);\n    result.reverse();\n    result.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hello\"`,\n right: `\"ehllo\"`', /tmp/tmptba5nihr.rs:29:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823244
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut shuffled = s.split_whitespace().map(|w| w.chars().collect::<Vec<_>>());\n\
    \    let mut res = s.split_whitespace().collect::<Vec<_>>();\n    for i in 0..res.len()\
    \ {\n        let mut word = shuffled.next().unwrap();\n        word.sort();\n\
    \        res[i] = word.iter().collect::<String>();\n    }\n    res.join(\" \"\
    )\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdo2922i_.rs:13:18\n   |\n\
    13 |         res[i] = word.iter().collect::<String>();\n   |                 \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |                  |\n   |             \
    \     expected `&str`, found struct `String`\n   |                  help: consider\
    \ borrowing here: `&word.iter().collect::<String>()`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659823243
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut split = s.split(\" \");\n    let mut output\
    \ = Vec::new();\n    for word in split {\n        let mut chars: Vec<char> = word.chars().collect();\n\
    \        chars.sort();\n        output.push(chars.into_iter().collect());\n  \
    \  }\n    output.join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n --> /tmp/tmpxg_ezeu4.rs:9:22\n\
    \  |\n9 |     let mut output = Vec::new();\n  |         ----------   ^^^^^^^^\
    \ cannot infer type for type parameter `T`\n  |         |\n  |         consider\
    \ giving `output` the explicit type `Vec<T>`, where the type parameter `T` is\
    \ specified\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659823243
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let words: Vec<String> = s.split_whitespace().map(|s|\
    \ s.to_string()).collect();\n    let mut res: Vec<String> = vec![];\n    for word\
    \ in words {\n        let mut chars: Vec<char> = word.chars().collect();\n   \
    \     chars.sort();\n        res.push(chars.into_iter().collect());\n    }\n \
    \   res.join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n   \
    \ assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut ss = s.split(\" \");\n    let mut out = Vec::new();\n\
    \    let mut tmp: Vec<char>;\n    for i in ss {\n        tmp = i.chars().collect();\n\
    \        tmp.sort();\n        out.push(tmp.iter().cloned().collect::<String>());\n\
    \    }\n    out.join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    // Should return \"abc efghijkl mnopqrstuvwxyz\"\n\
    \    let words: Vec<&str> = s.split_whitespace().collect();\n    let mut rs: Vec<String>\
    \ = vec![];\n    for w in words {\n        let mut r: Vec<char> = w.chars().collect();\n\
    \        r.sort();\n        rs.push(r.into_iter().collect());\n    }\n    rs.join(\"\
    \ \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let spl = s.split(\" \");\n    let mut buf = String::new();\n\
    \    for word in spl {\n        let mut chars: Vec<char> = word.chars().collect();\n\
    \        chars.sort();\n        buf.push_str(&chars.iter().collect::<String>());\n\
    \        buf.push(' ');\n    }\n    buf.trim().to_string()\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut chars: Vec<Vec<char>> = Vec::new();\n    let\
    \ mut word: Vec<char> = Vec::new();\n    for c in s.chars() {\n        if c ==\
    \ ' ' {\n            chars.push(word);\n            word = Vec::new();\n     \
    \   } else {\n            word.push(c);\n        }\n    }\n    chars.push(word);\n\
    \    let mut result: Vec<String> = Vec::new();\n    for word in chars {\n    \
    \    word.sort();\n        result.push(word.into_iter().collect());\n    }\n \
    \   result.join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `word` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmppzdroso4.rs:21:9\n   |\n20 |     for word in chars {\n\
    \   |         ---- help: consider changing this to be mutable: `mut word`\n21\
    \ |         word.sort();\n   |         ^^^^ cannot borrow as mutable\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659823244
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut words: Vec<Vec<u8>> = vec![];\n    let mut\
    \ word: Vec<u8> = vec![];\n    for c in s.chars() {\n        if c == ' ' {\n \
    \           if !word.is_empty() {\n                words.push(word);\n       \
    \         word = vec![];\n            }\n            words.push(vec![' ' as u8]);\n\
    \        } else {\n            word.push(c as u8);\n        }\n    }\n    if !word.is_empty()\
    \ {\n        words.push(word);\n    }\n    let mut result: Vec<u8> = vec![];\n\
    \    for word in words {\n        if word.len() == 1 {\n            result.extend(word);\n\
    \        } else {\n            result.extend(word.clone());\n            result.sort();\n\
    \        }\n    }\n    String::from_utf8(result).unwrap()\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\" !!!HWdellloor\"`,\n right: `\"Hello !!!Wdlor\"`', /tmp/tmp7j0t_pec.rs:42:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823244
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut words: Vec<String> = s.split_whitespace().map(String::from).collect();\n\
    \    for w in words.iter_mut() {\n        w.make_ascii_lowercase();\n        let\
    \ mut chars: Vec<char> = w.chars().collect();\n        chars.sort();\n       \
    \ *w = chars.into_iter().collect();\n    }\n    words.join(\" \")\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"Hi\"`', /tmp/tmp4axf672_.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    s.split_whitespace()\n        .map(|x| {\n        \
    \    let mut v: Vec<char> = x.chars().collect();\n            v.sort();\n    \
    \        v.into_iter().collect()\n        })\n        .collect::<Vec<String>>()\n\
    \        .join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n \
    \   assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    s.split_whitespace()\n        .map(|x| {\n        \
    \    let mut chars: Vec<char> = x.chars().collect();\n            chars.sort();\n\
    \            chars.into_iter().collect::<String>()\n        })\n        .collect::<Vec<String>>()\n\
    \        .join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n \
    \   assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823243
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let words: Vec<&str> = s.split(' ').collect();\n  \
    \  let mut output = String::new();\n    for word in words {\n        let chars:\
    \ Vec<char> = word.chars().collect();\n        let mut sorted_chars: Vec<char>\
    \ = chars.clone();\n        sorted_chars.sort();\n        let mut temp_word =\
    \ String::new();\n        for i in 0..chars.len() {\n            temp_word +=\
    \ &sorted_chars[i].to_string();\n        }\n        output += &temp_word;\n  \
    \      output += \" \";\n    }\n    output.trim().to_string()\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut t = String::new();\n    for i in s.split_whitespace()\
    \ {\n        let mut chars: Vec<char> = i.chars().collect();\n        chars.sort();\n\
    \        for j in chars {\n            t.push(j);\n        }\n        t.push('\
    \ ');\n    }\n    t.pop();\n    t\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut words: Vec<String> = s.split(\" \").map(|e|\
    \ e.to_string()).collect();\n    let mut result = String::new();\n    for i in\
    \ 0..words.len() {\n        let mut word = words[i].clone();\n        word.chars().map(|e|\
    \ e as u8).sorted();\n        result.push_str(&word);\n        if i != words.len()\
    \ - 1 {\n            result.push(' ');\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sorted` found for struct `Map` in the current\
    \ scope\n  --> /tmp/tmpgi76yo7_.rs:12:39\n   |\n12 |         word.chars().map(|e|\
    \ e as u8).sorted();\n   |                                       ^^^^^^ method\
    \ not found in `Map<Chars<'_>, [closure@/tmp/tmpgi76yo7_.rs:12:26: 12:37]>`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    s.split_whitespace()\n        .map(|s| {\n        \
    \    let mut word: Vec<_> = s.chars().collect();\n            word.sort();\n \
    \           word.into_iter().collect()\n        })\n        .collect::<Vec<String>>()\n\
    \        .join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n \
    \   assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut ans = String::new();\n    let mut start = 0;\n\
    \    for (i, c) in s.char_indices() {\n        if c == ' ' {\n            let\
    \ mut word = String::new();\n            for c in s[start..i].chars().collect::<Vec<char>>().iter()\
    \ {\n                word.push(*c);\n            }\n            ans.push_str(&word.chars().sorted().collect::<String>());\n\
    \            ans.push(c);\n            start = i + 1;\n        }\n    }\n    let\
    \ mut word = String::new();\n    for c in s[start..].chars().collect::<Vec<char>>().iter()\
    \ {\n        word.push(*c);\n    }\n    ans.push_str(&word.chars().sorted().collect::<String>());\n\
    \    ans\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sorted` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmpx_vo5nt4.rs:16:40\n   |\n16 |             ans.push_str(&word.chars().sorted().collect::<String>());\n\
    \   |                                        ^^^^^^ method not found in `Chars<'_>`\n\
    \nerror[E0599]: no method named `sorted` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmpx_vo5nt4.rs:25:32\n   |\n25 |     ans.push_str(&word.chars().sorted().collect::<String>());\n\
    \   |                                ^^^^^^ method not found in `Chars<'_>`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let words: Vec<&str> = s.split(' ').collect();\n  \
    \  let res: Vec<String> = words.iter().map(|word| {\n        let mut c: Vec<char>\
    \ = word.chars().collect();\n        c.sort();\n        c.into_iter().collect()\n\
    \    }).collect();\n    res.join(\" \")\n}\n\nfn main() {\n    let candidate =\
    \ anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut words: Vec<String> = s.split(\" \").map(|x|\
    \ x.to_string()).collect();\n    for mut word in &mut words {\n        word.make_ascii_lowercase();\n\
    \        word.chars().map(|c| c).collect::<Vec<char>>();\n    }\n    let mut chars:\
    \ Vec<Vec<char>> = words.iter().map(|w| w.chars().collect()).collect();\n    for\
    \ mut chars in &mut chars {\n        chars.sort();\n    }\n    let mut res: Vec<String>\
    \ = chars.iter().map(|v| v.iter().cloned().collect()).collect();\n    res.join(\"\
    \ \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"Hi\"`', /tmp/tmpsvo9hx9b.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823244
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut words: Vec<String> = s.split_whitespace().map(|w|\
    \ w.to_string()).collect();\n    words.sort_by(|a, b| a.chars().collect::<Vec<char>>().clone().as_slice().cmp(b.chars().collect::<Vec<char>>().clone().as_slice()));\n\
    \    let mut result = String::new();\n    for (i, w) in words.iter().enumerate()\
    \ {\n        if i != 0 {\n            result.push_str(\" \");\n        }\n   \
    \     result.push_str(w);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hello\"`,\n right: `\"ehllo\"`', /tmp/tmp5vmgokfb.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    s.split(' ')\n        .map(|w| {\n            let mut\
    \ v: Vec<char> = w.chars().collect();\n            v.sort();\n            v.into_iter().collect()\n\
    \        })\n        .collect::<Vec<String>>()\n        .join(\" \")\n}\n\nfn\
    \ main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s: Vec<&str> = s.split(\" \").collect();\n\
    \    for w in s.iter_mut() {\n        let mut ch: Vec<char> = w.chars().collect();\n\
    \        ch.sort();\n        *w = ch.iter().collect::<String>().as_str();\n  \
    \  }\n    s.join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmpcnsd8x2v.rs:12:14\n\
    \   |\n9  |     for w in s.iter_mut() {\n   |              ------------ borrow\
    \ later used here\n...\n12 |         *w = ch.iter().collect::<String>().as_str();\n\
    \   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^         - temporary value is\
    \ freed at the end of this statement\n   |              |\n   |              creates\
    \ a temporary which is freed while still in use\n   |\n   = note: consider using\
    \ a `let` binding to create a longer lived value\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0716`.\n"
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut words: Vec<String> = s.split_whitespace().map(|word|\
    \ {\n        let mut chars: Vec<char> = word.chars().collect();\n        chars.sort();\n\
    \        chars.into_iter().collect()\n    }).collect();\n    words.join(\" \"\
    )\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let words: Vec<&str> = s.split_whitespace().collect();\n\
    \    let mut res = String::new();\n    for word in words {\n        res += &mut\
    \ String::from(\n            word.chars()\n                .collect::<Vec<char>>()\n\
    \                .sort_by(|a, b| a.cmp(b))\n                .iter()\n        \
    \        .collect::<String>(),\n        );\n        res += \" \";\n    }\n   \
    \ res.trim().to_string()\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for unit type `()` in the current\
    \ scope\n  --> /tmp/tmp124oeyca.rs:15:18\n   |\n15 |                 .iter()\n\
    \   |                  ^^^^ method not found in `()`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659823244
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    unimplemented!(\"anti_shuffle(\\\"{}\\\")\", s)\n}\n\
    \nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: anti_shuffle("Hi")'', /tmp/tmpu_ftpg_l.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823244
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut words: Vec<_> = s.split(' ').collect();\n \
    \   for i in 0..words.len() {\n        let mut chars: Vec<_> = words[i].chars().collect();\n\
    \        chars.sort();\n        words[i] = chars.into_iter().collect();\n    }\n\
    \    words.join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `&str` cannot be built from an iterator over\
    \ elements of type `char`\n  --> /tmp/tmp_3g6qmno.rs:12:38\n   |\n12 |       \
    \  words[i] = chars.into_iter().collect();\n   |                             \
    \         ^^^^^^^ value of type `&str` cannot be built from `std::iter::Iterator<Item=char>`\n\
    \   |\n   = help: the trait `FromIterator<char>` is not implemented for `&str`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823244
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut ans = String::new();\n    let mut words = Vec::new();\n\
    \    for c in s.chars() {\n        if c == ' ' {\n            if !words.is_empty()\
    \ {\n                ans.push_str(&words.join(\"\"));\n                words.clear();\n\
    \            }\n            ans.push(' ');\n        } else {\n            words.push(c);\n\
    \        }\n    }\n    if !words.is_empty() {\n        ans.push_str(&words.join(\"\
    \"));\n    }\n    ans\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n \
    \   assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `char: Borrow<str>` is not satisfied\n  -->\
    \ /tmp/tmpg3xnqgn8.rs:13:37\n   |\n13 |                 ans.push_str(&words.join(\"\
    \"));\n   |                                     ^^^^ the trait `Borrow<str>` is\
    \ not implemented for `char`\n   |\n   = note: required because of the requirements\
    \ on the impl of `Join<&str>` for `[char]`\n\nerror[E0599]: the method `join`\
    \ exists for struct `Vec<char>`, but its trait bounds were not satisfied\n  -->\
    \ /tmp/tmpg3xnqgn8.rs:22:29\n   |\n22 |         ans.push_str(&words.join(\"\"\
    ));\n   |                             ^^^^ method cannot be called on `Vec<char>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<[char] as Join<_>>::Output = _`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823244
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut ret = String::new();\n    let mut buffer =\
    \ String::new();\n    for c in s.chars() {\n        if c == ' ' {\n          \
    \  ret.push_str(&buffer);\n            ret.push(' ');\n            buffer.clear();\n\
    \        } else {\n            buffer.push(c);\n        }\n    }\n    ret.push_str(&buffer);\n\
    \    ret\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hello\"`,\n right: `\"ehllo\"`', /tmp/tmpc_qzipsu.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut words: Vec<String> = s.split_whitespace().map(String::from).collect();\n\
    \    for word in words.iter_mut() {\n        let mut chars: Vec<char> = word.chars().collect();\n\
    \        chars.sort();\n        *word = chars.into_iter().collect();\n    }\n\
    \    words.join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let words: Vec<&str> = s.split_whitespace().collect();\n\
    \    let output = words\n        .iter()\n        .map(|w| {\n            let\
    \ mut chars: Vec<char> = w.chars().collect();\n            chars.sort();\n   \
    \         chars.iter().collect::<String>()\n        })\n        .collect::<Vec<String>>()\n\
    \        .join(\" \");\n    output\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut words: Vec<&str> = s.split(\" \").collect();\n\
    \    for word in words.iter_mut() {\n        let mut chars: Vec<char> = word.chars().collect();\n\
    \        chars.sort();\n        *word = chars.iter().collect();\n    }\n    words.join(\"\
    \ \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `&str` cannot be built from an iterator over\
    \ elements of type `&char`\n  --> /tmp/tmpt8oozngp.rs:12:30\n   |\n12 |      \
    \   *word = chars.iter().collect();\n   |                              ^^^^^^^\
    \ value of type `&str` cannot be built from `std::iter::Iterator<Item=&char>`\n\
    \   |\n   = help: the trait `FromIterator<&char>` is not implemented for `&str`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823244
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut words: Vec<&str> = s.split(\" \").collect();\n\
    \    for w in words.iter_mut() {\n        let mut chars: Vec<char> = w.chars().collect();\n\
    \        chars.sort();\n        *w = chars.iter().collect::<String>().as_str();\n\
    \    }\n    words.join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmplrgasgxv.rs:12:14\n\
    \   |\n9  |     for w in words.iter_mut() {\n   |              ----------------\
    \ borrow later used here\n...\n12 |         *w = chars.iter().collect::<String>().as_str();\n\
    \   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^         - temporary value\
    \ is freed at the end of this statement\n   |              |\n   |           \
    \   creates a temporary which is freed while still in use\n   |\n   = note: consider\
    \ using a `let` binding to create a longer lived value\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0716`.\n"
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut words: Vec<String> = s.split_whitespace().map(|w|\
    \ {\n        let mut chars: Vec<char> = w.chars().collect();\n        chars.sort();\n\
    \        chars.into_iter().collect()\n    }).collect();\n    let mut str = String::new();\n\
    \    for word in words {\n        str.push_str(&word);\n        str.push(' ');\n\
    \    }\n    return str.trim().to_string();\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut words: Vec<String> = Vec::new();\n    let mut\
    \ acc: String = String::new();\n    for c in s.chars() {\n        if c == ' '\
    \ {\n            words.push(acc);\n            acc = String::new();\n        }\
    \ else {\n            acc.push(c);\n        }\n    }\n    words.push(acc);\n \
    \   let mut result: String = String::new();\n    for w in words {\n        result.push_str(&String::from(\n\
    \            w.chars()\n                .sorted()\n                .collect::<String>()\n\
    \                .as_str(),\n        ));\n        result.push(' ');\n    }\n \
    \   String::from(result.trim())\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sorted` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmpqxbohnnr.rs:23:18\n   |\n23 |                 .sorted()\n\
    \   |                  ^^^^^^ method not found in `Chars<'_>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    s.split_whitespace()\n        .map(|word| {\n     \
    \       let mut chars: Vec<char> = word.chars().collect();\n            chars.sort();\n\
    \            chars.into_iter().collect()\n        })\n        .collect::<Vec<String>>()\n\
    \        .join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n \
    \   assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    s.split_whitespace()\n        .map(|s| {\n        \
    \    let mut chars: Vec<char> = s.chars().collect();\n            chars.sort();\n\
    \            chars.into_iter().collect()\n        })\n        .collect::<Vec<String>>()\n\
    \        .join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n \
    \   assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823242
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpy_3u_j4j.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823241
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmppx3ge1jq.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut v: Vec<char> = s.chars().collect();\n    let\
    \ mut i = 0;\n    let len = v.len();\n    while i < len {\n        if v[i] ==\
    \ ' ' {\n            i += 1;\n            continue;\n        }\n        let mut\
    \ j = i + 1;\n        while j < len && v[j] != ' ' {\n            j += 1;\n  \
    \      }\n        v[i..j].sort();\n        i = j;\n    }\n    v.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmppx3ge1jq.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    return s\n        .split_whitespace()\n        .map(|s|\
    \ {\n            let mut s: Vec<char> = s.chars().collect();\n            s.sort();\n\
    \            s.iter().collect()\n        })\n        .collect::<Vec<String>>()\n\
    \        .join(\" \");\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut buf = String::new();\n    let mut split = s.split_whitespace();\n\
    \    while let Some(w) = split.next() {\n        if !buf.is_empty() {\n      \
    \      buf.push(' ');\n        }\n        let mut chars: Vec<char> = w.chars().collect();\n\
    \        chars.sort();\n        for c in chars {\n            buf.push(c);\n \
    \       }\n    }\n    buf\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut sorted_words: Vec<String> = s\n        .split_whitespace()\n\
    \        .map(|x| {\n            let mut word = x.chars().collect::<Vec<char>>();\n\
    \            word.sort();\n            word.into_iter().collect::<String>()\n\
    \        })\n        .collect();\n    sorted_words.sort();\n    sorted_words.join(\"\
    \ \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"!!!Wdlor Hello\"`,\n right: `\"Hello !!!Wdlor\"`', /tmp/tmpz7c1e71w.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    s.split_whitespace()\n        .map(|word| {\n     \
    \       let mut chars: Vec<char> = word.chars().collect();\n            chars.sort();\n\
    \            chars.into_iter().collect()\n        })\n        .collect::<Vec<String>>()\n\
    \        .join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n \
    \   assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut vs: Vec<&str> = s.split(\" \").collect();\n\
    \    vs.sort_by(|a, b| {\n        let mut ac: Vec<char> = a.chars().collect();\n\
    \        let mut bc: Vec<char> = b.chars().collect();\n        ac.sort();\n  \
    \      bc.sort();\n        let sa: String = ac.into_iter().collect();\n      \
    \  let sb: String = bc.into_iter().collect();\n        sa.cmp(&sb)\n    });\n\
    \    vs.join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n   \
    \ assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hello\"`,\n right: `\"ehllo\"`', /tmp/tmp__h2qfs1.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut res = vec![];\n    for w in s.split_whitespace()\
    \ {\n        let mut chars: Vec<char> = w.chars().collect();\n        chars.sort();\n\
    \        res.push(chars.into_iter().collect::<String>());\n    }\n    res.join(\"\
    \ \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut sentence: Vec<&str> = s.split_whitespace().collect();\n\
    \    let mut words: Vec<String> = Vec::new();\n    for word in sentence {\n  \
    \      let mut chars: Vec<char> = word.chars().collect();\n        chars.sort();\n\
    \        words.push(chars.into_iter().collect());\n    }\n    words.join(\" \"\
    )\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut res = String::new();\n    for i in s.split_whitespace()\
    \ {\n        let mut v: Vec<_> = i.chars().collect();\n        v.sort();\n   \
    \     res.push_str(&v.iter().collect::<String>());\n        res.push(' ');\n \
    \   }\n    res.pop();\n    res\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut res = String::new();\n    for word in s.split_whitespace()\
    \ {\n        let mut chars: Vec<char> = word.chars().collect();\n        chars.sort();\n\
    \        res.push_str(&chars.iter().collect::<String>());\n        res.push('\
    \ ');\n    }\n    res.pop();\n    res\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    s.split(' ')\n        .map(|w| {\n            let mut\
    \ chars: Vec<char> = w.chars().collect();\n            chars.sort();\n       \
    \     chars.into_iter().collect()\n        })\n        .collect::<Vec<String>>()\n\
    \        .join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n \
    \   assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut words: Vec<&str> = s.split_whitespace().collect();\n\
    \    for word in words.iter_mut() {\n        let mut chars: Vec<char> = word.chars().collect();\n\
    \        chars.sort();\n        *word = chars.iter().collect();\n    }\n    words.join(\"\
    \ \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `&str` cannot be built from an iterator over\
    \ elements of type `&char`\n  --> /tmp/tmpw5w9gphz.rs:12:30\n   |\n12 |      \
    \   *word = chars.iter().collect();\n   |                              ^^^^^^^\
    \ value of type `&str` cannot be built from `std::iter::Iterator<Item=&char>`\n\
    \   |\n   = help: the trait `FromIterator<&char>` is not implemented for `&str`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823245
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    // TODO: Write a function that takes a string and returns\
    \ an ordered version of it.\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hello\"`,\n right: `\"ehllo\"`', /tmp/tmpzicxyxl8.rs:15:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823245
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s: Vec<char> = s.chars().collect();\n    let\
    \ len = s.len();\n    let mut beg = 0;\n    for i in 0..len {\n        if s[i]\
    \ == ' ' {\n            let end = i;\n            anti_shuffle_internal(&mut s,\
    \ beg, end);\n            beg = i + 1;\n        }\n    }\n    anti_shuffle_internal(&mut\
    \ s, beg, len);\n    s.into_iter().collect()\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `anti_shuffle_internal` in this scope\n\
    \  --> /tmp/tmpju478i8h.rs:14:13\n   |\n14 |             anti_shuffle_internal(&mut\
    \ s, beg, end);\n   |             ^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `anti_shuffle_internal` in this scope\n \
    \ --> /tmp/tmpju478i8h.rs:18:5\n   |\n18 |     anti_shuffle_internal(&mut s, beg,\
    \ len);\n   |     ^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823244
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut chars = s.chars().collect::<Vec<char>>();\n\
    \    let mut chars2 = s.chars().collect::<Vec<char>>();\n    chars.sort();\n \
    \   chars2.sort_by(|x, y| y.cmp(x));\n    let mut index = 0;\n    for i in 0..s.len()\
    \ {\n        if s.chars().nth(i).unwrap().is_ascii_uppercase() {\n           \
    \ if chars2[index] != s.chars().nth(i).unwrap() {\n                chars[index]\
    \ = chars2[index].to_ascii_uppercase();\n            }\n            index += 1;\n\
    \        }\n    }\n    chars.iter().collect()\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Ii\"`,\n right: `\"Hi\"`', /tmp/tmp_hup7utu.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823245
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpy_3u_j4j.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823241
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut new_words = Vec::new();\n    for word in s.split(\"\
    \ \") {\n        let mut chars: Vec<char> = word.chars().collect();\n        chars.sort();\n\
    \        new_words.push(chars.into_iter().collect());\n    }\n    new_words.join(\"\
    \ \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n --> /tmp/tmpu1nlf6tk.rs:8:25\n\
    \  |\n8 |     let mut new_words = Vec::new();\n  |         -------------   ^^^^^^^^\
    \ cannot infer type for type parameter `T`\n  |         |\n  |         consider\
    \ giving `new_words` the explicit type `Vec<T>`, where the type parameter `T`\
    \ is specified\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    s.split(' ')\n        .map(|w| {\n            let mut\
    \ w = w.chars().collect::<Vec<_>>();\n            w.sort();\n            w.into_iter().collect::<String>()\n\
    \        })\n        .collect::<Vec<_>>()\n        .join(\" \")\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut words: Vec<_> = s.split(' ').collect();\n \
    \   words.sort_by(|w1, w2| w1.cmp(w2));\n    let mut s = String::new();\n    for\
    \ word in words {\n        s.push_str(word);\n        s.push(' ');\n    }\n  \
    \  s.pop();\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hello\"`,\n right: `\"ehllo\"`', /tmp/tmpsns724hn.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut v = Vec::new();\n    for word in s.split(\"\
    \ \") {\n        let mut chars: Vec<char> = word.chars().collect();\n        chars.sort();\n\
    \        v.push(chars.into_iter().collect::<String>());\n    }\n    v.join(\"\
    \ \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut s = s.split(\" \").collect::<Vec<&str>>();\n\
    \    s.iter_mut().for_each(|w| *w = &w.chars().sorted().collect::<String>());\n\
    \    s.join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sorted` found for struct `Chars` in the\
    \ current scope\n --> /tmp/tmpx3nipld0.rs:9:47\n  |\n9 |     s.iter_mut().for_each(|w|\
    \ *w = &w.chars().sorted().collect::<String>());\n  |                        \
    \                       ^^^^^^ method not found in `Chars<'_>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659823245
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut space\
    \ = false;\n    for c in s.chars() {\n        if c == ' ' {\n            space\
    \ = true;\n            result.push(' ');\n        } else {\n            if space\
    \ {\n                space = false;\n                result.push_str(\n      \
    \              &c.to_string()\n                        .chars()\n            \
    \            .collect::<Vec<char>>()\n                        .sort_by(|a, b|\
    \ a.cmp(b))\n                        .iter()\n                        .cloned()\n\
    \                        .collect::<String>(),\n                );\n         \
    \   } else {\n                result.push(c);\n            }\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for unit type `()` in the current\
    \ scope\n  --> /tmp/tmpkmy09cfo.rs:22:26\n   |\n22 |                         .iter()\n\
    \   |                          ^^^^ method not found in `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut chars = s.chars().collect::<Vec<char>>();\n\
    \    let mut start = 0;\n    let mut end = 0;\n    while start < chars.len() {\n\
    \        if chars[start] == ' ' {\n            start += 1;\n            end +=\
    \ 1;\n        } else {\n            while end < chars.len() && chars[end] != '\
    \ ' {\n                end += 1;\n            }\n            let mut word = &mut\
    \ chars[start..end];\n            word.sort();\n            start = end;\n   \
    \     }\n    }\n    chars.into_iter().collect()\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    s.split_whitespace()\n        .map(|word| {\n     \
    \       let mut chars: Vec<char> = word.chars().collect();\n            chars.sort();\n\
    \            chars.into_iter().collect()\n        })\n        .collect::<Vec<String>>()\n\
    \        .join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n \
    \   assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    s.split(' ')\n        .map(|word| {\n            let\
    \ mut w = word.chars().collect::<Vec<char>>();\n            w.sort();\n      \
    \      w.into_iter().collect::<String>()\n        })\n        .collect::<Vec<String>>()\n\
    \        .join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n \
    \   assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    // Note: Could implement sort of the chars in place,\
    \ but this is cleaner\n    s.split(' ')\n        .map(|chars| {\n            let\
    \ mut result: Vec<char> = chars.chars().collect();\n            result.sort();\n\
    \            result.iter().collect::<String>()\n        })\n        .collect::<Vec<String>>()\n\
    \        .join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n \
    \   assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let words: Vec<&str> = s.split_whitespace().collect();\n\
    \    let mut results: Vec<String> = vec![];\n    for word in words {\n       \
    \ let mut chars: Vec<char> = word.chars().collect();\n        chars.sort();\n\
    \        results.push(chars.into_iter().collect());\n    }\n    results.join(\"\
    \ \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    s.split(' ')\n        .map(|word| {\n            let\
    \ mut chars: Vec<char> = word.chars().collect();\n            chars.sort();\n\
    \            chars.into_iter().collect()\n        })\n        .collect::<Vec<String>>()\n\
    \        .join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n \
    \   assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    s.split_whitespace()\n        .map(|w| {\n        \
    \    let mut chars: Vec<char> = w.chars().collect();\n            chars.sort();\n\
    \            chars.into_iter().collect()\n        })\n        .collect::<Vec<String>>()\n\
    \        .join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n \
    \   assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmppx3ge1jq.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823241
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut words: Vec<String> = s.split_whitespace().map(String::from).collect();\n\
    \    for word in words.iter_mut() {\n        *word = sort_chars(word);\n    }\n\
    \    words.join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sort_chars` in this scope\n  --> /tmp/tmpj0v7d4fy.rs:10:17\n\
    \   |\n10 |         *word = sort_chars(word);\n   |                 ^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for word in s.split_whitespace()\
    \ {\n        let mut chars: Vec<char> = word.chars().collect();\n        chars.sort();\n\
    \        result.push_str(&chars.iter().collect::<String>());\n        result.push('\
    \ ');\n    }\n    result.pop();\n    result\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let re = Regex::new(r\"\\s+\").unwrap();\n    let mut\
    \ strings: Vec<String> = Vec::new();\n    let mut result: String = String::new();\n\
    \    for word in re.split(&s) {\n        let mut letters: Vec<char> = word.chars().collect();\n\
    \        letters.sort();\n        strings.push(letters.into_iter().collect());\n\
    \    }\n    for word in strings {\n        result.push_str(&word);\n        result.push('\
    \ ');\n    }\n    result.pop();\n    result\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmptmnh2jfe.rs:8:14\n\
    \  |\n8 |     let re = Regex::new(r\"\\s+\").unwrap();\n  |              ^^^^^\
    \ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut list: Vec<&str> = s.split(\" \").collect();\n\
    \    let mut list_str: Vec<String> = Vec::new();\n    for w in list {\n      \
    \  let mut chars: Vec<char> = w.chars().collect();\n        chars.sort();\n  \
    \      let w_str: String = chars.into_iter().collect();\n        list_str.push(w_str);\n\
    \    }\n    list_str.join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823246
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut new = s.split(\" \").map(|word| {\n       \
    \ let mut chars: Vec<char> = word.chars().collect();\n        chars.sort();\n\
    \        chars.into_iter().collect::<String>()\n    }).collect::<Vec<String>>();\n\
    \    new.join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n  \
    \  assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823246
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let v: Vec<&str> = s.split(' ').collect();\n    let\
    \ mut r = String::new();\n    for i in v {\n        let mut t = i.chars().collect::<Vec<char>>();\n\
    \        t.sort();\n        let m = t.into_iter().collect::<String>();\n     \
    \   r.push_str(&m);\n        r.push(' ');\n    }\n    r.pop();\n    r\n}\n\nfn\
    \ main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823246
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for word in s.split_whitespace()\
    \ {\n        if !result.is_empty() {\n            result.push(' ');\n        }\n\
    \        result.push_str(&word.chars().sorted().collect::<String>());\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sorted` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmpl4g98uzv.rs:13:39\n   |\n13 |         result.push_str(&word.chars().sorted().collect::<String>());\n\
    \   |                                       ^^^^^^ method not found in `Chars<'_>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut v = Vec::new();\n    for word in s.split_whitespace()\
    \ {\n        let mut chars: Vec<char> = word.chars().collect();\n        chars.sort();\n\
    \        v.push(chars.into_iter().collect::<String>());\n    }\n    v.join(\"\
    \ \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823246
- exit_code: 0
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut split = s.split_whitespace();\n    let mut\
    \ result = String::new();\n    while let Some(word) = split.next() {\n       \
    \ let mut chars: Vec<char> = word.chars().collect();\n        chars.sort();\n\
    \        result.push_str(&chars.iter().collect::<String>());\n        result.push('\
    \ ');\n    }\n    result.pop();\n    result\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823246
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    let mut words: Vec<String> = Vec::new();\n    let mut\
    \ word: String = String::new();\n    for ch in s.chars() {\n        if ch == '\
    \ ' {\n            words.push(word);\n            word = String::new();\n    \
    \    } else {\n            word.push(ch);\n        }\n    }\n    words.push(word);\n\
    \    let mut rev_words: Vec<String> = Vec::new();\n    for mut word in words {\n\
    \        word.chars().into_iter().collect::<Vec<char>>().sort();\n        rev_words.push(word);\n\
    \    }\n    rev_words.join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hello\"`,\n right: `\"ehllo\"`', /tmp/tmppqhurrwq.rs:30:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823246
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\nfn anti_shuffle(s:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmppx3ge1jq.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823241
