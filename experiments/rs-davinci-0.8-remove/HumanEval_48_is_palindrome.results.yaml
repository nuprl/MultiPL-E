language: rs
name: HumanEval_48_is_palindrome
results:
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut c: char;\n    let mut chars: Vec<char> = Vec::new();\n\
    \    for c in text.chars() {\n        if c.is_alphanumeric() {\n            chars.push(c.to_lowercase().next().unwrap());\n\
    \        }\n    }\n    let n = chars.len();\n    for i in 0..n/2 {\n        if\
    \ chars[i] != chars[n-i-1] {\n            return false;\n        }\n    }\n  \
    \  return true;\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().eq(text.chars().rev())\n}\n\nfn main() {\n    let\
    \ candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n\
    \    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 1
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n+\ttext.chars().rev().eq(text.chars())\n+}\n+\n+#[test]\n+fn test_is_palindrome()\
    \ {\n+\tassert!(is_palindrome(\"racecar\".to_string()));\n+\tassert!(is_palindrome(\"\
    kayak\".to_string()));\n+\tassert!(is_palindrome(\"kinnikinnik\".to_string()));\n\
    +\tassert!(is_palindrome(\"otto\".to_string()));\n+\tassert!(is_palindrome(\"\"\
    .to_string()));\n+\tassert!(is_palindrome(\"a\".to_string()));\n+\tassert!(is_palindrome(\"\
    aa\".to_string()));\n+\tassert!(is_palindrome(\"bob\".to_string()));\n+\tassert!(is_palindrome(\"\
    noon\".to_string()));\n+\tassert!(is_palindrome(\"radar\".to_string()));\n+\t\
    assert!(is_palindrome(\"radar\".to_string()));\n+\n+\tassert!(!is_palindrome(\"\
    racecars\".to_string()));\n+\tassert!(!is_palindrome(\"hello world\".to_string()));\n\
    +\tassert!(!is_palindrome(\"abbccbba\".to_string()));\n+\tassert!(!is_palindrome(\"\
    abcdcba\".to_string()));\n+\tassert!(!is_palindrome(\"aabcdcbaa\".to_string()));\n\
    +\tassert!(!is_palindrome(\"abccba\".to_string()));\n+\tassert!(!is_palindrome(\"\
    abccba\".to_string()));\n+\tassert!(!is_palindrome(\"abcba\".to_string()));\n\
    +\tassert!(!is_palindrome(\"abcddcba\".to_string()));\n+\tassert!(!is_palindrome(\"\
    abcdedcba\".to_string()));\n+\tassert!(!is_palindrome(\"abcdedcba\".to_string()));\n\
    +\tassert!(\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected expression, found `+`\n --> /tmp/tmpqnnqnloo.rs:3:1\n \
    \ |\n3 | +    text.chars().rev().eq(text.chars())\n  | ^ expected expression\n\
    \nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpqnnqnloo.rs:31:10\n\
    \   |\n7  | +fn test_is_palindrome() {\n   |                          - closing\
    \ delimiter possibly meant for this\n...\n31 | +    assert!(\n   |           \
    \  ^ unclosed delimiter\n32 | }\n   | ^ mismatched closing delimiter\n\nerror:\
    \ expected item, found `+`\n --> /tmp/tmpqnnqnloo.rs:5:1\n  |\n5 | +\n  | ^ expected\
    \ item\n\nerror: aborting due to 3 previous errors\n\n"
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().eq(text.chars().rev())\n}\n\nfn main() {\n    let\
    \ candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n\
    \    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let result = text.chars().rev().collect::<String>();\n    if\
    \ text == result {\n        return true;\n    }\n    false\n}\n\nfn main() {\n\
    \    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut chars: Vec<char> = text.chars().collect();\n    let mut\
    \ reverse_chars: Vec<char> = chars.clone();\n    reverse_chars.reverse();\n  \
    \  reverse_chars == chars\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 101
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n\tlet bytes = text.into_bytes();\n\tlet mid = bytes.len() / 2;\n\t\
    let mut i = 0;\n\tlet mut j = bytes.len() - 1;\n\twhile i < mid {\n\t\tif bytes[i]\
    \ != bytes[j] {\n\t\t\treturn false;\n\t\t}\n\t\ti += 1;\n\t\tj -= 1;\n\t}\n\t\
    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp90o3ejzl.rs:6:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let chars: Vec<char> = text.chars().collect();\n    let length\
    \ = chars.len();\n    let half_length = length / 2;\n\n    if length <= 1 {\n\
    \        return true;\n    }\n\n    for i in 0..half_length {\n        if chars[i]\
    \ != chars[length - i - 1] {\n            return false;\n        }\n    }\n\n\
    \    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.as_bytes().iter().zip(text.as_bytes().iter().rev()).all(|(l,\
    \ r)| l == r)\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut chars = text.chars();\n    let mut rev_chars = text.chars().rev();\n\
    \n    loop {\n        match (chars.next(), rev_chars.next()) {\n            (Some(c),\
    \ Some(rc)) => {\n                if c != rc {\n                    return false;\n\
    \                }\n            }\n            (None, None) => {\n           \
    \     return true;\n            }\n            _ => {\n                return\
    \ false;\n            }\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let text_vec: Vec<char> = text.chars().collect();\n    for i\
    \ in 0..text_vec.len() / 2 {\n        if text_vec[i] != text_vec[text_vec.len()\
    \ - i - 1] {\n            return false;\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut chars: Vec<char> = text.chars().collect();\n    chars.reverse();\n\
    \    text == chars.into_iter().collect::<String>()\n}\n\nfn main() {\n    let\
    \ candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n\
    \    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    // Store the current text\n    let current_text = text.clone();\n\
    \n    // Reverse the text and compare if both are equal\n    current_text == text.chars().rev().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 101
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut left = 0;\n    let mut right = text.len() - 1;\n\n  \
    \  while left < right {\n        if text.chars().nth(left) != text.chars().nth(right)\
    \ {\n            return false;\n        }\n\n        left += 1;\n        right\
    \ -= 1;\n    }\n\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmprneshmor.rs:4:21

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822437
- exit_code: 101
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let count = text.len();\n    let mut i = 0;\n    let mut j =\
    \ count - 1;\n    while i < j {\n        if text.as_bytes()[i] != text.as_bytes()[j]\
    \ {\n            return false;\n        }\n        i += 1;\n        j -= 1;\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpm_z3lk1j.rs:5:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    if text.len() < 2 {\n        return true;\n    }\n    let first_char\
    \ = &text[0..1];\n    let last_char = &text[text.len() - 1..text.len()];\n   \
    \ if first_char != last_char {\n        return false;\n    }\n    return is_palindrome(text[1..text.len()\
    \ - 1].to_string());\n}\n\nfn main() {\n    let candidate = is_palindrome;\n \
    \   assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut chars = text.chars();\n    let mut rev_chars = text.chars().rev();\n\
    \n    loop {\n        let l = chars.next();\n        let r = rev_chars.next();\n\
    \n        if l == None || r == None {\n            return true;\n        }\n\n\
    \        if l != r {\n            return false;\n        }\n    }\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: -1
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut count = 0;\n    let len = text.len();\n    let mut chars\
    \ = text.chars();\n    loop {\n        let a = chars.next();\n        let b =\
    \ chars.next_back();\n        if a != b {\n            return false;\n       \
    \ }\n        count += 1;\n        if count == len / 2 {\n            break;\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659822442
- exit_code: 1
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n+    let length = text.len();\n+    for i in 0..length / 2 {\n- \
    \       if text.chars().nth(i) != text.chars().nth(length - i - 1) {\n+      \
    \  if text.chars().nth(i) != text.chars().nth(length - i - 1) {\n            \
    \ return false;\n         }\n     }\n     true\n }\n@@ -23,4 +23,4 @@ fn main()\
    \ {\n     }\n }\n ```\n-![](C:\\Users\\Parth\\Documents\\GitHub\\rust-playground\\\
    palindrome\\test.png)\n\\ No newline at end of file\n+![](test.png)\n\\ No newline\
    \ at end of file\n```\n\n> Automatic reformatting (`rustfmt`) is currently not\
    \ supported.\n\n### Previewing\n\n![preview](preview.gif)\n\n### TODO\n\n- [ ]\
    \ Save file on reformat\n- [ ] Automatically format code\n- [ ] Add more languages\n\
    - [ ] Run code (with support for more languages)\n- [ ] Add more code examples\n\
    - [ ] Run code with examples\n- [ ] Show comparison for large changes\n- [ ] Add\
    \ tests\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: unknown start of token: `\n  --> /tmp/tmpj6m_m_pq.rs:15:2\n   |\n\
    15 |  ```\n   |  ^\n   |\nhelp: Unicode character '`' (Grave Accent) looks like\
    \ ''' (Single Quote), but it is not\n   |\n15 |  '``\n   |  ~\n\nerror: unknown\
    \ start of token: `\n  --> /tmp/tmpj6m_m_pq.rs:15:3\n   |\n15 |  ```\n   |   ^\n\
    \   |\nhelp: Unicode character '`' (Grave Accent) looks like ''' (Single Quote),\
    \ but it is not\n   |\n15 |  `'`\n   |   ~\n\nerror: unknown start of token: `\n\
    \  --> /tmp/tmpj6m_m_pq.rs:15:4\n   |\n15 |  ```\n   |    ^\n   |\nhelp: Unicode\
    \ character '`' (Grave Accent) looks like ''' (Single Quote), but it is not\n\
    \   |\n15 |  ``'\n   |    ~\n\nerror: unknown start of token: \\\n  --> /tmp/tmpj6m_m_pq.rs:16:8\n\
    \   |\n16 | -![](C:\\Users\\Parth\\Documents\\GitHub\\rust-playground\\palindrome\\\
    test.png)\n   |        ^\n\nerror: unknown start of token: \\\n  --> /tmp/tmpj6m_m_pq.rs:16:14\n\
    \   |\n16 | -![](C:\\Users\\Parth\\Documents\\GitHub\\rust-playground\\palindrome\\\
    test.png)\n   |              ^\n\nerror: unknown start of token: \\\n  --> /tmp/tmpj6m_m_pq.rs:16:20\n\
    \   |\n16 | -![](C:\\Users\\Parth\\Documents\\GitHub\\rust-playground\\palindrome\\\
    test.png)\n   |                    ^\n\nerror: unknown start of token: \\\n  -->\
    \ /tmp/tmpj6m_m_pq.rs:16:30\n   |\n16 | -![](C:\\Users\\Parth\\Documents\\GitHub\\\
    rust-playground\\palindrome\\test.png)\n   |                              ^\n\n\
    error: unknown start of token: \\\n  --> /tmp/tmpj6m_m_pq.rs:16:37\n   |\n16 |\
    \ -![](C:\\Users\\Parth\\Documents\\GitHub\\rust-playground\\palindrome\\test.png)\n\
    \   |                                     ^\n\nerror: unknown start of token:\
    \ \\\n  --> /tmp/tmpj6m_m_pq.rs:16:53\n   |\n16 | -![](C:\\Users\\Parth\\Documents\\\
    GitHub\\rust-playground\\palindrome\\test.png)\n   |                         \
    \                            ^\n\nerror: unknown start of token: \\\n  --> /tmp/tmpj6m_m_pq.rs:16:64\n\
    \   |\n16 | -![](C:\\Users\\Parth\\Documents\\GitHub\\rust-playground\\palindrome\\\
    test.png)\n   |                                                              \
    \  ^\n\nerror: unknown start of token: \\\n  --> /tmp/tmpj6m_m_pq.rs:17:1\n  \
    \ |\n17 | \\ No newline at end of file\n   | ^\n\nerr"
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().zip(text.chars().rev()).all(|(a, b)| a == b)\n}\n\
    \nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().zip(text.chars().rev()).all(|(a, b)| a == b)\n}\n\
    \nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().rev().collect::<String>() == text\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let chars: Vec<char> = text.chars().collect();\n    if chars.len()\
    \ < 2 {\n        return true;\n    }\n\n    if chars[0] != chars[chars.len() -\
    \ 1] {\n        return false;\n    }\n    is_palindrome(chars[1..chars.len() -\
    \ 1].iter().collect())\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let length = text.len();\n    for i in 0..length / 2 {\n    \
    \    if text.chars().nth(i) != text.chars().nth(length - i - 1) {\n          \
    \  return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    if text.len() < 2 {\n        return true;\n    }\n    if text.chars().nth(0).unwrap()\
    \ != text.chars().nth(text.len() - 1).unwrap() {\n        return false;\n    }\n\
    \    return is_palindrome(text[1..text.len() - 1].to_string());\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    if text.len() < 2 {\n        return true;\n    }\n\n    if text.chars().nth(0).unwrap()\
    \ != text.chars().nth(text.len() - 1).unwrap() {\n        return false;\n    }\n\
    \n    is_palindrome(text[1..text.len() - 1].to_string())\n}\n\nfn main() {\n \
    \   let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let bytes = text.into_bytes();\n    let len = bytes.len();\n\
    \    for (i, char) in bytes.iter().enumerate() {\n        if *char != bytes[len\
    \ - i - 1] {\n            return false;\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().rev().collect::<String>() == text\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().zip(text.chars().rev()).all(|(a, b)| a == b)\n}\n\
    \nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 101
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let text = text.to_lowercase();\n    let chars: Vec<char> = text.chars().collect();\n\
    \    let mut left = 0;\n    let mut right = chars.len() - 1;\n    while left <\
    \ right {\n        if chars[left] != chars[right] {\n            return false;\n\
    \        }\n        left += 1;\n        right -= 1;\n    }\n    true\n}\n\nfn\
    \ main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp3yi4_m4i.rs:6:21

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let lc_text = text.to_lowercase();\n    let reversed_lc_text\
    \ = lc_text.chars().rev().collect::<String>();\n    lc_text == reversed_lc_text\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 101
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut i = 0;\n    let mut j = text.len() - 1;\n    let chars:\
    \ Vec<char> = text.chars().collect();\n\n    while i < j {\n        if chars[i]\
    \ != chars[j] {\n            return false;\n        }\n        i += 1;\n     \
    \   j -= 1;\n    }\n\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmphgej49g4.rs:4:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822437
- exit_code: 1
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let result = text.to_lowercase();\n    let result: Vec<char>\
    \ = result.chars().collect();\n    let mut result: Vec<&char> = result.iter().collect();\n\
    \    result.reverse();\n    let result: String = result.iter().collect();\n  \
    \  result == text.to_lowercase()\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `String` cannot be built from an iterator\
    \ over elements of type `&&char`\n --> /tmp/tmpqb47qh5v.rs:7:40\n  |\n7 |    \
    \ let result: String = result.iter().collect();\n  |                         \
    \               ^^^^^^^ value of type `String` cannot be built from `std::iter::Iterator<Item=&&char>`\n\
    \  |\n  = help: the trait `FromIterator<&&char>` is not implemented for `String`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822437
- exit_code: 1
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut text = text.to_lowercase();\n    for c in text.chars()\
    \ {\n        if c.is_alphanumeric() {\n            continue;\n        }\n    \
    \    text.retain(|x| x != c);\n    }\n    text == text.chars().rev().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `text` as mutable because it is also borrowed\
    \ as immutable\n --> /tmp/tmpct1jhf1z.rs:8:9\n  |\n4 |     for c in text.chars()\
    \ {\n  |              ------------\n  |              |\n  |              immutable\
    \ borrow occurs here\n  |              immutable borrow later used here\n...\n\
    8 |         text.retain(|x| x != c);\n  |         ^^^^^^^^^^^^^^^^^^^^^^^ mutable\
    \ borrow occurs here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1659822437
- exit_code: 101
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let v: Vec<char> = text.chars().collect();\n    let mut i = 0;\n\
    \    let mut j = v.len() - 1;\n    while i < j {\n        if v[i] != v[j] {\n\
    \            return false;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp4ix9womm.rs:5:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822437
- exit_code: 1
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    // Palindrome checking technique\n    // Steps:\n    // 1. Remove\
    \ all punctuation, whitespace and lowercase the text\n    // 2. Create two strings:\
    \ one of the first half of the text and one of the second half\n    // 3. Reverse\
    \ the second half\n    // 4. Check if the first half is equal to the second half\n\
    \n    // 1. Remove all punctuation, whitespace and lowercase the text\n    let\
    \ stripped_text = remove_punctuation_whitespace(text);\n    let lowered_text =\
    \ lowercase_string(stripped_text);\n\n    // 2. Create two strings: one of the\
    \ first half of the text and one of the second half\n    let length = lowered_text.len();\n\
    \    let first_half = &lowered_text[0..(length / 2)];\n    let second_half = &lowered_text[length\
    \ / 2..length];\n\n    // 3. Reverse the second half\n    let mut reversed_second_half\
    \ = String::from(\"\");\n    for c in second_half.chars().rev() {\n        reversed_second_half.push(c);\n\
    \    }\n\n    // 4. Check if the first half is equal to the second half\n    first_half\
    \ == reversed_second_half\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `remove_punctuation_whitespace` in this\
    \ scope\n  --> /tmp/tmpic3kbwi8.rs:11:25\n   |\n11 |     let stripped_text = remove_punctuation_whitespace(text);\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `lowercase_string` in this scope\n\
    \  --> /tmp/tmpic3kbwi8.rs:12:24\n   |\n12 |     let lowered_text = lowercase_string(stripped_text);\n\
    \   |                        ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut word = text.chars().collect::<Vec<char>>();\n    word.reverse();\n\
    \    let reversed = word.iter().collect::<String>();\n    reversed == text\n}\n\
    \nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let text_len = text.len();\n    for i in 0..text_len / 2 {\n\
    \        if text.chars().nth(i) != text.chars().nth(text_len - i - 1) {\n    \
    \        return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n\
    \    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().eq(text.chars().rev())\n}\n\nfn main() {\n    let\
    \ candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n\
    \    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 101
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let s = text.to_lowercase();\n    let chars: Vec<char> = s.chars().collect();\n\
    \    let mut i = 0;\n    let mut j = chars.len() - 1;\n    while i < j {\n   \
    \     if chars[i] != chars[j] {\n            return false;\n        }\n      \
    \  i += 1;\n        j -= 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp_kl8ajrt.rs:6:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let half = text.len() / 2;\n    text[..half].chars().eq(text[text.len()\
    \ - half..].chars().rev())\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let rev_str: String = text.chars().rev().collect();\n    return\
    \ text == rev_str;\n}\n\nfn main() {\n    let candidate = is_palindrome;\n   \
    \ assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().eq(text.chars().rev())\n}\n\nfn main() {\n    let\
    \ candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n\
    \    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut it = text.chars();\n    for (i, c) in text.chars().enumerate()\
    \ {\n        match it.next_back() {\n            Some(l) => {\n              \
    \  if l != c {\n                    return false;\n                }\n       \
    \     }\n            None => {\n                break;\n            }\n      \
    \  }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let reversed = text.chars().rev().collect::<String>();\n    reversed\
    \ == text\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let len = text.len();\n    let half = len / 2;\n    let chars:\
    \ Vec<char> = text.chars().collect();\n    (0..half).all(|i| chars[i] == chars[len\
    \ - i - 1])\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let chars: Vec<char> = text.chars().collect();\n    let len =\
    \ chars.len();\n    let half = len / 2;\n\n    for i in 0..half {\n        if\
    \ chars[i] != chars[len - i - 1] {\n            return false;\n        }\n   \
    \ }\n\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    text == text.chars().rev().collect::<String>()\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 101
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let text_length = text.len();\n    let mut i = 0;\n    let mut\
    \ j = text_length - 1;\n    while i < j {\n        if text.chars().nth(i) != text.chars().nth(j)\
    \ {\n            return false;\n        }\n        i += 1;\n        j -= 1;\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpetquprw5.rs:5:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822437
- exit_code: 101
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let chars: Vec<char> = text.chars().collect();\n    let size\
    \ = chars.len();\n    if size == 0 {\n        return false;\n    }\n    let mut\
    \ start = 0;\n    let mut end = size - 1;\n    while start < end {\n        if\
    \ chars[start] != chars[end] {\n            return false;\n        }\n       \
    \ start += 1;\n        end -= 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp5l8nhimw.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().zip(text.chars().rev()).all(|(a, b)| a == b)\n}\n\
    \nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut iter = text.chars();\n    let mut iter_rev = text.chars().rev();\n\
    \n    while let (Some(c), Some(c_rev)) = (iter.next(), iter_rev.next()) {\n  \
    \      if c != c_rev {\n            return false;\n        }\n    }\n\n    true\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let text_chars: Vec<char> = text.chars().collect();\n    for\
    \ i in 0..text_chars.len() / 2 {\n        if text_chars[i] != text_chars[text_chars.len()\
    \ - i - 1] {\n            return false;\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let rev_text = text.chars().rev().collect::<String>();\n    text\
    \ == rev_text\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut rev_text = String::new();\n    for ch in text.chars().rev()\
    \ {\n        rev_text.push(ch);\n    }\n    println!(\"{}\", rev_text);\n    println!(\"\
    {}\", text);\n    rev_text == text\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: '


    aba

    aba

    aaaaa

    aaaaa

    dcbz

    zbcd

    xywyx

    xywyx

    zywyx

    xywyz

    xzwyx

    xywzx

    '
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.to_lowercase() == text.to_lowercase().chars().rev().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 101
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let s = text.to_lowercase();\n    let v: Vec<char> = s.chars().collect();\n\
    \    let mut start = 0;\n    let mut end = v.len() - 1;\n    while start < end\
    \ {\n        while !v[start].is_alphanumeric() {\n            start += 1;\n  \
    \      }\n        while !v[end].is_alphanumeric() {\n            end -= 1;\n \
    \       }\n        if v[start] != v[end] {\n            return false;\n      \
    \  }\n        start += 1;\n        end -= 1;\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmphwjfgmca.rs:6:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822437
- exit_code: 1
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n+    for i in 0..text.len() / 2 {\n+        if text.chars().nth(i)\
    \ != text.chars().nth(text.len() - i - 1) {\n+            return false;\n+   \
    \     }\n+    }\n+    true\n+}\n+\n+/// Checks if given u32 is a palindrome in\
    \ decimal notation\n+pub fn is_decimal_palindrome(num: u32) -> bool {\n+    is_palindrome(num.to_string())\n\
    +}\n+\n+/// Checks if given u32 is a palindrome in binary notation\n+pub fn is_binary_palindrome(num:\
    \ u32) -> bool {\n+    is_palindrome(format!(\"{:b}\", num))\n+}\n+\n+#[cfg(test)]\n\
    +mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn test_is_palindrome()\
    \ {\n+        assert_eq!(is_palindrome(\"abbab\".to_string()), false);\n+    \
    \    assert_eq!(is_palindrome(\"abcba\".to_string()), true);\n+        assert_eq!(is_palindrome(\"\
    abba\".to_string()), true);\n+        assert_eq!(is_palindrome(\"aa\".to_string()),\
    \ true);\n+        assert_eq!(is_palindrome(\"\".to_string()), true);\n+    }\n\
    +\n+    #[test]\n+    fn test_is_decimal_palindrome() {\n+        assert_eq!(is_decimal_palindrome(123_u32),\
    \ false);\n+        assert_eq!(is_decimal_palindrome(121_u32), true);\n+     \
    \   assert_eq!(is_decimal_palindrome(1_u32), true);\n+        assert_eq!(is_decimal_palindrome(999_u32),\
    \ true);\n+    }\n+\n+    #[test]\n+    fn test_is_binary_palindrome() {\n+  \
    \      assert_eq!(is_binary_\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp1mju0tt8.rs:56:3\n\
    \   |\n22 | +mod tests {\n   |            - unclosed delimiter\n...\n56 | }\n\
    \   |   ^\n\nerror: expected expression, found `+`\n --> /tmp/tmp1mju0tt8.rs:3:1\n\
    \  |\n3 | +    for i in 0..text.len() / 2 {\n  | ^ expected expression\n\nerror:\
    \ mismatched closing delimiter: `}`\n  --> /tmp/tmp1mju0tt8.rs:44:20\n   |\n43\
    \ | +    fn test_is_binary_palindrome() {\n   |                              \
    \       - closing delimiter possibly meant for this\n44 | +        assert_eq!(is_binary_\n\
    \   |                    ^ unclosed delimiter\n45 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror: expected item, found `+`\n  --> /tmp/tmp1mju0tt8.rs:10:1\n\
    \   |\n10 | +\n   | ^ expected item\n\nerror: aborting due to 4 previous errors\n\
    \n"
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let text = text.as_str();\n    let len = text.len();\n    let\
    \ half = (len / 2) as usize;\n    let start = &text[0..half];\n    let end = &text[(len\
    \ - half)..len];\n    start == end.chars().rev().collect::<String>()\n}\n\nfn\
    \ main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822438
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let input = text.to_lowercase();\n    let mut chars = input.chars();\n\
    \    let mut reverse = input.chars().rev();\n\n    while let (Some(c), Some(r))\
    \ = (chars.next(), reverse.next()) {\n        if c != r {\n            return\
    \ false;\n        }\n    }\n\n    true\n}\n\nfn main() {\n    let candidate =\
    \ is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822438
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let text = text.to_lowercase();\n    let mut chars: Vec<char>\
    \ = text.chars().collect();\n    chars.reverse();\n    text == chars.into_iter().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822438
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let left_chars: Vec<char> = text.chars().filter(|c| c.is_alphanumeric()).collect();\n\
    \    let mut right_chars: Vec<char> = left_chars.clone();\n    right_chars.reverse();\n\
    \    right_chars.into_iter().eq(left_chars.into_iter())\n}\n\nfn main() {\n  \
    \  let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822438
- exit_code: 101
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut word = String::from(text.trim().to_lowercase().as_str());\n\
    \    if word.len() == 0 {\n        return false;\n    }\n    word = word.replace(\"\
    \ \", \"\");\n    word = word.replace(\",\", \"\");\n    word = word.replace(\"\
    .\", \"\");\n    word = word.replace(\"/\", \"\");\n    let mut new_string = String::from(\"\
    \");\n    for c in word.chars() {\n        new_string = c.to_string() + &new_string;\n\
    \    }\n    return new_string == word;\n}\n\nfn main() {\n    let candidate =\
    \ is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpe0iqtvzm.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822438
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().zip(text.chars().rev()).all(|(a, b)| a == b)\n}\n\
    \nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let text_len = text.len();\n    let middle = text_len / 2;\n\
    \    let text_len_is_odd = text_len % 2 == 1;\n\n    let text_chars: Vec<char>\
    \ = text.chars().collect();\n\n    if text_len_is_odd {\n        text_chars[..middle].iter().eq(text_chars[middle\
    \ + 1..].iter().rev())\n    } else {\n        text_chars[..middle].iter().eq(text_chars[middle..].iter().rev())\n\
    \    }\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822438
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut text_chars = text.chars();\n    let mut rev_text_chars\
    \ = text.chars().rev();\n\n    loop {\n        match (text_chars.next(), rev_text_chars.next())\
    \ {\n            (Some(a), Some(b)) => {\n                if a != b {\n      \
    \              return false;\n                }\n            }\n            (None,\
    \ None) => return true,\n            _ => return false,\n        }\n    }\n}\n\
    \nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822438
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().zip(text.chars().rev()).all(|(a, b)| a == b)\n}\n\
    \nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 101
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut length = text.len();\n    let mut chars = text.chars();\n\
    \    loop {\n        if length < 2 {\n            return true;\n        }\n  \
    \      let first = chars.next().unwrap();\n        let last = chars.nth(length\
    \ - 2).unwrap();\n        if first != last {\n            return false;\n    \
    \    }\n        length -= 2;\n    }\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmp48g0kimk.rs:9:34

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822438
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut chars: Vec<char> = text.chars().collect();\n    let length\
    \ = chars.len();\n    let half_length = length / 2;\n\n    for i in 0..half_length\
    \ {\n        if chars[i] != chars[length - i - 1] {\n            return false;\n\
    \        }\n    }\n\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822438
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut normal = text.chars().collect::<Vec<char>>();\n    let\
    \ mut reverse = text.chars().rev().collect::<Vec<char>>();\n\n    // Strips both\
    \ vectors from punctuation\n    normal.retain(|x| !x.is_whitespace() && !x.is_ascii_punctuation());\n\
    \    reverse.retain(|x| !x.is_whitespace() && !x.is_ascii_punctuation());\n\n\
    \    // Checks if the vectors are equal\n    for i in 0..normal.len() {\n    \
    \    // Stores the lowercase versions of chars for comparison\n        let x =\
    \ normal[i].to_lowercase().next().unwrap();\n        let y = reverse[i].to_lowercase().next().unwrap();\n\
    \n        if x != y {\n            return false;\n        }\n    }\n\n    return\
    \ true;\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822438
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().eq(text.chars().rev())\n}\n\nfn main() {\n    let\
    \ candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n\
    \    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 1
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut chars = text.chars();\n    let mut res = true;\n    let\
    \ mut it1 = chars.by_ref();\n    let mut it2 = chars.rev();\n    while res {\n\
    \        match (it1.next(), it2.next()) {\n            (Some(a), Some(b)) => {\n\
    \                if a.to_lowercase().next().unwrap() != b.to_lowercase().next().unwrap()\
    \ {\n                    res = false;\n                }\n            }\n    \
    \        _ => break,\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n --> /tmp/tmpmpg6sjo8.rs:5:9\n\
    \  |\n5 |     let mut it1 = chars.by_ref();\n  |         ----^^^\n  |        \
    \ |\n  |         help: remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0505]: cannot move out of `chars` because it is borrowed\n\
    \ --> /tmp/tmpmpg6sjo8.rs:6:19\n  |\n5 |     let mut it1 = chars.by_ref();\n \
    \ |                   ----- borrow of `chars` occurs here\n6 |     let mut it2\
    \ = chars.rev();\n  |                   ^^^^^ move out of `chars` occurs here\n\
    7 |     while res {\n8 |         match (it1.next(), it2.next()) {\n  |       \
    \         --- borrow later used here\n\nerror: aborting due to previous error;\
    \ 1 warning emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0505`.\n"
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut length = text.len();\n    if length % 2 == 0 {\n    \
    \    length = length / 2;\n    } else {\n        length = (length - 1) / 2;\n\
    \    }\n    for i in 0..length {\n        if text.chars().nth(i) != text.chars().nth(text.len()\
    \ - i - 1) {\n            return false;\n        }\n    }\n    return true;\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822438
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut char_vec: Vec<char> = text.chars().collect();\n    char_vec.reverse();\n\
    \    let reversed_text: String = char_vec.into_iter().collect();\n    return text\
    \ == reversed_text;\n}\n\nfn main() {\n    let candidate = is_palindrome;\n  \
    \  assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822438
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    return text == String::from(text.chars().rev().collect::<String>());\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822438
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut chars = text.chars();\n    let mut rev_chars = text.chars().rev();\n\
    \n    for _ in 0..text.len() / 2 {\n        if chars.next() != rev_chars.next()\
    \ {\n            return false;\n        }\n    }\n\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822438
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.to_lowercase() == text.to_lowercase().chars().rev().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 1
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    // Remove whitespace from the string\n    let text_no_space =\
    \ text.replace(\" \", \"\");\n\n    // Create iterator over characters\n    let\
    \ mut char_iter = text_no_space.chars();\n\n    // Create sub iterator to iterate\
    \ over first half\n    let mut sub_iter = char_iter.by_ref().take(text_no_space.len()\
    \ / 2);\n\n    // Check if iterators are equal\n    // This means that if we compare\
    \ the first half of the word, with the word spelled backwards,\n    // they should\
    \ be equal\n    sub_iter.eq(char_iter.rev())\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpfgokvv63.rs:10:9\n\
    \   |\n10 |     let mut sub_iter = char_iter.by_ref().take(text_no_space.len()\
    \ / 2);\n   |         ----^^^^^^^^\n   |         |\n   |         help: remove\
    \ this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\nerror[E0505]:\
    \ cannot move out of `char_iter` because it is borrowed\n  --> /tmp/tmpfgokvv63.rs:15:17\n\
    \   |\n10 |     let mut sub_iter = char_iter.by_ref().take(text_no_space.len()\
    \ / 2);\n   |                        --------- borrow of `char_iter` occurs here\n\
    ...\n15 |     sub_iter.eq(char_iter.rev())\n   |              -- ^^^^^^^^^ move\
    \ out of `char_iter` occurs here\n   |              |\n   |              borrow\
    \ later used by call\n\nerror: aborting due to previous error; 1 warning emitted\n\
    \nFor more information about this error, try `rustc --explain E0505`.\n"
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut letters: Vec<char> = text.chars().collect();\n    let\
    \ original_letters = letters.clone();\n    letters.reverse();\n    original_letters\
    \ == letters\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822438
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut forward = text.chars();\n    let mut reverse = text.chars().rev();\n\
    \n    loop {\n        match (forward.next(), reverse.next()) {\n            (Some(f),\
    \ Some(r)) => {\n                if f != r {\n                    return false;\n\
    \                }\n            }\n            (None, None) => {\n           \
    \     return true;\n            }\n            _ => {\n                return\
    \ false;\n            }\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822438
- exit_code: 1
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n+\tlet text_len = text.len();\n+\tlet half_len = text_len / 2;\n\
    +\tlet mut is_palindrome = true;\n+\tlet mut i = 0;\n+\tlet mut j = text_len -\
    \ 1;\n+\twhile i < half_len && is_palindrome {\n+\t\tif text.as_bytes()[i] !=\
    \ text.as_bytes()[j] {\n+\t\t\tis_palindrome = false;\n+\t\t}\n+\t\ti += 1;\n\
    +\t\tj -= 1;\n+\t}\n+\tis_palindrome\n+}\n+\n+/// Run the algorithm for given\
    \ text\n+fn run(mut text: String) {\n+\tlet text_len = text.len();\n+\tlet half_len\
    \ = text_len / 2;\n+\tlet mut i = 0;\n+\tlet mut j = text_len - 1;\n+\twhile i\
    \ < half_len {\n+\t\tif text.as_bytes()[i] != text.as_bytes()[j] {\n+\t\t\tif\
    \ text.as_bytes()[i + 1] == text.as_bytes()[j] {\n+\t\t\t\ttext.remove(i);\n+\t\
    \t\t\tif is_palindrome(text.clone()) {\n+\t\t\t\t\tprintln!(\"Deletion of a character\
    \ will make it a palindrome!\");\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t\ttext.insert(i,\
    \ text.as_bytes()[i]);\n+\t\t\t}\n+\t\t\tif text.as_bytes()[i] == text.as_bytes()[j\
    \ - 1] {\n+\t\t\t\ttext.remove(j);\n+\t\t\t\tif is_palindrome(text.clone()) {\n\
    +\t\t\t\t\tprintln!(\"Deletion of a character will make it a palindrome!\");\n\
    +\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t\ttext.insert(j, text.as_bytes()[j]);\n\
    +\t\t\t}\n+\t\t\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpzldqhd1o.rs:54:3\n\
    \   |\n19 | +fn run(mut text: String) {\n   |                           - unclosed\
    \ delimiter\n...\n24 | +    while i < half_len {\n   |                       \
    \  - unclosed delimiter\n...\n54 | }\n   |   ^\n\nerror: expected expression,\
    \ found `+`\n --> /tmp/tmpzldqhd1o.rs:3:1\n  |\n3 | +    let text_len = text.len();\n\
    \  | ^ expected expression\n\nerror: expected item, found `+`\n  --> /tmp/tmpzldqhd1o.rs:17:1\n\
    \   |\n17 | +\n   | ^ expected item\n\nerror: aborting due to 3 previous errors\n\
    \n"
  stdout: ''
  timestamp: 1659822438
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let length = text.len();\n    let half_length = length / 2;\n\
    \    text[..half_length] == text[length - half_length..].chars().rev().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822438
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let text_len = text.len();\n    let text_half_len = text_len\
    \ / 2;\n    let reverse_text = text.chars().rev().collect::<String>();\n    for\
    \ i in 0..text_half_len {\n        if text.chars().nth(i) != reverse_text.chars().nth(i)\
    \ {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822438
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.to_lowercase() == text.to_lowercase().chars().rev().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut chars: Vec<char> = text.chars().collect();\n    while\
    \ chars.len() > 1 {\n        if chars.remove(0) != chars.pop().unwrap() {\n  \
    \          return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n\
    \    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822438
- exit_code: 101
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    if text.len() <= 1 {\n        return true;\n    }\n    let mut\
    \ front = 0;\n    let mut back = text.len() - 1;\n    for _ in 0..text.len() {\n\
    \        if text.chars().nth(front) != text.chars().nth(back) {\n            return\
    \ false;\n        }\n        front += 1;\n        back -= 1;\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmphmw3fn4f.rs:13:9

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822438
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let text = text.to_lowercase();\n    let text = text.replace(|c:\
    \ char| !c.is_alphanumeric(), \"\");\n    text == text.chars().rev().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822438
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let length = text.len();\n    let half_length = length / 2;\n\
    \    let half = &text[0..half_length];\n    let second_half = &text[length - half_length..length];\n\
    \    half == second_half.chars().rev().collect::<String>()\n}\n\nfn main() {\n\
    \    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822438
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().zip(text.chars().rev()).all(|(a, b)| a == b)\n}\n\
    \nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 101
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut front = 0;\n    let mut back = text.len() - 1;\n\n  \
    \  while front < back {\n        if text.as_bytes()[front] != text.as_bytes()[back]\
    \ {\n            return false;\n        }\n        front += 1;\n        back -=\
    \ 1;\n    }\n\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp9puum1s7.rs:4:20

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822438
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut chars: Vec<char> = text.chars().collect();\n    chars.reverse();\n\
    \    return text == chars.into_iter().collect::<String>();\n}\n\nfn main() {\n\
    \    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822438
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let text_chars: Vec<char> = text.chars().collect();\n    for\
    \ i in 0..text_chars.len() / 2 {\n        if text_chars[i] != text_chars[text_chars.len()\
    \ - i - 1] {\n            return false;\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let text_chars: Vec<char> = text.chars().collect();\n    let\
    \ text_chars_rev: Vec<char> = text.chars().rev().collect();\n    if text_chars\
    \ == text_chars_rev {\n        return true;\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822438
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let text = text.to_lowercase();\n    let text = text.replace(|c:\
    \ char| !c.is_alphanumeric(), \"\");\n    let text_reversed = text.chars().rev().collect::<String>();\n\
    \    text == text_reversed\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822438
- exit_code: 1
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let lowercase_text = text.to_lowercase();\n    let text_chars:\
    \ Vec<char> = lowercase_text.chars().collect();\n    let palindrome_indexes =\
    \ text_chars.iter().enumerate().filter(|&(i, _)| {\n        let text_length =\
    \ text_chars.len();\n        text_length - i - 1 != i\n    });\n    palindrome_indexes.all(|(i,\
    \ letter)| {\n        let mirror_index = text_chars.len() - i - 1;\n        text_chars[mirror_index]\
    \ == *letter\n    })\n}\n\nfn main() {\n    let candidate = is_palindrome;\n \
    \   assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `palindrome_indexes` as mutable, as it is not\
    \ declared as mutable\n --> /tmp/tmp1v90ij93.rs:9:5\n  |\n5 |     let palindrome_indexes\
    \ = text_chars.iter().enumerate().filter(|&(i, _)| {\n  |         ------------------\
    \ help: consider changing this to be mutable: `mut palindrome_indexes`\n...\n\
    9 |     palindrome_indexes.all(|(i, letter)| {\n  |     ^^^^^^^^^^^^^^^^^^ cannot\
    \ borrow as mutable\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659822438
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().collect::<Vec<char>>() == text.chars().rev().collect::<Vec<char>>()\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822438
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    if text.len() < 2 {\n        true\n    } else {\n        text.chars().next().unwrap()\
    \ == text.chars().last().unwrap() && is_palindrome(String::from(text.chars().take(text.len()\
    \ - 1).skip(1).collect::<String>()))\n    }\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822438
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    // We convert the text to lowercase and remove all the spaces,\n\
    \    // and then check if the text is equal to its reverse\n    text.to_lowercase().replace(\"\
    \ \", \"\") == text.to_lowercase().replace(\" \", \"\").chars().rev().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822438
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.to_lowercase() == text.to_lowercase().chars().rev().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut letters: Vec<char> = text.chars().collect();\n    letters.reverse();\n\
    \    let reversed = letters.into_iter().collect::<String>();\n    return text\
    \ == reversed;\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822438
- exit_code: 101
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().all(|x| text.chars().collect::<Vec<char>>()[text.len()\
    \ - x.len_utf8()] == x)\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpg4znc_my.rs:9:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822438
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let result = text.chars().all(|c| c == text.chars().rev().nth(text.chars().position(|v|\
    \ v == c).unwrap()).unwrap());\n    if result {\n        println!(\"{} is a palindrome\"\
    , text);\n    } else {\n        println!(\"{} is not a palindrome\", text);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = is_palindrome;\n   \
    \ assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ' is a palindrome

    aba is a palindrome

    aaaaa is a palindrome

    zbcd is not a palindrome

    xywyx is a palindrome

    xywyz is not a palindrome

    xywzx is not a palindrome

    '
  timestamp: 1659822438
- exit_code: 101
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let chars: Vec<char> = text.chars().collect();\n    let mut left\
    \ = 0;\n    let mut right = chars.len() - 1;\n    while left < right {\n     \
    \   if chars[left] != chars[right] {\n            return false;\n        }\n \
    \       left += 1;\n        right -= 1;\n    }\n    true\n}\n\nfn main() {\n \
    \   let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmps29qg_d_.rs:5:21

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822438
- exit_code: 1
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let text = text.to_lowercase();\n    let mut text = text.as_str();\n\
    \    text = text.trim();\n    text = text.replace(\" \", \"\");\n    text = text.replace(\"\
    ,\", \"\");\n    text = text.replace(\".\", \"\");\n    text = text.replace(\"\
    !\", \"\");\n    text = text.replace(\"?\", \"\");\n    text = text.replace(\"\
    \\\"\", \"\");\n    let mut other = text.chars().rev();\n    for a in text.chars()\
    \ {\n        let b = other.next().unwrap();\n        if a != b {\n           \
    \ return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp54_qvtbi.rs:6:12\n  |\n6 |\
    \     text = text.replace(\" \", \"\");\n  |            ^^^^^^^^^^^^^^^^^^^^^\n\
    \  |            |\n  |            expected `&str`, found struct `String`\n  |\
    \            help: consider borrowing here: `&text.replace(\" \", \"\")`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp54_qvtbi.rs:7:12\n  |\n7 |     text = text.replace(\"\
    ,\", \"\");\n  |            ^^^^^^^^^^^^^^^^^^^^^\n  |            |\n  |     \
    \       expected `&str`, found struct `String`\n  |            help: consider\
    \ borrowing here: `&text.replace(\",\", \"\")`\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp54_qvtbi.rs:8:12\n  |\n8 |     text = text.replace(\".\", \"\");\n\
    \  |            ^^^^^^^^^^^^^^^^^^^^^\n  |            |\n  |            expected\
    \ `&str`, found struct `String`\n  |            help: consider borrowing here:\
    \ `&text.replace(\".\", \"\")`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp54_qvtbi.rs:9:12\n\
    \  |\n9 |     text = text.replace(\"!\", \"\");\n  |            ^^^^^^^^^^^^^^^^^^^^^\n\
    \  |            |\n  |            expected `&str`, found struct `String`\n  |\
    \            help: consider borrowing here: `&text.replace(\"!\", \"\")`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp54_qvtbi.rs:10:12\n   |\n10 |     text = text.replace(\"\
    ?\", \"\");\n   |            ^^^^^^^^^^^^^^^^^^^^^\n   |            |\n   |  \
    \          expected `&str`, found struct `String`\n   |            help: consider\
    \ borrowing here: `&text.replace(\"?\", \"\")`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp54_qvtbi.rs:11:12\n   |\n11 |     text = text.replace(\"\\\"\"\
    , \"\");\n   |            ^^^^^^^^^^^^^^^^^^^^^^\n   |            |\n   |    \
    \        expected `&str`, found struct `String`\n   |            help: consider\
    \ borrowing here: `&text.replace(\"\\\"\", \"\")`\n\nerror: aborting due to 6\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659822438
- exit_code: 101
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n\tlet mut text_copy = text.clone();\n\tlet text_length = text.len();\n\
    \tlet mut start = 0;\n\tlet mut end = text_length - 1;\n\n\twhile start < end\
    \ {\n\t\tif text_copy.chars().nth(start) != text_copy.chars().nth(end) {\n\t\t\
    \treturn false;\n\t\t}\n\n\t\tstart += 1;\n\t\tend -= 1;\n\t}\n\n\treturn true;\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmprekybjbj.rs:6:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822438
- exit_code: 101
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut chars: Vec<char> = text.chars().collect();\n    let mut\
    \ len = chars.len();\n    let mut i = 0;\n    let mut j = len - 1;\n    let mid\
    \ = len / 2;\n    while i < mid {\n        if chars[i] != chars[j] {\n       \
    \     return false;\n        }\n        i += 1;\n        j -= 1;\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpmzbyp5n5.rs:6:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822438
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut text = text.to_lowercase();\n    text.retain(|c| c.is_alphanumeric());\n\
    \    text == text.chars().rev().collect::<String>()\n}\n\nfn main() {\n    let\
    \ candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n\
    \    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822438
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.as_bytes().iter().eq(text.as_bytes().iter().rev())\n}\n\n\
    fn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822438
- exit_code: 101
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let (mut left, mut right) = (0, text.len() - 1);\n    while left\
    \ < right {\n        while !text.as_bytes()[left].is_ascii_alphanumeric() {\n\
    \            left += 1;\n        }\n        while !text.as_bytes()[right].is_ascii_alphanumeric()\
    \ {\n            right -= 1;\n        }\n        if left < right {\n         \
    \   if text.as_bytes()[left].to_ascii_lowercase() != text.as_bytes()[right].to_ascii_lowercase()\
    \ {\n                return false;\n            }\n            left += 1;\n  \
    \          right -= 1;\n        }\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n\
    \    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdvb3t6ka.rs:3:37

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822438
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let text_bytes = text.into_bytes();\n    let text_len = text_bytes.len();\n\
    \    if text_len == 0 {\n        return true;\n    }\n    let mut i = 0;\n   \
    \ let mut j = text_len - 1;\n    while i < j {\n        if text_bytes[i] != text_bytes[j]\
    \ {\n            return false;\n        }\n        i += 1;\n        j -= 1;\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822438
- exit_code: 101
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut chars = text.chars();\n    let mut half: Vec<char> =\
    \ Vec::new();\n    let mut reverse: Vec<char> = Vec::new();\n\n    for _ in 0..(text.len()\
    \ / 2) {\n        let c = chars.next().unwrap();\n        half.push(c);\n    \
    \    reverse.insert(0, c);\n    }\n\n    if text.len() % 2 != 0 {\n        chars.next();\n\
    \    }\n\n    while let Some(c) = chars.next() {\n        let t = reverse.pop().unwrap();\n\
    \        if c != t {\n            return false;\n        }\n    }\n\n    true\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpouy2hamg.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822438
- exit_code: 1
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n+    let mut letters: Vec<char> = text.chars().collect();\n+    letters.reverse();\n\
    +    let reversed: String = letters.into_iter().collect();\n-    let reversed:\
    \ String = text.chars().rev().collect();\n+    let equal = text.eq_ignore_ascii_case(&reversed);\n\
    +    equal\n-    text.eq_ignore_ascii_case(&reversed)\n }\n```\n\n## 5. Sorting\n\
    \n> **Note:** _Currently there are no exercise for sorting. Do the [memory\n>\
    \ allocation](../memory-allocation) exercise on your own._\n\n## 6. Program structure\n\
    \n### 6.1. Single file\n\nUse the `String::from()` method to create a new `String`\
    \ from `s1` and `s2`.\n\n```diff\n-    let mut hello = String::from(\"Hello, \"\
    );\n-    hello.push_str(\"world!\");\n+    let hello = String::from(\"Hello, \"\
    );\n+    let world = String::from(\"world!\");\n+    let hello_world = format!(\"\
    {}{}\", hello, world);\n+    println!(\"{}\", hello_world);\n```\n\n### 6.2. Modules\n\
    \nUse the `create_triangle()` function to create a triangle.\n\n```diff\n-   \
    \ let triangle = Triangle {\n-        base: 3.0,\n-        height: 4.0,\n-   \
    \ };\n+    let triangle = shapes::create_triangle(3.0, 4.0);\n-    let area =\
    \ triangle.area();\n+    let area = triangle.area();\n```\n\n### 6.3. Tests\n\n\
    Remove the `#[test]` attribute from the `shapes` module.\n\n```diff\n-#[cfg(test)]\n\
    -mod tests {\n-    #[test]\n-    fn it_works() {\n-        assert_eq!(2 + 2, 4);\n\
    -    }\n-}\n```\n\nAdd the `#[test]` attribute to the `shapes` module.\n\n```diff\n\
    +#[cfg(test)]\n\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: unknown start of token: `\n  --> /tmp/tmp4c61meg3.rs:11:1\n   |\n\
    11 | ```\n   | ^\n   |\nhelp: Unicode character '`' (Grave Accent) looks like\
    \ ''' (Single Quote), but it is not\n   |\n11 | '``\n   | ~\n\nerror: unknown\
    \ start of token: `\n  --> /tmp/tmp4c61meg3.rs:11:2\n   |\n11 | ```\n   |  ^\n\
    \   |\nhelp: Unicode character '`' (Grave Accent) looks like ''' (Single Quote),\
    \ but it is not\n   |\n11 | `'`\n   |  ~\n\nerror: unknown start of token: `\n\
    \  --> /tmp/tmp4c61meg3.rs:11:3\n   |\n11 | ```\n   |   ^\n   |\nhelp: Unicode\
    \ character '`' (Grave Accent) looks like ''' (Single Quote), but it is not\n\
    \   |\n11 | ``'\n   |   ~\n\nerror: unknown start of token: `\n  --> /tmp/tmp4c61meg3.rs:22:9\n\
    \   |\n22 | Use the `String::from()` method to create a new `String` from `s1`\
    \ and `s2`.\n   |         ^\n   |\nhelp: Unicode character '`' (Grave Accent)\
    \ looks like ''' (Single Quote), but it is not\n   |\n22 | Use the 'String::from()`\
    \ method to create a new `String` from `s1` and `s2`.\n   |         ~\n\nerror:\
    \ unknown start of token: `\n  --> /tmp/tmp4c61meg3.rs:22:24\n   |\n22 | Use the\
    \ `String::from()` method to create a new `String` from `s1` and `s2`.\n   | \
    \                       ^\n   |\nhelp: Unicode character '`' (Grave Accent) looks\
    \ like ''' (Single Quote), but it is not\n   |\n22 | Use the `String::from()'\
    \ method to create a new `String` from `s1` and `s2`.\n   |                  \
    \      ~\n\nerror: unknown start of token: `\n  --> /tmp/tmp4c61meg3.rs:22:49\n\
    \   |\n22 | Use the `String::from()` method to create a new `String` from `s1`\
    \ and `s2`.\n   |                                                 ^\n   |\nhelp:\
    \ Unicode character '`' (Grave Accent) looks like ''' (Single Quote), but it is\
    \ not\n   |\n22 | Use the `String::from()` method to create a new 'String` from\
    \ `s1` and `s2`.\n   |                                                 ~\n\nerror:\
    \ unknown start of token: `\n  --> /tmp/tmp4c61meg3.rs:22:56\n   |\n22 | Use the\
    \ `String::from()` method to create a new `String` from `s1` and `s2`.\n   | \
    \                                                       ^\n   |\nhelp: Unicode\
    \ character '"
  stdout: ''
  timestamp: 1659822438
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let text = text.to_lowercase();\n    let text = text.chars().filter(|c|\
    \ c.is_alphanumeric()).collect::<String>();\n    text == text.chars().rev().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822438
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().zip(text.chars().rev()).all(|(a, b)| a == b)\n}\n\
    \nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 1
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n+    // Note, this function is a bit tricky, because it uses a closure\
    \ in a very weird way.\n+    // The closure is passed to an internal iterator\
    \ called `zip` and this iterator returns a\n+    // tuple of two elements, each\
    \ taken from a different iterator (the first element comes from\n+    // `text.chars()`\
    \ and the second element comes from `text.chars().rev()`). `zip` will return\n\
    +    // the tuples until one of the iterators is exhausted.\n+    //\n+    //\
    \ One of the iterators is always `text.chars().rev()` which is an infinite iterator.\
    \ It will\n+    // never be exhausted. This is very important because it makes\
    \ it impossible for `zip` to\n+    // ever return a tuple that isn't `text.chars().len()`\
    \ long.\n+    //\n+    // `text.chars()` is an iterator that will be exhausted\
    \ after it traverses the entire `text`\n+    // string. So it will produce `text.chars().len()`\
    \ elements before it stops. This will happen\n+    // in `text.chars().len()`\
    \ steps.\n+    //\n+    // When `text.chars()` is exhausted it will make `zip`\
    \ stop. Because `zip` iterator is the\n+    // iterator that `all` method is using,\
    \ it means that `all` will stop after `text.chars().len()`\n+    // steps (iterations).\n\
    +    //\n+    // But `zip` iterator is running as long as `text.chars().rev()`\
    \ is alive and will never be\n+    // exhausted. So it will keep generating `text.chars().len()`\
    \ tuples. Each tuple will have\n+    // `text.chars().len()` elements. Each element\
    \ is a `char` type.\n+    //\n+    // So, `all` will run for `text.chars().len()`\
    \ times, for each step it will create a tuple that\n+    // has `text.chars().len()`\
    \ elements and check if each of these elements equals to `true`.\n+    // This\
    \ check is what the closure does.\n+    //\n+    // So the check will run `text.\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected expression, found `+`\n --> /tmp/tmpnmwggw9r.rs:3:1\n \
    \ |\n3 | +    // Note, this function is a bit tricky, because it uses a closure\
    \ in a very weird way.\n  | ^ expected expression\n\nerror: aborting due to previous\
    \ error\n\n"
  stdout: ''
  timestamp: 1659822438
- exit_code: 101
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut iter = text.chars();\n    let mut len = text.len();\n\
    \    let mut head = iter.next();\n    let mut tail = iter.next_back();\n\n   \
    \ if let Some(a) = head {\n        if let Some(b) = tail {\n            if a !=\
    \ b {\n                return false;\n            }\n        }\n    }\n\n    len\
    \ -= 2;\n\n    for _ in 0..len {\n        head = iter.next();\n        tail =\
    \ iter.next_back();\n\n        if let Some(a) = head {\n            if let Some(b)\
    \ = tail {\n                if a != b {\n                    return false;\n \
    \               }\n            }\n        }\n    }\n\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdvpzsmzn.rs:16:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822438
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.to_lowercase() == text.to_lowercase().chars().rev().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().rev().collect::<String>() == text\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    // convert to lowercase and remove spaces\n    let text_lowercase\
    \ = text.to_lowercase();\n    let mut text_prepared = String::new();\n    for\
    \ c in text_lowercase.chars() {\n        if c != ' ' {\n            text_prepared.push(c);\n\
    \        }\n    }\n\n    // put the contents of the string into a vector and check\
    \ if\n    // the contents of the vector are the same backwards as forward\n  \
    \  let text_len = text_prepared.len();\n    let mut forward_iter = text_prepared.chars();\n\
    \    let mut backward_iter = text_prepared.chars().rev();\n    for _ in 0..text_len\
    \ {\n        if forward_iter.next() != backward_iter.next() {\n            return\
    \ false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822438
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut lower_text = text.to_lowercase();\n    lower_text.retain(|x|\
    \ x.is_alphanumeric());\n    let chars: Vec<char> = lower_text.chars().collect();\n\
    \    for i in 0..chars.len() / 2 {\n        if chars[i] != chars[chars.len() -\
    \ i - 1] {\n            return false;\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822438
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let text_length = text.len();\n    let upper_bound = text_length\
    \ / 2;\n    let mut i = 0;\n    while i < upper_bound {\n        if text.chars().nth(i)\
    \ != text.chars().nth(text_length - i - 1) {\n            return false;\n    \
    \    }\n        i += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822438
- exit_code: 101
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut chars = text.chars();\n    let mut left: Option<char>\
    \ = chars.next();\n    let mut right: Option<char> = chars.next_back();\n\n  \
    \  while left == right {\n        left = chars.next();\n        right = chars.next_back();\n\
    \n        if left == None || right == None {\n            break;\n        }\n\
    \    }\n\n    left == right\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpipyjh23g.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822439
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    text == text.chars().rev().collect::<String>()\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 101
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut chars: Vec<char> = text.chars().collect();\n    let text_len\
    \ = chars.len();\n    let mut i = 0;\n    let mut j = text_len - 1;\n    while\
    \ i < j {\n        if chars[i] != chars[j] {\n            return false;\n    \
    \    }\n        i += 1;\n        j -= 1;\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpsks2v36y.rs:6:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822439
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    text == text.chars().rev().collect::<String>()\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 101
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let (mut begin, mut end) = (0, text.len() - 1);\n    for _ in\
    \ 0..(text.len() / 2) {\n        if text.chars().nth(begin) != text.chars().nth(end)\
    \ {\n            return false;\n        }\n        begin += 1;\n        end -=\
    \ 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp67ukgp18.rs:3:36

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822439
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let reversed_string = String::from(text.chars().rev().collect::<String>());\n\
    \    return reversed_string == text;\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822439
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    // Remove spacing, punctuation and make everything lowercase\n\
    \    let filtered = text.split_whitespace().collect::<String>().to_lowercase();\n\
    \    // Check if reversed string is the same as filtered string\n    filtered\
    \ == filtered.chars().rev().collect::<String>()\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822439
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let text = text.to_lowercase();\n    text.chars().eq(text.chars().rev())\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822439
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().rev().collect::<String>() == text\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 101
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut chars: Vec<char> = text.chars().collect();\n    let mut\
    \ i = 0;\n    let mut j = chars.len() - 1;\n    while i < j {\n        if chars[i]\
    \ != chars[j] {\n            return false;\n        }\n        i += 1;\n     \
    \   j -= 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpk7td9dn_.rs:5:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822439
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().eq(text.chars().rev())\n}\n\nfn main() {\n    let\
    \ candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n\
    \    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 1
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n+    let mut len = text.len();\n+    for (i, c) in text.chars().enumerate()\
    \ {\n+        if c != text.chars().nth(len - i - 1).unwrap() {\n+            return\
    \ false;\n+        }\n+    }\n+    true\n+}\n+\n+/// Returns a vector containing\
    \ the first n palindromes\n+fn first_n_palindromes(n: usize) -> Vec<String> {\n\
    +    let mut palindromes = Vec::new();\n+    let mut i = 1;\n+    loop {\n+  \
    \      if is_palindrome(i.to_string()) {\n+            palindromes.push(i.to_string());\n\
    +        }\n+        if palindromes.len() == n {\n+            break;\n+     \
    \   }\n+        i += 1;\n+    }\n+    palindromes\n+}\n+\n+#[cfg(test)]\n+mod\
    \ tests {\n+    use super::*;\n+\n+    #[test]\n+    fn test_is_palindrome() {\n\
    +        assert_eq!(is_palindrome(\"\".to_string()), true);\n+        assert_eq!(is_palindrome(\"\
    a\".to_string()), true);\n+        assert_eq!(is_palindrome(\"aa\".to_string()),\
    \ true);\n+        assert_eq!(is_palindrome(\"aba\".to_string()), true);\n+  \
    \      assert_eq!(is_palindrome(\"abba\".to_string()), true);\n+        assert_eq!(is_palindrome(\"\
    abc\".to_string()), false);\n+        assert_eq!(is_palindrome(\"abab\".to_string()),\
    \ false);\n+    }\n+\n+    #[test]\n+    fn test_first_n_palindromes() {\n+  \
    \      assert_eq!(first_n_palindromes(5), [\"1\", \"2\", \"3\", \"4\", \"5\"]);\n\
    +    }\n+}\n\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: unexpected closing delimiter: `}`\n  --> /tmp/tmp_y5wvyzj.rs:49:1\n\
    \   |\n29 | +mod tests {\n   |            - this opening brace...\n...\n47 | +}\n\
    \   |  - ...matches this closing brace\n48 | \n49 | }\n   | ^ unexpected closing\
    \ delimiter\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659822438
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut string = text.to_lowercase();\n    string = string.trim_matches(|c:\
    \ char| !c.is_alphanumeric()).to_string();\n    string == string.chars().rev().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822439
- exit_code: 1
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut \n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n --> /tmp/tmpu0822iw4.rs:4:1\n \
    \ |\n4 | }\n  | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659822438
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let length = text.len();\n    let s = &text[..];\n    for i in\
    \ 0..length / 2 {\n        if s.chars().nth(i) != s.chars().nth(length - i - 1)\
    \ {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822439
- exit_code: 101
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut left = 0;\n    let mut right = text.len() - 1;\n\n  \
    \  while left < right {\n        while !text.is_char_boundary(left) {\n      \
    \      left += 1;\n        }\n        while !text.is_char_boundary(right) {\n\
    \            right -= 1;\n        }\n\n        if left > right {\n           \
    \ break;\n        }\n\n        if text.as_bytes()[left] != text.as_bytes()[right]\
    \ {\n            return false;\n        }\n\n        left += 1;\n        right\
    \ -= 1;\n    }\n\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp0vdxaeig.rs:4:21

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822439
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let text = text.to_lowercase();\n    let mut chars: Vec<char>\
    \ = text.chars().collect();\n    let len = chars.len();\n    for i in 0..len/2\
    \ {\n        if chars[i] != chars[len-i-1] {\n            return false;\n    \
    \    }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822439
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let trimmed_text = text.trim();\n    let text_length = trimmed_text.len();\n\
    \    let half_length = text_length / 2;\n\n    for i in 0..half_length {\n   \
    \     if trimmed_text.chars().nth(i) != trimmed_text.chars().nth(text_length -\
    \ i - 1) {\n            return false;\n        }\n    }\n\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822439
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    return text == text.chars().rev().collect::<String>();\n}\n\n\
    fn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822439
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let text = text.to_lowercase();\n    let text = text.chars().filter(|c|\
    \ c.is_alphanumeric()).collect::<String>();\n    let text_len = text.len();\n\
    \    text.chars().enumerate().all(|(i, c)| text.chars().nth(text_len - i - 1).unwrap()\
    \ == c)\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822439
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().rev().collect::<String>() == text\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let reversed_text = text.chars().rev().collect::<String>();\n\
    \    text == reversed_text\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822439
- exit_code: 1
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let text = text.to_lowercase();\n    let mut vec: Vec<char> =\
    \ text.chars().collect();\n    vec.retain(|x| x.is_alphanumeric());\n    vec ==\
    \ vec.iter().rev().cloned().collect()\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0283]: type annotations needed\n --> /tmp/tmp3ct8sz2l.rs:6:9\n \
    \ |\n6 |     vec == vec.iter().rev().cloned().collect()\n  |         ^^ cannot\
    \ infer type\n  |\n  = note: cannot satisfy `Vec<char>: PartialEq<_>`\nhelp: consider\
    \ specifying the type argument in the method call\n  |\n6 |     vec == vec.iter().rev().cloned().collect::<B>()\n\
    \  |                                             +++++\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0283`.\n"
  stdout: ''
  timestamp: 1659822439
- exit_code: 101
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    if text.len() <= 1 {\n        return true;\n    }\n\n    let\
    \ (first, last) = text.split_at(1);\n    let (_, middle) = text.split_at(text.len()\
    \ - 1);\n\n    if first != last {\n        return false;\n    }\n\n    is_palindrome(middle.to_string())\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpund7leel.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822439
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().eq(text.chars().rev())\n}\n\nfn main() {\n    let\
    \ candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n\
    \    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    text == text.chars().rev().collect::<String>()\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let chars: Vec<char> = text.chars().collect();\n    let len =\
    \ chars.len();\n    for i in 0..len / 2 {\n        if chars[i] != chars[len -\
    \ i - 1] {\n            return false;\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822439
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let letters = text.to_lowercase()\n        .chars()\n       \
    \ .filter(|ch| ch.is_alphabetic())\n        .collect::<Vec<char>>();\n\n    let\
    \ half_length = letters.len() / 2;\n    (0..half_length).all(|i| letters[i] ==\
    \ letters[letters.len() - i - 1])\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822439
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let clean_text = text.to_lowercase().replace(|c: char| !c.is_alphanumeric(),\
    \ \"\");\n    clean_text == clean_text.chars().rev().collect::<String>()\n}\n\n\
    fn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822439
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let len = text.len();\n    for i in 0..len / 2 {\n        if\
    \ text.chars().nth(i) != text.chars().nth(len - i - 1) {\n            return false;\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822439
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let len = text.len();\n    for i in 0..len / 2 {\n        if\
    \ text.chars().nth(i) != text.chars().nth(len - i - 1) {\n            return false;\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822439
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut forward_chars = text.chars();\n    let mut backward_chars\
    \ = text.chars().rev();\n\n    for _ in 0..(text.len() / 2) {\n        if forward_chars.next()\
    \ != backward_chars.next() {\n            return false;\n        }\n    }\n\n\
    \    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822439
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut text = text.chars().collect::<Vec<char>>();\n    let\
    \ len = text.len();\n    for i in 0..len/2 {\n        if text[i] != text[len-i-1]\
    \ {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822439
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    // TODO: Implement is_palindrome.\n    let vec: Vec<&str> = text.split(\"\
    \").collect();\n    for (i, &c) in vec.iter().enumerate() {\n        if c != vec[vec.len()\
    \ - 1 - i] {\n            return false;\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822439
- exit_code: 101
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut chars: Vec<char> = text.chars().collect();\n    let mut\
    \ front = 0;\n    let mut back = chars.len() - 1;\n\n    while front < back {\n\
    \        if chars[front] != chars[back] {\n            return false;\n       \
    \ }\n        front += 1;\n        back -= 1;\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpevolre_b.rs:5:20

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822439
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n\tlet mut text = text.to_lowercase();\n\ttext = text.replace(char::is_whitespace,\
    \ \"\");\n\ttext == text.chars().rev().collect::<String>()\n}\n\nfn main() {\n\
    \    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822439
- exit_code: 1
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n+    let reversed = text.chars().rev().collect::<String>();\n+  \
    \  text == reversed\n+}\n\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "error: unexpected closing delimiter: `}`\n --> /tmp/tmpjf584o_j.rs:7:1\n\
    \  |\n2 | fn is_palindrome(text: String) -> bool {\n  |                      \
    \                  - this opening brace...\n...\n5 | +}\n  |  - ...matches this\
    \ closing brace\n6 | \n7 | }\n  | ^ unexpected closing delimiter\n\nerror: aborting\
    \ due to previous error\n\n"
  stdout: ''
  timestamp: 1659822439
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().eq(text.chars().rev())\n}\n\nfn main() {\n    let\
    \ candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n\
    \    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().zip(text.chars().rev()).all(|(a, b)| a == b)\n}\n\
    \nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().rev().collect::<String>() == text\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 1
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let reversed_text = reverse_text(text);\n    text == reversed_text\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `reverse_text` in this scope\n --> /tmp/tmp7iwn6yrq.rs:3:25\n\
    \  |\n3 |     let reversed_text = reverse_text(text);\n  |                   \
    \      ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822439
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().eq(text.chars().rev())\n}\n\nfn main() {\n    let\
    \ candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n\
    \    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 101
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let len = text.len();\n    let last_index = len - 1;\n    let\
    \ first_char = text.chars().nth(0).unwrap();\n    let last_char = text.chars().nth(last_index).unwrap();\n\
    \n    let mut f_pointer = 0;\n    let mut l_pointer = last_index;\n\n    while\
    \ f_pointer < l_pointer {\n        if text.chars().nth(f_pointer).unwrap() !=\
    \ text.chars().nth(l_pointer).unwrap() {\n            return false;\n        }\n\
    \n        f_pointer += 1;\n        l_pointer -= 1;\n    }\n\n    true\n}\n\nfn\
    \ main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp70f3tb1x.rs:4:22

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822439
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut chars: Vec<char> = text.chars().collect();\n    chars.reverse();\n\
    \    text == chars.into_iter().collect::<String>()\n}\n\nfn main() {\n    let\
    \ candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n\
    \    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 101
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut chars = text.chars();\n    let mut stack = Vec::new();\n\
    \n    while let Some(c) = chars.next() {\n        if c.is_alphanumeric() {\n \
    \           stack.push(c.to_lowercase().next().unwrap());\n        }\n    }\n\n\
    \    while let Some(c) = stack.pop() {\n        if c != chars.next().unwrap().to_lowercase().next().unwrap()\
    \ {\n            return false;\n        }\n    }\n\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmpojt5t3e9.rs:13:30

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822439
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut text = text.clone();\n    text.make_ascii_lowercase();\n\
    \    text.chars().all(|c| c.is_alphanumeric()) && text == text.chars().rev().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822439
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let chars: Vec<char> = text.chars().collect();\n    for i in\
    \ 0..chars.len() / 2 {\n        if chars[i] != chars[chars.len() - i - 1] {\n\
    \            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n   \
    \ let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822439
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    // convert string to lowercase\n    let text = text.to_lowercase();\n\
    \    // convert string to vector of chars\n    let chars: Vec<char> = text.chars().collect();\n\
    \    // we want to check if the string is a palindrome\n    // this is the case\
    \ if the front half of the vector matches the back half of the vector\n    //\
    \ e.g. vec!['a', 'b', 'c', 'c', 'b', 'a'] has a palindrome with chars 'c' and\
    \ 'b'\n    let mut match_count = 0;\n    // loop through the first half of the\
    \ vector\n    for i in 0..chars.len() / 2 {\n        // if the current char matches\
    \ the last - index char\n        if chars[i] == chars[chars.len() - 1 - i] {\n\
    \            // increase the match counter\n            match_count += 1;\n  \
    \      }\n    }\n    // if the match count is equal to the number of chars in\
    \ the first half of the vector\n    if match_count == chars.len() / 2 {\n    \
    \    // it is a palindrome\n        return true;\n    }\n    // otherwise it is\
    \ not a palindrome\n    false\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822439
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    // remove special characters\n    let norm_text = text.chars().filter(|x|\
    \ x.is_alphanumeric()).collect::<String>();\n    // convert to lowercase\n   \
    \ let norm_text = norm_text.to_lowercase();\n    // create a reversed string\n\
    \    let rev_text = norm_text.chars().rev().collect::<String>();\n    // compare\
    \ the two\n    norm_text == rev_text\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822439
- exit_code: 101
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut chars: Vec<char> = text.chars().collect();\n    let mut\
    \ i = 0;\n    let mut j = chars.len() - 1;\n    while i < j {\n        if chars[i]\
    \ != chars[j] {\n            return false;\n        }\n        i += 1;\n     \
    \   j -= 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpk7td9dn_.rs:5:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822439
- exit_code: 101
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut left: usize = 0;\n    let mut right: usize = text.len()\
    \ - 1;\n\n    while left < right {\n        let left_char = text.chars().nth(left).unwrap();\n\
    \        let right_char = text.chars().nth(right).unwrap();\n\n        if left_char\
    \ != right_char {\n            return false;\n        }\n\n        left += 1;\n\
    \        right -= 1;\n    }\n\n    true\n}\n\nfn main() {\n    let candidate =\
    \ is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpkdmtoc8w.rs:4:28

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822439
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let forward = text.chars().collect::<Vec<char>>();\n    let backward\
    \ = text.chars().rev().collect::<Vec<char>>();\n    forward == backward\n}\n\n\
    fn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822439
- exit_code: 101
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut text_clone = text.clone();\n    text_clone.make_ascii_lowercase();\n\
    \    text_clone.drain(..).filter(|c| c.is_alphanumeric()).collect::<String>()\
    \ ==\n        text_clone.chars().rev().collect::<String>()\n}\n\nfn main() {\n\
    \    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp9dtrtmea.rs:12:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822439
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let lowercase_text = text.to_lowercase();\n    let sanitized_text\
    \ = lowercase_text.chars().filter(|c| c.is_alphanumeric()).collect::<String>();\n\
    \    let left = sanitized_text.chars();\n    let right = sanitized_text.chars().rev();\n\
    \    left.eq(right)\n}\n\nfn main() {\n    let candidate = is_palindrome;\n  \
    \  assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822439
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut chars = text.chars();\n    let mut is_palindrome = true;\n\
    \    let mut c1 = chars.next();\n    let mut c2 = chars.next_back();\n\n    loop\
    \ {\n        match (c1, c2) {\n            (Some(ref i), Some(ref j)) => {\n \
    \               if i != j {\n                    is_palindrome = false;\n    \
    \                break;\n                }\n            }\n            (None,\
    \ _) => break,\n            (_, None) => break,\n        }\n        c1 = chars.next();\n\
    \        c2 = chars.next_back();\n    }\n\n    is_palindrome\n}\n\nfn main() {\n\
    \    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822439
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    text == text.chars().rev().collect::<String>()\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let len = text.len();\n    let half = len / 2;\n    let upper\
    \ = &text[..half];\n    let lower = &text[len - half..];\n    upper == lower.chars().rev().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822439
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().rev().collect::<String>() == text\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    text == text.chars().rev().collect::<String>()\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().zip(text.chars().rev()).all(|(a, b)| a == b)\n}\n\
    \nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let trimmed = text.trim();\n    let reversed = trimmed.chars().rev().collect::<String>();\n\
    \    // if the chars are the same, that means it's a palindrome\n    return trimmed\
    \ == reversed;\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822439
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    if text.len() == 0 {\n        return true;\n    }\n    if text.len()\
    \ == 1 {\n        return true;\n    }\n    let first_char = text.chars().nth(0).unwrap();\n\
    \    let last_char = text.chars().nth(text.len() - 1).unwrap();\n    if first_char\
    \ != last_char {\n        return false;\n    }\n    let text = &text[1..text.len()\
    \ - 1];\n    is_palindrome(text.to_string())\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822439
- exit_code: 1
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let reverse = String::from_utf8(text.chars().rev().collect()).unwrap();\n\
    \    text == reverse\n}\n\nfn main() {\n    let candidate = is_palindrome;\n \
    \   assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n --> /tmp/tmpeyi8q7sw.rs:3:37\n  |\n3 |     let\
    \ reverse = String::from_utf8(text.chars().rev().collect()).unwrap();\n  |   \
    \                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n  |\n  = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659822439
- exit_code: 101
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut left = 0;\n    let mut right = text.len() - 1;\n\n  \
    \  while left < right {\n        while !text.chars().nth(left).unwrap().is_alphanumeric()\
    \ {\n            left += 1;\n        }\n\n        while !text.chars().nth(right).unwrap().is_alphanumeric()\
    \ {\n            right -= 1;\n        }\n\n        if text.chars().nth(left).unwrap().to_lowercase().next().unwrap()\
    \ != text.chars().nth(right).unwrap().to_lowercase().next().unwrap() {\n     \
    \       return false;\n        }\n\n        left += 1;\n        right -= 1;\n\
    \    }\n\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n   \
    \ assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp8hrfir58.rs:4:21

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822439
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().rev().collect::<String>() == text\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().rev().collect::<String>() == text\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut chars: Vec<char> = text.chars().collect();\n    chars.reverse();\n\
    \    text == chars.into_iter().collect::<String>()\n}\n\nfn main() {\n    let\
    \ candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n\
    \    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 101
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut chars: Vec<char> = text.chars().collect();\n    let mut\
    \ i = 0;\n    let mut j = chars.len() - 1;\n    while i < j {\n        if chars[i]\
    \ != chars[j] {\n            return false;\n        }\n        i += 1;\n     \
    \   j -= 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpk7td9dn_.rs:5:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822439
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().all(|c| c.is_alphanumeric()) && text.to_lowercase()\
    \ == text.to_lowercase().chars().rev().collect::<String>()\n}\n\nfn main() {\n\
    \    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822439
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut chars: Vec<char> = text.chars().collect();\n    chars.reverse();\n\
    \    let reversed = chars.into_iter().collect::<String>();\n    text == reversed\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822439
- exit_code: 101
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let len = text.len();\n    let mut i = 0;\n    let mut j = len\
    \ - 1;\n    while i < j {\n        if text.chars().nth(i) != text.chars().nth(j)\
    \ {\n            return false;\n        }\n        i += 1;\n        j -= 1;\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpga5_msay.rs:5:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822439
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    text.chars().rev().collect::<String>() == text\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822437
- exit_code: 1
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n+    text.chars().all(|x| x == text.chars().nth(text.len() - 1).unwrap())\n\
    +}\n+\n+// Tests\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n\
    +    fn test_is_palindrome() {\n+        assert_eq!(is_palindrome(\"racecar\"\
    .to_string()), true);\n+        assert_eq!(is_palindrome(\"refer\".to_string()),\
    \ false);\n+    }\n+}\n\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "error: unexpected closing delimiter: `}`\n  --> /tmp/tmp8mq9e9po.rs:18:1\n\
    \   |\n8  | +mod tests {\n   |            - this opening brace...\n...\n16 | +}\n\
    \   |  - ...matches this closing brace\n17 | \n18 | }\n   | ^ unexpected closing\
    \ delimiter\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659822439
- exit_code: 101
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let middle = text.len() / 2;\n    let first_half = &text[..middle];\n\
    \    let second_half = &text[middle..];\n    first_half == second_half.chars().rev().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmppop6_wt1.rs:12:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822439
- exit_code: 101
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    // TODO: If given string is a palindrome, return true. Otherwise,\
    \ return false.\n    let mut chars: Vec<char> = text.chars().collect();\n    let\
    \ mut i = 0;\n    let mut j = chars.len() - 1;\n    while i < j {\n        if\
    \ chars[i] != chars[j] {\n            return false;\n        }\n        i += 1;\n\
    \        j -= 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmprnnb51pe.rs:6:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822439
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n\tlet mut cleaned_text = String::new();\n\tfor ch in text.chars()\
    \ {\n\t\tif ch.is_alphanumeric() {\n\t\t\tcleaned_text.push(ch.to_lowercase().next().unwrap());\n\
    \t\t}\n\t}\n\tcleaned_text == cleaned_text.chars().rev().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822439
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    // fix case\n    let text = text.to_lowercase();\n    // remove\
    \ non-alpha characters\n    let text = text.chars().filter(|x| x.is_alphabetic()).collect::<String>();\n\
    \    // check if its a palindrome\n    text == text.chars().rev().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822440
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    // Remove spaces and convert to lowercase\n    let clean_text\
    \ = text.to_lowercase().replace(\" \", \"\");\n\n    // Use iterators to test\
    \ for equality\n    clean_text.chars().zip(clean_text.chars().rev()).all(|(a,\
    \ b)| a == b)\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822440
- exit_code: 0
  program: "/// Checks if given string is a palindrome\nfn is_palindrome(text: String)\
    \ -> bool {\n    let mut text = text.to_lowercase();\n    text.retain(|c| c.is_alphanumeric());\n\
    \    text == text.chars().rev().collect::<String>()\n}\n\nfn main() {\n    let\
    \ candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n\
    \    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822438
