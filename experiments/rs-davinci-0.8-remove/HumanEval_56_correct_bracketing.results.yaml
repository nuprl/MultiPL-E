language: rs
name: HumanEval_56_correct_bracketing
results:
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut opened = 0;\n    for c in brackets.chars() {\n\
    \        match c {\n            '<' => opened += 1,\n            '>' => opened\
    \ -= 1,\n            _ => panic!(\"Unexpected character\"),\n        }\n     \
    \   if opened < 0 {\n            return false;\n        }\n    }\n    opened ==\
    \ 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    // Given that we only have two different brackets, it\
    \ suffices to count them.\n    // In this code, \"open_count\" is the number of\
    \ opening brackets. When it is\n    // non-zero, we have to have a closing bracket\
    \ before adding another opening\n    // bracket.\n    let mut open_count = 0;\n\
    \    for b in brackets.chars() {\n        match b {\n            '<' => {\n  \
    \              if open_count == 0 {\n                    open_count += 1;\n  \
    \              } else {\n                    return false;\n                }\n\
    \            }\n            '>' => {\n                if open_count == 0 {\n \
    \                   return false;\n                } else {\n                \
    \    open_count -= 1;\n                }\n            }\n            _ => panic!(\"\
    Unexpected character\"),\n        }\n    }\n    return open_count == 0;\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmprdwg4fsa.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut depth = 0;\n    for c in brackets.chars() {\n\
    \        match c {\n            '<' => depth += 1,\n            '>' => depth -=\
    \ 1,\n            _ => panic!(\"Invalid character: {}\", c),\n        }\n    \
    \    if depth < 0 {\n            return false;\n        }\n    }\n    depth ==\
    \ 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().filter(|&c| c == '<').count() == brackets.chars().filter(|&c|\
    \ c == '>').count()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpffl_x1qe.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut count = 0;\n    for b in brackets.chars() {\n\
    \        if b == '<' {\n            count += 1;\n        } else if b == '>' {\n\
    \            count -= 1;\n        }\n        if count < 0 {\n            return\
    \ false;\n        }\n    }\n    count == 0\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    // Split string into an array of characters.\n    let\
    \ bracks = brackets.chars().collect::<Vec<char>>();\n    let mut stack = vec![];\n\
    \n    for b in bracks {\n        match b {\n            '<' => stack.push(b),\n\
    \            '>' => {\n                match stack.pop() {\n                 \
    \   Some(x) => {\n                        if x != '<' {\n                    \
    \        return false;\n                        }\n                    }\n   \
    \                 None => return false,\n                }\n            }\n  \
    \          _ => continue,\n        }\n    }\n\n    // If stack is empty, every\
    \ bracket was paired.\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut parent_depth = 0;\n    for ch in brackets.chars()\
    \ {\n        if ch == '<' {\n            parent_depth += 1;\n        } else if\
    \ ch == '>' {\n            parent_depth -= 1;\n        }\n        if parent_depth\
    \ < 0 {\n            return false;\n        }\n    }\n    parent_depth == 0\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut count = 0;\n    for bracket in brackets.chars()\
    \ {\n        match bracket {\n            '<' => count += 1,\n            '>'\
    \ => count -= 1,\n            _ => return false,\n        }\n        if count\
    \ < 0 {\n            return false;\n        }\n    }\n    return count == 0;\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    // Do something\n    true\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjgu61k4o.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut brackets = brackets.chars().collect::<Vec<char>>();\n\
    \    let mut brackets_stack = Vec::new();\n    while !brackets.is_empty() {\n\
    \        let bracket = brackets.pop().unwrap();\n        if bracket == '>' {\n\
    \            brackets_stack.push(bracket);\n        } else if bracket == '<' {\n\
    \            if brackets_stack.is_empty() {\n                return false;\n \
    \           }\n            brackets_stack.pop();\n        }\n    }\n    brackets_stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for ch in brackets.chars()\
    \ {\n        match ch {\n            '<' => stack.push(ch),\n            '>' =>\
    \ {\n                if stack.is_empty() {\n                    return false;\n\
    \                }\n                let last = stack.pop().unwrap();\n       \
    \         if last != '<' {\n                    return false;\n              \
    \  }\n            }\n            _ => (),\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    for b in brackets.chars()\
    \ {\n        match b {\n            '<' => stack.push(b),\n            '>' =>\
    \ {\n                if stack.is_empty() {\n                    return false;\n\
    \                }\n                let last = stack.pop().unwrap();\n       \
    \         if last != '<' {\n                    return false;\n              \
    \  }\n            }\n            _ => panic!(\"Unknown bracket: {}\", b),\n  \
    \      }\n    }\n    return stack.is_empty();\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    if brackets.len() % 2 != 0 {\n        return false;\n\
    \    }\n\n    let mut balance = 0;\n    for c in brackets.chars() {\n        match\
    \ c {\n            '<' => balance += 1,\n            '>' => balance -= 1,\n  \
    \          _ => panic!(\"Unexpected character {}\", c),\n        }\n        if\
    \ balance < 0 {\n            return false;\n        }\n    }\n    balance == 0\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    for c in brackets.chars()\
    \ {\n        match c {\n            '<' => stack.push(c),\n            '>' =>\
    \ {\n                if stack.is_empty() {\n                    return false;\n\
    \                }\n                let last = stack.pop().unwrap();\n       \
    \         if last != '<' {\n                    return false;\n              \
    \  }\n            }\n            _ => {}\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Stack::new();\n    for c in brackets.chars()\
    \ {\n        match c {\n            '<' => stack.push(c),\n            '>' =>\
    \ {\n                if stack.is_empty() {\n                    return false;\n\
    \                }\n                stack.pop();\n            }\n            _\
    \ => panic!(\"Unknown bracket: {}\", c),\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Stack`\n --> /tmp/tmpegutgqdw.rs:4:21\n\
    \  |\n4 |     let mut stack = Stack::new();\n  |                     ^^^^^ use\
    \ of undeclared type `Stack`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659821431
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut count = 0;\n    for c in brackets.chars() {\n\
    \        if c == '<' {\n            count += 1;\n        } else if c == '>' {\n\
    \            count -= 1;\n        }\n        if count < 0 {\n            return\
    \ false;\n        }\n    }\n    count == 0\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_count = 0;\n    for ch in brackets.chars()\
    \ {\n        match ch {\n            '<' => open_count += 1,\n            '>'\
    \ => open_count -= 1,\n            _ => continue,\n        }\n        if open_count\
    \ < 0 {\n            return false;\n        }\n    }\n    open_count == 0\n}\n\
    \nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut brackets = brackets.chars().peekable();\n   \
    \ let mut stack = Vec::new();\n    loop {\n        let bracket = brackets.next();\n\
    \        match bracket {\n            Some('<') => stack.push('<'),\n        \
    \    Some('>') => {\n                if stack.is_empty() {\n                 \
    \   return false;\n                }\n                stack.pop();\n         \
    \   }\n            Some(_) => {}\n            None => break,\n        }\n    }\n\
    \    stack.is_empty()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut count = 0;\n    for b in brackets.chars() {\n\
    \        if b == '<' {\n            count += 1;\n        } else if b == '>' {\n\
    \            count -= 1;\n        }\n        if count < 0 {\n            return\
    \ false;\n        }\n    }\n    count == 0\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut left_brackets: u32 = 0;\n    let mut right_brackets:\
    \ u32 = 0;\n\n    for char in brackets.chars() {\n        match char {\n     \
    \       '<' => left_brackets += 1,\n            '>' => right_brackets += 1,\n\
    \            _ => println!(\"Unexpected character!\"),\n        }\n    }\n\n \
    \   if left_brackets == right_brackets {\n        true\n    } else {\n       \
    \ false\n    }\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n  \
    \  assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpirm1sqh0.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    // `mut`s can only be declared inside functions, so we\
    \ can't declare `mut counter` in the main\n    // function.\n    let mut counter\
    \ = 0;\n    for ch in brackets.chars() {\n        match ch {\n            '<'\
    \ => counter += 1,\n            '>' => counter -= 1,\n            _ => println!(\"\
    unknown symbol {}\", ch),\n        }\n        if counter < 0 {\n            return\
    \ false;\n        }\n    }\n    counter == 0\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut unmatched_brackets = 0;\n    for ch in brackets.chars()\
    \ {\n        if ch == '<' {\n            unmatched_brackets += 1;\n        } else\
    \ if ch == '>' {\n            unmatched_brackets -= 1;\n        }\n        if\
    \ unmatched_brackets < 0 {\n            return false;\n        }\n    }\n    return\
    \ unmatched_brackets == 0;\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut counter = 0;\n    for bracket in brackets.chars()\
    \ {\n        if bracket == '<' {\n            counter += 1;\n        } else if\
    \ bracket == '>' {\n            counter -= 1;\n        }\n        if counter <\
    \ 0 {\n            return false;\n        }\n    }\n    counter == 0\n}\n\nfn\
    \ main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for bracket in brackets.chars()\
    \ {\n        match bracket {\n            '<' => stack.push(bracket),\n      \
    \      '>' => match stack.pop() {\n                Some('<') => {}\n         \
    \       _ => return false,\n            },\n            _ => unreachable!(),\n\
    \        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    // 'stack' is used to keep track of the bracketing of\
    \ the string.\n    //\n    // When the next bracket is an opening bracket, we\
    \ push it onto the stack.\n    // When the next bracket is a closing bracket,\
    \ we pop the top of the stack\n    // to see if it matches.\n    //\n    // When\
    \ the string is fully parsed, the stack should be empty.\n    let mut stack: Vec<char>\
    \ = Vec::new();\n\n    for c in brackets.chars() {\n        if c == '<' {\n  \
    \          stack.push(c);\n        } else if c == '>' {\n            // If there\
    \ is no last element, then there was a closing bracket\n            // without\
    \ a corresponding opening bracket.\n            if stack.pop() == None {\n   \
    \             return false;\n            }\n        }\n    }\n\n    // The stack\
    \ must be empty, otherwise there was an opening bracket without\n    // a corresponding\
    \ closing bracket.\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut counter = 0;\n    for b in brackets.chars() {\n\
    \        match b {\n            '<' => counter += 1,\n            '>' => counter\
    \ -= 1,\n            _ => (),\n        }\n        if counter < 0 {\n         \
    \   return false;\n        }\n    }\n    counter == 0\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets.chars()\
    \ {\n        match c {\n            '<' => stack.push(c),\n            '>' =>\
    \ {\n                if stack.len() == 0 {\n                    return false;\n\
    \                } else {\n                    let last = stack.pop().unwrap();\n\
    \                    if last != '<' {\n                        return false;\n\
    \                    }\n                }\n            }\n            _ => panic!(\"\
    Unexpected character. Expected < or >\"),\n        }\n    }\n    return stack.len()\
    \ == 0;\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets.chars()\
    \ {\n        match c {\n            '<' => stack.push(c),\n            '>' =>\
    \ {\n                match stack.pop() {\n                    Some('<') => continue,\n\
    \                    Some(_) => return false,\n                    None => return\
    \ false,\n                }\n            }\n            _ => (),\n        }\n\
    \    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut nest_lvl = 0;\n    for c in brackets.chars()\
    \ {\n        match c {\n            '<' => nest_lvl += 1,\n            '>' =>\
    \ nest_lvl -= 1,\n            _ => panic!(\"Unexpected character: {}\", c),\n\
    \        }\n        if nest_lvl < 0 {\n            return false;\n        }\n\
    \    }\n    nest_lvl == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for b in brackets.chars()\
    \ {\n        match b {\n            '<' => stack.push(b),\n            '>' =>\
    \ {\n                match stack.pop() {\n                    Some(t) => if t\
    \ != '<' { return false; },\n                    None => return false,\n     \
    \           }\n            },\n            _ => panic!(\"You used a letter that\
    \ is not < or >.\"),\n        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut unclosed_brackets = 0;\n    for c in brackets.chars()\
    \ {\n        match c {\n            '<' => unclosed_brackets += 1,\n         \
    \   '>' => unclosed_brackets -= 1,\n            _ => {\n                println!(\"\
    Non-bracketing string\");\n                return false;\n            }\n    \
    \    }\n        if unclosed_brackets < 0 {\n            return false;\n      \
    \  }\n    }\n    unclosed_brackets == 0\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets.chars()\
    \ {\n        match c {\n            '<' => stack.push(c),\n            '>' =>\
    \ match stack.pop() {\n                Some(x) => {\n                    if x\
    \ != '<' {\n                        return false;\n                    }\n   \
    \             }\n                None => return false,\n            },\n     \
    \       _ => panic!(\"Invalid character in string\"),\n        }\n    }\n    return\
    \ stack.is_empty();\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Stack::new();\n    for c in brackets.chars()\
    \ {\n        match c {\n            '<' => stack.push(c),\n            '>' =>\
    \ {\n                if stack.is_empty() {\n                    return false;\n\
    \                }\n                stack.pop();\n            }\n            _\
    \ => {}\n        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Stack`\n --> /tmp/tmp_gk4p3hd.rs:4:21\n\
    \  |\n4 |     let mut stack = Stack::new();\n  |                     ^^^^^ use\
    \ of undeclared type `Stack`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for b in brackets.chars()\
    \ {\n        match b {\n            '<' => stack.push(b),\n            '>' =>\
    \ match stack.pop() {\n                Some('<') => (),\n                _ =>\
    \ return false,\n            },\n            _ => return false,\n        }\n \
    \   }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut counter = 0;\n    for c in brackets.chars() {\n\
    \        match c {\n            '<' => counter += 1,\n            '>' => counter\
    \ -= 1,\n            _ => {},\n        }\n        if counter < 0 {\n         \
    \   return false;\n        }\n    }\n    return counter == 0;\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    for b in brackets.chars()\
    \ {\n        match b {\n            '>' => match stack.pop() {\n             \
    \   Some('<') => (),\n                _ => return false,\n            },\n   \
    \         '<' => stack.push(b),\n            _ => return false,\n        }\n \
    \   }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for ch in brackets.chars()\
    \ {\n        match ch {\n            '<' => stack.push(ch),\n            '>' =>\
    \ {\n                if stack.is_empty() {\n                    return false;\n\
    \                }\n                stack.pop();\n            }\n            _\
    \ => panic!(\"unexpected char: {}\", ch),\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().fold(0, |mut open, ch| {\n        if\
    \ ch == '<' {\n            open += 1;\n        } else if ch == '>' {\n       \
    \     open -= 1;\n        }\n        if open < 0 {\n            panic!(\"Found\
    \ closing '>' without opening '<'\");\n        }\n        open\n    }) == 0\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''Found closing ''>'' without opening ''<'''',
    /tmp/tmpu0n79r7c.rs:11:13

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for bracket in brackets.chars()\
    \ {\n        match bracket {\n            '<' => stack.push(bracket),\n      \
    \      '>' => {\n                match stack.pop() {\n                    Some(b)\
    \ => {\n                        if b != '<' {\n                            return\
    \ false;\n                        }\n                    }\n                 \
    \   None => return false,\n                }\n            }\n            _ =>\
    \ (),\n        }\n    }\n    return stack.is_empty();\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets.chars()\
    \ {\n        match c {\n            '<' => stack.push(c),\n            '>' =>\
    \ {\n                if stack.pop() != Some('<') {\n                    return\
    \ false;\n                }\n            }\n            _ => panic!(\"Invalid\
    \ bracket\"),\n        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for ch in brackets.chars()\
    \ {\n        match ch {\n            '<' => stack.push(ch),\n            '>' =>\
    \ {\n                if stack.pop() != Some('<') {\n                    return\
    \ false;\n                }\n            }\n            _ => {\n             \
    \   return false;\n            }\n        }\n    }\n    stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for ch in brackets.chars()\
    \ {\n        match ch {\n            '<' => stack.push(ch),\n            '>' =>\
    \ {\n                if stack.is_empty() {\n                    return false;\n\
    \                }\n                stack.pop();\n            }\n            _\
    \ => {}\n        }\n    }\n    return stack.is_empty();\n}\n\nfn main() {\n  \
    \  let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets.chars()\
    \ {\n        match c {\n            '<' => stack.push(c),\n            '>' =>\
    \ {\n                match stack.pop() {\n                    Some('<') => (),\n\
    \                    _ => return false,\n                }\n            }\n  \
    \          _ => (),\n        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut balance = 0;\n    for c in brackets.chars() {\n\
    \        match c {\n            '<' => balance += 1,\n            '>' => balance\
    \ -= 1,\n            _ => (),\n        }\n        if balance < 0 {\n         \
    \   return false;\n        }\n    }\n    balance == 0\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for b in brackets.chars()\
    \ {\n        match b {\n            '<' => stack.push(b),\n            '>' =>\
    \ {\n                if let Some(last) = stack.pop() {\n                    if\
    \ last != '<' {\n                        return false;\n                    }\n\
    \                } else {\n                    return false;\n               \
    \ }\n            }\n            _ => (),\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    if brackets.is_empty() {\n        return true;\n    }\n\
    \n    let mut stack = vec![];\n    for c in brackets.chars() {\n        match\
    \ c {\n            '<' => stack.push(c),\n            '>' => {\n             \
    \   if let Some('<') = stack.pop() {\n                    continue;\n        \
    \        }\n                return false;\n            }\n            _ => continue,\n\
    \        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Stack::new();\n    for bracket in brackets.chars()\
    \ {\n        match bracket {\n            '<' => stack.push(bracket),\n      \
    \      '>' => match stack.pop() {\n                Some('<') => (),\n        \
    \        _ => return false,\n            },\n            _ => (),\n        }\n\
    \    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Stack`\n --> /tmp/tmpss_3pwyf.rs:4:21\n\
    \  |\n4 |     let mut stack = Stack::new();\n  |                     ^^^^^ use\
    \ of undeclared type `Stack`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut counter = 0;\n    for c in brackets.chars() {\n\
    \        match c {\n            '<' => counter += 1,\n            '>' => counter\
    \ -= 1,\n            _ => {},\n        }\n        if counter < 0 {\n         \
    \   return false;\n        }\n    }\n    counter == 0\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets.chars()\
    \ {\n        match c {\n            '<' => stack.push(c),\n            '>' =>\
    \ {\n                if stack.is_empty() {\n                    return false;\n\
    \                }\n                stack.pop();\n            }\n            _\
    \ => return false,\n        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for b in brackets.chars()\
    \ {\n        match b {\n            '<' => stack.push(b),\n            '>' =>\
    \ {\n                if let Some(previous) = stack.pop() {\n                 \
    \   if previous != '<' {\n                        return false;\n            \
    \        }\n                } else {\n                    return false;\n    \
    \            }\n            }\n            _ => unreachable!(),\n        }\n \
    \   }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for bracket in brackets.chars()\
    \ {\n        match bracket {\n            '<' => stack.push(bracket),\n      \
    \      '>' => {\n                if stack.pop() != Some('<') {\n             \
    \       return false;\n                }\n            }\n            _ => (),\n\
    \        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut count = 0;\n    for ch in brackets.chars() {\n\
    \        match ch {\n            '<' => count += 1,\n            '>' => count\
    \ -= 1,\n            _ => (),\n        }\n        if count < 0 {\n           \
    \ return false;\n        }\n    }\n    count == 0\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for bracket in brackets.chars()\
    \ {\n        match bracket {\n            '<' => stack.push(bracket),\n      \
    \      '>' => {\n                if stack.is_empty() {\n                    return\
    \ false;\n                }\n                stack.pop();\n            }\n   \
    \         _ => (),\n        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().fold(0, |depth, bracket| {\n       \
    \ match bracket {\n            '<' => depth + 1,\n            '>' => depth - 1,\n\
    \            _ => depth,\n        }\n    }) == 0\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpnx6cyxmg.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Stack::new();\n    for c in brackets.chars()\
    \ {\n        match c {\n            '<' => stack.push(c),\n            '>' =>\
    \ {\n                if stack.is_empty() {\n                    return false;\n\
    \                }\n                let top = stack.pop().unwrap();\n        \
    \        if top != '<' {\n                    return false;\n                }\n\
    \            }\n            _ => {\n                return false;\n          \
    \  }\n        }\n    }\n    if !stack.is_empty() {\n        return false;\n  \
    \  }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n  \
    \  assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Stack`\n --> /tmp/tmpx97t317r.rs:4:21\n\
    \  |\n4 |     let mut stack = Stack::new();\n  |                     ^^^^^ use\
    \ of undeclared type `Stack`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open = 0;\n    for ch in brackets.chars() {\n\
    \        match ch {\n            '<' => open += 1,\n            '>' => {\n   \
    \             if open == 0 {\n                    return false;\n            \
    \    }\n                open -= 1;\n            }\n            _ => panic!(\"\
    unexpected char: {}\", ch),\n        }\n    }\n    open == 0\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_count = 0;\n    for c in brackets.chars()\
    \ {\n        if c == '<' {\n            open_count += 1;\n        } else if c\
    \ == '>' {\n            open_count -= 1;\n        }\n        if open_count < 0\
    \ {\n            return false;\n        }\n    }\n    open_count == 0\n}\n\nfn\
    \ main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut count = 0;\n    for bracket in brackets.chars()\
    \ {\n        if bracket == '<' {\n            count += 1;\n        } else if bracket\
    \ == '>' {\n            count -= 1;\n        }\n        if count < 0 {\n     \
    \       return false;\n        }\n    }\n    count == 0\n}\n\nfn main() {\n  \
    \  let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    if brackets.is_empty() {\n        return true;\n    }\n\
    \n    let mut stack = vec![];\n    for ch in brackets.chars() {\n        match\
    \ ch {\n            '<' => stack.push(ch),\n            '>' => {\n           \
    \     if stack.is_empty() {\n                    return false;\n             \
    \   }\n                if stack.pop().unwrap() != '<' {\n                    return\
    \ false;\n                }\n            }\n            _ => panic!(\"Invalid\
    \ bracket character\"),\n        }\n    }\n\n    return stack.is_empty();\n}\n\
    \nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets.chars()\
    \ {\n        match c {\n            '<' => stack.push(c),\n            '>' =>\
    \ match stack.pop() {\n                Some(x) => {\n                    if x\
    \ != '<' {\n                        return false;\n                    }\n   \
    \             }\n                None => return false,\n            },\n     \
    \       _ => (),\n        }\n    }\n    return stack.is_empty();\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Stack::new();\n    for bracket in brackets.chars()\
    \ {\n        match bracket {\n            '<' => stack.push(bracket),\n      \
    \      '>' => {\n                if stack.is_empty() {\n                    return\
    \ false;\n                }\n                stack.pop();\n            }\n   \
    \         _ => {}\n        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Stack`\n --> /tmp/tmpvi118auf.rs:4:21\n\
    \  |\n4 |     let mut stack = Stack::new();\n  |                     ^^^^^ use\
    \ of undeclared type `Stack`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut counter = 0;\n    for c in brackets.chars() {\n\
    \        match c {\n            '<' => counter += 1,\n            '>' => counter\
    \ -= 1,\n            _ => {}\n        }\n        if counter < 0 {\n          \
    \  return false;\n        }\n    }\n    counter == 0\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    if brackets.len() == 0 {\n        return true;\n    }\n\
    \    let mut stack: Vec<char> = Vec::new();\n    for c in brackets.chars() {\n\
    \        if c == '<' {\n            stack.push(c);\n        } else if c == '>'\
    \ {\n            if let Some(top) = stack.pop() {\n                if top != '<'\
    \ {\n                    return false;\n                }\n            } else\
    \ {\n                return false;\n            }\n        } else {\n        \
    \    return false;\n        }\n    }\n    return stack.len() == 0;\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let brackets = brackets.chars().collect::<Vec<char>>();\n\
    \    brackets.iter().position(|c| *c == '>').map_or(false, |i| {\n        brackets[0..i].iter().rev().position(|c|\
    \ *c == '<').map_or(false, |k| {\n            brackets[k..i].iter().fold(true,\
    \ |acc, c| acc && *c == '>')\n        })\n    })\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmph2bfq5m5.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut num_open: i32 = 0;\n    for b in brackets.chars()\
    \ {\n        if b == '<' {\n            num_open += 1;\n        } else if b ==\
    \ '>' {\n            num_open -= 1;\n        } else {\n            panic!(\"Unrecognized\
    \ character '{}'\", b);\n        }\n        if num_open < 0 {\n            return\
    \ false;\n        }\n    }\n    num_open == 0\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut counter = 0;\n    for c in brackets.chars() {\n\
    \        if c == '<' {\n            counter += 1;\n        } else if c == '>'\
    \ {\n            counter -= 1;\n        }\n        if counter < 0 {\n        \
    \    return false;\n        }\n    }\n    return counter == 0;\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for b in brackets.chars()\
    \ {\n        match b {\n            '<' => stack.push(b),\n            '>' =>\
    \ {\n                if stack.is_empty() {\n                    return false;\n\
    \                }\n                stack.pop();\n            }\n            _\
    \ => {}\n        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut depth = 0;\n    for c in brackets.chars() {\n\
    \        if c == '<' {\n            depth += 1;\n        } else if c == '>' {\n\
    \            depth -= 1;\n        }\n        if depth < 0 {\n            return\
    \ false;\n        }\n    }\n    depth == 0\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for ch in brackets.chars()\
    \ {\n        match ch {\n            '>' => {\n                if stack.is_empty()\
    \ {\n                    return false;\n                }\n                stack.pop();\n\
    \            }\n            '<' => {\n                stack.push(ch);\n      \
    \      }\n            _ => panic!(\"Unreachable\"),\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n\tlet mut left_brackets: i32 = 0;\n\tlet mut right_brackets:\
    \ i32 = 0;\n\tfor c in brackets.chars() {\n\t\tif c == '<' {\n\t\t\tleft_brackets\
    \ += 1;\n\t\t} else if c == '>' {\n\t\t\tright_brackets += 1;\n\t\t} else {\n\t\
    \t\treturn false;\n\t\t}\n\t}\n\tleft_brackets == right_brackets\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpi5npjjbq.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut count = 0;\n    for c in brackets.chars() {\n\
    \        match c {\n            '<' => count += 1,\n            '>' => count -=\
    \ 1,\n            _ => (),\n        }\n        if count < 0 {\n            return\
    \ false;\n        }\n    }\n    count == 0\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    // All brackets must be the same length.\n    if brackets.len()\
    \ % 2 != 0 {\n        return false;\n    }\n\n    // Each opening bracket must\
    \ have a corresponding closing bracket.\n    // The nesting of the brackets must\
    \ be correct.\n    let mut stack = Vec::new();\n    for c in brackets.chars()\
    \ {\n        match c {\n            '>' => {\n                if stack.len() ==\
    \ 0 {\n                    return false;\n                } else {\n         \
    \           let top_of_stack = stack.pop().unwrap();\n                    if top_of_stack\
    \ != '<' {\n                        return false;\n                    }\n   \
    \             }\n            }\n            '<' => {\n                stack.push(c);\n\
    \            }\n            _ => panic!(\"Unexpected character!\"),\n        }\n\
    \    }\n\n    // At the end of the string, the stack must be empty\n    if stack.len()\
    \ == 0 {\n        return true;\n    }\n\n    false\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut count = 0;\n    for c in brackets.chars() {\n\
    \        if c == '<' {\n            count += 1;\n        } else if c == '>' {\n\
    \            count -= 1;\n        }\n        if count < 0 {\n            return\
    \ false;\n        }\n    }\n    count == 0\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut count = 0;\n    for c in brackets.chars() {\n\
    \        if c == '<' {\n            count += 1;\n        } else if c == '>' {\n\
    \            count -= 1;\n        }\n        if count < 0 {\n            return\
    \ false;\n        }\n    }\n    return count == 0;\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for b in brackets.chars()\
    \ {\n        match b {\n            '<' => stack.push(b),\n            '>' =>\
    \ {\n                if stack.pop() != Some('<') {\n                    return\
    \ false;\n                }\n            }\n            _ => return false,\n \
    \       }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open = 0;\n    for c in brackets.chars() {\n\
    \        match c {\n            '<' => open += 1,\n            '>' => {\n    \
    \            if open > 0 {\n                    open -= 1;\n                }\
    \ else {\n                    return false;\n                }\n            }\n\
    \            _ => panic!(\"wrong char {}\", c),\n        }\n    }\n    return\
    \ open == 0;\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut count: i8 = 0;\n    for c in brackets.chars()\
    \ {\n        if c == '<' {\n            count += 1;\n        } else if c == '>'\
    \ {\n            count -= 1;\n        }\n        if count < 0 {\n            return\
    \ false;\n        }\n    }\n    return count == 0;\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for b in brackets.chars()\
    \ {\n        match b {\n            '<' => stack.push(b),\n            '>' =>\
    \ match stack.pop() {\n                Some(previous) => if previous != '<' {\
    \ return false },\n                None => return false,\n            },\n   \
    \         _ => return false,\n        }\n    }\n    stack.is_empty()\n}\n\nfn\
    \ main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for bracket in brackets.chars()\
    \ {\n        match bracket {\n            '<' => stack.push(bracket),\n      \
    \      '>' => match stack.pop() {\n                Some('<') => (),\n        \
    \        _ => return false,\n            },\n            _ => return false,\n\
    \        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for ch in brackets.chars()\
    \ {\n        match ch {\n            '<' => stack.push(ch),\n            '>' =>\
    \ {\n                if let Some(&'<') = stack.last() {\n                    stack.pop();\n\
    \                } else {\n                    return false;\n               \
    \ }\n            }\n            _ => (),\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    // TODO implement this!\n    let mut count = 0;\n   \
    \ for i in brackets.chars() {\n        if i == '<' {\n            count += 1;\n\
    \        } else if i == '>' {\n            count -= 1;\n        }\n        if\
    \ count < 0 {\n            return false;\n        }\n    }\n    if count == 0\
    \ {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nfn\
    \ main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut level = 0;\n    for b in brackets.chars() {\n\
    \        match b {\n            '<' => level += 1,\n            '>' => level -=\
    \ 1,\n            _ => {\n                // Validate failed, invalid input character\n\
    \                return false;\n            }\n        }\n        if level < 0\
    \ {\n            // Validate failed, missing opening bracket\n            return\
    \ false;\n        }\n    }\n    level == 0\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    for c in brackets.chars()\
    \ {\n        match c {\n            '<' => stack.push(c),\n            '>' =>\
    \ match stack.pop() {\n                Some('<') => (),\n                _ =>\
    \ return false,\n            },\n            _ => return false,\n        }\n \
    \   }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let b = brackets.as_bytes();\n    let mut stack = Vec::new();\n\
    \    for &byte in b {\n        match byte {\n            b'<' => stack.push(byte),\n\
    \            b'>' => {\n                if stack.is_empty() {\n              \
    \      return false;\n                }\n                let top = stack.pop().unwrap();\n\
    \                if top != b'<' {\n                    return false;\n       \
    \         }\n            }\n            _ => return false,\n        }\n    }\n\
    \    stack.is_empty()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for symbol in brackets.chars()\
    \ {\n        match symbol {\n            '<' => stack.push(symbol),\n        \
    \    '>' => {\n                match stack.pop() {\n                    Some('<')\
    \ => (),\n                    _ => return false,\n                }\n        \
    \    }\n            _ => (),\n        }\n    }\n    return stack.is_empty();\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    for bracket in brackets.chars()\
    \ {\n        match bracket {\n            '<' => stack.push(bracket),\n      \
    \      '>' => {\n                if stack.is_empty() {\n                    return\
    \ false;\n                } else {\n                    let popped = stack.pop().unwrap();\n\
    \                    if popped != '<' {\n                        return false;\n\
    \                    }\n                }\n            }\n            _ => panic!(\"\
    unexpected char\"),\n        }\n    }\n    return stack.is_empty();\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    for c in brackets.chars()\
    \ {\n        match c {\n            '<' => stack.push(c),\n            '>' =>\
    \ {\n                if stack.is_empty() {\n                    return false;\n\
    \                }\n                let l = stack.pop().unwrap();\n          \
    \      match l {\n                    '<' => {}\n                    _ => return\
    \ false,\n                }\n            }\n            _ => panic!(\"unexpected\
    \ char\"),\n        }\n    }\n    if stack.is_empty() {\n        return true;\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    // Start with 0 open brackets, because no brackets are\
    \ currently open.\n    let mut open_brackets = 0;\n\n    // Iterate over the characters\
    \ in the string.\n    for bracket in brackets.chars() {\n        // If we encounter\
    \ an opening bracket, increment the number of open brackets.\n        if bracket\
    \ == '<' {\n            open_brackets += 1;\n        }\n\n        // If we encounter\
    \ a closing bracket, decrement the number of open brackets.\n        if bracket\
    \ == '>' {\n            open_brackets -= 1;\n        }\n\n        // Return false\
    \ if there are too many closing brackets.\n        if open_brackets < 0 {\n  \
    \          return false;\n        }\n    }\n\n    // A string of brackets is well-bracketed\
    \ if the number of open brackets is 0 at the end.\n    open_brackets == 0\n}\n\
    \nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for b in brackets.chars()\
    \ {\n        match b {\n            '<' => stack.push(b),\n            '>' =>\
    \ {\n                if stack.pop() != Some('<') {\n                    return\
    \ false;\n                }\n            }\n            _ => panic!(\"unexpected\
    \ char {}\", b),\n        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n \
    \   let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    // TODO - replace this placeholder with your solution.\n\
    \    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp3rmx85cz.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut bracket_stack: Vec<char> = Vec::new();\n    for\
    \ bracket in brackets.chars() {\n        match bracket {\n            '<' => bracket_stack.push(bracket),\n\
    \            '>' => {\n                match bracket_stack.pop() {\n         \
    \           Some(opening_bracket) => {\n                        if opening_bracket\
    \ != '<' {\n                            return false;\n                      \
    \  }\n                    }\n                    None => return false,\n     \
    \           }\n            }\n            _ => continue,\n        }\n    }\n \
    \   if bracket_stack.len() > 0 {\n        return false;\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for ch in brackets.chars()\
    \ {\n        match ch {\n            '<' => stack.push(ch),\n            '>' =>\
    \ match stack.pop() {\n                Some('<') => (),\n                _ =>\
    \ return false,\n            },\n            _ => unreachable!(),\n        }\n\
    \    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut depth = 0;\n    for c in brackets.chars() {\n\
    \        match c {\n            '<' => depth += 1,\n            '>' => depth -=\
    \ 1,\n            _ => (),\n        }\n        if depth < 0 {\n            return\
    \ false;\n        }\n    }\n    depth == 0\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for b in brackets.chars()\
    \ {\n        match b {\n            '<' => stack.push(b),\n            '>' =>\
    \ {\n                if stack.is_empty() {\n                    return false;\n\
    \                }\n                stack.pop();\n            }\n            _\
    \ => unreachable!(),\n        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Stack::new();\n    for b in brackets.chars()\
    \ {\n        match b {\n            '<' => stack.push(b),\n            '>' =>\
    \ {\n                match stack.pop() {\n                    None => return false,\n\
    \                    Some(_) => (),\n                }\n            }\n      \
    \      _ => return false,\n        }\n    }\n    stack.is_empty()\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Stack`\n --> /tmp/tmpq43ypsjs.rs:4:21\n\
    \  |\n4 |     let mut stack = Stack::new();\n  |                     ^^^^^ use\
    \ of undeclared type `Stack`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().fold(0, |acc, x| match x {\n       \
    \ '<' => acc + 1,\n        '>' => acc - 1,\n        _ => panic!(\"not a valid\
    \ bracket!\"),\n    }) == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp57aqlryt.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut opening_brackets: Vec<char> = Vec::new();\n \
    \   for bracket in brackets.chars() {\n        match bracket {\n            '<'\
    \ => opening_brackets.push(bracket),\n            '>' => {\n                match\
    \ opening_brackets.pop() {\n                    Some(_) => (),\n             \
    \       None => return false,\n                }\n            }\n            _\
    \ => panic!(\"Unrecognized bracket: '{}'\", bracket),\n        }\n    }\n    return\
    \ opening_brackets.is_empty();\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets.chars()\
    \ {\n        match c {\n            '<' => stack.push(c),\n            '>' =>\
    \ match stack.pop() {\n                Some('<') => (),\n                _ =>\
    \ return false,\n            },\n            _ => return false,\n        }\n \
    \   }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for s in brackets.chars()\
    \ {\n        match s {\n            '<' => stack.push(s),\n            '>' =>\
    \ {\n                if stack.len() == 0 {\n                    return false;\n\
    \                }\n                stack.pop();\n            }\n            _\
    \ => {}\n        }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for bracket in brackets.chars()\
    \ {\n        match bracket {\n            '<' => stack.push(bracket),\n      \
    \      '>' => match stack.pop() {\n                Some(char) => {\n         \
    \           if char != '<' {\n                        return false;\n        \
    \            }\n                }\n                None => return false,\n   \
    \         },\n            _ => return false,\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets.chars()\
    \ {\n        match c {\n            '<' => stack.push(c),\n            '>' =>\
    \ {\n                if stack.is_empty() {\n                    return false;\n\
    \                }\n                if stack.pop().unwrap() != '<' {\n       \
    \             return false;\n                }\n            }\n            _ =>\
    \ {}\n        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    for b in brackets.chars()\
    \ {\n        match b {\n            '<' => stack.push(b),\n            '>' =>\
    \ match stack.pop() {\n                Some('<') => (),\n                _ =>\
    \ return false,\n            },\n            _ => (),\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Stack::new();\n    for ch in brackets.chars()\
    \ {\n        match ch {\n            '<' => stack.push('<'),\n            '>'\
    \ => {\n                match stack.pop() {\n                    Some(_) => (),\n\
    \                    None => return false,\n                }\n            }\n\
    \            _ => return false,\n        }\n    }\n    stack.pop().is_none()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Stack`\n --> /tmp/tmpx372yn93.rs:4:21\n\
    \  |\n4 |     let mut stack = Stack::new();\n  |                     ^^^^^ use\
    \ of undeclared type `Stack`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut current = 0;\n    for bracket in brackets.chars()\
    \ {\n        match bracket {\n            '<' => current += 1,\n            '>'\
    \ => current -= 1,\n            _ => panic!(\"Wrong bracketing\"),\n        }\n\
    \        if current < 0 {\n            return false;\n        }\n    }\n    return\
    \ current == 0;\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n \
    \   assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = LinkedList::new();\n    for symbol in\
    \ brackets.chars() {\n        match symbol {\n            '<' => stack.push_back(symbol),\n\
    \            '>' => {\n                match stack.pop_back() {\n            \
    \        Some('<') => (),\n                    _ => return false,\n          \
    \      }\n            }\n            _ => return false,\n        }\n    }\n  \
    \  stack.is_empty()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `LinkedList`\n\
    \ --> /tmp/tmpzzatklw_.rs:4:21\n  |\n4 |     let mut stack = LinkedList::new();\n\
    \  |                     ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::LinkedList;\n  |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for b in brackets.chars()\
    \ {\n        match b {\n            '<' => stack.push(b),\n            '>' =>\
    \ {\n                if stack.pop() != Some('<') {\n                    return\
    \ false;\n                }\n            }\n            _ => (),\n        }\n\
    \    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut count = 0;\n    for c in brackets.chars() {\n\
    \        match c {\n            '<' => count += 1,\n            '>' => count -=\
    \ 1,\n            _ => (),\n        }\n        if count < 0 {\n            return\
    \ false;\n        }\n    }\n    count == 0\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut bracket_stack: Vec<char> = Vec::new();\n    for\
    \ bracket in brackets.chars() {\n        match bracket {\n            '<' => bracket_stack.push(bracket),\n\
    \            '>' => {\n                if let Some(prev_bracket) = bracket_stack.pop()\
    \ {\n                    if prev_bracket != '<' {\n                        return\
    \ false;\n                    }\n                } else {\n                  \
    \  return false;\n                }\n            }\n            _ => return false,\n\
    \        }\n    }\n    bracket_stack.is_empty()\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut bracket_count = 0;\n    let mut answer = true;\n\
    \    for c in brackets.chars() {\n        match c {\n            '<' => bracket_count\
    \ += 1,\n            '>' => bracket_count -= 1,\n            _ => {},\n      \
    \  }\n        if bracket_count < 0 {\n            answer = false;\n          \
    \  break;\n        }\n    }\n    answer && bracket_count == 0\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut buffer = 0;\n    for b in brackets.chars() {\n\
    \        if b == '<' {\n            buffer += 1;\n        } else if b == '>' {\n\
    \            buffer -= 1;\n        } else {\n            // panic!(\"wrong bracket\
    \ at character {}\", b);\n            println!(\"wrong bracket at character {}\"\
    , b);\n            return false;\n        }\n        if buffer < 0 {\n       \
    \     return false;\n        }\n    }\n    return buffer == 0;\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut count = 0;\n    for ch in brackets.chars() {\n\
    \        if ch == '<' {\n            count += 1;\n        } else if ch == '>'\
    \ {\n            count -= 1;\n        } else {\n            panic!(\"Character\
    \ not allowed: {}\", ch);\n        }\n        if count < 0 {\n            return\
    \ false;\n        }\n    }\n    count == 0\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let chars: Vec<char> = brackets.chars().collect();\n\
    \    let mut stack: Vec<char> = Vec::new();\n    for c in chars {\n        match\
    \ c {\n            '<' => stack.push(c),\n            '>' => match stack.pop()\
    \ {\n                Some('<') => continue,\n                _ => return false,\n\
    \            },\n            _ => continue,\n        }\n    }\n    return stack.is_empty();\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut counter = 0;\n    for bracket in brackets.chars()\
    \ {\n        if bracket == '<' {\n            counter += 1;\n        } else if\
    \ bracket == '>' {\n            counter -= 1;\n        }\n        if counter <\
    \ 0 {\n            return false;\n        }\n    }\n    counter == 0\n}\n\nfn\
    \ main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut count = 0;\n    for b in brackets.chars() {\n\
    \        if b == '<' {\n            count += 1;\n        } else if b == '>' {\n\
    \            count -= 1;\n        }\n        if count < 0 {\n            return\
    \ false;\n        }\n    }\n    count == 0\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut bracket_count = 0;\n    for bracket in brackets.chars()\
    \ {\n        if bracket == '<' {\n            bracket_count += 1;\n        } else\
    \ if bracket == '>' {\n            bracket_count -= 1;\n        } else {\n   \
    \         panic!(\"invalid character in string\");\n        }\n        if bracket_count\
    \ < 0 {\n            return false;\n        }\n    }\n    return bracket_count\
    \ == 0;\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut cnt: i32 = 0;\n    for b in brackets.chars()\
    \ {\n        match b {\n            '<' => cnt += 1,\n            '>' => cnt -=\
    \ 1,\n            _ => panic!(\"bad char in string\"),\n        }\n        if\
    \ cnt < 0 {\n            return false;\n        }\n    }\n    return cnt == 0;\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut num_open = 0;\n    for c in brackets.chars()\
    \ {\n        if c == '<' {\n            num_open += 1;\n        } else if c ==\
    \ '>' {\n            num_open -= 1;\n        }\n        if num_open < 0 {\n  \
    \          return false;\n        }\n    }\n    num_open == 0\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    for bracket in brackets.chars()\
    \ {\n        match bracket {\n            '<' => stack.push(bracket),\n      \
    \      '>' => {\n                if stack.is_empty() {\n                    return\
    \ false;\n                }\n                stack.pop();\n            }\n   \
    \         _ => {}\n        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut count = 0;\n    for ch in brackets.chars() {\n\
    \        match ch {\n            '<' => count += 1,\n            '>' => count\
    \ -= 1,\n            _ => unreachable!()\n        }\n        if count < 0 {\n\
    \            return false;\n        }\n    }\n    count == 0\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut opened = 0;\n    for ch in brackets.chars() {\n\
    \        match ch {\n            '<' => opened += 1,\n            '>' => opened\
    \ -= 1,\n            _ => (),\n        }\n        if opened < 0 {\n          \
    \  return false;\n        }\n    }\n    opened == 0\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for bracket in brackets.chars()\
    \ {\n        match bracket {\n            '<' => stack.push(bracket),\n      \
    \      '>' => {\n                if let Some('<') = stack.pop() {\n          \
    \          continue;\n                } else {\n                    return false;\n\
    \                }\n            }\n            _ => continue,\n        }\n   \
    \ }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut brackets_vec: Vec<char> = brackets.chars().collect();\n\
    \    let mut stack: Vec<char> = Vec::new();\n\n    while let Some(bracket) = brackets_vec.pop()\
    \ {\n        match bracket {\n            '<' => stack.push(bracket),\n      \
    \      '>' => {\n                if stack.pop() != Some('<') {\n             \
    \       return false;\n                }\n            }\n            _ => return\
    \ false,\n        }\n    }\n\n    if stack.is_empty() {\n        true\n    } else\
    \ {\n        false\n    }\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpo_617aw6.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut counter = 0;\n    for b in brackets.chars() {\n\
    \        if b == '<' {\n            counter += 1;\n        } else if b == '>'\
    \ {\n            counter -= 1;\n        } else {\n            panic!(\"Invalid\
    \ bracket character\");\n        }\n        if counter < 0 {\n            return\
    \ false;\n        }\n    }\n    counter == 0\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut num_opening_brackets = 0i8;\n    for bracket\
    \ in brackets.chars() {\n        if bracket == '<' {\n            num_opening_brackets\
    \ += 1;\n        } else if bracket == '>' {\n            num_opening_brackets\
    \ -= 1;\n        }\n        if num_opening_brackets < 0 {\n            return\
    \ false;\n        }\n    }\n    num_opening_brackets == 0\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let chars: Vec<char> = brackets.chars().collect();\n\
    \    let mut stack: Vec<char> = Vec::new();\n    for c in chars {\n        match\
    \ c {\n            '<' => stack.push(c),\n            '>' => {\n             \
    \   if stack.is_empty() {\n                    return false;\n               \
    \ }\n                stack.pop();\n            }\n            _ => panic!(\"expect\
    \ < or >; got {}\", c),\n        }\n    }\n    stack.is_empty()\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let brackets: Vec<char> = brackets.chars().collect();\n\
    \    let mut stack: Vec<char> = Vec::new();\n    for bracket in brackets {\n \
    \       match bracket {\n            '<' => stack.push(bracket),\n           \
    \ '>' => match stack.pop() {\n                Some(b) => {\n                 \
    \   if b != '<' {\n                        return false;\n                   \
    \ }\n                }\n                None => return false,\n            },\n\
    \            _ => return false,\n        }\n    }\n    if stack.len() == 0 {\n\
    \        return true;\n    }\n    false\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut count = 0;\n    for c in brackets.chars() {\n\
    \        match c {\n            '<' => count += 1,\n            '>' => count -=\
    \ 1,\n            _ => continue,\n        }\n        if count < 0 {\n        \
    \    return false;\n        }\n    }\n    count == 0\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut depth = 0;\n    for b in brackets.chars() {\n\
    \        match b {\n            '<' => depth += 1,\n            '>' => depth -=\
    \ 1,\n            _ => (),\n        }\n        if depth < 0 {\n            return\
    \ false;\n        }\n    }\n    return depth == 0;\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut depth = 0;\n    for ch in brackets.chars() {\n\
    \        match ch {\n            '<' => depth += 1,\n            '>' => depth\
    \ -= 1,\n            _ => panic!(\"Unexpected character in string\"),\n      \
    \  }\n        if depth < 0 {\n            return false;\n        }\n    }\n  \
    \  return depth == 0;\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut count: i32 = 0;\n    for ch in brackets.chars()\
    \ {\n        if ch == '<' {\n            count += 1;\n        } else if ch ==\
    \ '>' {\n            count -= 1;\n        }\n        if count < 0 {\n        \
    \    return false;\n        }\n    }\n    count == 0\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = Vec::new();\n    for c in brackets.chars()\
    \ {\n        match c {\n            '<' => open_brackets.push(c),\n          \
    \  '>' => {\n                if open_brackets.len() == 0 {\n                 \
    \   return false;\n                }\n                open_brackets.pop();\n \
    \           }\n            _ => {}\n        }\n    }\n    return open_brackets.len()\
    \ == 0;\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut bracket_stack: Vec<char> = Vec::new();\n    for\
    \ bracket in brackets.chars() {\n        match bracket {\n            '<' => bracket_stack.push(bracket),\n\
    \            '>' => {\n                if bracket_stack.is_empty() {\n       \
    \             return false;\n                }\n                let popped = bracket_stack.pop().unwrap();\n\
    \                if popped != '<' {\n                    return false;\n     \
    \           }\n            }\n            _ => return false,\n        }\n    }\n\
    \    return bracket_stack.is_empty();\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets.chars()\
    \ {\n        match c {\n            '<' => stack.push(c),\n            '>' =>\
    \ match stack.pop() {\n                Some('<') => {}\n                _ => return\
    \ false,\n            },\n            _ => {}\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for b in brackets.chars()\
    \ {\n        match b {\n            '<' => stack.push(b),\n            '>' =>\
    \ {\n                match stack.pop() {\n                    Some('<') => (),\n\
    \                    _ => return false,\n                }\n            }\n  \
    \          _ => (),\n        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut count: i32 = 0;\n    for ch in brackets.chars()\
    \ {\n        if ch == '<' {\n            count += 1;\n        } else if ch ==\
    \ '>' {\n            count -= 1;\n        }\n        if count < 0 {\n        \
    \    return false;\n        }\n    }\n    return count == 0;\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut bracket_count = 0;\n    for bracket in brackets.chars()\
    \ {\n        match bracket {\n            '<' => bracket_count += 1,\n       \
    \     '>' => bracket_count -= 1,\n            _ => panic!(\"Unexpected bracket\
    \ symbol: {}\", bracket),\n        }\n        if bracket_count < 0 {\n       \
    \     return false;\n        }\n    }\n    return bracket_count == 0;\n}\n\nfn\
    \ main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut balance = 0;\n    for c in brackets.chars() {\n\
    \        if c == '<' {\n            balance += 1;\n        } else if c == '>'\
    \ {\n            balance -= 1;\n        }\n        if balance < 0 {\n        \
    \    return false;\n        }\n    }\n    return balance == 0;\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut paren_count = 0;\n    for bracket in brackets.chars()\
    \ {\n        if bracket == '<' {\n            paren_count += 1;\n        } else\
    \ if bracket == '>' {\n            paren_count -= 1;\n        } else {\n     \
    \       panic!(\"Unexpected character in bracket sequence: {}\", bracket);\n \
    \       }\n        if paren_count < 0 {\n            return false;\n        }\n\
    \    }\n    return paren_count == 0;\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n\tlet mut stack = vec![];\n\tfor b in brackets.chars() {\n\
    \t\tmatch b {\n\t\t\t'<' => stack.push(b),\n\t\t\t'>' => {\n\t\t\t\tif let Some(first)\
    \ = stack.pop() {\n\t\t\t\t\tif first != '<' {\n\t\t\t\t\t\treturn false;\n\t\t\
    \t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\
    _ => panic!(\"Encountered unexpected character.\"),\n\t\t}\n\t}\n\treturn stack.is_empty();\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    for c in brackets.chars()\
    \ {\n        match c {\n            '<' => stack.push(c),\n            '>' =>\
    \ {\n                if stack.is_empty() {\n                    return false;\n\
    \                }\n                stack.pop();\n            }\n            _\
    \ => panic!(\"Unknown char {} in string.\", c),\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets.chars()\
    \ {\n        match c {\n            '<' => stack.push(c),\n            '>' =>\
    \ {\n                match stack.pop() {\n                    Some(b) => {\n \
    \                       if b != '<' {\n                            return false;\n\
    \                        }\n                    }\n                    None =>\
    \ return false,\n                }\n            }\n            _ => panic!(\"\
    Bad character in brackets string\"),\n        }\n    }\n    if stack.len() !=\
    \ 0 {\n        return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    for b in brackets.chars()\
    \ {\n        match b {\n            '<' => stack.push(b),\n            '>' =>\
    \ {\n                if stack.is_empty() {\n                    return false;\n\
    \                }\n                stack.pop();\n            }\n            _\
    \ => panic!(\"Unexpected character\"),\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().fold(0i64, |count, ch| match ch {\n\
    \        '<' => count + 1,\n        '>' => count - 1,\n        _ => panic!(\"\
    Invalid bracketing character {:?}\", ch),\n    }) == 0\n}\n\nfn main() {\n   \
    \ let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqui3d7fs.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    for bracket in brackets.chars()\
    \ {\n        match bracket {\n            '<' => stack.push(bracket),\n      \
    \      '>' => {\n                match stack.pop() {\n                    Some('<')\
    \ => (),\n                    _ => return false,\n                }\n        \
    \    }\n            _ => return false,\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_count = 0;\n    for bracket in brackets.chars()\
    \ {\n        match bracket {\n            '<' => open_count += 1,\n          \
    \  '>' => {\n                if open_count == 0 {\n                    return\
    \ false;\n                }\n                open_count -= 1;\n            }\n\
    \            _ => panic!(\"non-bracket character\"),\n        }\n    }\n    open_count\
    \ == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for b in brackets.chars()\
    \ {\n        match b {\n            '<' => stack.push(b),\n            '>' =>\
    \ {\n                match stack.pop() {\n                    Some('<') => (),\n\
    \                    _ => return false,\n                }\n            }\n  \
    \          _ => panic!(\"Not a bracket\"),\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    if brackets.len() % 2 != 0 {\n        return false;\n\
    \    }\n\n    let mut stack = Vec::new();\n    for b in brackets.chars() {\n \
    \       match b {\n            '<' => stack.push(b),\n            '>' => match\
    \ stack.pop() {\n                Some('<') => (),\n                _ => return\
    \ false,\n            },\n            _ => return false,\n        }\n    }\n\n\
    \    stack.is_empty()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    for c in brackets.chars()\
    \ {\n        match c {\n            '<' => stack.push(c),\n            '>' =>\
    \ {\n                match stack.pop() {\n                    Some(c) => {\n \
    \                       if c != '<' {\n                            return false;\n\
    \                        }\n                    }\n                    None =>\
    \ return false,\n                }\n            }\n            _ => panic!(\"\
    Unexpected character {}\", c),\n        }\n    }\n    stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut previous_opening_brackets = Vec::new();\n   \
    \ for bracket in brackets.chars() {\n        if bracket == '<' {\n           \
    \ previous_opening_brackets.push(bracket);\n        } else if bracket == '>' {\n\
    \            match previous_opening_brackets.pop() {\n                Some(_)\
    \ => (),\n                None => return false,\n            }\n        }\n  \
    \  }\n    previous_opening_brackets.is_empty()\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut balance = 0;\n    for b in brackets.chars() {\n\
    \        match b {\n            '<' => balance += 1,\n            '>' => balance\
    \ -= 1,\n            _ => {}\n        }\n        if balance < 0 {\n          \
    \  return false;\n        }\n    }\n    balance == 0\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut bracket_stack: Vec<char> = Vec::new();\n    for\
    \ bracket in brackets.chars() {\n        match bracket {\n            '<' => bracket_stack.push(bracket),\n\
    \            '>' => match bracket_stack.pop() {\n                Some(b) => {\n\
    \                    if b != '<' {\n                        return false;\n  \
    \                  }\n                }\n                None => return false,\n\
    \            },\n            _ => (),\n        }\n    }\n    bracket_stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    for c in brackets.chars()\
    \ {\n        match c {\n            '<' => stack.push(c),\n            '>' =>\
    \ {\n                match stack.pop() {\n                    Some('<') => (),\n\
    \                    _ => return false,\n                }\n            }\n  \
    \          _ => unreachable!(),\n        }\n    }\n    stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut count = 0;\n    for bracket in brackets.chars()\
    \ {\n        match bracket {\n            '<' => count += 1,\n            '>'\
    \ => count -= 1,\n            _ => { panic!(\"unexpected input\"); }\n       \
    \ }\n        if count < 0 {\n            return false;\n        }\n    }\n   \
    \ count == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut counter = 0;\n    for char in brackets.chars()\
    \ {\n        if char == '<' {\n            counter += 1;\n        } else if char\
    \ == '>' {\n            counter -= 1;\n        }\n        if counter < 0 {\n \
    \           return false;\n        }\n    }\n    return counter == 0;\n}\n\nfn\
    \ main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets.chars()\
    \ {\n        match c {\n            '<' => stack.push(c),\n            '>' =>\
    \ {\n                if stack.pop() != Some('<') {\n                    return\
    \ false;\n                }\n            }\n            _ => (),\n        }\n\
    \    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut brackets_vec: Vec<char> = brackets.chars().collect();\n\
    \    let mut bracket_stack: Vec<char> = Vec::new();\n\n    while let Some(c) =\
    \ brackets_vec.pop() {\n        if c == '>' {\n            bracket_stack.push(c);\n\
    \        } else if c == '<' {\n            match bracket_stack.pop() {\n     \
    \           Some('>') => (),\n                Some(_) => return false,\n     \
    \           None => return false,\n            }\n        }\n    }\n\n    if bracket_stack.is_empty()\
    \ {\n        true\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut brackets_vec: Vec<char> = brackets.chars().collect();\n\
    \    let mut open: usize = 0;\n    let mut closing: usize = 0;\n    let n = brackets_vec.len();\n\
    \    for i in 0..n {\n        if brackets_vec[i] == '<' {\n            open +=\
    \ 1;\n        } else {\n            closing += 1;\n        }\n        if closing\
    \ > open {\n            return false;\n        }\n    }\n    if open == closing\
    \ {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nfn\
    \ main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut balance = 0;\n    for char in brackets.chars()\
    \ {\n        if char == '<' {\n            balance += 1;\n        } else if char\
    \ == '>' {\n            balance -= 1;\n        } else {\n            panic!(\"\
    Invalid input: {} is not a valid bracketing\", char);\n        }\n        if balance\
    \ < 0 {\n            return false;\n        }\n    }\n    balance == 0\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    // TODO\n    false\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp3e90d_bj.rs:10:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut opened = 0;\n    for c in brackets.chars() {\n\
    \        if c == '<' {\n            opened += 1;\n        } else if c == '>' {\n\
    \            opened -= 1;\n        }\n        if opened < 0 {\n            return\
    \ false;\n        }\n    }\n    opened == 0\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().fold(0, |acc, c| {\n        match c\
    \ {\n            '<' => acc + 1,\n            '>' => if acc > 0 { acc - 1 } else\
    \ { acc },\n            _ => panic!(\"Invalid character in string\"),\n      \
    \  }\n    }) == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp44dyhl3j.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut level = 0;\n    for bracket in brackets.chars()\
    \ {\n        if bracket == '<' {\n            level += 1;\n        } else if bracket\
    \ == '>' {\n            level -= 1;\n        } else {\n            panic!(\"Non-bracketing\
    \ character in input.\");\n        }\n        if level < 0 {\n            return\
    \ false;\n        }\n    }\n    return level == 0;\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut depth = 0;\n    for b in brackets.chars() {\n\
    \        match b {\n            '<' => depth += 1,\n            '>' => depth -=\
    \ 1,\n            _ => {}\n        }\n        if depth < 0 {\n            return\
    \ false;\n        }\n    }\n    depth == 0\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut counter = 0;\n    for c in brackets.chars() {\n\
    \        match c {\n            '<' => counter += 1,\n            '>' => counter\
    \ -= 1,\n            _ => (),\n        }\n        if counter < 0 {\n         \
    \   return false;\n        }\n    }\n    counter == 0\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for bracket in brackets.chars()\
    \ {\n        match bracket {\n            '<' => stack.push(bracket),\n      \
    \      '>' => {\n                if stack.pop() != Some('<') {\n             \
    \       return false;\n                }\n            }\n            _ => {}\n\
    \        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    // To make the problem easier, we can reduce the problem\
    \ to that of\n    // matching just the brackets.\n    let reduced_str = brackets.chars().filter(|&c|\
    \ c == '>' || c == '<').collect::<String>();\n\n    let mut num_chars = reduced_str.len();\n\
    \    if num_chars % 2 != 0 {\n        return false;\n    }\n\n    let mut previous_closing_index\
    \ = 0;\n    for (i, c) in reduced_str.chars().enumerate() {\n        if c == '>'\
    \ {\n            // This is a closing bracket.\n            // The number of characters\
    \ remaining must be even to be correctly bracketed.\n            num_chars -=\
    \ 1;\n            if num_chars % 2 != 0 {\n                return false;\n   \
    \         }\n\n            // The closing bracket must be preceded by a corresponding\
    \ opening bracket.\n            if previous_closing_index == 0 {\n           \
    \     return false;\n            }\n\n            previous_closing_index -= 1;\n\
    \        } else {\n            // This is an opening bracket.\n            previous_closing_index\
    \ += 1;\n        }\n    }\n\n    previous_closing_index == 0\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp7490etur.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut count = 0;\n    for c in brackets.chars() {\n\
    \        if c == '<' {\n            count += 1;\n        } else if c == '>' {\n\
    \            count -= 1;\n        }\n        if count < 0 {\n            return\
    \ false;\n        }\n    }\n    count == 0\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let brackets = brackets.chars().collect::<Vec<char>>();\n\
    \    let mut open = Vec::new();\n    for (i, bracket) in brackets.iter().enumerate()\
    \ {\n        match bracket {\n            '<' => open.push(i),\n            '>'\
    \ => {\n                if open.is_empty() {\n                    return false;\n\
    \                }\n                let j = open.pop().unwrap();\n           \
    \     if i - j <= 1 {\n                    return false;\n                }\n\
    \            }\n            _ => continue,\n        }\n    }\n    open.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpiuvdpvhv.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets.chars()\
    \ {\n        match c {\n            '>' => match stack.pop() {\n             \
    \   Some('<') => (),\n                _ => return false,\n            },\n   \
    \         '<' => stack.push(c),\n            _ => (),\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets.chars()\
    \ {\n        match c {\n            '<' => stack.push(c),\n            '>' =>\
    \ {\n                if stack.len() == 0 {\n                    return false;\n\
    \                }\n                let b = stack.pop().unwrap();\n          \
    \      if b != '<' {\n                    return false;\n                }\n \
    \           }\n            _ => (),\n        }\n    }\n    stack.len() == 0\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for char in brackets.chars()\
    \ {\n        match char {\n            '>' => {\n                let popped =\
    \ stack.pop();\n                if popped != Some('<') {\n                   \
    \ return false;\n                }\n            }\n            '<' => {\n    \
    \            stack.push(char);\n            }\n            _ => {}\n        }\n\
    \    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for b in brackets.chars()\
    \ {\n        match b {\n            '<' => stack.push(b),\n            '>' =>\
    \ {\n                match stack.pop() {\n                    Some('<') => {}\n\
    \                    _ => return false,\n                }\n            }\n  \
    \          _ => {}\n        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut left_b_counter = 0;\n    let mut right_b_counter\
    \ = 0;\n    for c in brackets.chars() {\n        if c == '<' {\n            left_b_counter\
    \ += 1;\n        } else if c == '>' {\n            right_b_counter += 1;\n   \
    \     }\n    }\n    left_b_counter == right_b_counter\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpkanoa_ia.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut bracket_stack: Vec<char> = Vec::new();\n    for\
    \ b in brackets.chars() {\n        match b {\n            '<' => bracket_stack.push(b),\n\
    \            '>' => {\n                if let Some(previous_bracket) = bracket_stack.pop()\
    \ {\n                    if previous_bracket != '<' {\n                      \
    \  return false;\n                    }\n                } else {\n          \
    \          return false;\n                }\n            }\n            _ => continue,\n\
    \        }\n    }\n    bracket_stack.is_empty()\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets.chars()\
    \ {\n        match c {\n            '<' => stack.push(c),\n            '>' =>\
    \ match stack.pop() {\n                Some('<') => (),\n                _ =>\
    \ return false,\n            },\n            _ => panic!(\"correct_bracketing\
    \ received non-bracket character\"),\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let v: Vec<char> = brackets.chars().collect();\n    let\
    \ mut stack: Vec<char> = Vec::new();\n    for c in v {\n        if c == '<' {\n\
    \            stack.push(c);\n        } else if c == '>' {\n            if stack.is_empty()\
    \ {\n                return false;\n            } else {\n                stack.pop();\n\
    \            }\n        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n   \
    \ let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut balance = 0;\n    for b in brackets.chars() {\n\
    \        match b {\n            '<' => balance += 1,\n            '>' => balance\
    \ -= 1,\n            _ => (),\n        }\n        if balance < 0 {\n         \
    \   return false;\n        }\n    }\n    balance == 0\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut counter = 0;\n    let mut iter = brackets.chars();\n\
    \    loop {\n        match iter.next() {\n            Some('<') => counter +=\
    \ 1,\n            Some('>') => counter -= 1,\n            Some(_) => (),\n   \
    \         None => break,\n        }\n        if counter < 0 {\n            return\
    \ false;\n        }\n    }\n    counter == 0\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut count = 0;\n    for bracket in brackets.chars()\
    \ {\n        match bracket {\n            '<' => count += 1,\n            '>'\
    \ => count -= 1,\n            _ => continue,\n        }\n        if count < 0\
    \ {\n            return false;\n        }\n    }\n    return count == 0;\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut depth = 0;\n    for bracket in brackets.chars()\
    \ {\n        match bracket {\n            '<' => depth += 1,\n            '>'\
    \ => {\n                if depth == 0 {\n                    return false;\n \
    \               }\n                depth -= 1;\n            }\n            _ =>\
    \ panic!(\"Unexpected char: {}\", bracket),\n        }\n    }\n    depth == 0\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    for ch in brackets.chars()\
    \ {\n        match ch {\n            '<' => stack.push(ch),\n            '>' =>\
    \ match stack.pop() {\n                Some('<') => (),\n                _ =>\
    \ return false,\n            },\n            _ => return false,\n        }\n \
    \   }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for bracket in brackets.chars()\
    \ {\n        match bracket {\n            '<' => stack.push(bracket),\n      \
    \      '>' => {\n                if let Some(opening_bracket) = stack.pop() {\n\
    \                    if opening_bracket != '<' {\n                        return\
    \ false;\n                    }\n                } else {\n                  \
    \  return false;\n                }\n            }\n            _ => (),\n   \
    \     }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets.chars()\
    \ {\n        match c {\n            '>' => match stack.pop() {\n             \
    \   Some('<') => (),\n                _ => return false,\n            },\n   \
    \         '<' => stack.push(c),\n            _ => (),\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    // let mut bb = brackets.chars();\n    // let mut num_open\
    \ = 0;\n    // while let Some(b) = bb.next() {\n    //     match b {\n    // \
    \        '<' => num_open += 1,\n    //         '>' => num_open -= 1,\n    // \
    \        _ => (),\n    //     }\n    //     if num_open < 0 {\n    //        \
    \ return false;\n    //     }\n    // }\n    // num_open == 0\n\n    // I wrote\
    \ this because I thought my implementation above was slow but\n    // then I was\
    \ incorrect.  In fact, this one is slower by about 2x!\n    // let mut num_open\
    \ = 0;\n    // for b in brackets.chars() {\n    //     match b {\n    //     \
    \    '<' => num_open += 1,\n    //         '>' => num_open -= 1,\n    //     \
    \    _ => (),\n    //     }\n    //     if num_open < 0 {\n    //         return\
    \ false;\n    //     }\n    // }\n    // num_open == 0\n\n    // Also slow.\n\
    \    // brackets.chars().fold(0, |o, b| match b {\n    //     '<' => o + 1,\n\
    \    //     '>' => o - 1,\n    //     _ => o,\n    // }) == 0\n\n    // This is\
    \ the fastest.  I'm not sure why.\n    brackets.chars().rev().fold(0, |o, b| match\
    \ b {\n        '<' => o - 1,\n        '>' => o + 1,\n        _ => o,\n    }) ==\
    \ 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0lbvpv3p.rs:55:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    // TODO: write this function\n\n    let mut stack = Vec::new();\n\
    \n    for character in brackets.chars() {\n        match character {\n       \
    \     '<' => stack.push(character),\n            '>' => {\n                if\
    \ stack.is_empty() {\n                    return false;\n                } else\
    \ {\n                    stack.pop();\n                }\n            }\n    \
    \        _ => continue,\n        }\n    }\n\n    stack.is_empty()\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut openings = Vec::new();\n    for c in brackets.chars()\
    \ {\n        match c {\n            '<' => openings.push(c),\n            '>'\
    \ => {\n                match openings.pop() {\n                    Some('<')\
    \ => (),\n                    _ => return false,\n                }\n        \
    \    }\n            _ => (),\n        }\n    }\n    return openings.is_empty();\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.split(\"<\").count() == brackets.split(\">\"\
    ).count()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjhzha2an.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open = 0;\n    for c in brackets.chars() {\n\
    \        if c == '<' {\n            open += 1;\n        } else if c == '>' {\n\
    \            open -= 1;\n        }\n        if open < 0 {\n            return\
    \ false;\n        }\n    }\n    open == 0\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut count = 0;\n    for b in brackets.chars() {\n\
    \        if b == '<' {\n            count += 1;\n        } else if b == '>' {\n\
    \            count -= 1;\n        }\n        if count < 0 {\n            return\
    \ false;\n        }\n    }\n    return count == 0;\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut count: i8 = 0;\n    for c in brackets.chars()\
    \ {\n        if c == '<' {\n            count += 1;\n        } else if c == '>'\
    \ {\n            count -= 1;\n        }\n        if count < 0 {\n            return\
    \ false;\n        }\n    }\n    return count == 0;\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let chars: Vec<char> = brackets.chars().collect();\n\
    \    let mut stack: Vec<char> = Vec::new();\n    for ch in chars {\n        if\
    \ ch == '<' {\n            stack.push(ch);\n        } else if ch == '>' {\n  \
    \          match stack.pop() {\n                Some(_) => (),\n             \
    \   None => return false,\n            }\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    for b in brackets.chars()\
    \ {\n        match b {\n            '>' => {\n                if stack.is_empty()\
    \ {\n                    return false;\n                }\n                let\
    \ last = stack.pop().unwrap();\n                if last != '<' {\n           \
    \         return false;\n                }\n            }\n            '<' =>\
    \ {\n                stack.push(b);\n            }\n            _ => {}\n    \
    \    }\n    }\n    return stack.is_empty();\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    for bracket in brackets.chars()\
    \ {\n        match bracket {\n            '<' => stack.push(bracket),\n      \
    \      '>' => {\n                match stack.pop() {\n                    Some('<')\
    \ => (),\n                    _ => return false,\n                }\n        \
    \    }\n            _ => panic!(\"Illegal bracket character '{}'\", bracket),\n\
    \        }\n    }\n    if stack.len() > 0 {\n        return false;\n    }\n  \
    \  true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut s = Stack::new();\n    for char in brackets.chars()\
    \ {\n        match char {\n            '<' => s.push(char),\n            '>' =>\
    \ {\n                if s.is_empty() {\n                    return false;\n  \
    \              }\n                s.pop();\n            }\n            _ => continue,\n\
    \        }\n    }\n    s.is_empty()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Stack`\n --> /tmp/tmpgbi8lmfc.rs:4:17\n\
    \  |\n4 |     let mut s = Stack::new();\n  |                 ^^^^^ use of undeclared\
    \ type `Stack`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for b in brackets.chars()\
    \ {\n        match b {\n            '<' => stack.push(b),\n            '>' =>\
    \ {\n                if let Some(c) = stack.pop() {\n                    if c\
    \ != '<' {\n                        return false;\n                    }\n   \
    \             } else {\n                    return false;\n                }\n\
    \            }\n            _ => {}\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets.chars()\
    \ {\n        match c {\n            '<' => stack.push(c),\n            '>' =>\
    \ match stack.pop() {\n                Some('<') => (),\n                _ =>\
    \ return false,\n            },\n            _ => (),\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    // Write here\n\n    let mut stack: Vec<char> = Vec::new();\n\
    \n    for i in brackets.chars() {\n        if i == '<' {\n            stack.push(i);\n\
    \        } else if i == '>' {\n            if stack.pop() == None {\n        \
    \        return false;\n            }\n        }\n    }\n\n    if stack.len()\
    \ == 0 {\n        return true;\n    }\n\n    false\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821436
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut char_count = 0;\n    for c in brackets.chars()\
    \ {\n        match c {\n            '<' => char_count += 1,\n            '>' =>\
    \ {\n                if char_count == 0 {\n                    return false;\n\
    \                }\n                char_count -= 1;\n            }\n        \
    \    _ => {},\n        }\n    }\n    char_count == 0\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = Vec::new();\n    for bracket\
    \ in brackets.chars() {\n        match bracket {\n            '<' => open_brackets.push(bracket),\n\
    \            '>' => {\n                if open_brackets.len() == 0 {\n       \
    \             return false;\n                }\n                open_brackets.pop();\n\
    \            }\n            _ => panic!(\"unexpected symbol!\"),\n        }\n\
    \    }\n    return open_brackets.len() == 0;\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut bracket_stack: Vec<char> = Vec::new();\n    for\
    \ c in brackets.chars() {\n        match c {\n            '<' => bracket_stack.push(c),\n\
    \            '>' => {\n                if bracket_stack.is_empty() {\n       \
    \             return false;\n                }\n                let top = bracket_stack.pop().unwrap();\n\
    \                if top != '<' {\n                    return false;\n        \
    \        }\n            }\n            _ => return false,\n        }\n    }\n\
    \    bracket_stack.is_empty()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
