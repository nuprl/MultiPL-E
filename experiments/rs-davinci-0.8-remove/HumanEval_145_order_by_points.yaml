name: HumanEval_145_order_by_points
language: rs
prompt: "/// Write a function which sorts the given list of integers\n/// in ascending\
  \ order according to the sum of their digits.\n/// Note: if there are several items\
  \ with similar sum of their digits,\n/// order them based on their index in original\
  \ list.\n/// For example:\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n"
tests: "}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
  \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
  \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
  \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
  \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
  \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
  \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
  \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
  \ 23, 6, 6]);\n}\n"
completions: ["    let mut temp = nums.clone();\n    temp.sort_by(|a, b| {\n     \
    \   let mut sum_a = 0;\n        let mut sum_b = 0;\n        for i in format!(\"\
    {}\", a).chars() {\n            sum_a += i.to_digit(10).unwrap() as isize;\n \
    \       }\n        for i in format!(\"{}\", b).chars() {\n            sum_b +=\
    \ i.to_digit(10).unwrap() as isize;\n        }\n        sum_a.cmp(&sum_b)\n  \
    \  });\n    temp", "    let mut tuples: Vec<(isize, isize)> = Vec::new();\n  \
    \  for (i, x) in nums.iter().enumerate() {\n        let sum: isize = x.to_string().chars().map(|y|\
    \ y.to_digit(10).unwrap() as isize).sum();\n        tuples.push((i, sum));\n \
    \   }\n    tuples.sort_by(|a, b| a.1.cmp(&b.1));\n    tuples.iter().map(|x| nums[x.0\
    \ as usize]).collect()", "    nums.iter()\n        .map(|x| (*x, digits(*x).iter().fold(0,\
    \ |a, x| a + x)))\n        .enumerate()\n        .sort_by(|(_, (a, b)), (_, (c,\
    \ d))| b.cmp(&d).then(a.cmp(&c)))\n        .map(|(i, (a, _))| (i, a))\n      \
    \  .enumerate()\n        .sort_by(|(i, _), (j, _)| i.cmp(&j))\n        .map(|(_,\
    \ (_, a))| a)\n        .collect()", "    let mut nums = nums;\n    nums.sort_by(|a,\
    \ b| (a.abs() % 10 + a.abs() / 10).cmp(&(b.abs() % 10 + b.abs() / 10)));\n   \
    \ nums", "    fn digit_sum(num: isize) -> usize {\n        let mut num = num;\n\
    \        let mut sum = 0;\n        while num > 0 {\n            sum += (num %\
    \ 10) as usize;\n            num /= 10;\n        }\n        sum\n    }\n\n   \
    \ let mut nums: Vec<_> = nums.into_iter().enumerate().collect();\n    nums.sort_by_key(|&(_,\
    \ num)| digit_sum(num));\n    nums.into_iter().map(|(_, x)| x).collect()", " \
    \   let mut new_vec = nums.clone();\n    new_vec.sort_by(|a, b| {\n        let\
    \ a_sum = sum_digit(*a);\n        let b_sum = sum_digit(*b);\n        a_sum.cmp(&b_sum)\n\
    \    });\n    new_vec", "    let mut nums: Vec<isize> = nums.into_iter().map(|x|\
    \ x.abs()).collect();\n    nums.sort_by(|a, b| a.abs().to_string().chars().map(|x|\
    \ x.to_digit(10).unwrap() as isize).sum::<isize>().cmp(&b.abs().to_string().chars().map(|x|\
    \ x.to_digit(10).unwrap() as isize).sum::<isize>()));\n    nums", "    nums.iter()\n\
    \        .enumerate()\n        .map(|(i, &n)| (sum_of_digits(n), i, n))\n    \
    \    .sorted()\n        .map(|(_, _, n)| n)\n        .collect()", "    nums.iter()\n\
    \        .enumerate()\n        .map(|(i, &n)| (i, n, get_digits_sum(n)))\n   \
    \     .collect::<Vec<_>>()\n        .sort_by(|a, b| {\n            if a.2 == b.2\
    \ {\n                a.0.cmp(&b.0)\n            } else {\n                a.2.cmp(&b.2)\n\
    \            }\n        })\n        .into_iter()\n        .map(|n| n.1)\n    \
    \    .collect()", "    let mut nums_rev = nums.clone();\n    nums_rev.reverse();\n\
    \    let mut nums_rev = nums_rev\n        .into_iter()\n        .enumerate()\n\
    \        .map(|(i, n)| (n, i))\n        .collect::<Vec<(isize, usize)>>();\n \
    \   nums_rev.sort_by(|a, b| {\n        let a_sum = sum_digits(a.0);\n        let\
    \ b_sum = sum_digits(b.0);\n        if a_sum < b_sum {\n            return Ordering::Less;\n\
    \        } else if a_sum > b_sum {\n            return Ordering::Greater;\n  \
    \      }\n        if a.1 < b.1 {\n            return Ordering::Less;\n       \
    \ } else if a.1 > b.1 {\n            return Ordering::Greater;\n        }\n  \
    \      Ordering::Equal\n    });\n    nums_rev.iter().map(|a| a.0).collect()",
  "    nums.into_iter().enumerate().sorted_by(|(_, a), (_, b)| {\n        let (a_sum,\
    \ b_sum) = (a.to_string().chars().map(|c| c.to_digit(10).unwrap() as usize).sum(),\n\
    \                              b.to_string().chars().map(|c| c.to_digit(10).unwrap()\
    \ as usize).sum());\n        if a_sum == b_sum {\n            Ord::cmp(&a, &b)\n\
    \        } else {\n            Ord::cmp(&a_sum, &b_sum)\n        }\n    }).map(|(_,\
    \ num)| num).collect()", "    nums.iter()\n        .enumerate()\n        .map(|(i,\
    \ x)| (i, sum_digits(*x)))\n        .sorted_by(|(i, sum_a), (j, sum_b)| {\n  \
    \          let comparison = sum_a.cmp(sum_b);\n            match comparison {\n\
    \                Ordering::Equal => i.cmp(j),\n                _ => comparison,\n\
    \            }\n        })\n        .map(|(_, x)| x)\n        .collect()", '    unimplemented!();',
  "    let mut nums = nums;\n    nums.sort_by(|a, b| {\n        let a_sum: isize =\
    \ a.to_string().chars().map(|c| c.to_digit(10).unwrap() as isize).sum();\n   \
    \     let b_sum: isize = b.to_string().chars().map(|c| c.to_digit(10).unwrap()\
    \ as isize).sum();\n        a_sum.cmp(&b_sum)\n    });\n    nums", "    let mut\
    \ sum_of_digits: Vec<(isize, usize)> = nums\n        .iter()\n        .enumerate()\n\
    \        .map(|(i, &x)| (sum_of_digits(x), i))\n        .collect();\n    sum_of_digits.sort();\n\
    \    sum_of_digits\n        .iter()\n        .map(|(x, _)| *x)\n        .collect()",
  "    nums.iter()\n        .enumerate()\n        .map(|(i, &x)| {\n            let\
    \ mut v = x;\n            let mut sum = 0;\n            while v > 0 {\n      \
    \          sum += v % 10;\n                v /= 10;\n            }\n         \
    \   (i, sum, x)\n        })\n        .sorted_by(|a, b| a.1.cmp(&b.1).then(a.0.cmp(&b.0)))\n\
    \        .map(|(_, _, x)| x)\n        .collect()", "    let mut nums = nums;\n\
    \    let sum = |a: &isize| {\n        let mut sum = 0;\n        let mut a = *a;\n\
    \        while a > 0 {\n            sum += a % 10;\n            a /= 10;\n   \
    \     }\n        sum\n    };\n    nums.sort_by(|a, b| sum(a).cmp(&sum(b)));\n\
    \    nums", "    let mut nums: Vec<isize> = nums;\n    nums.sort_by(|a, b| a.to_string().chars().map(|x|\
    \ x.to_digit(10).unwrap() as isize).sum::<isize>().cmp(&b.to_string().chars().map(|x|\
    \ x.to_digit(10).unwrap() as isize).sum::<isize>()));\n    nums", "    nums.iter()\n\
    \        .enumerate()\n        .map(|(i, v)| (v, i, sum_digits(*v)))\n       \
    \ .sorted_by(|x, y| x.2.cmp(&y.2).then(x.1.cmp(&y.1)))\n        .into_iter()\n\
    \        .map(|(v, _, _)| *v)\n        .collect()", "    let mut nums = nums;\n\
    \    let mut sums = vec![0; nums.len()];\n    for i in 0..nums.len() {\n     \
    \   let mut t = nums[i];\n        let mut sum = 0;\n        while t > 0 {\n  \
    \          sum += t % 10;\n            t /= 10;\n        }\n        sums[i] =\
    \ sum;\n    }\n    nums.sort_by(|x, y| sums[x].cmp(&sums[y]));\n    nums", " \
    \   // ...\n    let mut nums = nums;\n    nums.sort_by(|a, b| {\n        sum_digits(*a).cmp(&sum_digits(*b))\n\
    \    });\n    nums", "    // Write your code here\n    return nums.iter().zip(nums.iter().map(|x|\
    \ x.to_string().chars().map(|c| c.to_digit(10).unwrap() as isize).sum::<isize>()).collect::<Vec<isize>>()).collect::<Vec<_>>().sort_by(|x,\
    \ y| {\n        if x.1 == y.1 {\n            return x.0.cmp(y.0);\n        }\n\
    \        return x.1.cmp(&y.1);\n    }).iter().map(|x| *x.0).collect::<Vec<isize>>();",
  "    use std::cmp::Ordering;\n    let mut nums = nums;\n    nums.sort_by(|a, b|\
    \ {\n        let sum_a = sum_digits(*a);\n        let sum_b = sum_digits(*b);\n\
    \        match sum_a.cmp(&sum_b) {\n            Ordering::Equal => a.cmp(&b),\n\
    \            Ordering::Less => Ordering::Less,\n            Ordering::Greater\
    \ => Ordering::Greater,\n        }\n    });\n    nums", "    fn get_points(n:\
    \ isize) -> (usize, isize) {\n        let mut n = n;\n        let mut points =\
    \ 0;\n        while n > 0 {\n            points += n % 10;\n            n /= 10;\n\
    \        }\n        (points as usize, n)\n    }\n\n    let mut aux: Vec<_> = nums.iter().enumerate().map(|(i,\
    \ &x)| (get_points(x), i, x)).collect();\n    aux.sort();\n    aux.into_iter().map(|(_,\
    \ _, x)| x).collect()", "    nums.into_iter().enumerate().sorted_by(|a, b| {\n\
    \        a.1.to_string().chars().map(|d| d.to_digit(10).unwrap() as isize).sum::<isize>()\n\
    \            .cmp(&b.1.to_string().chars().map(|d| d.to_digit(10).unwrap() as\
    \ isize).sum::<isize>())\n            .then_with(|| a.0.cmp(&b.0))\n    }).map(|(_,\
    \ v)| v).collect()", "    let mut nums = nums;\n    nums.sort_by(|a, b| a.abs().sum::<isize>().cmp(&b.abs().sum::<isize>()));\n\
    \    nums", "    let mut pairs: Vec<(isize, isize)> = Vec::new();\n    for (index,\
    \ num) in nums.iter().enumerate() {\n        let mut sum: isize = 0;\n       \
    \ let mut n = *num;\n        while n > 0 {\n            sum += n % 10;\n     \
    \       n /= 10;\n        }\n        pairs.push((index as isize, sum));\n    }\n\
    \    pairs.sort_by(|a, b| a.1.cmp(&b.1));\n    let mut result: Vec<isize> = Vec::new();\n\
    \    for (index, _) in pairs {\n        result.push(nums[index as usize]);\n \
    \   }\n    result", "    let mut sum_digits = vec![0; nums.len()];\n    for i\
    \ in 0..nums.len() {\n        sum_digits[i] = nums[i].abs()\n            .to_string()\n\
    \            .chars()\n            .map(|c| c.to_digit(10).unwrap() as isize)\n\
    \            .sum::<isize>();\n    }\n    nums.iter()\n        .zip(sum_digits.iter())\n\
    \        .sorted_by(|a, b| a.1.cmp(b.1))\n        .map(|v| *v.0)\n        .collect()",
  "    let mut result = nums.clone();\n    result.sort_by(|a, b| a.sum_digits().cmp(&b.sum_digits()));\n\
    \    result", "    let mut sums = HashMap::new();\n    for (i, num) in nums.iter().enumerate()\
    \ {\n        let s = sum_digits(*num);\n        sums.insert(i, s);\n    }\n  \
    \  let mut sums = sums.into_iter().collect::<Vec<(usize, isize)>>();\n    sums.sort_by(|&(ref\
    \ a, ref b), &(ref c, ref d)| {\n        if b > d {\n            Ordering::Less\n\
    \        } else if b < d {\n            Ordering::Greater\n        } else {\n\
    \            a.cmp(c)\n        }\n    });\n    let mut result = Vec::new();\n\
    \    for (i, _) in sums {\n        result.push(nums[i]);\n    }\n    result",
  "    nums.iter()\n        .enumerate()\n        .map(|(i, v)| (i, count_digits(*v)))\n\
    \        .sorted_by(|(i1, d1), (i2, d2)| {\n            d1.cmp(&d2).then(i1.cmp(&i2))\n\
    \        })\n        .map(|(_, v)| v)\n        .collect()", "    let mut index_map:\
    \ HashMap<usize, isize> = HashMap::new();\n    let mut sum_vec: Vec<usize> = Vec::new();\n\
    \    let mut index_vec: Vec<usize> = Vec::new();\n    let mut result: Vec<isize>\
    \ = Vec::new();\n\n    // Calculate the sum of each digit of each number in the\
    \ list.\n    for index in 0..nums.len() {\n        let mut total = 0;\n      \
    \  let mut num = nums[index];\n        while num > 0 {\n            total += num\
    \ % 10;\n            num /= 10;\n        }\n        sum_vec.push(total);\n   \
    \     index_map.insert(index, nums[index]);\n    }\n\n    // Sorts the vector\
    \ of numbers based on the sum of their digits.\n    // The index of the element\
    \ is stored in the index_vec vector.\n    for index in 0..sum_vec.len() {\n  \
    \      for j in 0..sum_vec.len() {\n            if sum_vec[index] < sum_vec[j]\
    \ {\n                let temp = sum_vec[index];\n                sum_vec[index]\
    \ = sum_vec[j];\n                sum_vec[j] = temp;\n                index_vec.push(index);\n\
    \            }\n        }\n    }\n\n    // Builds the result vector with the numbers\
    \ based on their index in\n    // the index_vec vector, which contains the indexes\
    \ of the values\n    // that were sorted based on the sum of their digits.\n \
    \   for index in 0..index_vec.len() {\n        if let Some(num) = index_map.get(&index_vec[index])\
    \ {\n            result.push(*num);\n        }\n    }\n\n    result", "    let\
    \ mut nums = nums;\n    nums.sort_by(|a, b| sum_of_digits(*a).cmp(&sum_of_digits(*b)));\n\
    \    nums", "    fn order_by_points_inner(nums: Vec<isize>) -> Vec<isize> {\n\
    \        let mut original = nums.clone();\n        let mut sum_list = Vec::new();\n\
    \        let mut result = Vec::new();\n        for i in nums {\n            sum_list.push(sum_of_digits(i));\n\
    \        }\n        sum_list.sort();\n        for j in sum_list {\n          \
    \  for (index, i) in original.iter().enumerate() {\n                if sum_of_digits(*i)\
    \ == j {\n                    result.push(*i);\n                    original.remove(index);\n\
    \                    break;\n                }\n            }\n        }\n   \
    \     result\n    }\n    fn sum_of_digits(i: isize) -> isize {\n        if i <\
    \ 10 {\n            return i;\n        }\n        sum_of_digits(i / 10) + i %\
    \ 10\n    }\n    order_by_points_inner(nums)", "    let mut sum_vec: Vec<(isize,\
    \ usize)> = vec![];\n    let mut idx = 0;\n    for num in nums {\n        let\
    \ mut curr_num = num;\n        let mut sum = 0;\n        while curr_num > 0 {\n\
    \            sum += curr_num % 10;\n            curr_num /= 10;\n        }\n \
    \       sum_vec.push((sum, idx));\n        idx += 1;\n    }\n    sum_vec.sort_by(|a,\
    \ b| a.0.cmp(&b.0));\n    let mut res: Vec<isize> = vec![];\n    for (sum, idx)\
    \ in sum_vec {\n        res.push(nums[idx]);\n    }\n    res", "    nums.into_iter().enumerate().sort_by(|a,\
    \ b| {\n        a.1.to_string().chars().map(|c| c.to_digit(10).unwrap() as isize).sum::<isize>()\n\
    \            .cmp(&b.1.to_string().chars().map(|c| c.to_digit(10).unwrap() as\
    \ isize).sum::<isize>())\n            .then(a.0.cmp(&b.0))\n    }).map(|a| a.1).collect()",
  '    unimplemented!();', "    nums.into_iter().enumerate().collect::<Vec<_>>().sort_by(|x,\
    \ y| {\n        let (i, x) = *x;\n        let (j, y) = *y;\n        let (x, y)\
    \ = (x.abs(), y.abs());\n        x.to_string().chars().map(|c| c.to_digit(10).unwrap()\
    \ as usize).sum::<usize>().cmp(&y.to_string().chars().map(|c| c.to_digit(10).unwrap()\
    \ as usize).sum::<usize>()).then(i.cmp(&j))\n    }).into_iter().map(|(_, y)| y).collect()",
  "    nums.into_iter().enumerate().map(|(i, x)| (x, i)).sorted_by_key(|(x, _)| {\n\
    \        x.to_string().chars().map(|c| c.to_digit(10).unwrap() as isize).sum::<isize>()\n\
    \    }).map(|(x, _)| x).collect()", "    let mut sum_list: Vec<(isize, isize)>\
    \ = Vec::new();\n    for (idx, num) in nums.iter().enumerate() {\n        let\
    \ mut sum = 0;\n        let mut tmp = *num;\n        while tmp != 0 {\n      \
    \      sum += tmp % 10;\n            tmp /= 10;\n        }\n        sum_list.push((sum,\
    \ idx as isize));\n    }\n    sum_list.sort_by(|a, b| a.0.cmp(&b.0));\n    let\
    \ mut result: Vec<isize> = Vec::new();\n    for item in sum_list {\n        result.push(nums[item.1\
    \ as usize]);\n    }\n    result", "    let mut result = nums.clone();\n    result.sort_by(|a,\
    \ b| {\n        let a_sum: usize = a.to_string().chars().map(|c| c.to_digit(10).unwrap()).sum();\n\
    \        let b_sum: usize = b.to_string().chars().map(|c| c.to_digit(10).unwrap()).sum();\n\
    \        a_sum.cmp(&b_sum)\n    });\n    result", "    let mut nums = nums;\n\
    \    nums.sort_by(|a, b| {\n        let a_digits = a.to_string().chars().map(|d|\
    \ d.to_digit(10).unwrap() as isize);\n        let b_digits = b.to_string().chars().map(|d|\
    \ d.to_digit(10).unwrap() as isize);\n        let a_sum: isize = a_digits.sum();\n\
    \        let b_sum: isize = b_digits.sum();\n        a_sum.cmp(&b_sum)\n    });\n\
    \    nums", "    let mut result = vec![];\n    let mut temp = vec![];\n    let\
    \ mut temp_idx = vec![];\n    for (idx, &i) in nums.iter().enumerate() {\n   \
    \     let mut i = i;\n        let mut sum = 0;\n        while i > 0 {\n      \
    \      sum += i % 10;\n            i /= 10;\n        }\n        temp.push(sum);\n\
    \        temp_idx.push(idx);\n    }\n    // this will sort temp and temp_idx in\
    \ the same order\n    let mut sort = temp.iter().enumerate().collect::<Vec<_>>();\n\
    \    sort.sort_by(|a, b| a.1.cmp(b.1));\n    for i in sort {\n        result.push(nums[temp_idx[i.0]]);\n\
    \    }\n    result", "    nums.iter()\n        .enumerate()\n        .map(|(idx,\
    \ num)| (num, num.to_string().chars().fold(0, |acc, ch| acc + ch.to_digit(10).unwrap()\
    \ as isize)))\n        .sorted_by(|a, b| a.1.cmp(&b.1).then(a.0.cmp(&b.0)))\n\
    \        .map(|(num, _)| *num)\n        .collect()", "    if nums.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut m = vec![];\n    for (i, v) in nums.iter().enumerate()\
    \ {\n        let mut vv = *v;\n        let mut sum = 0;\n        while vv != 0\
    \ {\n            sum += vv % 10;\n            vv /= 10;\n        }\n        m.push((i,\
    \ sum));\n    }\n    m.sort_by(|a, b| a.1.cmp(&b.1));\n    let mut res = vec![];\n\
    \    for i in m {\n        res.push(nums[i.0]);\n    }\n    res", "    let mut\
    \ sum_count = nums.iter().map(|x| (digit_sum(*x), x)).collect::<Vec<_>>();\n \
    \   sum_count.sort_by(|x, y| x.0.cmp(&y.0));\n    sum_count.iter().map(|x| *x.1).collect()",
  "    let mut sorted_num: Vec<isize> = nums.iter().map(|num| (num, sum_digits(*num))).collect();\n\
    \    sorted_num.sort_by(|a, b| b.1.cmp(&a.1));\n    sorted_num.iter().map(|num|\
    \ *num.0).collect()", "    fn sum_digits(n: isize) -> isize {\n        let mut\
    \ acc = 0;\n        let mut n = n;\n        while n > 0 {\n            acc +=\
    \ n % 10;\n            n /= 10;\n        }\n        acc\n    }\n\n    nums.into_iter()\n\
    \        .enumerate()\n        .map(|(i, n)| (i, n, sum_digits(n)))\n        .sorted_by(|a,\
    \ b| {\n            let comp = a.2.cmp(&b.2);\n            if comp == Ordering::Equal\
    \ {\n                a.0.cmp(&b.0)\n            } else {\n                comp\n\
    \            }\n        })\n        .map(|(_, n, _)| n)\n        .collect()",
  "    let mut points: Vec<(isize, isize)> = nums.iter().map(|x| (x, dig_sum(*x))).collect();\n\
    \    points.sort_by(|x, y| {\n        let x = x.clone();\n        let y = y.clone();\n\
    \        x.1.cmp(&y.1)\n    });\n    points.iter().map(|x| x.0).collect()", " \
    \   nums.iter()\n        .enumerate()\n        .map(|(i, v)| (i, v, v.to_string().chars().filter_map(|c|\
    \ c.to_digit(10)).sum::<u32>() as isize))\n        .sorted_by(|a, b| (a.2, a.0).cmp(&(b.2,\
    \ b.0)))\n        .into_iter()\n        .map(|(_, &v, _)| v)\n        .collect()",
  "    let mut numbers: Vec<isize> = nums.clone();\n    let mut sorted_numbers: Vec<isize>\
    \ = vec![];\n    let mut min: isize = 0;\n    let mut index: usize = 0;\n    loop\
    \ {\n        for (i, n) in numbers.iter().enumerate() {\n            let mut sum\
    \ = 0;\n            for c in n.to_string().chars() {\n                sum += c.to_digit(10).unwrap()\
    \ as isize;\n            }\n            if sum < min || min == 0 {\n         \
    \       min = sum;\n                index = i;\n            }\n        }\n   \
    \     sorted_numbers.push(numbers[index]);\n        numbers.remove(index);\n \
    \       min = 0;\n        if numbers.len() == 0 {\n            break;\n      \
    \  }\n    }\n    sorted_numbers", "    let mut nums = nums;\n    nums.sort_by(|a,\
    \ b| {\n        let sum1 = a.to_string().chars().map(|ch| ch.to_digit(10).unwrap()).sum::<u32>();\n\
    \        let sum2 = b.to_string().chars().map(|ch| ch.to_digit(10).unwrap()).sum::<u32>();\n\
    \        sum1.cmp(&sum2)\n    });\n    nums", "    let mut vec = nums.clone();\n\
    \    vec.sort_by(|a, b| -> std::cmp::Ordering {\n        let points_a = a.to_string().chars().fold(0,\
    \ |sum, item| sum + item.to_digit(10).unwrap() as isize);\n        let points_b\
    \ = b.to_string().chars().fold(0, |sum, item| sum + item.to_digit(10).unwrap()\
    \ as isize);\n        points_a.cmp(&points_b)\n    });\n    vec", "    // transform\
    \ num to (num, sum_of_digits)\n    let mut digits: Vec<(isize, usize)> = nums.iter().map(|x|\
    \ (*x, x.to_string().chars().fold(0, |acc, n| acc + n.to_digit(10).unwrap() as\
    \ usize))).collect();\n    digits.sort_by(|a, b| if a.1 == b.1 { a.0.cmp(&b.0)\
    \ } else { a.1.cmp(&b.1) });\n    digits.iter().map(|x| x.0).collect()", "   \
    \ nums.into_iter().enumerate().collect::<Vec<_>>().sort_by(|(_, a), (_, b)| {\n\
    \        let (a_l, a_r) = split(a);\n        let (b_l, b_r) = split(b);\n    \
    \    (a_l + a_r).cmp(&(b_l + b_r))\n    }).into_iter().map(|(_, x)| x).collect()",
  "    //let nums = nums.clone();\n    nums.iter().enumerate().sorted_by(|x, y| {\n\
    \        let x = x.1;\n        let y = y.1;\n        let mut xsum = 0;\n     \
    \   let mut ysum = 0;\n        for c in x.to_string().chars() {\n            xsum\
    \ += c.to_digit(10).unwrap();\n        }\n        for c in y.to_string().chars()\
    \ {\n            ysum += c.to_digit(10).unwrap();\n        }\n        xsum.cmp(&ysum)\n\
    \    }).map(|(i, &x)| x).collect()", "    let mut array = nums.clone();\n    array.sort_by(|a,\
    \ b| {\n        let a_sum = split_digits(*a).iter().sum::<isize>();\n        let\
    \ b_sum = split_digits(*b).iter().sum::<isize>();\n        a_sum.cmp(&b_sum)\n\
    \    });\n    array", "    let mut nums = nums;\n    nums.sort_by(|x, y| digits(x).cmp(&digits(y)));\n\
    \    nums", "    nums.iter()\n        .enumerate()\n        .map(|(i, v)| (i,\
    \ v, v.to_string().chars().map(|d| d.to_digit(10).unwrap() as isize).sum()))\n\
    \        .sorted_by(|(_, _, a), (_, _, b)| a.cmp(b))\n        .map(|(_, v, _)|\
    \ *v)\n        .collect()", "    //fn digsum(n: isize) -> isize {\n    //    n.to_string().chars().fold(0,\
    \ |acc, d| acc + d.to_digit(10).unwrap())\n    //}\n    //nums.iter().enumerate().sorted_by(|a,\
    \ b| {\n    //    let asum = digsum(a.1);\n    //    let bsum = digsum(b.1);\n\
    \    //    asum.cmp(&bsum).then(a.0.cmp(&b.0))\n    //}).map(|(_, n)| *n).collect()\n\
    \    let mut res = nums.clone();\n    res.sort_by(|a, b| {\n        let (a_sum,\
    \ b_sum) = (digsum(*a), digsum(*b));\n        if a_sum == b_sum { a.cmp(b) } else\
    \ { a_sum.cmp(&b_sum) }\n    });\n    res", "    let mut nums_with_idx: Vec<_>\
    \ = nums.iter().enumerate().collect();\n    nums_with_idx.sort_by_key(|(_, &num)|\
    \ {\n        num.to_string()\n            .chars()\n            .fold(0, |acc,\
    \ c| acc + c.to_digit(10).unwrap())\n    });\n    nums_with_idx.into_iter().map(|(_,\
    \ &num)| num).collect()", "    let mut result = nums.clone();\n    result.sort_by(|a,\
    \ b| {\n        let a_sum = a.to_string().chars().map(|c| c.to_digit(10).unwrap()).sum::<u32>();\n\
    \        let b_sum = b.to_string().chars().map(|c| c.to_digit(10).unwrap()).sum::<u32>();\n\
    \        a_sum.cmp(&b_sum)\n    });\n    result", "    nums.iter()\n        .enumerate()\n\
    \        .map(|(idx, n)| (idx, n, sum_digits(*n)))\n        .sorted_by(|(_, n1,\
    \ points1), (_, n2, points2)| match points1.cmp(points2) {\n            Ordering::Equal\
    \ => n1.cmp(n2),\n            _ => points1.cmp(points2),\n        })\n       \
    \ .map(|(_, n, _)| *n)\n        .collect()", "    // TODO\n    let mut nums =\
    \ nums;\n    //let mut points = vec![];\n    let mut sum = 0;\n    let mut sort\
    \ = vec![];\n    let mut sum_digit = 0;\n    let mut new_nums = vec![];\n    let\
    \ mut new_nums_1 = vec![];\n    let mut num_res = vec![];\n    for num in nums.iter()\
    \ {\n        sum = 0;\n        let num_str = num.to_string();\n        for digit\
    \ in num_str.chars() {\n            let digit = digit.to_digit(10).unwrap();\n\
    \            sum += digit as isize;\n        }\n        sum_digit = sum;\n   \
    \     new_nums.push(sum_digit);\n    }\n    //println!(\"{:?}\", new_nums);\n\
    \    new_nums_1 = new_nums.clone();\n    new_nums_1.sort();\n    //println!(\"\
    {:?}\", new_nums_1);\n    for i in new_nums_1.iter() {\n        for (index, j)\
    \ in new_nums.iter().enumerate() {\n            if i == j {\n                sort.push(index);\n\
    \            }\n        }\n    }\n    //println!(\"{:?}\", sort);\n    for i in\
    \ sort.iter() {\n        num_res.push(nums[*i]);\n    }\n    num_res", '    nums.into_iter().enumerate().map(|(i,
    x)| (i, x, x.to_string().chars().map(|c| c.to_digit(10).unwrap() as isize).sum())).sorted_by(|&(_,
    _, a), &(_, _, b)| a.cmp(&b)).map(|(_, x, _)| x).collect()', "    let mut sum_nums\
    \ = nums.clone();\n    for (i, v) in nums.iter().enumerate() {\n        let t:\
    \ String = v.to_string();\n        let mut sum: isize = 0;\n        for c in t.chars()\
    \ {\n            let digit: isize = c.to_digit(10).unwrap() as isize;\n      \
    \      sum += digit;\n        }\n        sum_nums[i] = sum;\n    }\n    println!(\"\
    {:?}\", sum_nums);\n    let mut nums = nums;\n    nums.sort_by(|a, b| sum_nums[*a\
    \ as usize].cmp(&sum_nums[*b as usize]));\n    println!(\"{:?}\", nums);\n   \
    \ nums", "    fn sum_of_digits(num: isize) -> isize {\n        num.to_string()\n\
    \            .chars()\n            .map(|d| d.to_digit(10).unwrap() as isize)\n\
    \            .sum()\n    }\n\n    let mut sum_of_digits_map = nums\n        .iter()\n\
    \        .map(|num| (num, sum_of_digits(*num)))\n        .collect::<Vec<(&isize,\
    \ isize)>>();\n\n    // sort with descending order of sum of digits, then ascending\
    \ order of original index.\n    sum_of_digits_map.sort_by(|a, b| b.1.cmp(&a.1).then(a.0.cmp(&b.0)));\n\
    \n    sum_of_digits_map.iter().map(|(num, _)| *num).collect()", "    fn sum_digits(mut\
    \ num: isize) -> isize {\n        let mut sum = 0;\n        while num > 0 {\n\
    \            sum += num % 10;\n            num /= 10;\n        }\n        sum\n\
    \    }\n\n    let mut result = nums.iter().enumerate().collect::<Vec<_>>();\n\
    \    result.sort_by_key(|x| (sum_digits(x.1), x.0));\n    result.iter().map(|x|\
    \ *x.1).collect()", "    nums.into_iter().enumerate().sorted_by(|&(i1,n1), &(i2,n2)|{\n\
    \        (n1.to_string().chars().map(|c| c.to_digit(10).unwrap() as usize).sum(),\
    \ i1).cmp(&(n2.to_string().chars().map(|c| c.to_digit(10).unwrap() as usize).sum(),\
    \ i2))\n    }).map(|(i,n)| n).collect()", "    let mut result = nums.clone();\n\
    \    result.sort_by(|a, b| {\n        let a_num = sum_of_digits(*a);\n       \
    \ let b_num = sum_of_digits(*b);\n        a_num.cmp(&b_num)\n    });\n    result",
  "    // /////////////////////////////////////////////////////////////////////////\n\
    \    nums.iter()\n        .enumerate()\n        .map(|(i, &n)| (i, sum_digits(n),\
    \ n))\n        .sorted_by(|a, b| {\n            match a.1.cmp(&b.1) {\n      \
    \          std::cmp::Ordering::Equal => a.0.cmp(&b.0),\n                otherwise\
    \ => otherwise,\n            }\n        })\n        .map(|(_, _, n)| n)\n    \
    \    .collect()\n    // /////////////////////////////////////////////////////////////////////////",
  "    let mut nums = nums;\n    nums.sort_by(|a, b| {\n        a.to_string()\n  \
    \          .chars()\n            .map(|c| c.to_digit(10).unwrap() as isize)\n\
    \            .sum::<isize>()\n            .cmp(&b.to_string()\n              \
    \  .chars()\n                .map(|c| c.to_digit(10).unwrap() as isize)\n    \
    \            .sum::<isize>())\n    });\n    nums", "    let mut ret = nums.iter().enumerate().collect::<Vec<_>>();\n\
    \    ret.sort_by_key(|(i, &num)| (num.abs() as usize).to_string().chars().map(|ch|\
    \ ch.to_digit(10).unwrap() as usize).sum() * 100000 + *i);\n    ret.iter().map(|&(_,\
    \ num)| num).collect()", '    nums.into_iter().enumerate().collect::<Vec<_>>().sort_by(|&(_,
    a), &(_, b)| sum_of_digits(a).cmp(&sum_of_digits(b))).iter().map(|&(i, _)| nums[i]).collect()',
  "    // let sum: Vec<isize> = nums.iter().map(|x| x.to_string().chars().map(|y|\
    \ y.to_digit(10).unwrap() as isize).sum()).collect();\n    // let indexes: Vec<usize>\
    \ = (0..nums.len()).collect();\n    // let mut list: Vec<(isize, usize)> = sum.iter().zip(indexes.iter()).collect();\n\
    \    // list.sort_by(|a, b| a.0.cmp(&b.0));\n    // list.iter().map(|x| nums[x.1]).collect()\n\
    \    nums.iter().enumerate().sorted_by(|a, b| {\n        let a_sum = a.1.to_string().chars().map(|x|\
    \ x.to_digit(10).unwrap() as isize).sum();\n        let b_sum = b.1.to_string().chars().map(|x|\
    \ x.to_digit(10).unwrap() as isize).sum();\n        a_sum.cmp(&b_sum).then(a.0.cmp(&b.0))\n\
    \    }).iter().map(|x| *x.1).collect()", "    let mut orders: Vec<(isize, isize)>\
    \ = nums.iter().map(|n| {\n        let mut num: isize = *n;\n        let mut sum:\
    \ isize = 0;\n        while num > 0 {\n            sum += num % 10;\n        \
    \    num /= 10;\n        }\n        (sum, *n)\n    }).collect();\n    orders.sort_by(|a,\
    \ b| a.0.cmp(&b.0));\n    orders.iter().map(|i| i.1).collect()", "    let mut\
    \ sum_nums = vec![];\n    for (index, num) in nums.iter().enumerate() {\n    \
    \    sum_nums.push((index, num.to_string().chars().map(|d| d.to_digit(10).unwrap()\
    \ as isize).sum()));\n    }\n    sum_nums.sort_by(|a, b| a.1.cmp(&b.1));\n   \
    \ let mut res = vec![];\n    for (_, v) in sum_nums {\n        res.push(nums[v\
    \ as usize]);\n    }\n    res", "    nums.iter()\n        .enumerate()\n     \
    \   .map(|(i, n)| (n, i, n.to_string().chars().map(|c| c.to_digit(10).unwrap()\
    \ as isize).sum()))\n        .collect::<Vec<_>>()\n        .sort_by(|&(_, _, s1),\
    \ &(_, _, s2)| {\n            if s1 == s2 {\n                core::cmp::Ordering::Equal\n\
    \            } else if s1 < s2 {\n                core::cmp::Ordering::Less\n\
    \            } else {\n                core::cmp::Ordering::Greater\n        \
    \    }\n        })\n        .iter()\n        .map(|&(n, _, _)| *n)\n        .collect()",
  '    nums.into_iter().enumerate().collect::<Vec<_>>().sort_by(|(_, x), (_, y)| x.abs().to_string().chars().map(|z|
    z.to_digit(10).unwrap() as isize).sum::<isize>().cmp(&y.abs().to_string().chars().map(|z|
    z.to_digit(10).unwrap() as isize).sum::<isize>()).then(x.cmp(&y))).into_iter().map(|(i,
    _)| i as isize).collect::<Vec<_>>()', "    let mut list = nums;\n    let mut temp:\
    \ usize;\n    let mut sum: isize;\n    let mut d: isize;\n    let mut i: usize;\n\
    \    let mut j: usize;\n    let mut index: usize;\n    let mut key: isize;\n \
    \   for i in 1..list.len() {\n        key = list[i];\n        temp = key.abs()\
    \ as usize;\n        sum = 0;\n        while temp > 0 {\n            d = temp\
    \ % 10;\n            sum += d;\n            temp = temp / 10;\n        }\n   \
    \     j = i - 1;\n        while j >= 0 && (list[j].abs() as usize).count_ones()\
    \ < sum.count_ones() {\n            list[j + 1] = list[j];\n            j = j\
    \ - 1;\n        }\n        if j >= 0 && (list[j].abs() as usize).count_ones()\
    \ == sum.count_ones() {\n            index = nums.iter().position(|&val| val ==\
    \ key).unwrap();\n            while j >= 0 && (list[j].abs() as usize).count_ones()\
    \ == sum.count_ones() && (nums.iter().position(|&val| val == list[j]).unwrap()\
    \ > index) {\n                list[j + 1] = list[j];\n                j = j -\
    \ 1;\n            }\n        }\n        list[j + 1] = key;\n    }\n    list",
  "    fn sum_digits(n: isize) -> isize {\n        let mut result = 0;\n        let\
    \ mut n = n;\n        while n > 0 {\n            result += n % 10;\n         \
    \   n /= 10;\n        }\n        result\n    }\n\n    let mut nums: Vec<_> = nums.into_iter().enumerate().collect();\n\
    \    nums.sort_by_key(|(index, &number)| (sum_digits(number), index));\n    nums.into_iter().map(|(_,\
    \ number)| number).collect()", "    // WIP\n    let mut nums = nums;\n    nums.sort_by(|a,\
    \ b| {\n        let split_a = a.to_string().chars().map(|x| x.to_digit(10).unwrap()).sum::<u32>();\n\
    \        let split_b = b.to_string().chars().map(|x| x.to_digit(10).unwrap()).sum::<u32>();\n\
    \        split_a.cmp(&split_b)\n    });\n    nums", "    nums.into_iter().enumerate().sorted_by(|a,\
    \ b| {\n        a.1.to_string().chars().map(|c| c.to_digit(10).unwrap() as isize).sum::<isize>()\n\
    \            .cmp(&b.1.to_string().chars().map(|c| c.to_digit(10).unwrap() as\
    \ isize).sum::<isize>())\n            .then_with(|| a.0.cmp(&b.0))\n    }).map(|(_,\
    \ x)| x).collect()", "    nums.iter()\n        .enumerate()\n        .map(|(index,\
    \ &num)| (index, num))\n        .map(|(index, num)| (index, num, num.to_string().chars().map(|ch|\
    \ ch.to_digit(10).unwrap() as isize).sum()))\n        .map(|(index, num, points)|\
    \ (points, num, index))\n        .sorted_by(|&(p1, _, _), &(p2, _, _)| p1.cmp(&p2))\n\
    \        .map(|(_, num, _)| num)\n        .collect()", "    fn sum_digits(mut\
    \ num: isize) -> isize {\n        let mut sum = 0;\n        while num > 0 {\n\
    \            sum += num % 10;\n            num /= 10;\n        }\n        sum\n\
    \    }\n\n    let mut nums = nums;\n    nums.sort_by_key(|num| (sum_digits(*num),\
    \ num));\n    nums", '    unimplemented!()', "    nums.iter()\n        .enumerate()\n\
    \        .map(|(index, n)| (index, n, sum_of_digits(*n)))\n        .sorted_by(|(_,\
    \ _, a), (_, _, b)| a.cmp(b))\n        .into_iter()\n        .map(|(_, n, _)|\
    \ *n)\n        .collect()", "    // CODE HERE\n    unimplemented!()", "    nums.into_iter().enumerate().sorted_by(|(_,\
    \ a), (_, b)| {\n        get_digits_sum(*a).cmp(&get_digits_sum(*b))\n    }).map(|(_,\
    \ x)| x).collect()", '    unimplemented!()', "    let sum_digits = |num: &isize|\
    \ -> isize {\n        let mut sum = 0;\n        let mut num = *num;\n        while\
    \ num > 0 {\n            sum += num % 10;\n            num /= 10;\n        }\n\
    \        sum\n    };\n\n    nums.iter()\n        .enumerate()\n        .sorted_by(|(_,\
    \ a), (_, b)| {\n            if sum_digits(a) == sum_digits(b) {\n           \
    \     Ordering::Equal\n            } else if sum_digits(a) < sum_digits(b) {\n\
    \                Ordering::Less\n            } else {\n                Ordering::Greater\n\
    \            }\n        })\n        .map(|(i, &num)| num)\n        .collect()",
  "    let mut nums = nums;\n    nums.sort_by(|a, b| {\n        let a_digits = a.to_string().chars().map(|c|\
    \ c.to_digit(10).unwrap() as isize);\n        let b_digits = b.to_string().chars().map(|c|\
    \ c.to_digit(10).unwrap() as isize);\n        a_digits.sum::<isize>().cmp(&b_digits.sum::<isize>())\n\
    \    });\n    nums", "    let mut dig_sums: Vec<(isize, isize)> = vec![];\n  \
    \  for (idx, num) in nums.iter().enumerate() {\n        let sum: isize = num.to_string().chars().map(|c|\
    \ c.to_digit(10).unwrap() as isize).sum();\n        dig_sums.push((sum, idx as\
    \ isize));\n    }\n    dig_sums.sort_by(|a, b| a.0.cmp(&b.0));\n    let mut result:\
    \ Vec<isize> = vec![];\n    for dig_sum in dig_sums {\n        result.push(nums[dig_sum.1\
    \ as usize]);\n    }\n    result", "    let mut m = HashMap::new();\n    for i\
    \ in 0..nums.len() {\n        let s = sum_digits(nums[i]);\n        m.entry(s).or_insert(Vec::new()).push(nums[i]);\n\
    \    }\n    let mut keys: Vec<isize> = m.keys().map(|x| *x).collect();\n    keys.sort();\n\
    \    let mut out = Vec::new();\n    for k in keys {\n        out.append(&mut m.get(&k).unwrap().clone());\n\
    \    }\n    out", "    let mut sum_vec: Vec<(isize, isize)> = Vec::new();\n  \
    \  for num in nums {\n        let mut num = num;\n        let mut sum = 0;\n \
    \       while num > 0 {\n            sum += num % 10;\n            num /= 10;\n\
    \        }\n        sum_vec.push((sum, num));\n    }\n    sum_vec.sort_by(|a,\
    \ b| a.cmp(b));\n    sum_vec.iter().map(|&(_, num)| num).collect()", '    nums.into_iter().enumerate().collect::<Vec<_>>().sort_by(|a,
    b| a.1.sum_of_digits().cmp(&b.1.sum_of_digits())).into_iter().map(|(_, x)| x).collect()',
  "    fn digit_sum(n: isize) -> usize {\n        let mut sum = 0;\n        let mut\
    \ n = n;\n        while n > 0 {\n            sum += (n % 10) as usize;\n     \
    \       n /= 10;\n        }\n        sum\n    }\n\n    let mut nums = nums;\n\
    \    nums.sort_by_key(|&n| (digit_sum(n), n));\n    nums", "    // this is amazing\n\
    \    let mut nums = nums;\n    nums.sort_by_key(|&x| (x.abs() as usize).to_string().chars().map(|c|\
    \ c.to_digit(10).unwrap()).sum::<u32>());\n    nums", "    let mut nums: Vec<_>\
    \ = nums.into_iter().enumerate().collect();\n    nums.sort_by_key(|(_, &item)|\
    \ item.to_string().as_bytes().iter().map(|&x| x - '0' as u8).sum::<u8>());\n \
    \   nums.into_iter().map(|(i, _)| i as isize).collect()", "    nums.iter()\n \
    \       .enumerate()\n        .map(|(i, n)| (i, sum_digits(*n)))\n        .collect::<Vec<(usize,\
    \ isize)>>()\n        .sort_by(|a, b| {\n            if a.1 < b.1 {\n        \
    \        Ordering::Less\n            } else if a.1 > b.1 {\n                Ordering::Greater\n\
    \            } else {\n                a.0.cmp(&b.0)\n            }\n        })\n\
    \        .iter()\n        .map(|x| nums[x.0])\n        .collect()", "    let mut\
    \ result = nums.clone();\n    result.sort_by(|a, b| {\n        let ad = sum_digits(*a);\n\
    \        let bd = sum_digits(*b);\n        match ad.cmp(&bd) {\n            Ordering::Equal\
    \ => a.cmp(&b),\n            Ordering::Less => Ordering::Less,\n            Ordering::Greater\
    \ => Ordering::Greater,\n        }\n    });\n    result", "    let mut sorted_nums\
    \ = nums.clone();\n    sorted_nums.sort_by(|a, b| (sum_digits(*a), a).cmp(&(sum_digits(*b),\
    \ b)));\n    sorted_nums", "    let mut final_vec: Vec<isize> = Vec::new();\n\
    \    let mut sum_point_pair: Vec<(isize, isize)> = Vec::new();\n    for num in\
    \ nums {\n        let mut sum = 0;\n        let mut num_copy = num;\n        while\
    \ num_copy > 0 {\n            sum += num_copy % 10;\n            num_copy /= 10;\n\
    \        }\n        sum_point_pair.push((sum, num));\n    }\n    sum_point_pair.sort();\n\
    \    for pair in sum_point_pair {\n        final_vec.push(pair.1);\n    }\n  \
    \  final_vec", "    // Your code here\n    let mut sorted_nums = nums.clone();\n\
    \    sorted_nums.sort_by(|a, b| {\n        let a_sum = a.to_string().chars().fold(0,\
    \ |acc, c| acc + c.to_digit(10).unwrap() as isize);\n        let b_sum = b.to_string().chars().fold(0,\
    \ |acc, c| acc + c.to_digit(10).unwrap() as isize);\n        a_sum.cmp(&b_sum)\n\
    \    });\n    sorted_nums", "    let mut tuples: Vec<(isize, usize)> = Vec::new();\n\
    \    for (i, x) in nums.iter().enumerate() {\n        let mut sum = 0;\n     \
    \   let mut x = *x;\n        while x > 0 {\n            sum += x % 10;\n     \
    \       x /= 10;\n        }\n        tuples.push((sum, i));\n    }\n    tuples.sort();\n\
    \    let mut res: Vec<isize> = Vec::new();\n    for x in tuples {\n        res.push(nums[x.1]);\n\
    \    }\n    res", "    let mut tuples: Vec<(isize, usize)> = nums.iter().enumerate().map(|(i,\
    \ x)| (x.to_string().chars().map(|d| d.to_digit(10).unwrap() as isize).sum(),\
    \ i)).collect();\n    tuples.sort_by(|a, b| {\n        if a.0 == b.0 {\n     \
    \       a.1.cmp(&b.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    tuples.iter().map(|t| nums[t.1]).collect()", "    nums.iter()\n\
    \        .enumerate()\n        .map(|(index, num)| (num, num.to_string().chars().map(|c|\
    \ c.to_digit(10).unwrap()).sum::<u32>() as isize, index))\n        .sorted_by(|(_,\
    \ a, _), (_, b, _)| a.cmp(b))\n        .map(|(num, _, _)| *num)\n        .collect()",
  "    let mut nums = nums;\n    nums.sort_by(|a, b| -> std::cmp::Ordering {\n   \
    \     let a_sum = sum_digits(*a);\n        let b_sum = sum_digits(*b);\n     \
    \   if a_sum < b_sum {\n            std::cmp::Ordering::Less\n        } else if\
    \ a_sum > b_sum {\n            std::cmp::Ordering::Greater\n        } else {\n\
    \            std::cmp::Ordering::Equal\n        }\n    });\n    nums", "    let\
    \ mut nums = nums;\n    nums.sort_by(|a, b| sum_digits(*a).cmp(&sum_digits(*b)));\n\
    \    nums", "    let mut res = nums.clone();\n    res.sort_by(|a, b| {\n     \
    \   let a_digits = a.to_string().chars().map(|d| d.to_digit(10).unwrap() as usize).sum();\n\
    \        let b_digits = b.to_string().chars().map(|d| d.to_digit(10).unwrap()\
    \ as usize).sum();\n        a_digits.cmp(&b_digits)\n    });\n    res", "    let\
    \ mut order = nums.iter().enumerate().collect::<Vec<(usize, &isize)>>();\n   \
    \ order.sort_by(|a, b| {\n        let sum_a = sum_digits(*a.1);\n        let sum_b\
    \ = sum_digits(*b.1);\n        if sum_a == sum_b {\n            a.0.cmp(&b.0)\n\
    \        } else {\n            sum_a.cmp(&sum_b)\n        }\n    });\n    order.iter().map(|&(_,\
    \ &i)| i).collect()", "    nums.iter()\n        .enumerate()\n        .map(|(i,\
    \ n)| (i, n, sum_of_digits(*n)))\n        .sorted_by(|a, b| a.2.cmp(&b.2).then(a.0.cmp(&b.0)))\n\
    \        .into_iter()\n        .map(|(_, n, _)| *n)\n        .collect()", '    unimplemented!();',
  "    // let v = &nums;\n    let mut v = nums.clone();\n    v.sort_by(|a, b| {\n\
    \        let sum_a = a.to_string().chars().map(|c| c.to_digit(10).unwrap()).sum::<u32>();\n\
    \        let sum_b = b.to_string().chars().map(|c| c.to_digit(10).unwrap()).sum::<u32>();\n\
    \        // println!(\"{}-{}\", sum_a, sum_b);\n        sum_a.cmp(&sum_b)\n  \
    \  });\n    v", "    let mut result = vec![];\n    let mut dict = HashMap::new();\n\
    \    for (index, &num) in nums.iter().enumerate() {\n        let score = num.to_string().chars().map(|x|\
    \ x.to_digit(10).unwrap() as isize).sum();\n        dict.insert(index, score);\n\
    \    }\n    let mut idx = dict.keys().cloned().collect::<Vec<usize>>();\n    idx.sort_by_key(|&x|\
    \ dict[&x]);\n    for &i in idx.iter() {\n        result.push(nums[i]);\n    }\n\
    \    result", "    let mut nums_sum = Vec::new();\n    for i in 0..nums.len()\
    \ {\n        let mut num = nums[i];\n        let mut sum = 0;\n        while num\
    \ > 0 {\n            sum += num % 10;\n            num /= 10;\n        }\n   \
    \     nums_sum.push((sum, i));\n    }\n    nums_sum.sort();\n    let mut sorted_nums\
    \ = Vec::new();\n    for j in 0..nums_sum.len() {\n        sorted_nums.push(nums[nums_sum[j].1]);\n\
    \    }\n    sorted_nums", '    unimplemented!();', "    let mut nums_sum_map:\
    \ HashMap<isize, Vec<isize>> = HashMap::new();\n    for i in 0..nums.len() {\n\
    \        let sum = sum_digits(nums[i]);\n        let mut entry = nums_sum_map.entry(sum).or_insert(Vec::new());\n\
    \        entry.push(nums[i]);\n    }\n    let mut nums_sum_map: Vec<(&isize, &Vec<isize>)>\
    \ = nums_sum_map.iter().collect();\n    nums_sum_map.sort_by(|x, y| x.0.cmp(y.0));\n\
    \    let mut res: Vec<isize> = Vec::new();\n    for (_, values) in nums_sum_map\
    \ {\n        res.extend(values.iter());\n    }\n    res", "    let mut sum_vec:\
    \ Vec<(isize, usize)> = Vec::new();\n    for (idx, &num) in nums.iter().enumerate()\
    \ {\n        sum_vec.push((num, idx));\n    }\n    let mut new_vec: Vec<isize>\
    \ = Vec::new();\n    sum_vec.sort_by(|a, b| a.1.cmp(&b.1));\n    sum_vec.sort_by(|a,\
    \ b| sum_digits(a.0).cmp(&sum_digits(b.0)));\n    for num in sum_vec {\n     \
    \   new_vec.push(num.0);\n    }\n    new_vec", "    let mut res = nums.clone();\n\
    \    res.sort_by(|a, b| sum_digits(*a).cmp(&sum_digits(*b)));\n    res", "   \
    \ fn digits_sum(n: isize) -> isize {\n        fn acc(n: isize, acc: isize) ->\
    \ isize {\n            if n == 0 {\n                acc\n            } else {\n\
    \                acc(n / 10, acc + n % 10)\n            }\n        }\n       \
    \ acc(n, 0)\n    }\n    let mut nums = nums;\n    nums.sort_by(|a, b| digits_sum(*a).cmp(&digits_sum(*b)));\n\
    \    nums", "    let mut nums: Vec<_> = nums.into_iter().enumerate().collect();\n\
    \    nums.sort_by_key(|&(_, x)| {\n        x.abs()\n            .to_string()\n\
    \            .chars()\n            .map(|c| c.to_digit(10).unwrap() as u32)\n\
    \            .sum::<u32>()\n    });\n    nums.into_iter().map(|(_, x)| x).collect()",
  "    let mut result = vec![];\n    let mut nums = nums;\n    nums.sort_by(|a, b|\
    \ (digit_sum(*a)).cmp(&digit_sum(*b)));\n    result.extend(nums);\n    result",
  "    let mut total = Vec::new();\n    let mut sort = Vec::new();\n    for x in nums.iter()\
    \ {\n        let mut y = x.clone();\n        let mut sum = 0;\n        while y\
    \ > 0 {\n            sum += y % 10;\n            y /= 10;\n        }\n       \
    \ total.push(sum);\n    }\n    let mut min_so_far = 0;\n    while sort.len() <\
    \ nums.len() {\n        for x in 0..nums.len() {\n            if total[x] < total[min_so_far]\
    \ {\n                min_so_far = x;\n            }\n        }\n        sort.push(nums[min_so_far]);\n\
    \        total[min_so_far] = 100;\n    }\n    sort", "    // the sum_of_digits()\
    \ function is provided for your use\n    fn sum_of_digits(n: isize) -> isize {\n\
    \        n.to_string()\n            .chars()\n            .map(|c| c.to_digit(10).unwrap()\
    \ as isize)\n            .sum()\n    }\n\n    // order_by_points(vec![51, 32,\
    \ 43]) == vec![32, 43, 51]\n    // because 51 -> 5 + 1 = 6, 32 -> 3 + 2 = 5, 43\
    \ -> 4 + 3 = 7.\n    //\n    // order_by_points(vec![99, 77, 55, 33, 1, 0]) ==\
    \ vec![99, 77, 55, 1, 33, 0]\n    // because 55 -> 5 + 5 = 10, 33 -> 3 + 3 = 6,\
    \ 77 -> 7 + 7 = 14,\n    // 1 -> 1 = 1, 99 -> 9 + 9 = 18, 0 -> 0 = 0.\n    //\n\
    \    // order_by_points(vec![12, 23, 34, 45, 56, 67, 78, 89, 90]) == vec![12,\
    \ 89, 23, 78, 34, 67, 45, 56, 90]\n    // because 12 -> 1 + 2 = 3, 23 -> 2 + 3\
    \ = 5, 34 -> 3 + 4 = 7,\n    // 45 -> 4 + 5 = 9, 56 -> 5 + 6 = 11, 67 -> 6 + 7\
    \ = 13,\n    // 78 -> 7 + 8 = 15, 89 -> 8 + 9 = 17, 90 -> 9 + 0 = 9.\n    //\n\
    \    // Note: order of items with similar sum of digits may differ.\n    // For\
    \ example:\n    // order_by_points(vec![12, 23, 34, 45, 56, 67, 78, 89, 90]) ==\
    \ vec![12, 23, 34, 45, 56, 67, 78, 89, 90]\n    // is also a valid answer.\n \
    \   let mut result = nums.clone();\n    result.sort_by_key(|&x| (sum_of_digits(x),\
    \ x));\n    result", "    let mut nums: Vec<(isize, usize)> = nums.into_iter().enumerate().map(|(i,\
    \ x)| (x, i)).collect();\n    nums.sort_by(|a, b| {\n        let (a, ai) = a;\n\
    \        let (b, bi) = b;\n        let a_sum = a.to_string().chars().map(|c| c.to_digit(10).unwrap()\
    \ as isize).sum();\n        let b_sum = b.to_string().chars().map(|c| c.to_digit(10).unwrap()\
    \ as isize).sum();\n        a_sum.cmp(&b_sum).then(ai.cmp(&bi))\n    });\n   \
    \ nums.into_iter().map(|(a, _)| a).collect()", "    nums.into_iter().enumerate().collect::<Vec<_>>().sort_by(|a,\
    \ b| {\n        let sum_a = a.1.to_string().chars().map(|c| c.to_digit(10).unwrap()\
    \ as isize).sum();\n        let sum_b = b.1.to_string().chars().map(|c| c.to_digit(10).unwrap()\
    \ as isize).sum();\n        sum_a.cmp(&sum_b).then(a.0.cmp(&b.0))\n    }).into_iter().map(|(_,\
    \ x)| x).collect()", "    nums.iter()\n        .enumerate()\n        .map(|(i,\
    \ n)| {\n            (\n                i,\n                n.to_string()\n  \
    \                  .chars()\n                    .map(|c| c.to_digit(10).unwrap())\n\
    \                    .sum::<u32>(),\n            )\n        })\n        .sorted_by(|a,\
    \ b| Ord::cmp(&a.1, &b.1))\n        .map(|(i, _)| nums[i])\n        .collect()",
  "    fn sum_digits(x: isize) -> isize {\n        let mut sum = 0;\n        let mut\
    \ x = x;\n        while x > 0 {\n            sum += x % 10;\n            x /=\
    \ 10;\n        }\n        sum\n    }\n    let mut nums = nums;\n    nums.sort_by(|&a,\
    \ &b| {\n        let a = sum_digits(a);\n        let b = sum_digits(b);\n    \
    \    if a == b {\n            Less\n        } else if a < b {\n            Less\n\
    \        } else {\n            Greater\n        }\n    });\n    nums", "    if\
    \ nums.len() < 2 {\n        return nums;\n    }\n    nums.iter()\n        .enumerate()\n\
    \        .map(|(i, n)| {\n            let mut digits_sum = 0;\n            let\
    \ mut num = *n;\n            while num > 0 {\n                digits_sum += num\
    \ % 10;\n                num /= 10;\n            }\n            (digits_sum, i)\n\
    \        })\n        .collect::<Vec<(isize, usize)>>()\n        .sort_by(|a, b|\
    \ a.0.cmp(&b.0))\n        .iter()\n        .map(|x| nums[x.1])\n        .collect()",
  "    let mut nums = nums;\n    let mut new_nums = Vec::new();\n    let mut sum =\
    \ 0;\n    for i in 0..nums.len() {\n        for digit in nums[i].to_string().chars()\
    \ {\n            sum += digit.to_digit(10).unwrap() as isize;\n        }\n   \
    \     new_nums.push((sum, nums[i]));\n        sum = 0;\n    }\n    new_nums.sort();\n\
    \    let mut final_nums = Vec::new();\n    for i in 0..new_nums.len() {\n    \
    \    final_nums.push(new_nums[i].1);\n    }\n    final_nums", "    if nums.len()\
    \ <= 1 {\n        return nums;\n    }\n    let mut nums = nums;\n    let length\
    \ = nums.len();\n    for i in 0..length {\n        for j in 0..length - i - 1\
    \ {\n            if digits_sum(&nums[j]) > digits_sum(&nums[j + 1]) {\n      \
    \          nums.swap(j, j + 1);\n            }\n        }\n    }\n    nums", " \
    \   // let mut nums_map = HashMap::new();\n    // for (k, v) in nums.iter().enumerate()\
    \ {\n    //     let sum_digits = v.to_string().chars().map(|x| x.to_digit(10).unwrap()).sum::<u32>();\n\
    \    //     nums_map.insert(k, sum_digits);\n    // }\n    // let mut nums_vec:\
    \ Vec<_> = nums_map.iter().collect();\n    // nums_vec.sort_by(|a, b| a.1.cmp(b.1));\n\
    \    // let mut res = vec![];\n    // for x in nums_vec {\n    //     res.push(nums[*x.0]);\n\
    \    // }\n    // res\n    nums.into_iter().enumerate().map(|(k, v)| (k, v.to_string().chars().map(|x|\
    \ x.to_digit(10).unwrap()).sum::<u32>())).collect::<Vec<_>>().sort_by(|a, b| a.1.cmp(&b.1)).into_iter().map(|x|\
    \ nums[x.0]).collect()", '    nums.into_iter().enumerate().map(|(idx, n)| (idx,
    n, n.to_string().chars().map(|c| c.to_digit(10).unwrap() as isize).sum())).sorted_by(|(_,
    _, a), (_, _, b)| a.cmp(b)).map(|(_, n, _)| n).collect()', "    let mut result\
    \ = nums.clone();\n    result.sort_by(|a, b| {\n        let a_sum = sum_digits(*a);\n\
    \        let b_sum = sum_digits(*b);\n        a_sum.cmp(&b_sum)\n    });\n   \
    \ result", "    let mut v = Vec::new();\n    for i in nums {\n        let x =\
    \ i.to_string();\n        let y = x.chars().filter_map(|c| c.to_digit(10)).sum::<u32>();\n\
    \        v.push((i, y));\n    }\n    v.sort_by(|a, b| a.1.cmp(&b.1));\n    let\
    \ mut k = Vec::new();\n    for i in v {\n        k.push(i.0);\n    }\n    k",
  "    let mut sum_digits: Vec<(isize, isize)> = nums.iter().map(|n| (*n, sum_digits(*n))).collect();\n\
    \    sum_digits.sort_by(|a, b| a.1.cmp(&b.1));\n    sum_digits.iter().map(|x|\
    \ x.0).collect()", "    // let sum = |n: &isize| n.to_string().chars().map(|c|\
    \ c.to_digit(10).unwrap()).sum::<u32>();\n    let sum = |n: &isize| n.to_string().chars().map(|c|\
    \ c.to_digit(10).unwrap()).sum::<u32>();\n    let mut nums = nums;\n    nums.sort_by_key(|n|\
    \ (sum(n), n));\n    nums", '    unimplemented!()', "    let mut nums = nums;\n\
    \    nums.sort_by(|a, b| {\n        let (sa, sb) = (sum_digits(*a), sum_digits(*b));\n\
    \        if sa == sb {\n            a.cmp(b)\n        } else {\n            sa.cmp(&sb)\n\
    \        }\n    });\n    nums", "    let sum_digits = |x: &isize| {\n        let\
    \ mut n = *x;\n        let mut sum = 0;\n        while n > 0 {\n            sum\
    \ += n % 10;\n            n /= 10;\n        }\n        sum\n    };\n    nums.iter()\n\
    \        .enumerate()\n        .map(|(idx, val)| (idx, val, sum_digits(val)))\n\
    \        .sorted_by(|(_, _, score_a), (_, _, score_b)| score_a.cmp(score_b))\n\
    \        .into_iter()\n        .map(|(_, val, _)| *val)\n        .collect()",
  "    nums.iter()\n        .enumerate()\n        .map(|(i, &v)| (v, sum_digits(v),\
    \ i))\n        .sorted_by(|a, b| (a.1, a.2).cmp(&(b.1, b.2)))\n        .into_iter()\n\
    \        .map(|(v, _, _)| v)\n        .collect()", "    nums.iter()\n        .enumerate()\n\
    \        .map(|(i, &x)| (i, x, sum_digits(x)))\n        .sorted_by(|(_, _, a),\
    \ (_, _, b)| b.cmp(a))\n        .map(|(_, x, _)| x)\n        .collect()", "  \
    \  let mut result = Vec::new();\n    let mut buf: HashMap<isize, isize> = HashMap::new();\n\
    \    for (index, value) in nums.iter().enumerate() {\n        let mut sum = 0;\n\
    \        let mut num = *value;\n        while num > 0 {\n            sum += num\
    \ % 10;\n            num /= 10;\n        }\n        buf.insert(sum, index as isize);\n\
    \    }\n    let mut keys: Vec<isize> = buf.keys().map(|x| *x).collect();\n   \
    \ keys.sort();\n    for key in keys {\n        result.push(nums[buf[&key] as usize]);\n\
    \    }\n    result", '    nums.into_iter().enumerate().map(|(i, v)| (v, sum_digits(v
    as isize), i)).collect::<Vec<(isize, isize, usize)>>().sort_by(|a, b| a.1.cmp(&b.1).then(a.2.cmp(&b.2))).into_iter().map(|(v,
    _, _)| v).collect()', "    nums.iter()\n        .enumerate()\n        .map(|(i,\
    \ v)| (v, i))\n        .collect::<Vec<_>>()\n        .sort_by(|(v1, _), (v2, _)|\
    \ v1.cmp(v2))\n        .iter()\n        .map(|(v, _)| v)\n        .cloned()\n\
    \        .collect()", "    nums.iter()\n        .enumerate()\n        .map(|(i,\
    \ val)| (val, sum_digits(*val), i))\n        .sorted_by(|a, b| a.1.cmp(&b.1).then(a.2.cmp(&b.2)))\n\
    \        .map(|(val, _, _)| *val)\n        .collect()", "    let mut nums_with_points:\
    \ Vec<(isize, usize)> = Vec::new();\n    for (idx, x) in nums.iter().enumerate()\
    \ {\n        let digits: Vec<char> = x.to_string().chars().collect();\n      \
    \  let mut points = 0;\n        for digit in digits {\n            let digit_value\
    \ = digit.to_digit(10).unwrap();\n            points += digit_value as usize;\n\
    \        }\n        nums_with_points.push((*x, points));\n    }\n    nums_with_points.sort_by(|a,\
    \ b| a.1.cmp(&b.1));\n    let mut result: Vec<isize> = Vec::new();\n    for (x,\
    \ _) in nums_with_points {\n        result.push(x);\n    }\n    result", "   \
    \ let mut pairs: Vec<(isize, isize)> = nums.iter().map(|&n| (n, num_sum(n))).collect();\n\
    \    pairs.sort_by(|&(a, _), &(b, _)| a.cmp(&b));\n    pairs.into_iter().map(|(a,\
    \ _)| a).collect()", "    let mut v: Vec<(isize, usize)> = nums.iter().enumerate().map(|(i,\
    \ n)| (n, i)).collect();\n    v.sort_by(|(a, _), (b, _)| {\n        let a: String\
    \ = a.to_string();\n        let b: String = b.to_string();\n        let (a, b)\
    \ = (a.chars().map(|c| c.to_digit(10).unwrap()).sum::<u32>(),\n              \
    \        b.chars().map(|c| c.to_digit(10).unwrap()).sum::<u32>());\n        a.cmp(&b)\n\
    \    });\n    v.iter().map(|(n, _)| *n).collect()", "    let mut nums = nums;\n\
    \    nums.sort_by(|a, b| a.to_string().chars().sum::<u32>().cmp(&b.to_string().chars().sum::<u32>()));\n\
    \    nums", "    let mut digit_sum_vec: Vec<(isize, usize)> = nums\n        .iter()\n\
    \        .enumerate()\n        .map(|(i, x)| (x.to_string().chars().map(|c| c.to_digit(10).unwrap()\
    \ as isize).sum(), i))\n        .collect();\n    digit_sum_vec.sort_by(|a, b|\
    \ a.0.cmp(&b.0));\n    digit_sum_vec.iter().map(|a| nums[a.1]).collect()", " \
    \   let mut nums = nums;\n    nums.sort_by(|a, b| {\n        let a_val = order_by_points_value(*a);\n\
    \        let b_val = order_by_points_value(*b);\n        a_val.cmp(&b_val)\n \
    \   });\n    nums", "    nums.iter()\n        .enumerate()\n        .map(|(i,\
    \ n)| (sum_of_digits(*n), i, *n))\n        .sorted_by(|a, b| a.0.cmp(&b.0).then(a.1.cmp(&b.1)))\n\
    \        .into_iter()\n        .map(|(_, _, n)| n)\n        .collect()", "   \
    \ let mut m = nums.iter().enumerate().map(|(i, &n)| (i, n, digit_sum(n))).collect::<Vec<_>>();\n\
    \    m.sort_by(|a, b| a.2.cmp(&b.2).then(a.0.cmp(&b.0)));\n    m.iter().map(|&(_,\
    \ n, _)| n).collect()", '    unimplemented!()', "    let mut nums = nums;\n  \
    \  nums.sort_by(|a, b| a.abs().to_string().chars().sum::<u32>().cmp(&b.abs().to_string().chars().sum::<u32>()));\n\
    \    nums", "    nums.iter()\n        .enumerate()\n        .map(|(i, &x)| (x,\
    \ i))\n        .map(|(x, i)| (x, sum_digits(x), i))\n        .sorted_by(|a, b|\
    \ {\n            let (a, a_sum, a_i) = a;\n            let (b, b_sum, b_i) = b;\n\
    \            a_sum.cmp(&b_sum).then(a_i.cmp(&b_i))\n        })\n        .map(|(x,\
    \ _, _)| x)\n        .collect()", "    let mut points = nums.iter().map(|&x| (x,\
    \ digits_sum(x))).collect::<Vec<_>>();\n    points.sort_by(|a, b| match a.1.cmp(&b.1)\
    \ {\n        std::cmp::Ordering::Equal => a.0.cmp(&b.0),\n        a => a,\n  \
    \  });\n    points.iter().map(|&x| x.0).collect()", "    let mut new_nums = vec![];\n\
    \    for i in nums {\n        new_nums.push((split_sum(i), i));\n    }\n    new_nums.sort();\n\
    \    let mut result = vec![];\n    for (_, i) in new_nums {\n        result.push(i);\n\
    \    }\n    result", "    nums.iter()\n        .enumerate()\n        .map(|(idx,\
    \ n)| (idx, n, n.to_string().as_bytes().iter().fold(0, |acc, x| acc + (x - '0'\
    \ as u8) as isize)))\n        .sorted_by(|(_, _, p1), (_, _, p2)| p1.cmp(p2))\n\
    \        .map(|(_, n, _)| *n)\n        .collect()", "    fn sum_of_digits(num:\
    \ isize) -> isize {\n        let mut sum = 0;\n        let mut m = num;\n    \
    \    while m > 0 {\n            sum += m % 10;\n            m /= 10;\n       \
    \ }\n        sum\n    }\n\n    fn sum_of_digits_desc(lhs: &isize, rhs: &isize)\
    \ -> Ordering {\n        let (lhs_sum, rhs_sum) = (sum_of_digits(*lhs), sum_of_digits(*rhs));\n\
    \        lhs_sum.cmp(&rhs_sum).reverse()\n    }\n\n    nums.into_iter().sorted_by(sum_of_digits_desc).collect()",
  "    let mut nums: Vec<isize> = nums;\n    nums.sort_by(|a, b| {\n        let a_sum\
    \ = digit_sum(*a);\n        let b_sum = digit_sum(*b);\n        if a_sum == b_sum\
    \ {\n            a.cmp(b)\n        } else {\n            a_sum.cmp(&b_sum)\n \
    \       }\n    });\n    nums", "    // Result: {0, 10, 1, 7, 8, 9, 2, 6, 5, 3,\
    \ 4}\n    // Input: {10, 7, 2, 8, 3, 9, 0, 6, 4, 5, 1}\n    let sums: Vec<isize>\
    \ = nums.iter().map(|x| x.to_string().chars().map(|x| x.to_digit(10).unwrap()\
    \ as isize).sum()).collect();\n    //    let mut nums: Vec<isize> = nums.clone();\n\
    \    nums.sort_by(|a, b| sums[*a as usize].cmp(&sums[*b as usize]));\n    nums",
  "    let mut s = Vec::new();\n    let mut i = 0;\n    for n in nums {\n        s.push((n,\
    \ i, digits_sum(n)));\n        i += 1;\n    }\n    s.sort_by(|a, b| {\n      \
    \  match a.2.cmp(&b.2) {\n            Ordering::Equal => a.1.cmp(&b.1),\n    \
    \        r => r,\n        }\n    });\n    s.iter().map(|t| t.0).collect()", " \
    \   nums.iter()\n        .enumerate()\n        .map(|(i, x)| (x, x.abs() as isize\
    \ % 10 + x.abs() / 10 as isize % 10))\n        .sorted_by(|(_, a), (_, b)| a.cmp(b))\n\
    \        .map(|(x, _)| *x)\n        .collect()", '    nums.into_iter().enumerate().sorted_by(|(_,
    a), (_, b)| a.cmp(b)).map(|(_, x)| x).collect()', "    nums.iter()\n        .enumerate()\n\
    \        .map(|(i, n)| (n, (n % 10 + n / 10) as usize, i))\n        .sorted_by(|a,\
    \ b| (a.1, a.2).cmp(&(b.1, b.2)))\n        .map(|(n, _, _)| *n)\n        .collect()",
  '    nums.into_iter().enumerate().map(|(i, n)| (i, n, n.to_string().chars().map(|c|
    c.to_digit(10).unwrap() as usize).sum::<usize>())).collect::<Vec<_>>().sort_by(|a,
    b| if a.2 == b.2 { a.0.cmp(&b.0) } else { a.2.cmp(&b.2) }).into_iter().map(|(_,
    n, _)| n).collect::<Vec<_>>()', "    // let mut new_vec = Vec::new();\n    //\
    \ for num in nums {\n    //     new_vec.push(num)\n    // }\n    // new_vec.sort_by(|a,\
    \ b| a.to_string().chars().sum::<i32>().cmp(&b.to_string().chars().sum::<i32>()));\n\
    \    // new_vec\n    nums.sort_by(|a, b| {\n        a.to_string().chars().sum::<i32>().cmp(&b.to_string().chars().sum::<i32>())\n\
    \    });\n    nums", "    use std::collections::HashMap;\n    let mut points:\
    \ HashMap<isize, isize> = HashMap::new();\n    let mut result: Vec<isize> = vec![];\n\
    \    for num in nums {\n        let mut sum = 0;\n        let mut n = num;\n \
    \       while n > 0 {\n            sum += n % 10;\n            n /= 10;\n    \
    \    }\n        if points.contains_key(&sum) {\n            points.insert(sum,\
    \ -1);\n        } else {\n            points.insert(sum, num);\n        }\n  \
    \  }\n    for i in 0..nums.len() {\n        if let Some(num) = points.get(&(i\
    \ as isize)) {\n            if *num != -1 {\n                result.push(*num);\n\
    \            }\n        }\n    }\n    result", "    // TODO\n    let mut res =\
    \ nums.clone();\n    res.sort_by(|x, y| {\n        let x_sum = sum_digits(*x);\n\
    \        let y_sum = sum_digits(*y);\n        if x_sum < y_sum {\n           \
    \ Ordering::Less\n        } else if x_sum > y_sum {\n            Ordering::Greater\n\
    \        } else {\n            Ordering::Equal\n        }\n    });\n    res",
  "    let mut ret = Vec::with_capacity(nums.len());\n    let mut sorted = nums.clone();\n\
    \    sorted.sort_by(|a, b| sum_digits(*a).cmp(&sum_digits(*b)));\n    for i in\
    \ sorted {\n        ret.push(nums.iter().position(|x| x == &i).unwrap() as isize)\n\
    \    }\n    ret", "    nums.iter()\n        .enumerate()\n        .map(|(index,\
    \ &value)| (index, digit_sum(value), value))\n        .sorted_by(|(index1, points1,\
    \ _), (index2, points2, _)| {\n            match points1.cmp(points2) {\n    \
    \            std::cmp::Ordering::Equal => index1.cmp(index2),\n              \
    \  other => other,\n            }\n        })\n        .map(|(_, _, value)| value)\n\
    \        .collect()", "    nums.into_iter().enumerate().map(|(i, n)| (n, i)).collect::<Vec<_>>().sort_by(|x,\
    \ y| {\n        let (nx, ix) = x;\n        let (ny, iy) = y;\n        digits_sum(nx).cmp(&digits_sum(ny)).then(ix.cmp(&iy))\n\
    \    }).into_iter().map(|(x, _)| x).collect()", "    let mut nums = nums;\n  \
    \  let mut sums = nums.iter().map(|num| {\n        let mut num = *num;\n     \
    \   let mut sum = 0;\n        while num > 0 {\n            sum += num % 10;\n\
    \            num /= 10;\n        }\n        sum\n    }).collect::<Vec<isize>>();\n\
    \    nums.sort_by(|x, y| sums[x.abs() as usize].cmp(&sums[y.abs() as usize]));\n\
    \    nums", "    let mut new_nums = nums.clone();\n    new_nums.sort_by(|a, b|\
    \ {\n        let a_sum: isize = a.to_string().chars().map(|c| c.to_digit(10).unwrap()\
    \ as isize).sum();\n        let b_sum: isize = b.to_string().chars().map(|c| c.to_digit(10).unwrap()\
    \ as isize).sum();\n        if a_sum == b_sum {\n            return nums.iter().position(|&x|\
    \ x == *a).unwrap().cmp(&nums.iter().position(|&x| x == *b).unwrap());\n     \
    \   }\n        a_sum.cmp(&b_sum)\n    });\n    new_nums", "    let mut v: Vec<(isize,\
    \ usize)> = Vec::new();\n    for (i, n) in nums.iter().enumerate() {\n       \
    \ let mut num = *n;\n        let mut sum = 0;\n        while num > 0 {\n     \
    \       sum += num % 10;\n            num /= 10;\n        }\n        v.push((sum,\
    \ i));\n    }\n    v.sort();\n    let mut result: Vec<isize> = Vec::new();\n \
    \   for &(sum, i) in v.iter() {\n        result.push(nums[i]);\n    }\n    result",
  "    let mut xs = nums.clone();\n    xs.sort_by(|a, b| {\n        let a_sum = get_sum_of_digits(*a);\n\
    \        let b_sum = get_sum_of_digits(*b);\n        if a_sum == b_sum {\n   \
    \         a.cmp(b)\n        } else {\n            a_sum.cmp(&b_sum)\n        }\n\
    \    });\n    xs", "    // let mut result: Vec<isize> = Vec::new();\n    // for\
    \ num in nums {\n    //     let mut sum: isize = 0;\n    //     let mut rem: isize\
    \ = num;\n    //     while rem > 0 {\n    //         sum += rem % 10;\n    //\
    \         rem /= 10;\n    //     }\n    //     result.push(sum);\n    // }\n \
    \   // result.sort();\n    // result\n    // nums.into_iter().zip(nums.iter().map(|&x|\
    \ x.to_string().chars().map(|x| x.to_digit(10).unwrap() as isize).sum()).collect()).sorted_by(|a,\
    \ b| b.1.cmp(&a.1)).map(|x| x.0).collect()\n    nums.into_iter().zip(nums.iter().map(|&x|\
    \ x.to_string().chars().map(|x| x.to_digit(10).unwrap() as isize).sum()).collect()).sorted_by(|a,\
    \ b| b.1.cmp(&a.1)).map(|x| x.0).collect()", "    let mut res = Vec::new();\n\
    \    for (i, &x) in nums.iter().enumerate() {\n        let mut sum = 0;\n    \
    \    let mut it = x;\n        while it > 0 {\n            sum += it % 10;\n  \
    \          it /= 10;\n        }\n        res.push((i, sum, x));\n    }\n    res.sort_by(|a,\
    \ b| a.1.cmp(&b.1));\n    res.iter().map(|&(_, _, x)| x).collect()", "    nums.into_iter().enumerate().collect::<Vec<_>>().sort_by(|a,\
    \ b| {\n        let (index_a, n_a) = a;\n        let (index_b, n_b) = b;\n   \
    \     let mut sum_a = n_a;\n        let mut sum_b = n_b;\n        let mut x =\
    \ 0;\n        let mut y = 0;\n        loop {\n            x += sum_a % 10;\n \
    \           sum_a /= 10;\n            if sum_a == 0 {\n                break;\n\
    \            }\n        }\n        loop {\n            y += sum_b % 10;\n    \
    \        sum_b /= 10;\n            if sum_b == 0 {\n                break;\n \
    \           }\n        }\n        let val = x.cmp(&y);\n        if val == Ordering::Equal\
    \ {\n            index_a.cmp(&index_b)\n        } else {\n            val\n  \
    \      }\n    }).into_iter().map(|(_, n)| n).collect()", "    let mut res = nums.clone();\n\
    \    res.sort_by(|a, b| get_sum_of_digits(*a).cmp(&get_sum_of_digits(*b)));\n\
    \    res", "    let mut nums_clone = nums.clone();\n    nums_clone.sort_by(|a,\
    \ b| {\n        let (a_sum, b_sum) = (*a, *b);\n        let (a_sum, b_sum) = (sum_of_digits(a_sum),\
    \ sum_of_digits(b_sum));\n        a_sum.cmp(&b_sum)\n    });\n    nums_clone",
  "    let mut ret: Vec<isize> = nums.clone();\n    let mut sum = vec![];\n    for\
    \ i in nums {\n        let mut a = i;\n        let mut s = 0;\n        while a\
    \ > 0 {\n            s += a % 10;\n            a /= 10;\n        }\n        sum.push(s);\n\
    \    }\n    let mut i = 0;\n    while i < sum.len() {\n        let mut j = i +\
    \ 1;\n        while j < sum.len() {\n            if sum[i] > sum[j] {\n      \
    \          sum.swap(i, j);\n                ret.swap(i, j);\n            }\n \
    \           j += 1;\n        }\n        i += 1;\n    }\n    ret", "    nums.iter()\n\
    \        .enumerate()\n        .map(|(i, &x)| {\n            let mut n = x;\n\
    \            let mut sum = 0;\n            while n > 0 {\n                sum\
    \ += n % 10;\n                n /= 10;\n            }\n            (sum, i, x)\n\
    \        })\n        .sorted_by(|&(s1, _, _), &(s2, _, _)| s1.cmp(&s2))\n    \
    \    .map(|(_, _, x)| x)\n        .collect()", "    nums.iter()\n        .enumerate()\n\
    \        .map(|(index, item)| (sum_digits(*item), index, *item))\n        .sorted_by(|a,\
    \ b| a.0.cmp(&b.0).then(a.1.cmp(&b.1)))\n        .map(|tuple| tuple.2)\n     \
    \   .collect()", "    let sum = |x: &isize| -> isize { x.to_string().chars().map(|x|\
    \ x.to_digit(10).unwrap() as isize).sum() };\n    let mut nums = nums;\n    nums.sort_by_key(|x|\
    \ sum(x));\n    nums", "    let mut result = vec![];\n    for n in nums {\n  \
    \      let s = n.to_string();\n        let mut sum = 0;\n        for c in s.chars()\
    \ {\n            let d = c.to_digit(10).unwrap();\n            sum += d as isize;\n\
    \        }\n        result.push((sum, n));\n    }\n    result.sort();\n    result.iter().map(|(_,\
    \ n)| *n).collect()", "    let mut pairs: Vec<(isize, usize)> = nums.iter().map(|n|\
    \ (*n, n.to_string().chars().map(|c| c.to_digit(10).unwrap() as isize).sum())).collect();\n\
    \    pairs.sort_by(|a, b| a.1.cmp(&b.1));\n    pairs.iter().map(|(n, _)| *n).collect()",
  "    nums.into_iter().enumerate().collect::<Vec<_>>().sort_by(|a, b| {\n       \
    \ let (_, a) = a;\n        let (_, b) = b;\n        if sum_digits(*a) == sum_digits(*b)\
    \ {\n            Ord::cmp(&a, &b)\n        } else {\n            Ord::cmp(&sum_digits(*a),\
    \ &sum_digits(*b))\n        }\n    }).into_iter().map(|(_, a)| a).collect()",
  "    let mut map = std::collections::HashMap::new();\n    for i in 0..nums.len()\
    \ {\n        let num = nums[i];\n        let mut sum = 0;\n        let mut tmp\
    \ = num;\n        while tmp > 0 {\n            sum += tmp % 10;\n            tmp\
    \ /= 10;\n        }\n        let entry = map.entry(sum).or_insert(vec![]);\n \
    \       entry.push(num);\n    }\n    let mut v: Vec<&Vec<isize>> = map.values().collect();\n\
    \    v.sort_by(|x, y| x[0].cmp(&y[0]));\n    let mut res = vec![];\n    for v\
    \ in v {\n        for i in v {\n            res.push(*i);\n        }\n    }\n\
    \    res", "    let mut sum_digits = Vec::new();\n    let mut sorted_nums = Vec::new();\n\
    \    for i in 0..nums.len() {\n        let digits = split_digits(nums[i]);\n \
    \       let sum = digits.iter().fold(0, |sum, &x| sum + x);\n        sum_digits.push((i,\
    \ sum));\n    }\n    sum_digits.sort_by(|a, b| a.1.cmp(&b.1));\n    for j in 0..sum_digits.len()\
    \ {\n        sorted_nums.push(nums[sum_digits[j].0]);\n    }\n    sorted_nums",
  "    let mut nums = nums;\n    nums.sort_by(|a, b| {\n        num_digits(a).cmp(&num_digits(b))\n\
    \    });\n    nums", "    let mut sums: Vec<_> = nums.iter().map(|x| sum_of_digits(*x)).collect();\n\
    \    let mut res: Vec<isize> = Vec::new();\n    while sums.len() > 0 {\n     \
    \   let min_index = sums.iter().enumerate().min_by_key(|x| x.1).unwrap().0;\n\
    \        res.push(nums[min_index]);\n        sums.remove(min_index);\n       \
    \ nums.remove(min_index);\n    }\n    res", "    let mut map: HashMap<usize, Vec<isize>>\
    \ = HashMap::new();\n    for x in nums.iter() {\n        map.entry(sum_of_digits(*x)).or_insert(vec![]).push(*x);\n\
    \    }\n    let mut sorted_k: Vec<_> = map.keys().cloned().collect();\n    sorted_k.sort();\n\
    \    let mut res: Vec<isize> = vec![];\n    for k in sorted_k {\n        let v\
    \ = map.get(&k).unwrap();\n        for x in v.iter() {\n            res.push(*x);\n\
    \        }\n    }\n    res", '    unimplemented!();', '    nums.into_iter().enumerate().map(|(i,
    n)| (i, n, sum_digits(n))).collect::<Vec<_>>().sort_by(|(_, _, x), (_, _, y)|
    y.cmp(x)).iter().map(|(_, n, _)| *n).collect()', "    nums.iter()\n        .enumerate()\n\
    \        .sorted_by(|(_, a), (_, b)| {\n            let mut a_points = 0;\n  \
    \          let mut b_points = 0;\n            for digit in format!(\"{}\", a).chars()\
    \ {\n                a_points += digit.to_digit(10).unwrap();\n            }\n\
    \            for digit in format!(\"{}\", b).chars() {\n                b_points\
    \ += digit.to_digit(10).unwrap();\n            }\n            if a_points == b_points\
    \ {\n                Ordering::Equal\n            } else if a_points > b_points\
    \ {\n                Ordering::Greater\n            } else {\n               \
    \ Ordering::Less\n            }\n        })\n        .map(|(_, &val)| val)\n \
    \       .collect()", "    let mut sum_digits = vec![];\n    for num in nums.iter()\
    \ {\n        let mut num_copy = *num;\n        let mut sum = 0;\n        while\
    \ num_copy > 0 {\n            sum += num_copy % 10;\n            num_copy /= 10;\n\
    \        }\n        sum_digits.push(sum);\n    }\n    let mut result = vec![];\n\
    \    let mut index = 0;\n    while sum_digits.iter().any(|&s| s > 0) {\n     \
    \   let mut min = 9;\n        let mut min_index = 0;\n        for i in 0..sum_digits.len()\
    \ {\n            if sum_digits[i] > 0 && sum_digits[i] < min {\n             \
    \   min = sum_digits[i];\n                min_index = i;\n            }\n    \
    \    }\n        result.push(nums[min_index]);\n        sum_digits[min_index] =\
    \ -1;\n        index += 1;\n    }\n    result"]
stop_tokens:
- "\n}"
