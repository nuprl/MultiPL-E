language: rs
name: HumanEval_93_encode
results:
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut res = String::new();\n    for c in message.chars()\
    \ {\n        if ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') {\n         \
    \   if c.is_lowercase() {\n                res.push(c.to_uppercase().next().unwrap());\n\
    \            } else {\n                res.push(c.to_lowercase().next().unwrap());\n\
    \            }\n        } else {\n            res.push(c);\n        }\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmp4zb847a3.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821793
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = message.chars().map(|c| {\n        match c\
    \ {\n            'a' => 'c',\n            'e' => 'g',\n            'i' => 'k',\n\
    \            'o' => 'q',\n            'u' => 'y',\n            c if c.is_ascii_uppercase()\
    \ => c.to_ascii_lowercase(),\n            c if c.is_ascii_lowercase() => c.to_ascii_uppercase(),\n\
    \            _ => c,\n        }\n    }).collect::<String>();\n    result\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmp_ety2wdx.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821793
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded_message = String::new();\n    for character\
    \ in message.chars() {\n        if is_vowel(character) {\n            encoded_message.push(get_next_vowel(character));\n\
    \        } else if is_uppercase(character) {\n            encoded_message.push(character.to_lowercase().next().unwrap());\n\
    \        } else {\n            encoded_message.push(character.to_uppercase().next().unwrap());\n\
    \        }\n    }\n    encoded_message\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpy5ghjht3.rs:10:12\n\
    \   |\n10 |         if is_vowel(character) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `get_next_vowel` in this\
    \ scope\n  --> /tmp/tmpy5ghjht3.rs:11:34\n   |\n11 |             encoded_message.push(get_next_vowel(character));\n\
    \   |                                  ^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `is_uppercase` in this scope\n  --> /tmp/tmpy5ghjht3.rs:12:19\n\
    \   |\n12 |         } else if is_uppercase(character) {\n   |                \
    \   ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821792
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let encoded_message = message.chars().map(|c| {\n        let\
    \ new_c = match c {\n            'a' => 'c',\n            'e' => 'g',\n      \
    \      'i' => 'k',\n            'o' => 'q',\n            'u' => 'w',\n       \
    \     'A' => 'C',\n            'E' => 'G',\n            'I' => 'K',\n        \
    \    'O' => 'Q',\n            'U' => 'W',\n            _ => c,\n        };\n \
    \       new_c\n    }).collect::<String>();\n    encoded_message\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmp3atoxli4.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821793
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut code = String::new();\n    let vowels = [\n       \
    \ 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'\n    ];\n    for c in message.chars()\
    \ {\n        if c == 'z' {\n            code.push('a');\n        } else if c ==\
    \ 'Z' {\n            code.push('A');\n        } else if vowels.contains(&c) {\n\
    \            code.push((c as u8 + 2) as char);\n        } else if c.is_uppercase()\
    \ {\n            code.push(c.to_lowercase().next().unwrap());\n        } else\
    \ if c.is_lowercase() {\n            code.push(c.to_uppercase().next().unwrap());\n\
    \        } else {\n            code.push(c);\n        }\n    }\n    code\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"tGst\"`,\n right: `\"tgst\"`', /tmp/tmpfx5961tl.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821793
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let chars: Vec<char> = message.chars().collect();\n    let\
    \ mut output = String::new();\n    for c in chars {\n        let mut temp = c;\n\
    \        if c.is_alphabetic() {\n            if c.is_lowercase() {\n         \
    \       temp = c.to_uppercase().nth(0).unwrap();\n            } else {\n     \
    \           temp = c.to_lowercase().nth(0).unwrap();\n            }\n        \
    \    if temp == 'A' {\n                temp = 'C';\n            } else if temp\
    \ == 'B' {\n                temp = 'D';\n            } else if temp == 'C' {\n\
    \                temp = 'E';\n            } else if temp == 'D' {\n          \
    \      temp = 'F';\n            } else if temp == 'E' {\n                temp\
    \ = 'G';\n            } else if temp == 'F' {\n                temp = 'H';\n \
    \           } else if temp == 'G' {\n                temp = 'I';\n           \
    \ } else if temp == 'H' {\n                temp = 'J';\n            } else if\
    \ temp == 'I' {\n                temp = 'K';\n            } else if temp == 'J'\
    \ {\n                temp = 'L';\n            } else if temp == 'K' {\n      \
    \          temp = 'M';\n            } else if temp == 'L' {\n                temp\
    \ = 'N';\n            } else if temp == 'M' {\n                temp = 'O';\n \
    \           } else if temp == 'N' {\n                temp = 'P';\n           \
    \ } else if temp == 'O' {\n                temp = 'Q';\n            } else if\
    \ temp == 'P' {\n                temp = 'R';\n            } else if temp == 'Q'\
    \ {\n                temp = 'S';\n            } else if temp == 'R' {\n      \
    \          temp = 'T';\n            } else if temp == 'S' {\n                temp\
    \ = 'U';\n            } else if temp == 'T' {\n                temp = 'V';\n \
    \           } else if temp == 'U' {\n                temp = 'W';\n           \
    \ } else if temp == 'V' {\n                temp = 'X';\n            } else if\
    \ temp ==\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp0h5btl78.rs:72:3\n\
    \   |\n7  | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n10 |     for c in chars {\n   | \
    \                   - unclosed delimiter\n11 |         let mut temp = c;\n12 |\
    \         if c.is_alphabetic() {\n   |                              - this delimiter\
    \ might not be properly closed...\n...\n63 | }\n   | - ...as it matches this but\
    \ it has different indentation\n...\n72 | }\n   |   ^\n\nerror: expected expression,\
    \ found `}`\n  --> /tmp/tmp0h5btl78.rs:63:1\n   |\n63 | }\n   | ^ expected expression\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp0h5btl78.rs:10:5\n   |\n7  | \
    \  fn encode(message: String) -> String {\n   |                              \
    \   ------ expected `String` because of return type\n...\n10 | /     for c in\
    \ chars {\n11 | |         let mut temp = c;\n12 | |         if c.is_alphabetic()\
    \ {\n13 | |             if c.is_lowercase() {\n...  |\n71 | |     assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    72 | | }\n   | |__^ expected struct `String`, found `()`\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659821793
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let n = message.len();\n    let mut encoded = String::with_capacity(n);\n\
    \    for ch in message.chars() {\n        if ch.is_lowercase() {\n           \
    \ encoded.push(ch.to_uppercase().next().unwrap());\n        } else if ch.is_uppercase()\
    \ {\n            encoded.push(ch.to_lowercase().next().unwrap());\n        } else\
    \ {\n            encoded.push(ch);\n        }\n    }\n    let mut vowels = [false;\
    \ 5];\n    vowels[0] = true; //a\n    vowels[2] = true; //e\n    vowels[4] = true;\
    \ //i\n    vowels[1] = true; //o\n    vowels[3] = true; //u\n    for (i, ch) in\
    \ encoded.chars().enumerate() {\n        if ch == 'a' {\n            encoded.replace_range(i..i+1,\
    \ \"c\");\n        } else if ch == 'e' {\n            encoded.replace_range(i..i+1,\
    \ \"g\");\n        } else if ch == 'i' {\n            encoded.replace_range(i..i+1,\
    \ \"k\");\n        } else if ch == 'o' {\n            encoded.replace_range(i..i+1,\
    \ \"q\");\n        } else if ch == 'u' {\n            encoded.replace_range(i..i+1,\
    \ \"s\");\n        }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `encoded` as mutable because it is also borrowed\
    \ as immutable\n  --> /tmp/tmpsvv11qpc.rs:27:13\n   |\n25 |     for (i, ch) in\
    \ encoded.chars().enumerate() {\n   |                    ---------------------------\n\
    \   |                    |\n   |                    immutable borrow occurs here\n\
    \   |                    immutable borrow later used here\n26 |         if ch\
    \ == 'a' {\n27 |             encoded.replace_range(i..i+1, \"c\");\n   |     \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n\nerror[E0502]:\
    \ cannot borrow `encoded` as mutable because it is also borrowed as immutable\n\
    \  --> /tmp/tmpsvv11qpc.rs:29:13\n   |\n25 |     for (i, ch) in encoded.chars().enumerate()\
    \ {\n   |                    ---------------------------\n   |               \
    \     |\n   |                    immutable borrow occurs here\n   |          \
    \          immutable borrow later used here\n...\n29 |             encoded.replace_range(i..i+1,\
    \ \"g\");\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ mutable borrow\
    \ occurs here\n\nerror[E0502]: cannot borrow `encoded` as mutable because it is\
    \ also borrowed as immutable\n  --> /tmp/tmpsvv11qpc.rs:31:13\n   |\n25 |    \
    \ for (i, ch) in encoded.chars().enumerate() {\n   |                    ---------------------------\n\
    \   |                    |\n   |                    immutable borrow occurs here\n\
    \   |                    immutable borrow later used here\n...\n31 |         \
    \    encoded.replace_range(i..i+1, \"k\");\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ mutable borrow occurs here\n\nerror[E0502]: cannot borrow `encoded` as mutable\
    \ because it is also borrowed as immutable\n  --> /tmp/tmpsvv11qpc.rs:33:13\n\
    \   |\n25 |     for (i, ch) in encoded.chars().enumerate() {\n   |           \
    \         ---------------------------\n   |                    |\n   |       \
    \             immutable borrow occurs here\n   |                    immutable\
    \ borrow later used here\n...\n33 |             encoded.replace_range(i..i+1,\
    \ \"q\");\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ mutable borrow\
    \ occurs here\n\n"
  stdout: ''
  timestamp: 1659821792
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded_message = String::new();\n    let vowels =\
    \ String::from(\"aeiou\");\n    let mut alphabet = String::from(\"abcdefghijklmnopqrstuvwxyz\"\
    );\n    alphabet.push_str(\"abcdefghijklmnopqrstuvwxyz\");\n    for c in message.chars()\
    \ {\n        let idx = vowels.find(c);\n        if idx.is_some() {\n         \
    \   let idx = idx.unwrap();\n            encoded_message.push(alphabet.chars().nth(idx\
    \ + 2).unwrap());\n        } else {\n            encoded_message.push(c);\n  \
    \      }\n    }\n    encoded_message\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmp0_2mn8e5.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821793
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    if message.is_empty() {\n        return message;\n    }\n\n\
    \    let mut encoded = String::new();\n    for c in message.chars() {\n      \
    \  encoded.push(match c {\n            'a' => 'c',\n            'e' => 'g',\n\
    \            'i' => 'k',\n            'o' => 'q',\n            'u' => 'y',\n \
    \           _ if c.is_ascii_uppercase() => c.to_ascii_lowercase(),\n         \
    \   _ if c.is_ascii_lowercase() => c.to_ascii_uppercase(),\n            _ => c,\n\
    \        });\n    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmp5gbvg5vh.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821793
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    for i in message.chars() {\n        if vowels.contains(&i)\
    \ {\n            result.push(((i as u8) + 2) as char);\n        } else {\n   \
    \         result.push(i);\n        }\n    }\n    result\n}\n\nfn main() {\n  \
    \  let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmpzmwa5dd8.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821793
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|c| {\n        let n = match c {\n    \
    \        'a' | 'e' | 'i' | 'o' | 'u' => 2,\n            'A' | 'E' | 'I' | 'O'\
    \ | 'U' => 2,\n            _ => 0,\n        };\n        match c {\n          \
    \  'a'...'z' => ('a' as u8 + ((c as u8 - 'a' as u8 + n) % 26)) as char,\n    \
    \        'A'...'Z' => ('A' as u8 + ((c as u8 - 'A' as u8 + n) % 26)) as char,\n\
    \            _ => c,\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmpypje27y7.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821793
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    // message.\n    // let v = vec!['a', 'e', 'i', 'o', 'u'];\n\
    \    // let letters = b'a'..=b'z';\n    // let vowels = vec!['a', 'e', 'i', 'o',\
    \ 'u'];\n    let v = \"aeiou\".to_string();\n    let mut result = String::new();\n\
    \    for c in message.chars() {\n        if v.contains(c) {\n            // let\
    \ t = c as u8;\n            // let mut t = c;\n            let mut t = c as u8;\n\
    \            t += 2;\n            // if t > b'u' {\n            //     t -= 4;\n\
    \            // }\n            if t > 117 {\n                t -= 4;\n       \
    \     }\n            let t = char::from(t);\n            result.push(t);\n   \
    \     } else {\n            if c >= 'a' && c <= 'z' {\n                // let\
    \ t = c as u8;\n                // t += 32;\n                // let t = char::from(t);\n\
    \                // result.push(t);\n                result.push(c.to_ascii_uppercase());\n\
    \            } else {\n                result.push(c);\n            }\n      \
    \  }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmpfh1g0kvh.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821793
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    // YOUR CODE HERE\n    unimplemented!();\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp2zsced_g.rs:9:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821793
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let message_chars: Vec<char>\
    \ = message.chars().collect();\n    for c in message_chars {\n        match c\
    \ {\n            'a' => result.push('c'),\n            'e' => result.push('g'),\n\
    \            'i' => result.push('k'),\n            'o' => result.push('q'),\n\
    \            'u' => result.push('s'),\n            'A' => result.push('C'),\n\
    \            'E' => result.push('G'),\n            'I' => result.push('K'),\n\
    \            'O' => result.push('Q'),\n            'U' => result.push('S'),\n\
    \            _ => result.push(c),\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmp8ybfq6kz.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821793
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut out: String = String::new();\n    let vowels = \"aeiou\"\
    ;\n    let mut characters = message.chars();\n    while let Some(character) =\
    \ characters.next() {\n        if character.is_ascii_uppercase() {\n         \
    \   let lower = character.to_ascii_lowercase();\n            if vowels.contains(lower)\
    \ {\n                let vowels = \"aeiou\".chars();\n                let mut\
    \ offset = 0;\n                while let Some(vowel) = vowels.next() {\n     \
    \               if vowel == lower {\n                        break;\n        \
    \            }\n                    offset += 1;\n                }\n        \
    \        offset += 2;\n                let vowels = \"aeiou\".chars();\n     \
    \           let mut new_char = 'a';\n                for vowel in vowels {\n \
    \                   if offset == 0 {\n                        new_char = vowel;\n\
    \                        break;\n                    }\n                    offset\
    \ -= 1;\n                }\n                out.push(new_char.to_ascii_uppercase());\n\
    \            } else {\n                out.push(character);\n            }\n \
    \       } else if character.is_ascii_lowercase() {\n            let upper = character.to_ascii_uppercase();\n\
    \            if vowels.contains(upper) {\n                let vowels = \"aeiou\"\
    .chars();\n                let mut offset = 0;\n                while let Some(vowel)\
    \ = vowels.next() {\n                    if vowel == upper {\n               \
    \         break;\n                    }\n                    offset += 1;\n  \
    \              }\n                offset += 2;\n                let vowels = \"\
    aeiou\".chars();\n                let mut new_char = 'a';\n                for\
    \ vowel in vowels {\n                    if offset == 0 {\n                  \
    \      new_char = vowel;\n                        break;\n                   \
    \ }\n                    offset -= 1;\n                }\n                out.push(new_char);\n\
    \            } else {\n                out.push(character);\n            }\n \
    \       } else {\n            out.push(character);\n        }\n    }\n    out\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `vowels` as mutable, as it is not declared\
    \ as mutable\n  --> /tmp/tmp4b5i6val.rs:17:41\n   |\n15 |                 let\
    \ vowels = \"aeiou\".chars();\n   |                     ------ help: consider\
    \ changing this to be mutable: `mut vowels`\n16 |                 let mut offset\
    \ = 0;\n17 |                 while let Some(vowel) = vowels.next() {\n   |   \
    \                                      ^^^^^^ cannot borrow as mutable\n\nerror[E0596]:\
    \ cannot borrow `vowels` as mutable, as it is not declared as mutable\n  --> /tmp/tmp4b5i6val.rs:42:41\n\
    \   |\n40 |                 let vowels = \"aeiou\".chars();\n   |            \
    \         ------ help: consider changing this to be mutable: `mut vowels`\n41\
    \ |                 let mut offset = 0;\n42 |                 while let Some(vowel)\
    \ = vowels.next() {\n   |                                         ^^^^^^ cannot\
    \ borrow as mutable\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659821792
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    for c in message.chars()\
    \ {\n        let c = if c.is_lowercase() {\n            c.to_uppercase().next().unwrap()\n\
    \        } else {\n            c.to_lowercase().next().unwrap()\n        };\n\
    \        result.push(match c {\n            'A' => 'C',\n            'E' => 'G',\n\
    \            'I' => 'K',\n            'O' => 'Q',\n            'U' => 'Y',\n \
    \           _ => c,\n        });\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmphuk5m7ip.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821793
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let code = message.as_bytes();\n    let mut encoded = String::new();\n\
    \    let mut pos:usize = 0;\n    while pos < code.len() {\n        let i = code[pos];\n\
    \        if i >= b'a' && i <= b'z' {\n            encoded.push((i - b'a' + b'A')\
    \ as char);\n        } else if i >= b'A' && i <= b'Z' {\n            encoded.push((i\
    \ - b'A' + b'a') as char);\n        } else if i == b' ' {\n            encoded.push('\
    \ ');\n        } else if i == b'Z' {\n            encoded.push('A');\n       \
    \ } else if i == b'z' {\n            encoded.push('a');\n        } else {\n  \
    \          let c = (i + 2) as char;\n            encoded.push(c);\n        }\n\
    \        pos += 1;\n    }\n    encoded\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmpjjje_egs.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821793
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    for c in message.chars()\
    \ {\n        let c_lowercase = c.to_lowercase().to_string();\n        if \"aeiou\"\
    .contains(c_lowercase.as_str()) {\n            let next_two = c_lowercase.chars().nth(2).unwrap().to_string();\n\
    \            if c.is_lowercase() {\n                result.push_str(next_two.as_str());\n\
    \            } else {\n                result.push_str(next_two.to_uppercase().as_str());\n\
    \            }\n        } else {\n            result.push(c);\n        }\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmpeueg9bhv.rs:12:55

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821793
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpzpnpla0m.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821793
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\".chars().collect::<Vec<char>>();\n\
    \    let vowels = \"aeiou\".chars().collect::<Vec<char>>();\n    let mut encoded_message\
    \ = String::new();\n    for letter in message.chars() {\n        let letter_lower\
    \ = letter.to_lowercase().collect::<Vec<char>>()[0];\n        if let Some(idx)\
    \ = alphabet.iter().position(|&r| r == letter_lower) {\n            if vowels.contains(&letter_lower)\
    \ {\n                let mut new_letter = alphabet[(idx + 2) % alphabet.len()];\n\
    \                if letter.is_uppercase() {\n                    new_letter =\
    \ new_letter.to_uppercase().collect::<Vec<char>>()[0];\n                }\n  \
    \              encoded_message.push(new_letter);\n            } else {\n     \
    \           let new_letter = if letter.is_uppercase() {\n                    alphabet[idx].to_uppercase().collect::<Vec<char>>()[0]\n\
    \                } else {\n                    alphabet[idx]\n               \
    \ };\n                encoded_message.push(new_letter);\n            }\n     \
    \   }\n    }\n    encoded_message\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmpjaj3q7up.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821793
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\".chars().collect::<Vec<char>>();\n\
    \    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut encoded = String::new();\n\
    \    let lowercase_message = message.to_lowercase();\n    for c in lowercase_message.chars()\
    \ {\n        if alphabet.contains(&c) {\n            let i = alphabet.iter().position(|x|\
    \ *x == c).unwrap();\n            let new_c = if vowels.contains(&c) {\n     \
    \           if i + 2 > alphabet.len() - 1 {\n                    alphabet[(i +\
    \ 2) - alphabet.len()]\n                } else {\n                    alphabet[i\
    \ + 2]\n                }\n            } else {\n                alphabet[i]\n\
    \            };\n            encoded.push(new_c);\n        } else {\n        \
    \    encoded.push(c);\n        }\n    }\n    encoded\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"mwdcskr\"`,\n right: `\"mWDCSKR\"`', /tmp/tmpn0pzyrdt.rs:35:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821793
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    message.chars().map(|c|\
    \ {\n        if c.is_alphabetic() {\n            let offset = if c.is_lowercase()\
    \ { 'a' } else { 'A' };\n            let mut char_offset = (c as u8 - offset as\
    \ u8 + 2) % 26;\n            if char_offset == 0 {\n                char_offset\
    \ = 26;\n            }\n            if vowels.contains(&(offset as char + char_offset\
    \ as char)) {\n                char_offset += 1;\n            }\n            (offset\
    \ as u8 + char_offset) as char\n        } else {\n            c\n        }\n \
    \   }).collect()\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot add `char` to `char`\n  --> /tmp/tmpgaidpaw8.rs:16:49\n\
    \   |\n16 |             if vowels.contains(&(offset as char + char_offset as char))\
    \ {\n   |                                  -------------- ^ -------------------\
    \ char\n   |                                  |\n   |                        \
    \          char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659821792
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let message_bytes = message.as_bytes();\n    let mut result:\
    \ Vec<u8> = Vec::new();\n    for &byte in message_bytes {\n        match byte\
    \ {\n            x if x >= 97 && x <= 122 => {\n                result.push(x\
    \ - 32);\n            },\n            x if x >= 65 && x <= 90 => {\n         \
    \       result.push(x + 32);\n            },\n            x => {\n           \
    \     result.push(x);\n            }\n        }\n    }\n    let result_message\
    \ = String::from_utf8(result).unwrap();\n    let mut encoded: Vec<u8> = Vec::new();\n\
    \    for character in result_message.chars() {\n        match character {\n  \
    \          'a' => {\n                encoded.push(b'c');\n            },\n   \
    \         'e' => {\n                encoded.push(b'g');\n            },\n    \
    \        'i' => {\n                encoded.push(b'k');\n            },\n     \
    \       'o' => {\n                encoded.push(b'm');\n            },\n      \
    \      'u' => {\n                encoded.push(b'w');\n            },\n       \
    \     x => {\n                encoded.push(x as u8);\n            }\n        }\n\
    \    }\n    String::from_utf8(encoded).unwrap()\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"mUDASIR\"`,\n right: `\"mWDCSKR\"`', /tmp/tmpmzbsbgtu.rs:53:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821793
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    for ch in message.chars()\
    \ {\n        if ch.is_ascii_uppercase() {\n            result.push(ch.to_ascii_lowercase());\n\
    \        } else if ch.is_ascii_lowercase() {\n            result.push(ch.to_ascii_uppercase());\n\
    \        } else {\n            result.push(ch);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmp0kuoz4ol.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821793
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut res = String::new();\n    let vowels = ['a', 'e', 'i',\
    \ 'o', 'u'];\n    for c in message.chars() {\n        match c {\n            c\
    \ if c.is_lowercase() => res.push(c.to_uppercase().next().unwrap()),\n       \
    \     c if c.is_uppercase() => res.push(c.to_lowercase().next().unwrap()),\n \
    \           c if vowels.contains(&c) => {\n                let index = vowels.iter().position(|x|\
    \ *x == c).unwrap();\n                res.push(vowels[(index + 2) % vowels.len()]);\n\
    \            },\n            _ => res.push(c),\n        }\n    }\n    res\n}\n\
    \nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmpstnwxbun.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821793
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut in_vowel = false;\n\
    \    for letter in message.chars() {\n        if !letter.is_alphabetic() {\n \
    \           encoded.push(letter);\n            continue;\n        }\n        if\
    \ !in_vowel {\n            encoded.push(letter.to_uppercase().to_string());\n\
    \        } else {\n            encoded.push(letter.to_lowercase().to_string());\n\
    \        }\n        match letter {\n            'a' => encoded.push_str(\"c\"\
    ),\n            'e' => encoded.push_str(\"g\"),\n            'i' => encoded.push_str(\"\
    k\"),\n            'o' => encoded.push_str(\"q\"),\n            'u' => encoded.push_str(\"\
    s\"),\n            _ => {}\n        }\n        in_vowel = !in_vowel;\n    }\n\
    \    encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8kd912fm.rs:16:26\n   |\n\
    16 |             encoded.push(letter.to_uppercase().to_string());\n   |      \
    \                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found\
    \ struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8kd912fm.rs:18:26\n\
    \   |\n18 |             encoded.push(letter.to_lowercase().to_string());\n   |\
    \                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found struct `String`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659821793
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded_message = String::from(\"\");\n    let vowels\
    \ = ['a', 'e', 'i', 'o', 'u'];\n    for character in message.chars() {\n     \
    \   if character.is_alphabetic() {\n            if vowels.contains(&character)\
    \ {\n                encoded_message.push(find_next_vowel(character));\n     \
    \       } else {\n                encoded_message.push(character.to_lowercase().next().unwrap());\n\
    \            }\n        } else {\n            encoded_message.push(character);\n\
    \        }\n    }\n    encoded_message\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_next_vowel` in this scope\n  -->\
    \ /tmp/tmpcb6drrig.rs:13:38\n   |\n13 |                 encoded_message.push(find_next_vowel(character));\n\
    \   |                                      ^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821793
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    String::from(\"Encoded message\")\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Encoded message\"`,\n right: `\"tgst\"`', /tmp/tmpz_hwrng7.rs:13:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821793
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n\tlet mut res: String = String::new();\n\tlet vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n\tlet mut count = 0;\n\tfor letter in message.chars()\
    \ {\n\t\tlet mut l = letter;\n\t\tif l.is_ascii_uppercase() {\n\t\t\tl = l.to_ascii_lowercase();\n\
    \t\t}\n\t\tif vowels.contains(&l) {\n\t\t\tlet mut i = 0;\n\t\t\tfor v in vowels.iter()\
    \ {\n\t\t\t\tif l == *v {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ti += 1;\n\t\t\t\
    }\n\t\t\tif i == 4 {\n\t\t\t\tl = vowels[0];\n\t\t\t} else {\n\t\t\t\tl = vowels[i\
    \ + 1];\n\t\t\t}\n\t\t}\n\t\tif count % 2 == 0 {\n\t\t\tl = l.to_ascii_uppercase();\n\
    \t\t}\n\t\tres.push(l);\n\t\tcount += 1;\n\t}\n\tres\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TiSt\"`,\n right: `\"tgst\"`', /tmp/tmpewitym3y.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821793
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n  let mut encoded = String::new();\n  for c in message.chars()\
    \ {\n    if c.is_ascii_lowercase() {\n      encoded.push(c.to_ascii_uppercase());\n\
    \    } else if c.is_ascii_uppercase() {\n      encoded.push(c.to_ascii_lowercase());\n\
    \    } else {\n      encoded.push(c);\n    }\n  }\n  encoded\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmp_p3p1h89.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821793
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = message.to_owned();\n    result.make_ascii_lowercase();\n\
    \    result.chars().map(|c| {\n        match c {\n            'a' => 'c',\n  \
    \          'e' => 'g',\n            'i' => 'k',\n            'o' => 'q',\n   \
    \         'u' => 'y',\n            _ => c,\n        }\n    }).collect()\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"mydcskr\"`,\n right: `\"mWDCSKR\"`', /tmp/tmpmgas1o6u.rs:25:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821793
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpzpnpla0m.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821793
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    //1. Split the string into individual characters\n    //2.\
    \ Iterate through the chars using enumerate\n    //3. Check if it is a letter,\
    \ else ignore\n    //4. If a vowel, replace it with the char 2 places ahead of\
    \ it\n    //5. Check if is a capital letter and if so, make it lowercase\n   \
    \ //6. Check if is a lowercase letter and if so, make it uppercase\n    //7. Collect\
    \ the chars and return them as a string\n    message.chars().enumerate().map(|(i,\
    \ c)| {\n        if c.is_alphabetic() {\n            match c {\n             \
    \   'a' | 'e' | 'i' | 'o' | 'u' => match c.to_lowercase().next().unwrap() {\n\
    \                    'a' => 'c',\n                    'e' => 'g',\n          \
    \          'i' => 'k',\n                    'o' => 'q',\n                    'u'\
    \ => 'y',\n                    _ => c\n                },\n                _ =>\
    \ c\n            }\n        } else {\n            c\n        }\n    }).map(|c|\
    \ {\n        if c.is_uppercase() {\n            c.to_lowercase().next().unwrap()\n\
    \        } else {\n            c.to_uppercase().next().unwrap()\n        }\n \
    \   }).collect()\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmper_til7u.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821793
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let normal_vowels = \"aeiou\";\n    let mut encoded = message.clone();\n\
    \    for ch in encoded.chars_mut() {\n        let lower = ch.to_lowercase().to_string();\n\
    \        if lower == ch {\n            ch.make_ascii_uppercase();\n        } else\
    \ {\n            ch.make_ascii_lowercase();\n        }\n        if normal_vowels.contains(ch)\
    \ {\n            let mut split = lower.chars();\n            let _a = split.next().unwrap();\n\
    \            let b = split.next().unwrap();\n            if let Some(c) = split.next()\
    \ {\n                *ch = c;\n            } else {\n                *ch = b;\n\
    \            }\n        }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars_mut` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmp0o9ptn8j.rs:10:23\n   |\n10 |     for ch in\
    \ encoded.chars_mut() {\n   |                       ^^^^^^^^^ method not found\
    \ in `String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659821793
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n  let mut answer = String::new();\n  let mut skip_next = false;\n\
    \  for c in message.chars() {\n    if skip_next {\n      skip_next = false;\n\
    \      continue;\n    }\n    let mut curr_char = c;\n    if c.is_ascii_lowercase()\
    \ {\n      curr_char = c.to_ascii_uppercase();\n    } else if c.is_ascii_uppercase()\
    \ {\n      curr_char = c.to_ascii_lowercase();\n    } else if c == '\\'' {\n \
    \     answer.push(c);\n      continue;\n    }\n    match curr_char {\n      'A'\
    \ => {\n        answer.push('C');\n        skip_next = true;\n      },\n     \
    \ 'E' => {\n        answer.push('G');\n        skip_next = true;\n      },\n \
    \     'I' => {\n        answer.push('K');\n        skip_next = true;\n      },\n\
    \      'O' => {\n        answer.push('Q');\n        skip_next = true;\n      },\n\
    \      'U' => {\n        answer.push('W');\n        skip_next = true;\n      },\n\
    \      'Y' => {\n        answer.push('A');\n        skip_next = true;\n      },\n\
    \      _ => answer.push(curr_char),\n    }\n  }\n  answer\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmpftm_8x_v.rs:57:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821793
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = \"\".to_string();\n    let vowels = [\"a\"\
    , \"e\", \"i\", \"o\", \"u\"];\n    for c in message.chars() {\n        if vowels.contains(&c.to_string().as_str())\
    \ {\n            result.push_str(next_vowel(c.to_string()).as_str());\n      \
    \  } else {\n            result.push_str(c.to_string().as_str());\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `next_vowel` in this scope\n  --> /tmp/tmp8lrbpkck.rs:12:29\n\
    \   |\n12 |             result.push_str(next_vowel(c.to_string()).as_str());\n\
    \   |                             ^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821793
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|l| {\n        if l.is_ascii_uppercase()\
    \ {\n            l.to_ascii_lowercase()\n        } else if l.is_ascii_lowercase()\
    \ {\n            l.to_ascii_uppercase()\n        } else {\n            l\n   \
    \     }\n    }).map(|l| {\n        if l == 'a' {\n            'c'\n        } else\
    \ if l == 'e' {\n            'g'\n        } else if l == 'i' {\n            'k'\n\
    \        } else if l == 'o' {\n            'q'\n        } else if l == 'u' {\n\
    \            'w'\n        } else {\n            l\n        }\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"mUDASIR\"`,\n right: `\"mWDCSKR\"`', /tmp/tmpcnkdzms9.rs:36:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821793
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    for c in message.chars()\
    \ {\n        match c {\n            'a' => result.push('c'),\n            'e'\
    \ => result.push('g'),\n            'i' => result.push('k'),\n            'o'\
    \ => result.push('q'),\n            'u' => result.push('s'),\n            'y'\
    \ => result.push('a'),\n            'A' => result.push('C'),\n            'E'\
    \ => result.push('G'),\n            'I' => result.push('K'),\n            'O'\
    \ => result.push('Q'),\n            'U' => result.push('S'),\n            'Y'\
    \ => result.push('A'),\n            _ => result.push(c),\n        }\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmpafy__mty.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821793
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut output = message.clone();\n    for (i, c) in message.chars().enumerate()\
    \ {\n        if c.is_ascii_lowercase() {\n            output.as_mut_str().replace_range(i..i+1,\
    \ &c.to_ascii_uppercase().to_string());\n        } else if c.is_ascii_uppercase()\
    \ {\n            output.as_mut_str().replace_range(i..i+1, &c.to_ascii_lowercase().to_string());\n\
    \        } else if c == 'a' {\n            output.as_mut_str().replace_range(i..i+1,\
    \ \"c\");\n        } else if c == 'e' {\n            output.as_mut_str().replace_range(i..i+1,\
    \ \"g\");\n        } else if c == 'i' {\n            output.as_mut_str().replace_range(i..i+1,\
    \ \"k\");\n        } else if c == 'o' {\n            output.as_mut_str().replace_range(i..i+1,\
    \ \"q\");\n        } else if c == 'u' {\n            output.as_mut_str().replace_range(i..i+1,\
    \ \"s\");\n        } else if c == 'A' {\n            output.as_mut_str().replace_range(i..i+1,\
    \ \"C\");\n        } else if c == 'E' {\n            output.as_mut_str().replace_range(i..i+1,\
    \ \"G\");\n        } else if c == 'I' {\n            output.as_mut_str().replace_range(i..i+1,\
    \ \"K\");\n        } else if c == 'O' {\n            output.as_mut_str().replace_range(i..i+1,\
    \ \"Q\");\n        } else if c == 'U' {\n            output.as_mut_str().replace_range(i..i+1,\
    \ \"S\");\n        }\n    }\n    output\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `replace_range` found for mutable reference\
    \ `&mut str` in the current scope\n  --> /tmp/tmpf2q37djl.rs:11:33\n   |\n11 |\
    \             output.as_mut_str().replace_range(i..i+1, &c.to_ascii_uppercase().to_string());\n\
    \   |                                 ^^^^^^^^^^^^^ method not found in `&mut\
    \ str`\n\nerror[E0599]: no method named `replace_range` found for mutable reference\
    \ `&mut str` in the current scope\n  --> /tmp/tmpf2q37djl.rs:13:33\n   |\n13 |\
    \             output.as_mut_str().replace_range(i..i+1, &c.to_ascii_lowercase().to_string());\n\
    \   |                                 ^^^^^^^^^^^^^ method not found in `&mut\
    \ str`\n\nerror[E0599]: no method named `replace_range` found for mutable reference\
    \ `&mut str` in the current scope\n  --> /tmp/tmpf2q37djl.rs:15:33\n   |\n15 |\
    \             output.as_mut_str().replace_range(i..i+1, \"c\");\n   |        \
    \                         ^^^^^^^^^^^^^ method not found in `&mut str`\n\nerror[E0599]:\
    \ no method named `replace_range` found for mutable reference `&mut str` in the\
    \ current scope\n  --> /tmp/tmpf2q37djl.rs:17:33\n   |\n17 |             output.as_mut_str().replace_range(i..i+1,\
    \ \"g\");\n   |                                 ^^^^^^^^^^^^^ method not found\
    \ in `&mut str`\n\nerror[E0599]: no method named `replace_range` found for mutable\
    \ reference `&mut str` in the current scope\n  --> /tmp/tmpf2q37djl.rs:19:33\n\
    \   |\n19 |             output.as_mut_str().replace_range(i..i+1, \"k\");\n  \
    \ |                                 ^^^^^^^^^^^^^ method not found in `&mut str`\n\
    \nerror[E0599]: no method named `replace_range` found for mutable reference `&mut\
    \ str` in the current scope\n  --> /tmp/tmpf2q37djl.rs:21:33\n   |\n21 |     \
    \        output.as_mut_str().replace_range(i..i+1, \"q\");\n   |             \
    \                    ^^^^^^^^^^^^^ method not found in `&mut str`\n\nerror[E0599]:\
    \ no method named `replace_range` found for mutable reference `&mut str` in the\
    \ current scope\n  --> /tmp/tmpf2q37djl.rs:23:33\n   |\n23 |             output.as_mut_str().replace_range(i..i+1,\
    \ \"s\");\n   |                          "
  stdout: ''
  timestamp: 1659821793
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for c in message.chars()\
    \ {\n        let mut is_upper = false;\n        let c = if c.is_uppercase() {\n\
    \            is_upper = true;\n            c.to_lowercase().collect::<Vec<char>>()[0]\n\
    \        } else {\n            c\n        };\n        let encoded_c = match c\
    \ {\n            'a' => 'c',\n            'e' => 'g',\n            'i' => 'k',\n\
    \            'o' => 'q',\n            'u' => 'y',\n            _ => c,\n     \
    \   };\n        if is_upper {\n            encoded.push(encoded_c.to_uppercase().collect::<Vec<char>>()[0]);\n\
    \        } else {\n            encoded.push(encoded_c);\n        }\n    }\n  \
    \  encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmpqdafe5d7.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821793
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpzpnpla0m.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821793
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|x| match x {\n        'a' => 'c',\n  \
    \      'e' => 'g',\n        'i' => 'k',\n        'o' => 'q',\n        'u' => 'w',\n\
    \        'A' => 'C',\n        'E' => 'G',\n        'I' => 'K',\n        'O' =>\
    \ 'Q',\n        'U' => 'W',\n        _ => x,\n    }).collect()\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmpvj6g7oxt.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821793
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpzpnpla0m.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821793
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    String::from(\"\")\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"tgst\"`', /tmp/tmpyzev_yig.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821793
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    String::from(\"\")\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"tgst\"`', /tmp/tmpyzev_yig.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821793
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n  let mut encoded = String::new();\n  let  alphabet_bytes = String::from(\"\
    abcdefghijklmnopqrstuvwxyz\").into_bytes();\n  let vowels = String::from(\"aeiou\"\
    ).into_bytes();\n  let diff_vowels = 2;\n  let mut vowels_iter = vowels.iter();\n\
    \  let mut vowels_ptr = vowels_iter.next();\n  for c in message.into_bytes() {\n\
    \    let encode_char = match c {\n      65 ... 90 => if c > 65 + diff_vowels {\n\
    \        c + diff_vowels\n      } else {\n        90 - 65 + diff_vowels + c\n\
    \      },\n      97 ... 122 => if c > 97 + diff_vowels {\n        c + diff_vowels\n\
    \      } else {\n        122 - 97 + diff_vowels + c\n      },\n      _ => c\n\
    \    };\n    if vowels_ptr.is_some() && encode_char == *vowels_ptr.unwrap() {\n\
    \      vowels_ptr = vowels_iter.next();\n      if let Some(letter) = alphabet_bytes.get(encode_char\
    \ - 97 + 2) {\n        encoded.push(*letter as char);\n      }\n    } else {\n\
    \      encoded.push(encode_char as char);\n    }\n  }\n  encoded\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "warning: `...` range patterns are deprecated\n  --> /tmp/tmpy2fik93z.rs:16:10\n\
    \   |\n16 |       65 ... 90 => if c > 65 + diff_vowels {\n   |          ^^^ help:\
    \ use `..=` for an inclusive range\n   |\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]`\
    \ on by default\n   = warning: this is accepted in the current edition (Rust 2015)\
    \ but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nwarning: `...` range patterns are deprecated\n  --> /tmp/tmpy2fik93z.rs:21:10\n\
    \   |\n21 |       97 ... 122 => if c > 97 + diff_vowels {\n   |          ^^^ help:\
    \ use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the\
    \ current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for\
    \ more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nerror[E0277]: the type `[u8]` cannot be indexed by `u8`\n  --> /tmp/tmpy2fik93z.rs:30:48\n\
    \   |\n30 |       if let Some(letter) = alphabet_bytes.get(encode_char - 97 +\
    \ 2) {\n   |                                                ^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[u8]>` is not implemented for `u8`\n\nerror: aborting due\
    \ to previous error; 2 warnings emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659821793
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let\
    \ vowels2 = [\"b\", \"f\", \"j\", \"p\", \"v\"];\n    let alphabets = \"abcdefghijklmnopqrstuvwxyz\"\
    .to_string();\n    let alphabets2 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".to_string();\n\
    \    let mut encoded = String::new();\n    for ch in message.chars() {\n     \
    \   if vowels.contains(&ch.to_string().as_str()) {\n            let idx = alphabets.find(ch).unwrap();\n\
    \            let new_idx = (idx + 2) % vowels.len();\n            encoded.push_str(vowels2[new_idx]);\n\
    \        } else if vowels2.contains(&ch.to_string().as_str()) {\n            let\
    \ idx = alphabets2.find(ch).unwrap();\n            let new_idx = (idx + 2) % vowels2.len();\n\
    \            encoded.push_str(vowels[new_idx]);\n        } else {\n          \
    \  encoded.push(ch);\n        }\n    }\n    encoded\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmptde23tux.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821793
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for letter in message.chars()\
    \ {\n        match letter {\n            'a' => encoded.push('c'),\n         \
    \   'e' => encoded.push('g'),\n            'i' => encoded.push('k'),\n       \
    \     'o' => encoded.push('q'),\n            'u' => encoded.push('y'),\n     \
    \       ' ' => encoded.push(' '),\n            _ => encoded.push(letter.to_uppercase().next().unwrap()),\n\
    \        }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmpk_qx8ecm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821793
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded_message = String::new();\n    for character\
    \ in message.chars() {\n        if character.is_lowercase() {\n            encoded_message.push(character.to_uppercase().next().unwrap());\n\
    \        } else if character.is_uppercase() {\n            encoded_message.push(character.to_lowercase().next().unwrap());\n\
    \        } else {\n            encoded_message.push(character);\n        }\n \
    \   }\n    encoded_message\n}\n\nfn main() {\n    let candidate = encode;\n  \
    \  assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n  \
    \  assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"));\n\
    \    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n  \
    \  assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmp6julvskb.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821793
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded_message = String::new();\n    let vowels =\
    \ \"aeiou\";\n    let mut i = 0;\n    while i < message.len() {\n        let letter\
    \ = message.chars().nth(i).unwrap();\n        if is_vowel(letter) {\n        \
    \    let new_letter = determine_new_letter(letter, vowels);\n            encoded_message.push(new_letter);\n\
    \        } else {\n            encoded_message.push(letter);\n        }\n    \
    \    i += 1;\n    }\n    return encoded_message;\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpv9gqncmp.rs:13:12\n\
    \   |\n13 |         if is_vowel(letter) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `determine_new_letter` in\
    \ this scope\n  --> /tmp/tmpv9gqncmp.rs:14:30\n   |\n14 |             let new_letter\
    \ = determine_new_letter(letter, vowels);\n   |                              ^^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821793
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let lower_case_vowels = ['a', 'e', 'i', 'o', 'u'];\n    let\
    \ upper_case_vowels = ['A', 'E', 'I', 'O', 'U'];\n    let mut result = String::new();\n\
    \    for c in message.chars() {\n        if lower_case_vowels.contains(&c) {\n\
    \            let next_char = (c as u8 + 2) as char;\n            result.push(next_char);\n\
    \        } else if upper_case_vowels.contains(&c) {\n            let next_char\
    \ = (c as u8 + 2) as char;\n            result.push(next_char);\n        } else\
    \ if c.is_ascii_uppercase() {\n            let next_char = (c as u8 + 32) as char;\n\
    \            result.push(next_char);\n        } else if c.is_ascii_lowercase()\
    \ {\n            let next_char = (c as u8 - 32) as char;\n            result.push(next_char);\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"tGst\"`,\n right: `\"tgst\"`', /tmp/tmpyoaklpga.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821793
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::from(\"\");\n    for c in message.chars()\
    \ {\n        match c {\n            'a' => result.push('c'),\n            'e'\
    \ => result.push('g'),\n            'i' => result.push('k'),\n            'o'\
    \ => result.push('q'),\n            'u' => result.push('y'),\n            'A'\
    \ => result.push('C'),\n            'E' => result.push('G'),\n            'I'\
    \ => result.push('K'),\n            'O' => result.push('Q'),\n            'U'\
    \ => result.push('Y'),\n            ' ' => result.push(' '),\n            _ =>\
    \ result.push(c),\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmpkeduab70.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821793
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpzpnpla0m.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821793
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    let mut encoded_message\
    \ = String::from(\"\");\n    for c in message.chars() {\n        let mut next_char\
    \ = c;\n        if vowels.contains(&c) {\n            let distance = (c as u8\
    \ + 2) - 'a' as u8;\n            next_char = 'a' as u8 + distance % 5;\n     \
    \   }\n        let mut next_char = if c.is_ascii_uppercase() {\n            next_char.to_ascii_lowercase()\n\
    \        } else {\n            next_char.to_ascii_uppercase()\n        };\n  \
    \      encoded_message.push(next_char);\n    }\n    encoded_message\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplhxk1te7.rs:14:25\n   |\n\
    14 |             next_char = 'a' as u8 + distance % 5;\n   |                 \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `u8`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659821793
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpzpnpla0m.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821793
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    return \"abc\".to_string();\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"abc\"`,\n right: `\"tgst\"`', /tmp/tmpzxznue3q.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821793
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::from(\"\");\n    for c in message.chars()\
    \ {\n        let up = c.is_uppercase();\n        if up {\n            result.push(c.to_lowercase().next().unwrap());\n\
    \        } else {\n            result.push(c.to_uppercase().next().unwrap());\n\
    \        }\n    }\n    let chars: Vec<char> = result.chars().collect();\n    let\
    \ mut result = String::from(\"\");\n    for c in chars {\n        let index =\
    \ ENCODE_VOWELS.find(c).unwrap();\n        let new_c = ENCODE_VOWELS.chars().nth(index\
    \ + 2).unwrap();\n        result.push(new_c);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `ENCODE_VOWELS` in this scope\n  --> /tmp/tmpfo9445zc.rs:20:21\n\
    \   |\n20 |         let index = ENCODE_VOWELS.find(c).unwrap();\n   |        \
    \             ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `ENCODE_VOWELS` in this scope\n  --> /tmp/tmpfo9445zc.rs:21:21\n   |\n\
    21 |         let new_c = ENCODE_VOWELS.chars().nth(index + 2).unwrap();\n   |\
    \                     ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821793
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for c in message.chars()\
    \ {\n        match c {\n            'a' | 'A' => encoded.push('c'),\n        \
    \    'e' | 'E' => encoded.push('g'),\n            'i' | 'I' => encoded.push('k'),\n\
    \            'o' | 'O' => encoded.push('q'),\n            'u' | 'U' => encoded.push('y'),\n\
    \            c if c.is_lowercase() => encoded.push((c as u8 + 2) as char),\n \
    \           c if c.is_uppercase() => encoded.push((c as u8 + 2 - 32) as char),\n\
    \            _ => encoded.push(c),\n        }\n    }\n    encoded\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"6g56\"`,\n right: `\"tgst\"`', /tmp/tmpd9233932.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821793
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    .to_string();\n    let vowels = \"aeiou\".to_string();\n    for c in message.chars()\
    \ {\n        if c.is_ascii_lowercase() {\n            result.push(c.to_ascii_uppercase());\n\
    \        } else if c.is_ascii_uppercase() {\n            result.push(c.to_ascii_lowercase());\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmpkvoz957p.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821793
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|c| {\n        if c.is_lowercase() {\n\
    \            c.to_uppercase().next().unwrap()\n        } else if c.is_uppercase()\
    \ {\n            c.to_lowercase().next().unwrap()\n        } else {\n        \
    \    c\n        }\n    }).map(|c| {\n        match c {\n            'a' => 'c',\n\
    \            'e' => 'g',\n            'i' => 'k',\n            'o' => 'q',\n \
    \           'u' => 'y',\n            _ => c\n        }\n    }).collect()\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"mUDASIR\"`,\n right: `\"mWDCSKR\"`', /tmp/tmpyn310g66.rs:31:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821794
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    // TODO\n    \"\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"tgst\"`', /tmp/tmpwugvfup0.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821794
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    //TODO\n    String::new()\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"tgst\"`', /tmp/tmpkwbnxi8a.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821794
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut shifted_message\
    \ = String::new();\n    for c in message.chars() {\n        if vowels.contains(&c)\
    \ {\n            match c {\n                'a' => shifted_message.push('c'),\n\
    \                'e' => shifted_message.push('g'),\n                'i' => shifted_message.push('k'),\n\
    \                'o' => shifted_message.push('q'),\n                'u' => shifted_message.push('s'),\n\
    \                _ => (),\n            }\n        } else {\n            shifted_message.push(c);\n\
    \        }\n    }\n    shifted_message\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmp79ua6kfv.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821794
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n    let mut\
    \ new_message = String::from(\"\");\n    for character in message.chars() {\n\
    \        let mut index = alphabet.find(character).unwrap();\n        if character.is_lowercase()\
    \ {\n            index += 2;\n            new_message.push_str(&alphabet[index..index+1]);\n\
    \        } else {\n            index += 2;\n            new_message.push_str(&alphabet[index..index+1].to_uppercase());\n\
    \        }\n    }\n    new_message\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmpi0giefn0.rs:11:50

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821794
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let alphabet: [char; 26] = [\n        'a', 'b', 'c', 'd', 'e',\
    \ 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n        'n', 'o', 'p', 'q', 'r', 's',\
    \ 't', 'u', 'v', 'w', 'x', 'y', 'z'\n    ];\n    let vowels: [char; 5] = ['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut encoded_message = String::new();\n    for\
    \ ch in message.chars() {\n        if ch.is_lowercase() {\n            if let\
    \ Some(index) = alphabet.iter().position(|&x| x == ch) {\n                encoded_message.push(alphabet[index-1]);\n\
    \            }\n        } else if ch.is_uppercase() {\n            if let Some(index)\
    \ = alphabet.iter().position(|&x| x == ch.to_lowercase().next().unwrap()) {\n\
    \                encoded_message.push(alphabet[index+1].to_uppercase().next().unwrap());\n\
    \            }\n        } else {\n            encoded_message.push(ch);\n    \
    \    }\n    }\n    for ch in encoded_message.chars() {\n        if vowels.contains(&ch)\
    \ {\n            match ch {\n                'a' => encoded_message = encoded_message.replace(ch,\
    \ \"c\"),\n                'e' => encoded_message = encoded_message.replace(ch,\
    \ \"g\"),\n                'i' => encoded_message = encoded_message.replace(ch,\
    \ \"k\"),\n                'o' => encoded_message = encoded_message.replace(ch,\
    \ \"q\"),\n                'u' => encoded_message = encoded_message.replace(ch,\
    \ \"s\"),\n                _ => encoded_message.push(ch),\n            }\n   \
    \     }\n    }\n    encoded_message\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0506]: cannot assign to `encoded_message` because it is borrowed\n\
    \    --> /tmp/tmputj5_t7m.rs:30:24\n     |\n27   |     for ch in encoded_message.chars()\
    \ {\n     |               -----------------------\n     |               |\n  \
    \   |               borrow of `encoded_message` occurs here\n     |          \
    \     borrow later used here\n...\n30   |                 'a' => encoded_message\
    \ = encoded_message.replace(ch, \"c\"),\n     |                        ^^^^^^^^^^^^^^^\
    \ assignment to borrowed `encoded_message` occurs here\n     |\n     = note: borrow\
    \ occurs due to deref coercion to `str`\nnote: deref defined here\n\nerror[E0506]:\
    \ cannot assign to `encoded_message` because it is borrowed\n    --> /tmp/tmputj5_t7m.rs:31:24\n\
    \     |\n27   |     for ch in encoded_message.chars() {\n     |              \
    \ -----------------------\n     |               |\n     |               borrow\
    \ of `encoded_message` occurs here\n     |               borrow later used here\n\
    ...\n31   |                 'e' => encoded_message = encoded_message.replace(ch,\
    \ \"g\"),\n     |                        ^^^^^^^^^^^^^^^ assignment to borrowed\
    \ `encoded_message` occurs here\n     |\n     = note: borrow occurs due to deref\
    \ coercion to `str`\nnote: deref defined here\n\nerror[E0506]: cannot assign to\
    \ `encoded_message` because it is borrowed\n    --> /tmp/tmputj5_t7m.rs:32:24\n\
    \     |\n27   |     for ch in encoded_message.chars() {\n     |              \
    \ -----------------------\n     |               |\n     |               borrow\
    \ of `encoded_message` occurs here\n     |               borrow later used here\n\
    ...\n32   |                 'i' => encoded_message = encoded_message.replace(ch,\
    \ \"k\"),\n     |                        ^^^^^^^^^^^^^^^ assignment to borrowed\
    \ `encoded_message` occurs here\n     |\n     = note: borrow occurs due to deref\
    \ coercion to `str`\nnote: deref defined here\n\nerror[E0506]: cannot assign to\
    \ `encoded_message` because it is borrowed\n    --> /tmp/tmputj5_t7m.rs:33:24\n\
    \     |\n27   |     for ch in encoded_message.chars() {\n     |              \
    \ -----------------------\n     |          "
  stdout: ''
  timestamp: 1659821793
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n    let vowels\
    \ = \"aeiou\";\n    let mut encoded = String::new();\n    for character in message.chars()\
    \ {\n        match character {\n            'a' => encoded.push(alphabet.chars().nth(2).unwrap()),\n\
    \            'e' => encoded.push(alphabet.chars().nth(4).unwrap()),\n        \
    \    'i' => encoded.push(alphabet.chars().nth(6).unwrap()),\n            'o' =>\
    \ encoded.push(alphabet.chars().nth(8).unwrap()),\n            'u' => encoded.push(alphabet.chars().nth(10).unwrap()),\n\
    \            'A' => encoded.push(alphabet.chars().nth(2).unwrap().to_uppercase().next().unwrap()),\n\
    \            'E' => encoded.push(alphabet.chars().nth(4).unwrap().to_uppercase().next().unwrap()),\n\
    \            'I' => encoded.push(alphabet.chars().nth(6).unwrap().to_uppercase().next().unwrap()),\n\
    \            'O' => encoded.push(alphabet.chars().nth(8).unwrap().to_uppercase().next().unwrap()),\n\
    \            'U' => encoded.push(alphabet.chars().nth(10).unwrap().to_uppercase().next().unwrap()),\n\
    \            _ => encoded.push(character),\n        }\n    }\n    encoded\n}\n\
    \nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmpjspu89qg.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821794
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|x| encode_letter(x)).collect()\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `encode_letter` in this scope\n -->\
    \ /tmp/tmpbtm0lqhg.rs:8:29\n  |\n8 |     message.chars().map(|x| encode_letter(x)).collect()\n\
    \  |                             ^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821794
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    if message.is_empty() {\n        return message;\n    }\n\n\
    \    let mut encoded_message = String::new();\n    for character in message.chars()\
    \ {\n        if character.is_uppercase() {\n            encoded_message.push(character.to_lowercase().next().unwrap());\n\
    \        } else if character.is_lowercase() {\n            encoded_message.push(character.to_uppercase().next().unwrap());\n\
    \        } else {\n            encoded_message.push(character);\n        }\n \
    \   }\n\n    encoded_message\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmpftz14k9_.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821794
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let message_bytes = message.into_bytes();\n    let mut encoded_bytes\
    \ = vec![];\n    for byte in message_bytes {\n        if byte >= 65 && byte <=\
    \ 90 {\n            encoded_bytes.push(byte + 32);\n        } else if byte >=\
    \ 97 && byte <= 122 {\n            encoded_bytes.push(byte - 32);\n        } else\
    \ {\n            encoded_bytes.push(byte);\n        }\n    }\n    String::from_utf8(encoded_bytes).unwrap()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmpub09g6jq.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821794
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded_message = String::from(\"\");\n    for c in\
    \ message.chars() {\n        if c.is_ascii_uppercase() {\n            encoded_message.push(c.to_ascii_lowercase());\n\
    \        } else if c.is_ascii_lowercase() {\n            encoded_message.push(c.to_ascii_uppercase());\n\
    \        } else {\n            encoded_message.push(c);\n        }\n    }\n  \
    \  encoded_message\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmpo3qt1t2k.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821794
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let encoded = message.chars().map(|x| {\n        let mut x\
    \ = x.to_ascii_lowercase();\n        if x == 'z' {\n            x = 'b';\n   \
    \     } else if x == 'y' {\n            x = 'a';\n        } else if x == 'x' {\n\
    \            x = '@';\n        } else if x == 'w' {\n            x = '9';\n  \
    \      } else if x == 'v' {\n            x = '8';\n        } else if x == 'u'\
    \ {\n            x = '7';\n        } else if x == 't' {\n            x = '6';\n\
    \        } else if x == 's' {\n            x = '5';\n        } else if x == 'r'\
    \ {\n            x = '4';\n        } else if x == 'q' {\n            x = '3';\n\
    \        } else if x == 'p' {\n            x = '2';\n        } else if x == 'o'\
    \ {\n            x = '1';\n        } else if x == 'n' {\n            x = '0';\n\
    \        } else if x == 'm' {\n            x = 'z';\n        } else if x == 'l'\
    \ {\n            x = 'y';\n        } else if x == 'k' {\n            x = 'x';\n\
    \        } else if x == 'j' {\n            x = 'w';\n        } else if x == 'i'\
    \ {\n            x = 'v';\n        } else if x == 'h' {\n            x = 'u';\n\
    \        } else if x == 'g' {\n            x = 't';\n        } else if x == 'f'\
    \ {\n            x = 's';\n        } else if x == 'e' {\n            x = 'r';\n\
    \        } else if x == 'd' {\n            x = 'q';\n        } else if x == 'c'\
    \ {\n            x = 'p';\n        } else if x == 'b' {\n            x = 'o';\n\
    \        } else if x == 'a' {\n            x = 'n';\n        }\n        let y\
    \ = x.to_as\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpgoy6158q.rs:73:3\n\
    \   |\n7  | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n8  |     let encoded = message.chars().map(|x|\
    \ {\n   |                                      - unclosed delimiter\n...\n73 |\
    \ }\n   |   ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpgoy6158q.rs:63:24\n\
    \   |\n63 |         let y = x.to_as\n   |                        ^ help: add `;`\
    \ here\n64 | }\n   | - unexpected token\n\nerror: expected one of `)`, `,`, `.`,\
    \ `?`, or an operator, found keyword `fn`\n  --> /tmp/tmpgoy6158q.rs:66:1\n  \
    \ |\n64 | }\n   |  - expected one of `)`, `,`, `.`, `?`, or an operator\n65 |\
    \ \n66 | fn main() {\n   | ^^ unexpected token\n\nerror: aborting due to 3 previous\
    \ errors\n\n"
  stdout: ''
  timestamp: 1659821794
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let v = ['a', 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n\
    \    for c in message.chars() {\n        match c {\n            'a' => result.push('c'),\n\
    \            'e' => result.push('g'),\n            'i' => result.push('k'),\n\
    \            'o' => result.push('q'),\n            'u' => result.push('s'),\n\
    \            c if v.contains(&c) => result.push(c.to_ascii_uppercase()),\n   \
    \         _ => result.push(c),\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmpzyhi_1pq.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821794
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    for ch in message.chars()\
    \ {\n        if ch.is_ascii_lowercase() {\n            result.push(ch.to_ascii_uppercase());\n\
    \        } else if ch.is_ascii_uppercase() {\n            result.push(ch.to_ascii_lowercase());\n\
    \        } else {\n            result.push(ch);\n        }\n    }\n    let mut\
    \ result: Vec<char> = result.chars().collect();\n    for ch in result.iter_mut()\
    \ {\n        if ch.is_ascii_lowercase() {\n            let mut index = 0;\n  \
    \          for ch2 in ALPHABET.chars() {\n                if ch2 == *ch {\n  \
    \                  break;\n                }\n                index += 1;\n  \
    \          }\n            index += 2;\n            index %= 26;\n            *ch\
    \ = ALPHABET.chars().nth(index).unwrap();\n        } else if ch.is_ascii_uppercase()\
    \ {\n            let mut index = 0;\n            for ch2 in ALPHABET.chars() {\n\
    \                if ch2 == *ch {\n                    break;\n               \
    \ }\n                index += 1;\n            }\n            index += 2;\n   \
    \         index %= 26;\n            *ch = ALPHABET.chars().nth(index).unwrap().to_ascii_uppercase();\n\
    \        }\n    }\n    result.iter().collect()\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `ALPHABET` in this scope\n  --> /tmp/tmpoi0v4p6b.rs:22:24\n\
    \   |\n22 |             for ch2 in ALPHABET.chars() {\n   |                  \
    \      ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `ALPHABET`\
    \ in this scope\n  --> /tmp/tmpoi0v4p6b.rs:30:19\n   |\n30 |             *ch =\
    \ ALPHABET.chars().nth(index).unwrap();\n   |                   ^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `ALPHABET` in this scope\n\
    \  --> /tmp/tmpoi0v4p6b.rs:33:24\n   |\n33 |             for ch2 in ALPHABET.chars()\
    \ {\n   |                        ^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `ALPHABET` in this scope\n  --> /tmp/tmpoi0v4p6b.rs:41:19\n\
    \   |\n41 |             *ch = ALPHABET.chars().nth(index).unwrap().to_ascii_uppercase();\n\
    \   |                   ^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659821794
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let message = message.as_bytes();\n    let mut result = Vec::new();\n\
    \    for &ch in message {\n        let letter = match ch {\n            b'a'..=b'z'\
    \ => ch - b'a',\n            b'A'..=b'Z' => ch - b'A',\n            _ => panic!(\"\
    only letters\"),\n        };\n        match letter {\n            b'a'..=b'y'\
    \ => result.push(b'a' + letter + 2),\n            b'z' => result.push(b'a'),\n\
    \            b'A'..=b'Y' => result.push(b'A' + letter + 2),\n            b'Z'\
    \ => result.push(b'A'),\n            _ => unreachable!(),\n        }\n    }\n\
    \    String::from_utf8(result).unwrap()\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''internal error: entered unreachable code'',
    /tmp/tmpa30yu36a.rs:21:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821794
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    String::from(\"encode message here\")\n}\n\nfn main() {\n \
    \   let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"encode message here\"`,\n right: `\"tgst\"`', /tmp/tmp31i4qid7.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821794
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut message = message.chars().peekable();\n    let mut\
    \ encoded_message = String::new();\n    while let Some(c) = message.next() {\n\
    \        if c.is_ascii_alphabetic() {\n            let mut next_char = c.to_ascii_lowercase();\n\
    \            if next_char.is_ascii_lowercase() {\n                next_char =\
    \ next_char.to_ascii_uppercase();\n            }\n            if next_char ==\
    \ 'A' || next_char == 'E' || next_char == 'I' || next_char == 'O' || next_char\
    \ == 'U' {\n                let peek = message.peek();\n                if let\
    \ Some(n) = peek {\n                    if n == &'A' || n == &'E' || n == &'I'\
    \ || n == &'O' || n == &'U' {\n                        next_char = match n {\n\
    \                            'A' => 'C',\n                            'E' => 'G',\n\
    \                            'I' => 'K',\n                            'O' => 'Q',\n\
    \                            'U' => 'W',\n                            _ => '_',\n\
    \                        };\n                        message.next();\n       \
    \             }\n                }\n            }\n            encoded_message.push(next_char);\n\
    \        } else {\n            encoded_message.push(c);\n        }\n    }\n  \
    \  encoded_message\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmpamd1fsim.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821794
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let encoded_map = \"abcdefghijklmnopqrstuvwxyz\".chars().fold(HashMap::new(),\
    \ |mut map, ch| {\n        map.insert(ch, vec![2, 4, 5, 7, 9, 11, 13, 15, 17,\
    \ 19, 21, 23]);\n        map\n    });\n    let vowels = \"aeiou\".chars().collect::<HashSet<_>>();\n\
    \    let mut result = String::new();\n    let mut iter = message.chars();\n  \
    \  while let Some(ch) = iter.next() {\n        if ch.is_uppercase() {\n      \
    \      result.push(ch.to_lowercase().next().unwrap());\n        } else if vowels.contains(&ch)\
    \ {\n            let random_picker = encoded_map.get(&ch).unwrap();\n        \
    \    let random_index = rand::thread_rng().gen_range(0, random_picker.len());\n\
    \            let shift = random_picker[random_index];\n            let mut next_char\
    \ = ch as u8 + shift;\n            if next_char > 122 {\n                next_char\
    \ = next_char - 26;\n            }\n            result.push(next_char as char);\n\
    \        } else {\n            result.push(ch);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `rand`\n\
    \  --> /tmp/tmp01vizfqg.rs:20:32\n   |\n20 |             let random_index = rand::thread_rng().gen_range(0,\
    \ random_picker.len());\n   |                                ^^^^ use of undeclared\
    \ crate or module `rand`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `HashMap`\n --> /tmp/tmp01vizfqg.rs:8:65\n  |\n8 |     let encoded_map\
    \ = \"abcdefghijklmnopqrstuvwxyz\".chars().fold(HashMap::new(), |mut map, ch|\
    \ {\n  |                                                                 ^^^^^^^\
    \ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 |\
    \ use std::collections::HashMap;\n  |\n\nerror[E0412]: cannot find type `HashSet`\
    \ in this scope\n  --> /tmp/tmp01vizfqg.rs:12:44\n   |\n12 |     let vowels =\
    \ \"aeiou\".chars().collect::<HashSet<_>>();\n   |                           \
    \                 ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0412, E0433.\n\
    For more information about an error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659821794
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|c| encode_char(c)).collect()\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `encode_char` in this scope\n --> /tmp/tmp_0ehw93n.rs:8:29\n\
    \  |\n8 |     message.chars().map(|c| encode_char(c)).collect()\n  |         \
    \                    ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659821794
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let alphabets = \"abcdefghijklmnopqrstuvwxyz\".to_string();\n\
    \    let mut vowels: Vec<char> = vec![];\n    let mut encoded_message = message.clone();\n\
    \    for i in message.chars() {\n        if i.is_alphabetic() {\n            encoded_message\
    \ = encoded_message.replace(i, if i.is_uppercase() {\n                i.to_lowercase().next().unwrap()\n\
    \            } else {\n                i.to_uppercase().next().unwrap()\n    \
    \        });\n        }\n        if i.is_lowercase() {\n            if alphabets.contains(i)\
    \ {\n                vowels.push(i);\n            }\n        }\n    }\n    for\
    \ i in vowels {\n        let mut temp = alphabets.find(i).unwrap() + 2;\n    \
    \    if temp > alphabets.len() {\n            temp = temp - alphabets.len();\n\
    \        }\n        encoded_message = encoded_message.replace(i, alphabets.chars().nth(temp).unwrap());\n\
    \    }\n    encoded_message\n}\n\nfn main() {\n    let candidate = encode;\n \
    \   assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n \
    \   assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsjkdi4sg.rs:14:17\n   |\n\
    14 |                 i.to_lowercase().next().unwrap()\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsjkdi4sg.rs:16:17\n\
    \   |\n16 |                 i.to_uppercase().next().unwrap()\n   |           \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpsjkdi4sg.rs:30:54\n   |\n30 |         encoded_message\
    \ = encoded_message.replace(i, alphabets.chars().nth(temp).unwrap());\n   |  \
    \                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found `char`\n\nerror: aborting due to 3 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659821794
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut v = Vec::new();\n    let mut n = 2;\n    let mut z\
    \ = 1;\n    let mut result = String::new();\n    let vowels = vec!['a', 'e', 'i',\
    \ 'o', 'u'];\n    for c in message.chars() {\n        if vowels.contains(&c) {\n\
    \            v.push(c);\n        }\n    }\n    for c in message.chars() {\n  \
    \      if c.is_lowercase() {\n            result.push(c.to_uppercase().next().unwrap());\n\
    \        } else if c.is_uppercase() {\n            result.push(c.to_lowercase().next().unwrap());\n\
    \        } else if c.is_alphabetic() {\n            result.push(v[v.len() - n].to_uppercase().next().unwrap());\n\
    \            n += 1;\n        } else {\n            result.push(c);\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmpemeywch0.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821794
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    // Save ourselves from some repetitive calculations\n    let\
    \ lower_vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let upper_vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let lower_letters = ['a', 'b', 'c', 'd', 'e', 'f',\
    \ 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',\
    \ 'w', 'x', 'y', 'z'];\n    let upper_letters = ['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n\n    // Get the index of the letter we're at\n    fn\
    \ get_index(letter: char, list: &[char]) -> usize {\n        for (i, l) in list.iter().enumerate()\
    \ {\n            if l == &letter {\n                return i;\n            }\n\
    \        }\n        // If we're here, we're not in the list\n        panic!(\"\
    Letter not in list!\");\n    }\n\n    // Create a new string and fill it\n   \
    \ let mut new_message = String::new();\n    for letter in message.chars() {\n\
    \        if lower_vowels.contains(&letter) {\n            // If it's lowercase,\
    \ replace with the letter 2 forward in the alphabet, wrapping if necessary\n \
    \           let index = get_index(letter, &lower_vowels);\n            let new_index\
    \ = (index + 2) % lower_vowels.len();\n            new_message.push(lower_vowels[new_index]);\n\
    \        } else if upper_vowels.contains(&letter) {\n            // If it's uppercase,\
    \ replace with the letter 2 forward in the alphabet, wrapping if necessary\n \
    \           let index = get_index(letter, &\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp673i3vbd.rs:45:3\n\
    \   |\n7  | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n27 |     for letter in message.chars()\
    \ {\n   |                                   - unclosed delimiter\n...\n33 |  \
    \       } else if upper_vowels.contains(&letter) {\n   |                     \
    \                             - this delimiter might not be properly closed...\n\
    ...\n36 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    45 | }\n   |   ^\n\nerror: expected expression, found `)`\n  --> /tmp/tmp673i3vbd.rs:36:1\n\
    \   |\n36 | }\n   | ^ expected expression\n\nerror: expected one of `.`, `;`,\
    \ `?`, `else`, or an operator, found `}`\n  --> /tmp/tmp673i3vbd.rs:36:1\n   |\n\
    36 | }\n   | ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nerror:\
    \ mismatched closing delimiter: `}`\n  --> /tmp/tmp673i3vbd.rs:35:34\n   |\n7\
    \  | fn encode(message: String) -> String {\n   |                            \
    \          - closing delimiter possibly meant for this\n...\n35 |            \
    \ let index = get_index(letter, &\n   |                                  ^ unclosed\
    \ delimiter\n36 | }\n   | ^ mismatched closing delimiter\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp673i3vbd.rs:27:5\n   |\n7  |   fn encode(message: String)\
    \ -> String {\n   |                                 ------ expected `String` because\
    \ of return type\n...\n27 | /     for letter in message.chars() {\n28 | |    \
    \     if lower_vowels.contains(&letter) {\n29 | |             // If it's lowercase,\
    \ replace with the letter 2 forward in the alphabet, wrapping if necessary\n30\
    \ | |             let index = get_index(letter, &lower_vowels);\n...  |\n44 |\
    \ |     assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt tO WrItE\")), String::from(\"\
    k dQnT kNqW wHcT Tq wRkTg\"));\n45 | | }\n   | |__^ expected struct `String`,\
    \ found `()`\n\nerror: aborting due to 5 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659821794
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpzpnpla0m.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821793
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut res = String::new();\n    let mut itr = message.chars();\n\
    \    while let Some(c) = itr.next() {\n        if !c.is_alphabetic() {\n     \
    \       res.push(c);\n            continue;\n        }\n        if c.is_ascii_uppercase()\
    \ {\n            res.push(c.to_ascii_lowercase());\n        } else {\n       \
    \     res.push(c.to_ascii_uppercase());\n        }\n        match c {\n      \
    \      'a' | 'e' | 'i' | 'o' | 'u' => res.push(itr.next().unwrap()),\n       \
    \     _ => res.push(c),\n        }\n    }\n    res\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"tTeEsStT\"`,\n right: `\"tgst\"`', /tmp/tmp16gbtie3.rs:30:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821794
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    // TODO\n    return String::from(\"\");\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"tgst\"`', /tmp/tmpz79_sq2d.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821794
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut chars = message.chars();\n\
    \    while let Some(c) = chars.next() {\n        let c_lower = c.to_lowercase().collect::<Vec<char>>()[0];\n\
    \        if c.is_lowercase() {\n            encoded.push(c.to_uppercase().collect::<Vec<char>>()[0]);\n\
    \        } else if c.is_uppercase() {\n            encoded.push(c_lower);\n  \
    \      } else {\n            encoded.push(c);\n        }\n        match c_lower\
    \ {\n            'a' => encoded.push('c'),\n            'e' => encoded.push('g'),\n\
    \            'i' => encoded.push('k'),\n            'o' => encoded.push('q'),\n\
    \            'u' => encoded.push('y'),\n            _ => encoded.push(c),\n  \
    \      }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"tTegsStT\"`,\n right: `\"tgst\"`', /tmp/tmpj4ky4gkj.rs:33:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821794
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let alpha = vec![\"a\", \"b\", \"c\", \"d\", \"e\", \"f\",\
    \ \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\"\
    , \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let vowels\
    \ = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut new_string = String::new();\n\
    \    let mut in_vowel = false;\n    for c in message.chars() {\n        let c_lower\
    \ = c.to_lowercase().collect::<Vec<char>>()[0];\n        let curr_char = alpha[c_lower\
    \ as usize - 97];\n        let mut in_vowel = false;\n        for vowel in vowels.iter()\
    \ {\n            if curr_char == vowel {\n                in_vowel = true;\n \
    \           }\n        }\n        if in_vowel {\n            let mut new_vowel_index\
    \ = 0;\n            for i in 0..(alpha.len() - 2) {\n                if curr_char\
    \ == alpha[i] {\n                    new_vowel_index = i + 2;\n              \
    \  }\n            }\n            new_string += alpha[new_vowel_index];\n     \
    \   } else {\n            new_string += curr_char;\n        }\n    }\n    new_string\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `str` with `&str`\n  --> /tmp/tmpl49igoew.rs:17:26\n\
    \   |\n17 |             if curr_char == vowel {\n   |                        \
    \  ^^ no implementation for `str == &str`\n   |\n   = help: the trait `PartialEq<&str>`\
    \ is not implemented for `str`\n   = note: required because of the requirements\
    \ on the impl of `PartialEq<&&str>` for `&str`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659821794
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut my_answer = String::new();\n    let mut capital = false;\n\
    \    let mut message = message.to_lowercase();\n    let vowels = [\"a\", \"e\"\
    , \"i\", \"o\", \"u\"];\n    let chars: Vec<char> = message.chars().collect();\n\
    \    let mut i = 0;\n    while i < chars.len() {\n        let mut letter = String::new();\n\
    \        letter.push(chars[i]);\n        if vowels.contains(&letter.as_str())\
    \ {\n            if i == chars.len() - 1 {\n                my_answer.push_str(chars[i].to_string().as_str());\n\
    \            } else {\n                my_answer.push_str(chars[i + 2].to_string().as_str());\n\
    \            }\n            i += 1;\n        } else {\n            if capital\
    \ {\n                my_answer.push_str(chars[i].to_string().to_uppercase().as_str());\n\
    \                capital = false;\n            } else {\n                my_answer.push_str(chars[i].to_string().as_str());\n\
    \                capital = true;\n            }\n        }\n        i += 1;\n\
    \    }\n    my_answer\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ttT\"`,\n right: `\"tgst\"`', /tmp/tmpvn5sid2r.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821794
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut a = message.chars();\n    let mut b = message.chars();\n\
    \    let mut c = message.chars();\n    let mut encoded = String::new();\n    for\
    \ i in 0..message.len() {\n        let c = a.next().unwrap();\n        let c2\
    \ = b.next().unwrap();\n        let c3 = c2.to_lowercase().collect::<Vec<char>>();\n\
    \        let c4 = c.to_lowercase().collect::<Vec<char>>();\n        let c5 = c3[0];\n\
    \        let c6 = c4[0];\n        let c7 = match c5 {\n            'a' => 'c',\n\
    \            'e' => 'g',\n            'i' => 'k',\n            'o' => 'q',\n \
    \           'u' => 'y',\n            _ => c2,\n        };\n        let c8 = match\
    \ c6 {\n            'a' => 'A',\n            'e' => 'E',\n            'i' => 'I',\n\
    \            'o' => 'O',\n            'u' => 'U',\n            _ => c,\n     \
    \   };\n        let c9 = match c6 {\n            'A' => 'a',\n            'E'\
    \ => 'e',\n            'I' => 'i',\n            'O' => 'o',\n            'U' =>\
    \ 'u',\n            _ => c,\n        };\n        encoded.push(c8);\n        encoded.push(c7);\n\
    \        encoded.push(c9);\n    }\n    encoded\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TTTEgESSSTTT\"`,\n right: `\"tgst\"`', /tmp/tmp4k_dfpj7.rs:52:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821794
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    String::from(\"\")\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"tgst\"`', /tmp/tmpyzev_yig.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821793
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let chars: Vec<char> = message.chars().collect();\n    let\
    \ mut out: Vec<char> = Vec::new();\n    for c in chars {\n        if c.is_alphabetic()\
    \ {\n            if c.is_lowercase() {\n                out.push(c.to_uppercase().to_string().chars().next().unwrap());\n\
    \            } else {\n                out.push(c.to_lowercase().to_string().chars().next().unwrap());\n\
    \            }\n        } else {\n            out.push(c);\n        }\n    }\n\
    \    let mut output: String = out.into_iter().collect();\n    for v in vec!['a',\
    \ 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'] {\n        output = output.replace(v,\
    \ \"\");\n    }\n    output\n}\n\nfn main() {\n    let candidate = encode;\n \
    \   assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n \
    \   assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"tst\"`,\n right: `\"tgst\"`', /tmp/tmpki4udo4n.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821794
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded_message = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_alphabetic() {\n            encoded_message.push(c.to_ascii_uppercase());\n\
    \        } else {\n            encoded_message.push(c);\n        }\n    }\n  \
    \  encoded_message\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmp_3sutaxw.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821794
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut encoded\
    \ = String::new();\n    for c in message.chars() {\n        if vowels.contains(&c)\
    \ {\n            encoded.push(vowels[((vowels.iter().position(|&x| x == c).unwrap()\
    \ + 2) % 5) as usize]);\n        } else if c.is_uppercase() {\n            encoded.push(c.to_lowercase().to_string().chars().next().unwrap());\n\
    \        } else {\n            encoded.push(c.to_uppercase().to_string().chars().next().unwrap());\n\
    \        }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmprwudd6b4.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821794
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let alphabet: Vec<char> = \"abcdefghijklmnopqrstuvwxyz\".chars().collect();\n\
    \    let mut encoded_message = String::new();\n    for letter in message.chars()\
    \ {\n        let index = match alphabet.iter().position(|&r| r == letter) {\n\
    \            Some(index) => index,\n            None => 0,\n        };\n     \
    \   let index = match alphabet.iter().position(|&r| r == letter.to_ascii_lowercase())\
    \ {\n            Some(index) => index,\n            None => 0,\n        };\n \
    \       let encoded_letter = match letter.is_uppercase() {\n            true =>\
    \ alphabet[(index + 2) % alphabet.len()].to_ascii_uppercase(),\n            false\
    \ => alphabet[(index + 2) % alphabet.len()],\n        };\n        encoded_message.push(encoded_letter);\n\
    \    }\n    encoded_message\n}\n\nfn main() {\n    let candidate = encode;\n \
    \   assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n \
    \   assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"VGUV\"`,\n right: `\"tgst\"`', /tmp/tmps17gpm4y.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821794
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    \"cipher\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"cipher\"`,\n right: `\"tgst\"`', /tmp/tmpzyqme_dy.rs:13:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821794
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    // https://stackoverflow.com/questions/32081808/iterate-over-chars-in-a-string-in-rust\n\
    \    let alpha: Vec<char> = \"abcdefghijklmnopqrstuvwxyz\".chars().collect();\n\
    \    let mut encoded_message = String::new();\n    for c in message.chars() {\n\
    \        if c.is_ascii_uppercase() {\n            // use alpha.iter().position\
    \ instead of alpha.iter().find_position\n            // because find_position\
    \ returns Option<(usize, char)> whereas \n            // position() returns Option<usize>\n\
    \            let pos = alpha.iter().position(|&ch| ch == c.to_ascii_lowercase()).unwrap();\n\
    \            encoded_message.push(alpha[pos]);\n        } else if c.is_ascii_lowercase()\
    \ {\n            let pos = alpha.iter().position(|&ch| ch == c).unwrap();\n  \
    \          encoded_message.push(alpha[pos].to_ascii_uppercase());\n        } else\
    \ {\n            encoded_message.push(c);\n        }\n    }\n    // https://stackoverflow.com/questions/34971539/how-do-i-replace-a-substring-within-a-string-in-rust\n\
    \    return encoded_message.replace(\"a\", \"c\").replace(\"e\", \"g\").replace(\"\
    i\", \"k\").replace(\"o\", \"q\").replace(\"u\", \"w\");\n}\n\nfn main() {\n \
    \   let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"mUDASIR\"`,\n right: `\"mWDCSKR\"`', /tmp/tmp3hwk2g47.rs:32:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821794
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    // your code here\n    let mut result: String = String::new();\n\
    \    for letter in message.chars() {\n        match letter {\n            'a'\
    \ => result.push('c'),\n            'e' => result.push('g'),\n            'i'\
    \ => result.push('k'),\n            'o' => result.push('q'),\n            'u'\
    \ => result.push('s'),\n            'A' => result.push('C'),\n            'E'\
    \ => result.push('G'),\n            'I' => result.push('K'),\n            'O'\
    \ => result.push('Q'),\n            'U' => result.push('S'),\n            _ =>\
    \ result.push(letter)\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmp66w1abcb.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821794
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpzpnpla0m.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821793
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let vowels = \"aeiouAEIOU\";\n    let chars: Vec<char> = message.chars().collect();\n\
    \    let mut result = String::new();\n    for c in chars {\n        if vowels.contains(c)\
    \ {\n            let v = (c as u8) + 2;\n            result.push(v as char);\n\
    \        } else {\n            let c = if c.is_uppercase() {\n               \
    \ c.to_lowercase().to_string()\n            } else {\n                c.to_uppercase().to_string()\n\
    \            };\n            result.push_str(&c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"tGst\"`,\n right: `\"tgst\"`', /tmp/tmpwrrtrm7y.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821794
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|c| {\n        if c.is_alphabetic() {\n\
    \            if c.is_uppercase() {\n                c.to_lowercase().collect::<Vec<char>>()[0]\n\
    \            } else {\n                c.to_uppercase().collect::<Vec<char>>()[0]\n\
    \            }\n        } else {\n            c\n        }\n    }).collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmp9dcgddz6.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821794
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    \"result\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"result\"`,\n right: `\"tgst\"`', /tmp/tmp4rtpek2s.rs:13:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821794
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let alphabets = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\",\
    \ \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\"\
    , \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let vowels\
    \ = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut encoded_string = String::new();\n\
    \    for character in message.chars() {\n        match character {\n         \
    \   'A'...'Z' => {\n                encoded_string.push(character.to_ascii_lowercase());\n\
    \            },\n            'a'...'z' => {\n                encoded_string.push(character);\n\
    \            },\n            _ => {\n                encoded_string.push(character);\n\
    \            }\n        }\n    }\n    let mut i = 0;\n    for character in encoded_string.chars()\
    \ {\n        for vowel in vowels.iter() {\n            if character == vowel.chars().next().unwrap()\
    \ {\n                encoded_string.replace_range(i..i+1, alphabets[i+2]);\n \
    \           }\n        }\n        i += 1;\n    }\n    encoded_string\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "warning: `...` range patterns are deprecated\n  --> /tmp/tmppfkqgui1.rs:13:16\n\
    \   |\n13 |             'A'...'Z' => {\n   |                ^^^ help: use `..=`\
    \ for an inclusive range\n   |\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]`\
    \ on by default\n   = warning: this is accepted in the current edition (Rust 2015)\
    \ but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nwarning: `...` range patterns are deprecated\n  --> /tmp/tmppfkqgui1.rs:16:16\n\
    \   |\n16 |             'a'...'z' => {\n   |                ^^^ help: use `..=`\
    \ for an inclusive range\n   |\n   = warning: this is accepted in the current\
    \ edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information,\
    \ see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nerror[E0502]: cannot borrow `encoded_string` as mutable because it is also borrowed\
    \ as immutable\n  --> /tmp/tmppfkqgui1.rs:28:17\n   |\n25 |     for character\
    \ in encoded_string.chars() {\n   |                      ----------------------\n\
    \   |                      |\n   |                      immutable borrow occurs\
    \ here\n   |                      immutable borrow later used here\n...\n28 |\
    \                 encoded_string.replace_range(i..i+1, alphabets[i+2]);\n   |\
    \                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ mutable\
    \ borrow occurs here\n\nerror: aborting due to previous error; 2 warnings emitted\n\
    \nFor more information about this error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1659821794
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut res = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_alphabetic() {\n            if c.is_uppercase() {\n     \
    \           res.push(c.to_lowercase().collect::<Vec<char>>()[0]);\n          \
    \  } else {\n                res.push(c.to_uppercase().collect::<Vec<char>>()[0]);\n\
    \            }\n        } else {\n            res.push(c);\n        }\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmp2z9opuiy.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821794
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let new_message = message.chars().map(|x| {\n            match\
    \ x {\n                'a' => 'c',\n                'e' => 'g',\n            \
    \    'i' => 'k',\n                'o' => 'q',\n                'u' => 'y',\n \
    \               'A' => 'C',\n                'E' => 'G',\n                'I'\
    \ => 'K',\n                'O' => 'Q',\n                'U' => 'Y',\n        \
    \        _ => if x.is_lowercase() { x.to_uppercase().next().unwrap() } else {\
    \ x.to_lowercase().next().unwrap() },\n            }\n        }).collect();\n\
    \    new_message\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"tGst\"`,\n right: `\"tgst\"`', /tmp/tmpt4qewdnl.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821794
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|x| {\n        if \"a\" <= x && x <= \"\
    z\" {\n            let offset = if x == 'y' {\n                24\n          \
    \  } else if x == 'z' {\n                25\n            } else {\n          \
    \      x as i8 - 'a' as i8 + 2\n            };\n            (offset + 'a' as i8)\
    \ as u8 as char\n        } else if \"A\" <= x && x <= \"Z\" {\n            let\
    \ offset = if x == 'Y' {\n                24\n            } else if x == 'Z' {\n\
    \                25\n            } else {\n                x as i8 - 'A' as i8\
    \ + 2\n            };\n            (offset + 'A' as i8) as u8 as char\n      \
    \  } else {\n            x\n        }\n    }).collect()\n}\n\nfn main() {\n  \
    \  let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4nd0h2lg.rs:9:19\n  |\n9 |\
    \         if \"a\" <= x && x <= \"z\" {\n  |                   ^ expected `&str`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4nd0h2lg.rs:9:29\n\
    \  |\n9 |         if \"a\" <= x && x <= \"z\" {\n  |                         \
    \    ^^^ expected `char`, found `&str`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp4nd0h2lg.rs:18:26\n   |\n18 |         } else if \"A\" <= x && x <= \"\
    Z\" {\n   |                          ^ expected `&str`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4nd0h2lg.rs:18:36\n   |\n18 |         } else\
    \ if \"A\" <= x && x <= \"Z\" {\n   |                                    ^^^ expected\
    \ `char`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659821794
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n  \"\".to_string()\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"tgst\"`', /tmp/tmpxsjexei3.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821794
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    // TODO: Implement this function\n    return message;\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmpoo5ilxsv.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821794
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded_string = String::new();\n    let vowels: Vec<char>\
    \ = vec!['a', 'e', 'i', 'o', 'u'];\n    for c in message.chars() {\n        let\
    \ mut is_vowel = false;\n        for v in vowels.iter() {\n            if c ==\
    \ *v {\n                is_vowel = true;\n                break;\n           \
    \ }\n        }\n        if is_vowel {\n            let mut char_int = ((c as u8)\
    \ + 2) as char;\n            if (char_int as u8) > (b'z') {\n                char_int\
    \ = ((char_int as u8) - 26) as char;\n            }\n            encoded_string.push(char_int);\n\
    \        } else {\n            encoded_string.push(c);\n        }\n    }\n   \
    \ encoded_string\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmpb6ewu1xs.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821794
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    // convert to ascii\n    let ascii = message.as_bytes();\n\
    \    let mut encoded = String::new();\n    for i in ascii {\n        match i {\n\
    \            // to uppercase\n            b'a'...b'z' => encoded.push(i.to_ascii_uppercase()\
    \ as char),\n            b'A'...b'Z' => encoded.push(i.to_ascii_lowercase() as\
    \ char),\n            // increase\n            // b'a' => encoded.push('c'),\n\
    \            // b'e' => encoded.push('g'),\n            // b'i' => encoded.push('k'),\n\
    \            // b'o' => encoded.push('q'),\n            // b'u' => encoded.push('y'),\n\
    \            // b'A' => encoded.push('C'),\n            // b'E' => encoded.push('G'),\n\
    \            // b'I' => encoded.push('K'),\n            // b'O' => encoded.push('Q'),\n\
    \            // b'U' => encoded.push('Y'),\n            _ => encoded.push(i as\
    \ char),\n        }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "warning: `...` range patterns are deprecated\n  --> /tmp/tmpsnpzxdlj.rs:14:17\n\
    \   |\n14 |             b'a'...b'z' => encoded.push(i.to_ascii_uppercase() as\
    \ char),\n   |                 ^^^ help: use `..=` for an inclusive range\n  \
    \ |\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n \
    \  = warning: this is accepted in the current edition (Rust 2015) but is a hard\
    \ error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nwarning: `...` range patterns are deprecated\n  --> /tmp/tmpsnpzxdlj.rs:15:17\n\
    \   |\n15 |             b'A'...b'Z' => encoded.push(i.to_ascii_lowercase() as\
    \ char),\n   |                 ^^^ help: use `..=` for an inclusive range\n  \
    \ |\n   = warning: this is accepted in the current edition (Rust 2015) but is\
    \ a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nerror[E0606]: casting `&u8` as `char` is invalid\n  --> /tmp/tmpsnpzxdlj.rs:27:31\n\
    \   |\n27 |             _ => encoded.push(i as char),\n   |                  \
    \             -^^^^^^^^\n   |                               |\n   |          \
    \                     cannot cast `&u8` as `char`\n   |                      \
    \         help: dereference the expression: `*i`\n\nerror: aborting due to previous\
    \ error; 2 warnings emitted\n\nFor more information about this error, try `rustc\
    \ --explain E0606`.\n"
  stdout: ''
  timestamp: 1659821794
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let vowels = [ 'a', 'e', 'i', 'o', 'u' ];\n    let mut message_chars\
    \ = message.chars();\n    let mut new_string = String::new();\n    while let Some(letter)\
    \ = message_chars.next() {\n        match vowels.contains(&letter) {\n       \
    \     true => {\n                match vowels.contains(&((letter as u8 + 2) as\
    \ char)) {\n                    true => new_string.push((letter as u8 + 2) as\
    \ char),\n                    false => new_string.push((letter as u8 + 3) as char),\n\
    \                }\n            },\n            false => new_string.push(letter),\n\
    \        }\n    }\n    new_string\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmptle7drfx.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821795
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|c| encode_letter(c)).collect()\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `encode_letter` in this scope\n -->\
    \ /tmp/tmp6fk5fnio.rs:8:29\n  |\n8 |     message.chars().map(|c| encode_letter(c)).collect()\n\
    \  |                             ^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821794
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    // convert to bytes\n    let mut encoded_message = message.into_bytes();\n\
    \    for i in 0..encoded_message.len() {\n        let mut char = encoded_message[i];\n\
    \        // to uppercase\n        if char >= 'a' as u8 && char <= 'z' as u8 {\n\
    \            char = char - 32;\n        }\n        // swap case\n        if char\
    \ >= 'A' as u8 && char <= 'Z' as u8 {\n            if char >= 'A' as u8 && char\
    \ <= 'M' as u8 {\n                char = char + 13;\n            } else {\n  \
    \              char = char - 13;\n            }\n        }\n        // replace\
    \ vowels\n        if char == 'A' as u8 || char == 'E' as u8 || char == 'I' as\
    \ u8 || char == 'O' as u8 || char == 'U' as u8 {\n            char = char + 2;\n\
    \        }\n        encoded_message[i] = char;\n    }\n    return String::from_utf8(encoded_message).unwrap();\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"GRFG\"`,\n right: `\"tgst\"`', /tmp/tmpoqnom1a9.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821794
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded_message = message.clone();\n    let vowels\
    \ = [65, 69, 73, 79, 85, 97, 101, 105, 111, 117];\n    for i in 0..message.len()\
    \ {\n        let index = message.chars().nth(i).unwrap() as u32;\n        if vowels.contains(&index)\
    \ {\n            let new_index = (((index - 1) % 26) + 1) + 2;\n            encoded_message.replace_range(i..i+1,\
    \ &(new_index as u8 as char).to_string());\n        } else if (65..90).contains(&index)\
    \ {\n            encoded_message.replace_range(i..i+1, &(index+32).to_string());\n\
    \        } else if (97..122).contains(&index) {\n            encoded_message.replace_range(i..i+1,\
    \ &(index-32).to_string());\n        }\n    }\n    encoded_message\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"1\\u{13}11165EST\"`,\n right: `\"tgst\"`', /tmp/tmp95ahk5r6.rs:26:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821795
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    String::from(\"A\")\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"A\"`,\n right: `\"tgst\"`', /tmp/tmpp9_9v7ys.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821794
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut cipher = String::new();\n    for i in message.chars()\
    \ {\n        match i {\n            'a' | 'A' => cipher.push('c'),\n         \
    \   'e' | 'E' => cipher.push('g'),\n            'i' | 'I' => cipher.push('k'),\n\
    \            'o' | 'O' => cipher.push('q'),\n            'u' | 'U' => cipher.push('y'),\n\
    \            'A'..='Z' => cipher.push((i as u8 + 32) as char),\n            'a'..='z'\
    \ => cipher.push((i as u8 - 32) as char),\n            _ => cipher.push(i),\n\
    \        }\n    }\n    cipher\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"myDcSkR\"`,\n right: `\"mWDCSKR\"`', /tmp/tmp95iediao.rs:27:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821795
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    //let vowels = ['a', 'e', 'i', 'o', 'u'];\n    let mut new_message\
    \ = String::new();\n    for c in message.chars() {\n        match c {\n      \
    \      'a' => new_message.push('c'),\n            'e' => new_message.push('g'),\n\
    \            'i' => new_message.push('k'),\n            'o' => new_message.push('q'),\n\
    \            'u' => new_message.push('s'),\n            'A' => new_message.push('C'),\n\
    \            'E' => new_message.push('G'),\n            'I' => new_message.push('K'),\n\
    \            'O' => new_message.push('Q'),\n            'U' => new_message.push('S'),\n\
    \            ' ' => new_message.push(' '),\n            _ => new_message.push(c),\n\
    \        }\n    }\n    new_message\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmpadjilsbe.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821795
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpzpnpla0m.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821793
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut ret = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_ascii_uppercase() {\n            let mut c = c.to_ascii_lowercase();\n\
    \            match c {\n                'a' => c = 'c',\n                'e' =>\
    \ c = 'g',\n                'i' => c = 'k',\n                'o' => c = 'q',\n\
    \                'u' => c = 's',\n                _ => {}\n            }\n   \
    \         ret.push(c);\n        } else if c.is_ascii_lowercase() {\n         \
    \   let mut c = c.to_ascii_uppercase();\n            match c {\n             \
    \   'A' => c = 'C',\n                'E' => c = 'G',\n                'I' => c\
    \ = 'K',\n                'O' => c = 'Q',\n                'U' => c = 'S',\n \
    \               _ => {}\n            }\n            ret.push(c);\n        } else\
    \ {\n            ret.push(c);\n        }\n    }\n    ret\n}\n\nfn main() {\n \
    \   let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"mSDCSKR\"`,\n right: `\"mWDCSKR\"`', /tmp/tmptw6sg8nk.rs:42:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821795
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded_msg = String::new();\n    let vowel_array =\
    \ ['a', 'e', 'i', 'o', 'u'];\n    let vowels_iter = vowel_array.iter();\n    let\
    \ mut prev_vowel_index = 0;\n    let mut index = 0;\n    let mut prev_vowel =\
    \ false;\n    for ch in message.chars() {\n        let mut letter_pos = ch as\
    \ u8;\n        if letter_pos >= 65 && letter_pos <= 90 {\n            // uppercase\n\
    \            letter_pos += 32;\n        }\n        if letter_pos >= 97 && letter_pos\
    \ <= 122 {\n            for vowel in vowels_iter {\n                if *vowel\
    \ == ch {\n                    if prev_vowel {\n                        letter_pos\
    \ = (letter_pos + 2 - 97) % 26 + 97;\n                    } else {\n         \
    \               letter_pos = (letter_pos + 1 - 97) % 26 + 97;\n              \
    \      }\n                    prev_vowel = true;\n                    break;\n\
    \                }\n            }\n            if !prev_vowel {\n            \
    \    if letter_pos >= 97 && letter_pos <= 122 {\n                    letter_pos\
    \ -= 32;\n                }\n            }\n        }\n        encoded_msg.push(letter_pos\
    \ as char);\n        index += 1;\n    }\n    encoded_msg\n}\n\nfn main() {\n \
    \   let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "warning: unused variable: `prev_vowel_index`\n  --> /tmp/tmpqac7upx0.rs:11:13\n\
    \   |\n11 |     let mut prev_vowel_index = 0;\n   |             ^^^^^^^^^^^^^^^^\
    \ help: if this is intentional, prefix it with an underscore: `_prev_vowel_index`\n\
    \   |\n   = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable\
    \ `index` is assigned to, but never used\n  --> /tmp/tmpqac7upx0.rs:12:13\n  \
    \ |\n12 |     let mut index = 0;\n   |             ^^^^^\n   |\n   = note: consider\
    \ using `_index` instead\n\nwarning: variable does not need to be mutable\n  -->\
    \ /tmp/tmpqac7upx0.rs:11:9\n   |\n11 |     let mut prev_vowel_index = 0;\n   |\
    \         ----^^^^^^^^^^^^^^^^\n   |         |\n   |         help: remove this\
    \ `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\nerror[E0382]:\
    \ use of moved value: `vowels_iter`\n   --> /tmp/tmpqac7upx0.rs:21:26\n    |\n\
    10  |     let vowels_iter = vowel_array.iter();\n    |         ----------- move\
    \ occurs because `vowels_iter` has type `std::slice::Iter<'_, char>`, which does\
    \ not implement the `Copy` trait\n...\n21  |             for vowel in vowels_iter\
    \ {\n    |                          ^^^^^^^^^^^\n    |                       \
    \   |\n    |                          `vowels_iter` moved due to this implicit\
    \ call to `.into_iter()`, in previous iteration of loop\n    |               \
    \           help: consider borrowing to avoid moving into the for loop: `&vowels_iter`\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `vowels_iter`\n\nerror: aborting due to previous error; 3 warnings emitted\n\
    \nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659821794
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|c| match c {\n        'a' => 'c',\n  \
    \      'A' => 'C',\n        'e' => 'g',\n        'E' => 'G',\n        'i' => 'k',\n\
    \        'I' => 'K',\n        'o' => 'q',\n        'O' => 'Q',\n        'u' =>\
    \ 'y',\n        'U' => 'Y',\n        ' ' => ' ',\n        a => match a.is_uppercase()\
    \ {\n            true => a.to_lowercase().to_string().chars().nth(0).unwrap(),\n\
    \            false => a.to_uppercase().to_string().chars().nth(0).unwrap(),\n\
    \        }\n    }).collect()\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"tGst\"`,\n right: `\"tgst\"`', /tmp/tmp8gk2bl2x.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821795
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_alphabetic() {\n            result.push(shift_char(c));\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `shift_char` in this scope\n  --> /tmp/tmpjcaiyr3j.rs:11:25\n\
    \   |\n11 |             result.push(shift_char(c));\n   |                    \
    \     ^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821794
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded_message = String::new();\n    let vowels =\
    \ vec!['a', 'e', 'i', 'o', 'u'];\n    for character in message.chars() {\n   \
    \     if vowels.contains(&character) {\n            encoded_message.push(vowels[(vowels.iter().position(|&x|\
    \ x == character).unwrap() + 2) % 5]);\n        } else if character.is_uppercase()\
    \ {\n            encoded_message.push(character.to_lowercase().next().unwrap());\n\
    \        } else {\n            encoded_message.push(character.to_uppercase().next().unwrap());\n\
    \        }\n    }\n    encoded_message\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmpyzvv182h.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821795
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let\
    \ mut encoded_message = String::new();\n    for char in message.chars() {\n  \
    \      let mut new_char = char;\n        if char.is_alphabetic() {\n         \
    \   if char.is_uppercase() {\n                new_char = char.to_lowercase().to_string().chars().nth(0).unwrap();\n\
    \            } else {\n                new_char = char.to_uppercase().to_string().chars().nth(0).unwrap();\n\
    \            }\n            if vowels.contains(&new_char.to_string().as_str())\
    \ {\n                new_char = get_char_two_ahead(new_char);\n            }\n\
    \        }\n        encoded_message.push(new_char);\n    }\n    encoded_message\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_char_two_ahead` in this scope\n\
    \  --> /tmp/tmpoou9hryi.rs:19:28\n   |\n19 |                 new_char = get_char_two_ahead(new_char);\n\
    \   |                            ^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821794
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded_message = String::from(\"\");\n    let mut\
    \ encoder = Encoder::new();\n    for character in message.chars() {\n        encoded_message.push(encoder.encode(character));\n\
    \    }\n    encoded_message\n}\n\nfn main() {\n    let candidate = encode;\n \
    \   assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n \
    \   assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Encoder`\n -->\
    \ /tmp/tmp2n5l415m.rs:9:23\n  |\n9 |     let mut encoder = Encoder::new();\n \
    \ |                       ^^^^^^^ use of undeclared type `Encoder`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659821794
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = message.to_string();\n    let a_code = \"\
    a\".chars().next().unwrap() as i32;\n    let z_code = \"z\".chars().next().unwrap()\
    \ as i32;\n    let vowels = \"aeiou\";\n    for c in encoded.chars_mut() {\n \
    \       // flip case\n        *c = if c.is_ascii_uppercase() {\n            c.to_ascii_lowercase()\n\
    \        } else {\n            c.to_ascii_uppercase()\n        };\n        //\
    \ check for vowels\n        if vowels.contains(c) {\n            let mut c_code\
    \ = c.to_ascii_lowercase() as i32;\n            c_code += 2;\n            // if\
    \ we go over the edge, wrap around\n            if c_code > z_code {\n       \
    \         c_code = a_code + (c_code - z_code - 1);\n            }\n          \
    \  *c = c_code as u8 as char;\n        }\n    }\n    encoded\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars_mut` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpnz_phzbt.rs:12:22\n   |\n12 |     for c in\
    \ encoded.chars_mut() {\n   |                      ^^^^^^^^^ method not found\
    \ in `String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659821794
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|c| {\n        match c {\n            'A'\
    \ | 'a' => 'C',\n            'E' | 'e' => 'G',\n            'I' | 'i' => 'K',\n\
    \            'O' | 'o' => 'Q',\n            'U' | 'u' => 'S',\n            x =>\
    \ match x.is_uppercase() {\n                true => x.to_lowercase().next().unwrap(),\n\
    \                false => x.to_uppercase().next().unwrap(),\n            }\n \
    \       }\n    }).collect()\n}\n\nfn main() {\n    let candidate = encode;\n \
    \   assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n \
    \   assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"tGst\"`,\n right: `\"tgst\"`', /tmp/tmp3b0zzgsd.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821795
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let vowels = ['a', 'e',\
    \ 'i', 'o', 'u'];\n    for c in message.chars() {\n        if vowels.contains(&c)\
    \ {\n            let new_char = next_char(c, 1);\n            result.push(next_char(new_char,\
    \ 1));\n        } else {\n            result.push(c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `next_char` in this scope\n  --> /tmp/tmp70f4bio2.rs:12:28\n\
    \   |\n12 |             let new_char = next_char(c, 1);\n   |                \
    \            ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `next_char` in this scope\n  --> /tmp/tmp70f4bio2.rs:13:25\n   |\n13 |     \
    \        result.push(next_char(new_char, 1));\n   |                         ^^^^^^^^^\
    \ help: a local variable with a similar name exists: `new_char`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821794
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    // TODO\n    \"\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"tgst\"`', /tmp/tmpwugvfup0.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821794
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|c| {\n        match c {\n            'a'\
    \ => 'c',\n            'e' => 'g',\n            'i' => 'k',\n            'o' =>\
    \ 'q',\n            'u' => 'y',\n            _ => c.to_ascii_uppercase(),\n  \
    \      }\n    }).collect()\n}\n\nfn main() {\n    let candidate = encode;\n  \
    \  assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n  \
    \  assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"));\n\
    \    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n  \
    \  assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmpo4p3199m.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821795
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for (_i, c) in message.chars().enumerate()\
    \ {\n        match c {\n            'a' | 'A' => encoded.push('c'),\n        \
    \    'e' | 'E' => encoded.push('g'),\n            'i' | 'I' => encoded.push('k'),\n\
    \            'o' | 'O' => encoded.push('q'),\n            'u' | 'U' => encoded.push('y'),\n\
    \            _ => encoded.push(c),\n        }\n    }\n    encoded\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TgST\"`,\n right: `\"tgst\"`', /tmp/tmp3k7_4bs7.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821795
- exit_code: 0
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|c| {\n        if c.is_lowercase() {\n\
    \            c.to_uppercase().next().unwrap()\n        } else if c.is_uppercase()\
    \ {\n            c.to_lowercase().next().unwrap()\n        } else {\n        \
    \    c\n        }\n    }).map(|c| {\n        match c {\n            'A' => 'C',\n\
    \            'E' => 'G',\n            'I' => 'K',\n            'O' => 'Q',\n \
    \           'U' => 'W',\n            'a' => 'c',\n            'e' => 'g',\n  \
    \          'i' => 'k',\n            'o' => 'q',\n            'u' => 'w',\n   \
    \         _ => c\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821795
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|ch| {\n        let offset = if ch.is_ascii_uppercase()\
    \ { 32 } else { 0 };\n        let mut ch = ch as u8 + offset;\n        if ch ==\
    \ 'a' as u8 { ch = 'c' as u8; }\n        else if ch == 'e' as u8 { ch = 'g' as\
    \ u8; }\n        else if ch == 'i' as u8 { ch = 'k' as u8; }\n        else if\
    \ ch == 'o' as u8 { ch = 'q' as u8; }\n        else if ch == 'u' as u8 { ch =\
    \ 'w' as u8; }\n        else if ch >= 'z' as u8 { ch -= 26; }\n        else if\
    \ ch == 'A' as u8 { ch = 'C' as u8; }\n        else if ch == 'E' as u8 { ch =\
    \ 'G' as u8; }\n        else if ch == 'I' as u8 { ch = 'K' as u8; }\n        else\
    \ if ch == 'O' as u8 { ch = 'Q' as u8; }\n        else if ch == 'U' as u8 { ch\
    \ = 'W' as u8; }\n        else if ch >= 'Z' as u8 { ch -= 26; }\n        ch -=\
    \ offset;\n        ch as char\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\":G9:\"`,\n right: `\"tgst\"`', /tmp/tmpi35wfsgs.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821795
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|c| encode_char(c)).collect()\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `encode_char` in this scope\n --> /tmp/tmp_0ehw93n.rs:8:29\n\
    \  |\n8 |     message.chars().map(|c| encode_char(c)).collect()\n  |         \
    \                    ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659821794
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut coder: HashMap<char, char> = HashMap::new();\n    let\
    \ mut viter = \"aeiou\".chars();\n    coder.insert('a', viter.next().unwrap());\n\
    \    coder.insert('e', viter.next().unwrap());\n    coder.insert('i', viter.next().unwrap());\n\
    \    coder.insert('o', viter.next().unwrap());\n    coder.insert('u', viter.next().unwrap());\n\
    \    let mut rv = String::new();\n    for c in message.chars() {\n        if coder.contains_key(&c)\
    \ {\n            rv.push(coder[&c]);\n        } else if coder.contains_key(&c.to_lowercase().nth(0).unwrap())\
    \ {\n            rv.push(coder[&c.to_lowercase().nth(0).unwrap()].to_uppercase().nth(0).unwrap());\n\
    \        } else {\n            rv.push(c);\n        }\n    }\n    rv\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n --> /tmp/tmpxq5qo_os.rs:8:20\n\
    \  |\n8 |     let mut coder: HashMap<char, char> = HashMap::new();\n  |      \
    \              ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashMap`\n --> /tmp/tmpxq5qo_os.rs:8:42\n\
    \  |\n8 |     let mut coder: HashMap<char, char> = HashMap::new();\n  |      \
    \                                    ^^^^^^^ not found in this scope\n  |\nhelp:\
    \ consider importing this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0412, E0433.\nFor more information about an error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659821795
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    // TODO: implement this\n    message\n}\n\nfn main() {\n  \
    \  let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmph00ify4z.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821795
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n    message.chars().map(|x|\
    \ {\n        match x {\n            'a'...'z' => {\n                let index\
    \ = (alphabet.find(x).unwrap() + 2) % 26;\n                alphabet.chars().nth(index).unwrap()\n\
    \            },\n            'A'...'Z' => {\n                let index = (alphabet.to_uppercase().find(x).unwrap()\
    \ + 2) % 26;\n                alphabet.to_uppercase().chars().nth(index).unwrap()\n\
    \            },\n            _ => x\n        }\n    }).collect()\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"VGUV\"`,\n right: `\"tgst\"`', /tmp/tmpx54974t8.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821795
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut chars: Vec<char> = message.chars().collect();\n   \
    \ for i in 0..chars.len() {\n        let ch = chars[i];\n        if ch.is_alphabetic()\
    \ {\n            chars[i] = if ch.is_uppercase() {\n                ch.to_lowercase().nth(0).unwrap()\n\
    \            } else {\n                ch.to_uppercase().nth(0).unwrap()\n   \
    \         };\n            match ch {\n                'a' | 'e' | 'i' | 'o' |\
    \ 'u' => {\n                    chars[i] = ALPHABET[(ALPHABET.iter().position(|&c|\
    \ c == chars[i]).unwrap() + 2) % 26];\n                },\n                _ =>\
    \ {}\n            }\n        }\n    }\n    return chars.into_iter().collect();\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `ALPHABET` in this scope\n  --> /tmp/tmpjdmf62uu.rs:19:32\n\
    \   |\n19 |                     chars[i] = ALPHABET[(ALPHABET.iter().position(|&c|\
    \ c == chars[i]).unwrap() + 2) % 26];\n   |                                ^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `ALPHABET` in this\
    \ scope\n  --> /tmp/tmpjdmf62uu.rs:19:42\n   |\n19 |                     chars[i]\
    \ = ALPHABET[(ALPHABET.iter().position(|&c| c == chars[i]).unwrap() + 2) % 26];\n\
    \   |                                          ^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821795
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|x| \n        match x {\n            'a'\
    \ => 'c',\n            'e' => 'g',\n            'i' => 'k',\n            'o' =>\
    \ 'q',\n            'u' => 'y',\n            _ => x.to_uppercase().next().unwrap()\n\
    \        }\n    ).collect()\n}\n\nfn main() {\n    let candidate = encode;\n \
    \   assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n \
    \   assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmpkq_8it4a.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821795
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|x| match x {\n        'a' => 'c',\n  \
    \      'e' => 'g',\n        'i' => 'k',\n        'o' => 'q',\n        'u' => 'w',\n\
    \        'A' => 'C',\n        'E' => 'G',\n        'I' => 'K',\n        'O' =>\
    \ 'Q',\n        'U' => 'W',\n        _ => x.to_ascii_uppercase(),\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmpz8esda64.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821795
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded_message = String::from(\"\");\n    let mut\
    \ alpha_vec = Vec::new();\n    for i in 97..=122 {\n        alpha_vec.push(i as\
    \ char);\n    }\n    for i in 0..message.len() {\n        let mut ch = message.chars().nth(i).unwrap();\n\
    \        if ch.is_lowercase() {\n            ch = ch.to_uppercase().next().unwrap();\n\
    \        } else if ch.is_uppercase() {\n            ch = ch.to_lowercase().next().unwrap();\n\
    \        }\n        if alpha_vec.contains(&ch) {\n            let idx = alpha_vec.iter().position(|&r|\
    \ r == ch).unwrap();\n            if ch == 'u' {\n                ch = 'A';\n\
    \            } else if ch == 'U' {\n                ch = 'a';\n            } else\
    \ {\n                let idx = alpha_vec.iter().position(|&r| r == ch).unwrap();\n\
    \                let new_char = alpha_vec.get(idx + 2).unwrap();\n           \
    \     ch = *new_char;\n            }\n        }\n        encoded_message.push(ch);\n\
    \    }\n    encoded_message\n}\n\nfn main() {\n    let candidate = encode;\n \
    \   assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n \
    \   assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0604]: only `u8` can be cast as `char`, not `i32`\n  --> /tmp/tmp5yx9b59x.rs:11:24\n\
    \   |\n11 |         alpha_vec.push(i as char);\n   |                        ^^^^^^^^^\
    \ invalid cast\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0604`.\n"
  stdout: ''
  timestamp: 1659821795
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    for c in message.chars() {\n        if c.is_lowercase()\
    \ {\n            encoded.push(c.to_uppercase().next().unwrap());\n        } else\
    \ if c.is_uppercase() {\n            encoded.push(c.to_lowercase().next().unwrap());\n\
    \        } else {\n            encoded.push(c);\n        }\n    }\n    for v in\
    \ vowels {\n        let old_v = encoded.find(v);\n        if old_v != None {\n\
    \            encoded.remove(old_v.unwrap());\n            let next_v = old_v.unwrap()\
    \ + 2;\n            encoded.insert(next_v, v);\n        }\n    }\n    encoded\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"tste\"`,\n right: `\"tgst\"`', /tmp/tmpgtx7_9iq.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821795
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let vowels = ['a', 'e',\
    \ 'i', 'o', 'u'];\n    for c in message.chars() {\n        if c.is_ascii_uppercase()\
    \ {\n            encoded.push(c.to_ascii_lowercase());\n        } else if c.is_ascii_lowercase()\
    \ {\n            encoded.push(c.to_ascii_uppercase());\n        } else {\n   \
    \         encoded.push(c);\n        }\n    }\n    encoded\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmpk0jkajwr.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821795
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let my_dict = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let\
    \ mut new_message = \"\".to_string();\n    for c in message.chars() {\n      \
    \  let mut new_char = c;\n        if c.is_alphabetic() {\n            if c.is_uppercase()\
    \ {\n                new_char = c.to_lowercase().next().unwrap();\n          \
    \  } else {\n                new_char = c.to_uppercase().next().unwrap();\n  \
    \          }\n            let index = my_dict.iter().position(|&r| r == new_char.to_string().as_str());\n\
    \            match index {\n                Some(n) => {\n                   \
    \ let next_letter = ((n + 2) % 5) as usize;\n                    new_char = my_dict[next_letter].chars().next().unwrap();\n\
    \                },\n                None => ()\n            }\n        }\n  \
    \      new_message.push(new_char);\n    }\n    new_message\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"tost\"`,\n right: `\"tgst\"`', /tmp/tmp93jw_2qv.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821795
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    ;\n    let mut alphabet_char = alphabet.chars();\n    let mut alphabet_index =\
    \ 1;\n    let mut vowel_index: usize = 0;\n    let vowels = \"aeiou\";\n    let\
    \ mut vowels_char = vowels.chars();\n    for character in message.chars() {\n\
    \        if vowels_char.next() == Some(character) {\n            let vowel_char\
    \ = match alphabet_char.nth(vowel_index + 2) {\n                Some(c) => c,\n\
    \                None => alphabet_char.nth(0).unwrap(),\n            };\n    \
    \        encoded.push(vowel_char);\n            vowel_index = 0;\n           \
    \ alphabet_char = alphabet.chars();\n        } else {\n            encoded.push(match\
    \ character.is_uppercase() {\n                true => alphabet_char.nth(alphabet_index).unwrap().to_uppercase().next().unwrap(),\n\
    \                false => alphabet_char.nth(alphabet_index).unwrap(),\n      \
    \      });\n            alphabet_index += 1;\n            vowel_index += 1;\n\
    \        }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"BEIN\"`,\n right: `\"tgst\"`', /tmp/tmpjmesglan.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821795
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|c| {\n        match c {\n            'a'\
    \ => 'c',\n            'e' => 'g',\n            'i' => 'k',\n            'o' =>\
    \ 'q',\n            'u' => 'y',\n            'A' => 'C',\n            'E' => 'G',\n\
    \            'I' => 'K',\n            'O' => 'Q',\n            'U' => 'Y',\n \
    \           c => {\n                if c.is_ascii_lowercase() {\n            \
    \        c.to_ascii_uppercase()\n                } else {\n                  \
    \  c.to_ascii_lowercase()\n                }\n            }\n        }\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"tGst\"`,\n right: `\"tgst\"`', /tmp/tmpw34hthf1.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821795
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    return message;\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmp005_kvwh.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821795
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    return String::new();\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"tgst\"`', /tmp/tmpbah9tlre.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821795
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::from(\"\");\n    for c in message.chars()\
    \ {\n        if is_vowel(c) {\n            result.push(next_letter(c, 2));\n \
    \       } else if is_lowercase(c) {\n            result.push(c.to_uppercase().next().unwrap());\n\
    \        } else {\n            result.push(c.to_lowercase().next().unwrap());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp8ut84zh8.rs:10:12\n\
    \   |\n10 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `next_letter` in this scope\n  -->\
    \ /tmp/tmp8ut84zh8.rs:11:25\n   |\n11 |             result.push(next_letter(c,\
    \ 2));\n   |                         ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_lowercase` in this scope\n  --> /tmp/tmp8ut84zh8.rs:12:19\n\
    \   |\n12 |         } else if is_lowercase(c) {\n   |                   ^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821795
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let vowel_shift = [b'a', b'e', b'i', b'o', b'u'];\n    let\
    \ mut encoded = Vec::new();\n    for b in message.as_bytes() {\n        let mut\
    \ b = b.clone();\n        if *b >= b'a' && *b <= b'z' {\n            b += b'A'\
    \ - b'a';\n        }\n        else if *b >= b'A' && *b <= b'Z' {\n           \
    \ b += b'a' - b'A';\n        }\n        if vowel_shift.contains(&b) {\n      \
    \      b += 2;\n        }\n        encoded.push(b);\n    }\n    String::from_utf8(encoded).unwrap()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0614]: type `u8` cannot be dereferenced\n  --> /tmp/tmp5jyh73t_.rs:12:12\n\
    \   |\n12 |         if *b >= b'a' && *b <= b'z' {\n   |            ^^\n\nerror[E0614]:\
    \ type `u8` cannot be dereferenced\n  --> /tmp/tmp5jyh73t_.rs:12:26\n   |\n12\
    \ |         if *b >= b'a' && *b <= b'z' {\n   |                          ^^\n\n\
    error[E0614]: type `u8` cannot be dereferenced\n  --> /tmp/tmp5jyh73t_.rs:15:17\n\
    \   |\n15 |         else if *b >= b'A' && *b <= b'Z' {\n   |                 ^^\n\
    \nerror[E0614]: type `u8` cannot be dereferenced\n  --> /tmp/tmp5jyh73t_.rs:15:31\n\
    \   |\n15 |         else if *b >= b'A' && *b <= b'Z' {\n   |                 \
    \              ^^\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659821795
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    for c in message.chars()\
    \ {\n        if is_lowercase_vowel(c) {\n            result.push(next_vowel(c));\n\
    \        } else if is_uppercase_vowel(c) {\n            result.push(next_vowel(c).to_uppercase().next().unwrap());\n\
    \        } else if is_lowercase_letter(c) {\n            result.push(c.to_uppercase().next().unwrap());\n\
    \        } else if is_uppercase_letter(c) {\n            result.push(c.to_lowercase().next().unwrap());\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_lowercase_vowel` in this scope\n\
    \  --> /tmp/tmp_qyh1ysu.rs:10:12\n   |\n10 |         if is_lowercase_vowel(c)\
    \ {\n   |            ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `next_vowel` in this scope\n  --> /tmp/tmp_qyh1ysu.rs:11:25\n\
    \   |\n11 |             result.push(next_vowel(c));\n   |                    \
    \     ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `is_uppercase_vowel` in this scope\n  --> /tmp/tmp_qyh1ysu.rs:12:19\n   |\n\
    12 |         } else if is_uppercase_vowel(c) {\n   |                   ^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `next_vowel` in\
    \ this scope\n  --> /tmp/tmp_qyh1ysu.rs:13:25\n   |\n13 |             result.push(next_vowel(c).to_uppercase().next().unwrap());\n\
    \   |                         ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_lowercase_letter` in this scope\n  --> /tmp/tmp_qyh1ysu.rs:14:19\n\
    \   |\n14 |         } else if is_lowercase_letter(c) {\n   |                 \
    \  ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `is_uppercase_letter` in this scope\n  --> /tmp/tmp_qyh1ysu.rs:16:19\n   |\n\
    16 |         } else if is_uppercase_letter(c) {\n   |                   ^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 6 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821795
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    String::from(\"Encoded Message\")\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Encoded Message\"`,\n right: `\"tgst\"`', /tmp/tmpff6mwxp0.rs:13:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821795
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n\tmessage.chars().map(|c| {\n\t\tif c.is_ascii_alphabetic() {\n\
    \t\t\tmatch c {\n\t\t\t\t'a' => 'c',\n\t\t\t\t'e' => 'g',\n\t\t\t\t'i' => 'k',\n\
    \t\t\t\t'o' => 'q',\n\t\t\t\t'u' => 'y',\n\t\t\t\t'A' => 'C',\n\t\t\t\t'E' =>\
    \ 'G',\n\t\t\t\t'I' => 'K',\n\t\t\t\t'O' => 'Q',\n\t\t\t\t'U' => 'Y',\n\t\t\t\t\
    c => if c.is_ascii_uppercase() { \n\t\t\t\t\t(c as u8 + 2).to_ascii_uppercase()\n\
    \t\t\t\t} else {\n\t\t\t\t\t(c as u8 + 2).to_ascii_lowercase()\n\t\t\t\t}\n\t\t\
    \t}\n\t\t} else {\n\t\t\tc\n\t\t}\n\t}).collect()\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: `match` arms have incompatible types\n  --> /tmp/tmpxzmcrtcz.rs:21:10\n\
    \   |\n10 |               match c {\n   |               ------- `match` arms have\
    \ incompatible types\n...\n20 |                   'U' => 'Y',\n   |          \
    \                --- this and all prior arms are found to be of type `char`\n\
    21 |                   c => if c.is_ascii_uppercase() { \n   |  ______________________^\n\
    22 | |                     (c as u8 + 2).to_ascii_uppercase()\n23 | |        \
    \         } else {\n24 | |                     (c as u8 + 2).to_ascii_lowercase()\n\
    25 | |                 }\n   | |_________________^ expected `char`, found `u8`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659821795
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let lowercase_alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n\
    \    let uppercase_alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    let vowels\
    \ = \"aeiou\";\n    let mut encoded_message = String::new();\n    for character\
    \ in message.chars() {\n        if character.is_alphabetic() {\n            let\
    \ lowercase_character = character.to_lowercase().next().unwrap();\n          \
    \  if vowels.contains(lowercase_character) {\n                let mut encoded_character\
    \ = lowercase_character;\n                let mut encoded_alphabet = lowercase_alphabet;\n\
    \                if character.is_uppercase() {\n                    encoded_alphabet\
    \ = uppercase_alphabet;\n                }\n                let mut encoded_index\
    \ = 0;\n                for (index, letter) in encoded_alphabet.chars().enumerate()\
    \ {\n                    if letter == lowercase_character {\n                \
    \        encoded_index = index;\n                        break;\n            \
    \        }\n                }\n                encoded_index += 2;\n         \
    \       encoded_index %= encoded_alphabet.len();\n                for (index,\
    \ letter) in encoded_alphabet.chars().enumerate() {\n                    if index\
    \ == encoded_index {\n                        encoded_character = letter;\n  \
    \                      break;\n                    }\n                }\n    \
    \            encoded_message.push(encoded_character);\n            } else {\n\
    \                encoded_message.push(character);\n            }\n        } else\
    \ {\n            encoded_message.push(character);\n        }\n    }\n    encoded_message\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TCST\"`,\n right: `\"tgst\"`', /tmp/tmpovwblemv.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821795
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|c| c.to_string()).collect::<Vec<String>>().join(\"\
    \")\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmpfbtrl8h0.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821795
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let vowels = \"aeiou\";\n    let mut new_message = String::new();\n\
    \    for c in message.chars() {\n        match c {\n            'a' => new_message.push('c'),\n\
    \            'e' => new_message.push('g'),\n            'i' => new_message.push('k'),\n\
    \            'o' => new_message.push('q'),\n            'u' => new_message.push('s'),\n\
    \            'A' => new_message.push('C'),\n            'E' => new_message.push('G'),\n\
    \            'I' => new_message.push('K'),\n            'O' => new_message.push('Q'),\n\
    \            'U' => new_message.push('S'),\n            _ => new_message.push(c),\n\
    \        }\n    }\n    new_message\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmp3013bpgn.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821795
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded_message = String::from(\"\");\n    for ch in\
    \ message.chars() {\n        if ch.is_alphabetic() {\n            encoded_message.push(swap_char(ch));\n\
    \        } else {\n            encoded_message.push(ch);\n        }\n    }\n \
    \   encoded_message\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap_char` in this scope\n  --> /tmp/tmptk42nsy9.rs:11:34\n\
    \   |\n11 |             encoded_message.push(swap_char(ch));\n   |           \
    \                       ^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659821795
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut message = message.chars().collect::<Vec<char>>();\n\
    \    for idx in 0..message.len() {\n        match message[idx] {\n           \
    \ 'a' => message[idx] = 'c',\n            'A' => message[idx] = 'C',\n       \
    \     'e' => message[idx] = 'g',\n            'E' => message[idx] = 'G',\n   \
    \         'i' => message[idx] = 'k',\n            'I' => message[idx] = 'K',\n\
    \            'o' => message[idx] = 'q',\n            'O' => message[idx] = 'Q',\n\
    \            'u' => message[idx] = 's',\n            'U' => message[idx] = 'S',\n\
    \            'y' => message[idx] = 'a',\n            'Y' => message[idx] = 'A',\n\
    \            c if c.is_uppercase() => message[idx] = c.to_lowercase().nth(0).unwrap(),\n\
    \            c if c.is_lowercase() => message[idx] = c.to_uppercase().nth(0).unwrap(),\n\
    \            _ => {}\n        }\n    }\n    String::from_iter(message)\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no function or associated item named `from_iter` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmpoz1n4v3y.rs:28:13\n   |\n\
    28 |     String::from_iter(message)\n   |             ^^^^^^^^^ function or associated\
    \ item not found in `String`\n   |\n   = help: items from traits can only be used\
    \ if the trait is in scope\nhelp: the following trait is implemented but not in\
    \ scope; perhaps add a `use` for it:\n   |\n1  | use std::iter::FromIterator;\n\
    \   |\nhelp: there is an associated function with a similar name\n   |\n28 | \
    \    String::from_utf8(message)\n   |             ~~~~~~~~~\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659821795
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut chars = message.chars();\n    let mut ret = String::new();\n\
    \    while let Some(c) = chars.next() {\n        match c {\n            'a'...'z'\
    \ => {\n                let ch = c as u8;\n                let converted = \n\
    \                    if ch >= 110 {\n                        97 + (ch + 2 - 122)\n\
    \                    } else {\n                        ch + 2\n              \
    \      };\n                ret.push(converted as char);\n            },\n    \
    \        'A'...'Z' => {\n                let ch = c as u8;\n                let\
    \ converted = \n                    if ch >= 78 {\n                        65\
    \ + (ch + 2 - 90)\n                    } else {\n                        ch +\
    \ 2\n                    };\n                ret.push(converted as char);\n  \
    \          },\n            _ => ret.push(c),\n        }\n    }\n    ret\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpcjpc38b_.rs:26:30

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821795
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let chars = message.chars();\n    let mut result = String::new();\n\
    \    for c in chars {\n        match c {\n            'a' => result.push('c'),\n\
    \            'e' => result.push('g'),\n            'i' => result.push('k'),\n\
    \            'o' => result.push('q'),\n            'u' => result.push('s'),\n\
    \            'A' => result.push('C'),\n            'E' => result.push('G'),\n\
    \            'I' => result.push('K'),\n            'O' => result.push('Q'),\n\
    \            'U' => result.push('S'),\n            'A' ... 'Z' => result.push((c\
    \ as u8 + 32) as char),\n            'a' ... 'z' => result.push((c as u8 - 32)\
    \ as char),\n            _ => result.push(c),\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"tGst\"`,\n right: `\"tgst\"`', /tmp/tmp6oetgvwk.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821795
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    // TODO implement this function\n    let mut encoded_message\
    \ = String::new();\n    let vowels: Vec<char> = vec!['a', 'e', 'i', 'o', 'u'];\n\
    \    for character in message.chars() {\n        if vowels.contains(&character)\
    \ {\n            let index = (character as u8) - 97;\n            encoded_message.push(((index\
    \ + 2) % 26 + 97) as char);\n        } else if character.is_ascii_uppercase()\
    \ {\n            encoded_message.push(character.to_ascii_lowercase());\n     \
    \   } else {\n            encoded_message.push(character.to_ascii_uppercase());\n\
    \        }\n    }\n    encoded_message\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmp112mt2eo.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821795
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let vowels = ['a', 'e',\
    \ 'i', 'o', 'u'];\n    for c in message.chars() {\n        let encoded = if c.is_lowercase()\
    \ { c.to_uppercase().next().unwrap() }\n                        else { c.to_lowercase().next().unwrap()\
    \ };\n        let encoded = if vowels.contains(&encoded) { vowels[vowels.iter().position(|&v|\
    \ v == encoded).unwrap()+2] }\n                        else { encoded };\n   \
    \     result.push(encoded);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"tost\"`,\n right: `\"tgst\"`', /tmp/tmpzm5iwv4k.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821795
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let ascii_offset: u8\
    \ = 'a' as u8;\n    let mut chars = message.chars();\n    loop {\n        match\
    \ chars.next() {\n            Some(c) => {\n                if c.is_lowercase()\
    \ {\n                    encoded.push_str(&(c.to_ascii_uppercase().to_string()));\n\
    \                } else if c.is_uppercase() {\n                    encoded.push_str(&(c.to_ascii_lowercase().to_string()));\n\
    \                } else {\n                    encoded.push_str(&c.to_string());\n\
    \                }\n            },\n            None => break,\n        }\n  \
    \  }\n    chars = encoded.chars();\n    encoded.clear();\n    loop {\n       \
    \ match chars.next() {\n            Some(c) => {\n                if c == 'a'\
    \ {\n                    encoded.push_str(\"c\");\n                } else if c\
    \ == 'e' {\n                    encoded.push_str(\"g\");\n                } else\
    \ if c == 'i' {\n                    encoded.push_str(\"k\");\n              \
    \  } else if c == 'o' {\n                    encoded.push_str(\"q\");\n      \
    \          } else if c == 'u' {\n                    encoded.push_str(\"y\");\n\
    \                } else if c == 'A' {\n                    encoded.push_str(\"\
    C\");\n                } else if c == 'E' {\n                    encoded.push_str(\"\
    G\");\n                } else if c == 'I' {\n                    encoded.push_str(\"\
    K\");\n                } else if c == 'O' {\n                    encoded.push_str(\"\
    Q\");\n                } else if c == 'U' {\n                    encoded.push_str(\"\
    Y\");\n                } else {\n                    encoded.push_str(&c.to_string());\n\
    \                }\n            },\n            None => break,\n        }\n  \
    \  }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "warning: unused variable: `ascii_offset`\n --> /tmp/tmpu72vcrrc.rs:9:9\n\
    \  |\n9 |     let ascii_offset: u8 = 'a' as u8;\n  |         ^^^^^^^^^^^^ help:\
    \ if this is intentional, prefix it with an underscore: `_ascii_offset`\n  |\n\
    \  = note: `#[warn(unused_variables)]` on by default\n\nerror[E0502]: cannot borrow\
    \ `encoded` as mutable because it is also borrowed as immutable\n  --> /tmp/tmpu72vcrrc.rs:26:5\n\
    \   |\n25 |     chars = encoded.chars();\n   |             ------- immutable borrow\
    \ occurs here\n26 |     encoded.clear();\n   |     ^^^^^^^^^^^^^^^ mutable borrow\
    \ occurs here\n27 |     loop {\n28 |         match chars.next() {\n   |      \
    \         ----- immutable borrow later used here\n\nerror[E0502]: cannot borrow\
    \ `encoded` as mutable because it is also borrowed as immutable\n  --> /tmp/tmpu72vcrrc.rs:31:21\n\
    \   |\n25 |     chars = encoded.chars();\n   |             ------- immutable borrow\
    \ occurs here\n...\n28 |         match chars.next() {\n   |               -----\
    \ immutable borrow later used here\n...\n31 |                     encoded.push_str(\"\
    c\");\n   |                     ^^^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n\
    \nerror[E0502]: cannot borrow `encoded` as mutable because it is also borrowed\
    \ as immutable\n  --> /tmp/tmpu72vcrrc.rs:33:21\n   |\n25 |     chars = encoded.chars();\n\
    \   |             ------- immutable borrow occurs here\n...\n28 |         match\
    \ chars.next() {\n   |               ----- immutable borrow later used here\n\
    ...\n33 |                     encoded.push_str(\"g\");\n   |                 \
    \    ^^^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n\nerror[E0502]: cannot\
    \ borrow `encoded` as mutable because it is also borrowed as immutable\n  -->\
    \ /tmp/tmpu72vcrrc.rs:35:21\n   |\n25 |     chars = encoded.chars();\n   |   \
    \          ------- immutable borrow occurs here\n...\n28 |         match chars.next()\
    \ {\n   |               ----- immutable borrow later used here\n...\n35 |    \
    \                 encoded.push_str(\"k\");\n   |                     ^^^^^^^^^^^^^^^^^^^^^\
    \ mutable borrow occurs here\n\nerror[E0502]: cannot borrow `encoded` as mutable\
    \ because it"
  stdout: ''
  timestamp: 1659821795
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    return message;\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmp005_kvwh.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821795
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp4kx54535.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821795
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut cipher = String::from(\"\");\n    for i in message.as_bytes()\
    \ {\n        let mut char_value = i;\n        if char_value < 97 {\n         \
    \   if char_value == 65 {\n                char_value = 65 + 32;\n           \
    \ } else if char_value == 69 {\n                char_value = 69 + 32;\n      \
    \      } else if char_value == 73 {\n                char_value = 73 + 32;\n \
    \           } else if char_value == 79 {\n                char_value = 79 + 32;\n\
    \            } else if char_value == 85 {\n                char_value = 85 + 32;\n\
    \            }\n        } else {\n            if char_value == 97 {\n        \
    \        char_value = 97 - 32;\n            } else if char_value == 101 {\n  \
    \              char_value = 101 - 32;\n            } else if char_value == 105\
    \ {\n                char_value = 105 - 32;\n            } else if char_value\
    \ == 111 {\n                char_value = 111 - 32;\n            } else if char_value\
    \ == 117 {\n                char_value = 117 - 32;\n            }\n        }\n\
    \        cipher.push(char_value as char);\n    }\n    return cipher;\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphfswsks8.rs:11:25\n   |\n\
    11 |         if char_value < 97 {\n   |                         ^^\n   |     \
    \                    |\n   |                         expected `&u8`, found integer\n\
    \   |                         help: consider borrowing here: `&97`\n\nerror[E0277]:\
    \ can't compare `&u8` with `{integer}`\n  --> /tmp/tmphfswsks8.rs:12:27\n   |\n\
    12 |             if char_value == 65 {\n   |                           ^^ no implementation\
    \ for `&u8 == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is\
    \ not implemented for `&u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphfswsks8.rs:13:30\n\
    \   |\n13 |                 char_value = 65 + 32;\n   |                      \
    \        ^^^^^^^\n   |                              |\n   |                  \
    \            expected `&u8`, found integer\n   |                             \
    \ help: consider borrowing here: `&(65 + 32)`\n\nerror[E0277]: can't compare `&u8`\
    \ with `{integer}`\n  --> /tmp/tmphfswsks8.rs:14:34\n   |\n14 |             }\
    \ else if char_value == 69 {\n   |                                  ^^ no implementation\
    \ for `&u8 == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is\
    \ not implemented for `&u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphfswsks8.rs:15:30\n\
    \   |\n15 |                 char_value = 69 + 32;\n   |                      \
    \        ^^^^^^^\n   |                              |\n   |                  \
    \            expected `&u8`, found integer\n   |                             \
    \ help: consider borrowing here: `&(69 + 32)`\n\nerror[E0277]: can't compare `&u8`\
    \ with `{integer}`\n  --> /tmp/tmphfswsks8.rs:16:34\n   |\n16 |             }\
    \ else if char_value == 73 {\n   |                                  ^^ no implementation\
    \ for `&u8 == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is\
    \ not implemented for `&u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphfswsks8.rs:17:30\n\
    \   |\n17 |                 char_value = 73 + 32;\n   |                      \
    \        ^^^^^^^\n   |                              |\n   |                  \
    \           "
  stdout: ''
  timestamp: 1659821795
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded_string = String::from(\"\");\n    for c in\
    \ message.chars() {\n        let mut encoded_char = String::from(\"\");\n    \
    \    if c.is_lowercase() {\n            encoded_char.push(c.to_uppercase().to_string());\n\
    \        } else if c.is_uppercase() {\n            encoded_char.push(c.to_lowercase().to_string());\n\
    \        } else {\n            encoded_char.push(c.to_string());\n        }\n\
    \        encoded_string.push_str(&encoded_char);\n    }\n    encoded_string\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4qkw75iq.rs:12:31\n   |\n\
    12 |             encoded_char.push(c.to_uppercase().to_string());\n   |      \
    \                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found\
    \ struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4qkw75iq.rs:14:31\n\
    \   |\n14 |             encoded_char.push(c.to_lowercase().to_string());\n   |\
    \                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4qkw75iq.rs:16:31\n\
    \   |\n16 |             encoded_char.push(c.to_string());\n   |              \
    \                 ^^^^^^^^^^^^^ expected `char`, found struct `String`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659821795
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::from(\"\");\n    for ch in message.chars()\
    \ {\n        if ch.is_alphabetic() {\n            encoded.push(match ch {\n  \
    \              'a' => 'c',\n                'e' => 'g',\n                'i' =>\
    \ 'k',\n                'o' => 'q',\n                'u' => 'y',\n           \
    \     _ if ch.is_uppercase() => ch.to_lowercase().next().unwrap(),\n         \
    \       _ => ch.to_uppercase().next().unwrap(),\n            });\n        } else\
    \ {\n            encoded.push(ch);\n        }\n    }\n    encoded\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmpullot55t.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821795
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|c| {\n        if c.is_alphabetic() {\n\
    \            let base = match c.is_lowercase() {\n                true => b'a',\n\
    \                false => b'A',\n            };\n            let offset = if \"\
    aeiou\".contains(c) {\n                2\n            } else {\n             \
    \   0\n            };\n            (base + (c as u8 - base + offset) % 26) as\
    \ char\n        } else {\n            c\n        }\n    }).collect()\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmpwr4g1hs5.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821795
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    const ALPHABET: &'static [char] = &['a', 'b', 'c', 'd', 'e',\
    \ 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',\
    \ 'v', 'w', 'x', 'y', 'z'];\n    const VOWELS: &'static [char] = &['a', 'e', 'i',\
    \ 'o', 'u'];\n    let message_chars: Vec<char> = message.chars().collect();\n\
    \    let mut result = String::new();\n    for ch in message_chars {\n        if\
    \ ALPHABET.contains(&ch) {\n            if VOWELS.contains(&ch) {\n          \
    \      result.push(ALPHABET[((ALPHABET.iter().position(|&x| x == ch).unwrap()\
    \ + 2) % ALPHABET.len()) as usize]);\n            } else {\n                result.push(ALPHABET[((ALPHABET.iter().position(|&x|\
    \ x == ch).unwrap() + 2) % ALPHABET.len()) as usize]);\n            }\n      \
    \  } else {\n            result.push(ch);\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmp_8ei3rnw.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821795
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|x|\n        match x {\n            'a'\
    \ => 'c',\n            'e' => 'g',\n            'i' => 'k',\n            'o' =>\
    \ 'q',\n            'u' => 'w',\n            'A' => 'C',\n            'E' => 'G',\n\
    \            'I' => 'K',\n            'O' => 'Q',\n            'U' => 'W',\n \
    \           _ => x.to_ascii_uppercase(),\n        }\n    ).collect()\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmpumw96e4a.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821795
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|x| match x {\n        'A' => 'C',\n  \
    \      'E' => 'G',\n        'I' => 'K',\n        'O' => 'Q',\n        'U' => 'W',\n\
    \        'a' => 'c',\n        'e' => 'g',\n        'i' => 'k',\n        'o' =>\
    \ 'q',\n        'u' => 'w',\n        _ => x.to_uppercase().nth(0).unwrap_or(x),\n\
    \    }).collect()\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmpbxgxyj9r.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821795
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded_message = message.to_lowercase();\n    for\
    \ char in encoded_message.chars_mut() {\n        let number = if char.is_alphabetic()\
    \ {\n            char.to_digit(36).unwrap() - 9\n        } else {\n          \
    \  char.to_digit(36).unwrap()\n        };\n        char = std::char::from_digit(number,\
    \ 36).unwrap();\n    }\n    encoded_message\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars_mut` found for struct `String` in\
    \ the current scope\n --> /tmp/tmpdil3cr8z.rs:9:33\n  |\n9 |     for char in encoded_message.chars_mut()\
    \ {\n  |                                 ^^^^^^^^^ method not found in `String`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659821795
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let vowels = String::from(\"\
    AEIOUaeiou\");\n    let mut letter_count = 0;\n    for i in message.chars() {\n\
    \        match i {\n            'a'..='z' => result.push((i as u8 + 32) as char),\n\
    \            'A'..='Z' => result.push((i as u8 + 32) as char),\n            '\
    \ ' => result.push(' '),\n            _ => result.push(i),\n        }\n    }\n\
    \    for i in result.chars() {\n        match i {\n            'a' | 'e' | 'i'\
    \ | 'o' | 'u' => result.push_str(&(vowels.chars().nth(letter_count + 2).unwrap().to_string())),\n\
    \            _ => letter_count += 1,\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `result` as mutable because it is also borrowed\
    \ as immutable\n  --> /tmp/tmp9y4ts2c8.rs:21:44\n   |\n19 |     for i in result.chars()\
    \ {\n   |              --------------\n   |              |\n   |             \
    \ immutable borrow occurs here\n   |              immutable borrow later used\
    \ here\n20 |         match i {\n21 |             'a' | 'e' | 'i' | 'o' | 'u' =>\
    \ result.push_str(&(vowels.chars().nth(letter_count + 2).unwrap().to_string())),\n\
    \   |                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ mutable borrow occurs here\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1659821795
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    // TODO: implement me!\n    unimplemented!()\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp_n_co_pw.rs:9:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821795
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for letter in message.chars()\
    \ {\n        match letter {\n            'a' | 'A' => encoded.push('c'),\n   \
    \         'e' | 'E' => encoded.push('g'),\n            'i' | 'I' => encoded.push('k'),\n\
    \            'o' | 'O' => encoded.push('q'),\n            'u' | 'U' => encoded.push('y'),\n\
    \            'y' | 'Y' => encoded.push('a'),\n            ' ' => encoded.push('\
    \ '),\n            '.' => encoded.push('.'),\n            _ => encoded.push(letter),\n\
    \        }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TgST\"`,\n right: `\"tgst\"`', /tmp/tmph__h3ops.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821795
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n\tlet mut encoded = String::new();\n\tlet vowels = String::from(\"\
    aeiou\");\n\tlet s = message.chars().collect::<Vec<char>>();\n\tfor (i, c) in\
    \ s.iter().enumerate() {\n\t\tif vowels.contains(c) {\n\t\t\tlet c = match c {\n\
    \t\t\t\t'a' => 'c',\n\t\t\t\t'e' => 'g',\n\t\t\t\t'i' => 'k',\n\t\t\t\t'o' =>\
    \ 'q',\n\t\t\t\t'u' => 'y',\n\t\t\t\t_ => panic!(\"not a vowel: {}\", c),\n\t\t\
    \t};\n\t\t\tencoded.push(c);\n\t\t} else {\n\t\t\tencoded.push(s[i].to_ascii_uppercase());\n\
    \t\t}\n\t}\n\tencoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n  --> /tmp/tmpddzuft53.rs:12:22\n\
    \   |\n12 |         if vowels.contains(c) {\n   |                            ^\
    \ expected an `Fn<(char,)>` closure, found `char`\n   |\n   = help: the trait\
    \ `Fn<(char,)>` is not implemented for `char`\n   = note: required because of\
    \ the requirements on the impl of `FnOnce<(char,)>` for `&char`\n   = note: required\
    \ because of the requirements on the impl of `Pattern<'_>` for `&char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659821795
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    String::from(\"t3s7 c1d3\")\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"t3s7 c1d3\"`,\n right: `\"tgst\"`', /tmp/tmpd0wmf4qd.rs:13:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821796
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let index = |c: char| (c as u8 - b'a') as usize;\n    let mut\
    \ encoded = message.clone();\n    encoded.retain(|c| c.is_alphabetic());\n   \
    \ encoded.to_lowercase();\n    encoded.chars().map(|c| {\n        let i = index(c);\n\
    \        if \"aeiou\".contains(c) {\n            std::char::from_u32( (i + 2)\
    \ as u32 + b'a' as u32).unwrap()\n        } else {\n            c\n        }\n\
    \    }).collect()\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpz6s5ha_y.rs:8:27

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821796
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for i in message.chars()\
    \ {\n        match i {\n            'a' | 'A' => encoded.push_str(\"c\"),\n  \
    \          'e' | 'E' => encoded.push_str(\"g\"),\n            'i' | 'I' => encoded.push_str(\"\
    k\"),\n            'o' | 'O' => encoded.push_str(\"q\"),\n            'u' | 'U'\
    \ => encoded.push_str(\"s\"),\n            'y' | 'Y' => encoded.push_str(\"a\"\
    ),\n            'A' => encoded.push_str(\"C\"),\n            'E' => encoded.push_str(\"\
    G\"),\n            'I' => encoded.push_str(\"K\"),\n            'O' => encoded.push_str(\"\
    Q\"),\n            'U' => encoded.push_str(\"S\"),\n            'Y' => encoded.push_str(\"\
    A\"),\n            _ => encoded.push(i)\n        }\n    }\n    encoded\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TgST\"`,\n right: `\"tgst\"`', /tmp/tmpttv8oj5q.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821796
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let vowels = ['a', 'e',\
    \ 'i', 'o', 'u'];\n    for c in message.chars() {\n        let is_vowel = vowels.contains(&c);\n\
    \        let mut c_char = c;\n        if c.is_ascii_lowercase() {\n          \
    \  c_char = c.to_ascii_uppercase();\n        } else if c.is_ascii_uppercase()\
    \ {\n            c_char = c.to_ascii_lowercase();\n        }\n        if is_vowel\
    \ {\n            c_char = (c_char as u8 + 2) as char;\n        }\n        result.push(c_char);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmpff8lhrif.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821796
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let\
    \ alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n    message.chars().map(|c| {\n\
    \        let m = c.to_string().to_lowercase();\n        if vowels.contains(&m.as_str())\
    \ {\n            return alphabet.chars().nth((alphabet.find(m.as_str()).unwrap()\
    \ + 2) % 26).unwrap();\n        }\n        c\n    }).collect()\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TgST\"`,\n right: `\"tgst\"`', /tmp/tmpxi943dht.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821796
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for char in message.chars()\
    \ {\n        let swap_case_char = match char.is_uppercase() {\n            true\
    \ => char.to_lowercase().next().unwrap(),\n            false => char.to_uppercase().next().unwrap(),\n\
    \        };\n        let mut encoded_char = swap_case_char;\n        if is_vowel(swap_case_char)\
    \ {\n            encoded_char = swap_case_char.chars().skip(2).next().unwrap();\n\
    \        }\n        encoded.push(encoded_char);\n    }\n    encoded\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp2iag9fr4.rs:15:12\n\
    \   |\n15 |         if is_vowel(swap_case_char) {\n   |            ^^^^^^^^ not\
    \ found in this scope\n\nerror[E0599]: no method named `chars` found for type\
    \ `char` in the current scope\n  --> /tmp/tmp2iag9fr4.rs:16:43\n   |\n16 |   \
    \          encoded_char = swap_case_char.chars().skip(2).next().unwrap();\n  \
    \ |                                           ^^^^^ method not found in `char`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821795
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    return String::new();\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"tgst\"`', /tmp/tmpbah9tlre.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821795
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded_message = message.to_lowercase();\n    for\
    \ char in message.chars() {\n        if char.is_alphabetic() {\n            encoded_message.push(\n\
    \                ((char as u8) + 2) as char\n            );\n        }\n    }\n\
    \    encoded_message\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"testVGUV\"`,\n right: `\"tgst\"`', /tmp/tmpsfe782om.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821796
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut v = Vec::new();\n    for c in message.chars() {\n \
    \       let d = if c.is_lowercase() {\n            c.to_uppercase().next().unwrap()\n\
    \        } else {\n            c.to_lowercase().next().unwrap()\n        };\n\
    \        let e = match d {\n            'A' => 'C',\n            'E' => 'G',\n\
    \            'I' => 'K',\n            'O' => 'Q',\n            'U' => 'W',\n \
    \           'Y' => 'A',\n            _ => d,\n        };\n        v.push(e);\n\
    \    }\n    v.into_iter().collect()\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmpmmsnbqk5.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821796
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let vowels = \"aeiou\";\n    let mut encoded = String::new();\n\
    \    for ch in message.chars() {\n        if vowels.contains(ch) {\n         \
    \   encoded.push(next_vowel(ch));\n        } else if ch.is_uppercase() {\n   \
    \         encoded.push(ch.to_lowercase().next().unwrap());\n        } else {\n\
    \            encoded.push(ch.to_uppercase().next().unwrap());\n        }\n   \
    \ }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `next_vowel` in this scope\n  --> /tmp/tmpfyn0oxju.rs:12:26\n\
    \   |\n12 |             encoded.push(next_vowel(ch));\n   |                  \
    \        ^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821795
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|c|\n        match c {\n            'a'\
    \ ... 'z' => \n                (((c as u8) - 'a' as u8 + 2) % 26 + 'a' as u8)\
    \ as char,\n            'A' ... 'Z' => \n                (((c as u8) - 'A' as\
    \ u8 + 2) % 26 + 'A' as u8) as char,\n            _ => c\n        }\n    ).collect()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"VGUV\"`,\n right: `\"tgst\"`', /tmp/tmpvstflr8e.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821796
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut message_chars = message.chars();\n    let mut encoded_message:\
    \ String = String::new();\n    while let Some(c) = message_chars.next() {\n  \
    \      let encoded_letter = match c {\n            'a' => 'c',\n            'e'\
    \ => 'g',\n            'i' => 'k',\n            'o' => 'q',\n            'u' =>\
    \ 'y',\n            'A' => 'C',\n            'E' => 'G',\n            'I' => 'K',\n\
    \            'O' => 'Q',\n            'U' => 'Y',\n            _ => match c.is_uppercase()\
    \ {\n                true => c.to_lowercase().next().unwrap(),\n             \
    \   false => c.to_uppercase().next().unwrap(),\n            }\n        };\n  \
    \      encoded_message.push(encoded_letter);\n    }\n    encoded_message\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"tGst\"`,\n right: `\"tgst\"`', /tmp/tmpkfjyisdm.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821796
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    let mut encoded\
    \ = String::new();\n    for c in message.chars() {\n        if vowels.contains(&c)\
    \ {\n            encoded.push(((c as u8) + 2) as char);\n        } else {\n  \
    \          encoded.push(c);\n        }\n    }\n    encoded\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmpf3ekmxf9.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821796
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded_message = String::new();\n    for c in message.chars()\
    \ {\n        match c {\n            'a' => encoded_message.push('c'),\n      \
    \      'e' => encoded_message.push('g'),\n            'i' => encoded_message.push('k'),\n\
    \            'o' => encoded_message.push('q'),\n            'u' => encoded_message.push('y'),\n\
    \            'A' => encoded_message.push('C'),\n            'E' => encoded_message.push('G'),\n\
    \            'I' => encoded_message.push('K'),\n            'O' => encoded_message.push('Q'),\n\
    \            'U' => encoded_message.push('Y'),\n            _ => encoded_message.push(c),\n\
    \        }\n    }\n    encoded_message\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmpn6qjzt65.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821796
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = \"\".to_string();\n    for b in message.bytes()\
    \ {\n        if b >= 65 && b <= 90 {\n            encoded.push((b + 32) as char);\n\
    \        } else if b >= 97 && b <= 122 {\n            encoded.push((b - 32) as\
    \ char);\n        } else {\n            encoded.push(b as char);\n        }\n\
    \    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmpyd_dk4np.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821796
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = message.clone();\n    let mut idx = 0;\n\
    \    while idx < encoded.len() {\n        let curr = encoded.chars().nth(idx).unwrap();\n\
    \        if curr.is_alphabetic() {\n            let uppered = curr.to_uppercase().nth(0).unwrap();\n\
    \            let new_letter = (uppered as u8 + 2) as char;\n            if new_letter\
    \ > 'Z' {\n                let wrap_letter = (new_letter as u8 - 26) as char;\n\
    \                let _ = encoded.replace_range(idx..idx+1, &wrap_letter.to_lowercase().to_string());\n\
    \            } else {\n                let _ = encoded.replace_range(idx..idx+1,\
    \ &new_letter.to_lowercase().to_string());\n            }\n        }\n       \
    \ idx += 1;\n    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"vguv\"`,\n right: `\"tgst\"`', /tmp/tmp_2146txx.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821796
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut current = 0;\n    let mut result = String::new();\n\
    \    let vowels = [\n        'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'\n\
    \    ];\n    for letter in message.chars() {\n        if vowels.contains(&letter)\
    \ {\n            let mut code = letter as u8;\n            if code < 104 {\n \
    \               code += 2;\n            } else {\n                code -= 20;\n\
    \            }\n            result.push(code as char);\n        } else if letter.is_uppercase()\
    \ {\n            result.push(letter.to_lowercase().next().unwrap());\n       \
    \ } else {\n            result.push(letter.to_uppercase().next().unwrap());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"tGst\"`,\n right: `\"tgst\"`', /tmp/tmpaljy9twg.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821796
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded_message = String::from(\"\");\n    for (i,\
    \ character) in message.chars().enumerate() {\n        let next_letter = match\
    \ character {\n            'a' => 'c',\n            'e' => 'g',\n            'i'\
    \ => 'k',\n            'o' => 'q',\n            'u' => 'w',\n            _ =>\
    \ character\n        };\n        encoded_message.push(next_letter);\n    }\n \
    \   return encoded_message;\n}\n\nfn main() {\n    let candidate = encode;\n \
    \   assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n \
    \   assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmpiqp4_19d.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821796
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let s = message.chars().map(|c| {\n        if c.is_alphabetic()\
    \ {\n            if c.is_lowercase() {\n                c.to_uppercase().to_string()\n\
    \            } else {\n                c.to_lowercase().to_string()\n        \
    \    }\n        } else {\n            c.to_string()\n        }\n    }).collect::<String>();\n\
    \    let v = s.chars().map(|c| {\n        if c.is_alphabetic() {\n           \
    \ if c == 'a' {\n                'c'\n            } else if c == 'e' {\n     \
    \           'g'\n            } else if c == 'i' {\n                'k'\n     \
    \       } else if c == 'o' {\n                'q'\n            } else if c ==\
    \ 'u' {\n                'w'\n            } else {\n                c\n      \
    \      }\n        } else {\n            c\n        }\n    }).collect::<String>();\n\
    \    return v;\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"mUDASIR\"`,\n right: `\"mWDCSKR\"`', /tmp/tmpw9zekol8.rs:44:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821796
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    String::from(\"\")\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"tgst\"`', /tmp/tmpyzev_yig.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821793
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let vowels = \"aeiou\";\n    let consonants = \"bcdfghjklmnpqrstvwxyz\"\
    ;\n    let mut result = \"\".to_string();\n    for c in message.chars() {\n  \
    \      if c.is_ascii_lowercase() {\n            if let Some(index) = vowels.find(c)\
    \ {\n                result.push(vowels.chars().nth((index + 2) % 5).unwrap());\n\
    \            } else if let Some(index) = consonants.find(c) {\n              \
    \  result.push(consonants.chars().nth((index + 2) % 21).unwrap());\n         \
    \   }\n        } else if c.is_ascii_uppercase() {\n            if let Some(index)\
    \ = vowels.find(c.to_ascii_lowercase()) {\n                result.push(vowels.chars().nth((index\
    \ + 2) % 5).unwrap().to_ascii_uppercase());\n            } else if let Some(index)\
    \ = consonants.find(c.to_ascii_lowercase()) {\n                result.push(consonants.chars().nth((index\
    \ + 2) % 21).unwrap().to_ascii_uppercase());\n            }\n        } else {\n\
    \            result.push(c);\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"WOVW\"`,\n right: `\"tgst\"`', /tmp/tmp6nr2iorj.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821796
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|c| {\n        let upper = c.is_uppercase();\n\
    \        let mut c = c.to_lowercase().next().unwrap();\n        match c {\n  \
    \          'a' => c = 'c',\n            'e' => c = 'g',\n            'i' => c\
    \ = 'k',\n            'o' => c = 'q',\n            'u' => c = 's',\n         \
    \   _ => {}\n        }\n        if upper { c.to_uppercase().next().unwrap() }\
    \ else { c }\n    }).collect()\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmpa5ws_ru0.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821796
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    let mut encoded_message = String::new();\n    let vowels =\
    \ ['a', 'e', 'i', 'o', 'u'];\n    for c in message.chars() {\n        let next_char\
    \ = if vowels.contains(&c) {\n            match c {\n                'a' => 'c',\n\
    \                'e' => 'g',\n                'i' => 'k',\n                'o'\
    \ => 'q',\n                'u' => 'y',\n                _ => ' ',\n          \
    \  }\n        } else {\n            c\n        };\n        encoded_message.push(next_char);\n\
    \    }\n    encoded_message\n}\n\nfn main() {\n    let candidate = encode;\n \
    \   assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n \
    \   assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmpyue6y_et.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821796
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|char| {\n        let mut new_char = char;\n\
    \        if char.is_lowercase() {\n            new_char = char.to_uppercase().next().unwrap();\n\
    \        }\n        if char.is_uppercase() {\n            new_char = char.to_lowercase().next().unwrap();\n\
    \        }\n        match char {\n            'a' => 'c',\n            'e' =>\
    \ 'g',\n            'i' => 'k',\n            'o' => 'q',\n            'u' => 'y',\n\
    \            _ => new_char,\n        }\n    }).collect()\n}\n\nfn main() {\n \
    \   let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmpomk3fmbb.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821796
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|c| {\n        if c.is_lowercase() {\n\
    \            c.to_uppercase().next().unwrap()\n        } else if c.is_uppercase()\
    \ {\n            c.to_lowercase().next().unwrap()\n        } else {\n        \
    \    c\n        }\n    }).map(|c| {\n        if \"aeiou\".contains(c) {\n    \
    \        let c = c as i8 + 2;\n            if c > 122 {\n                (c -\
    \ 26) as u8 as char\n            } else {\n                c as u8 as char\n \
    \           }\n        } else {\n            c\n        }\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"mUDASIR\"`,\n right: `\"mWDCSKR\"`', /tmp/tmp66wgjc99.rs:33:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821796
