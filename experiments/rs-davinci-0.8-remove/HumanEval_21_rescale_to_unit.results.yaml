language: rs
name: HumanEval_21_rescale_to_unit
results:
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ max = numbers.iter().fold(std::f64::NEG_INFINITY, |a, b| a.max(*b));\n    let\
    \ min = numbers.iter().fold(std::f64::INFINITY, |a, b| a.min(*b));\n    let diff\
    \ = max - min;\n    let multiplier = 1.0 / diff;\n    numbers.iter().map(|x| (x\
    \ - min) * multiplier).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ (min, max) = if let Some(m) = numbers.iter().min() {\n        if let Some(M)\
    \ = numbers.iter().max() {\n            (*m, *M)\n        } else {\n         \
    \   panic!(\"No max!\");\n        }\n    } else {\n        panic!(\"No min!\"\
    );\n    };\n\n    let mut new_numbers = Vec::with_capacity(numbers.len());\n \
    \   for number in numbers {\n        new_numbers.push((number - min) / (max -\
    \ min));\n    }\n\n    new_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp63gttkk5.rs:4:54\n\
    \  |\n4 |     let (min, max) = if let Some(m) = numbers.iter().min() {\n  |  \
    \                                                    ^^^ the trait `Ord` is not\
    \ implemented for `f64`\n  |\n  = note: required because of the requirements on\
    \ the impl of `Ord` for `&f64`\n\nerror[E0277]: the trait bound `f64: Ord` is\
    \ not satisfied\n --> /tmp/tmp63gttkk5.rs:5:41\n  |\n5 |         if let Some(M)\
    \ = numbers.iter().max() {\n  |                                         ^^^ the\
    \ trait `Ord` is not implemented for `f64`\n  |\n  = note: required because of\
    \ the requirements on the impl of `Ord` for `&f64`\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659822482
- exit_code: 101
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    // Find\
    \ the maximum and minimum\n    let mut numbers = numbers;\n    numbers.sort_by(|a,\
    \ b| a.partial_cmp(b).unwrap());\n    let min = numbers[0];\n    let max = numbers[numbers.len()\
    \ - 1];\n\n    let numbers: Vec<f64> = numbers.iter().map(|&n| (n - min) / (max\
    \ - min)).collect();\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0.0, 1.0]`,\n right: `[1.0, 0.0]`', /tmp/tmp_3whtn8v.rs:17:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut result = Vec::new();\n    let (min, max) = (\n        numbers.iter().cloned().fold(f64::INFINITY,\
    \ f64::min),\n        numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max),\n\
    \    );\n    let scale = max - min;\n    for x in numbers {\n        result.push((x\
    \ - min) / scale);\n    }\n    result\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().cloned().fold(f64::MAX, f64::min);\n    let max = numbers.iter().cloned().fold(f64::MIN,\
    \ f64::max);\n    numbers.iter().map(|x| (x - min) / (max - min)).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ (min, max) = numbers.iter().fold((std::f64::MAX, std::f64::MIN), |(a, b), &x|\
    \ {\n        (cmp::min(a, x), cmp::max(b, x))\n    });\n    numbers.iter().map(|&x|\
    \ (x - min) / (max - min)).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \ --> /tmp/tmpwbnbe50m.rs:5:10\n  |\n5 |         (cmp::min(a, x), cmp::max(b,\
    \ x))\n  |          ^^^ use of undeclared crate or module `cmp`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `cmp`\n --> /tmp/tmpwbnbe50m.rs:5:26\n\
    \  |\n5 |         (cmp::min(a, x), cmp::max(b, x))\n  |                      \
    \    ^^^ use of undeclared crate or module `cmp`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659822482
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ smallest = numbers.iter().min().unwrap();\n    let largest = numbers.iter().max().unwrap();\n\
    \    let diff = *largest - *smallest;\n    numbers.iter().map(|x| {\n        if\
    \ diff == 0.0 {\n            0.0\n        } else {\n            (*x - *smallest)\
    \ / diff\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp921m2ru4.rs:4:35\n\
    \  |\n4 |     let smallest = numbers.iter().min().unwrap();\n  |             \
    \                      ^^^ the trait `Ord` is not implemented for `f64`\n  |\n\
    \  = note: required because of the requirements on the impl of `Ord` for `&f64`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp921m2ru4.rs:5:34\n\
    \  |\n5 |     let largest = numbers.iter().max().unwrap();\n  |              \
    \                    ^^^ the trait `Ord` is not implemented for `f64`\n  |\n \
    \ = note: required because of the requirements on the impl of `Ord` for `&f64`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822482
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ lv = numbers.iter().min().unwrap();\n    let rv = numbers.iter().max().unwrap();\n\
    \    let delta = rv - lv;\n    numbers.iter().map(|v| (*v - lv) / delta).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpee8ll8ur.rs:4:29\n\
    \  |\n4 |     let lv = numbers.iter().min().unwrap();\n  |                   \
    \          ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note: required\
    \ because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpee8ll8ur.rs:5:29\n\
    \  |\n5 |     let rv = numbers.iter().max().unwrap();\n  |                   \
    \          ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note: required\
    \ because of the requirements on the impl of `Ord` for `&f64`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822482
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().cloned().fold(f64::MAX, f64::min);\n    let max = numbers.iter().cloned().fold(f64::MIN,\
    \ f64::max);\n    let delta = max - min;\n    let new_max = 1.0;\n    let new_min\
    \ = 0.0;\n    let new_delta = new_max - new_min;\n    numbers.iter().map(|x| {\n\
    \        new_min + (x - min) * new_delta / delta\n    }).collect()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n    let max =\
    \ numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n    let diff = max\
    \ - min;\n    let mut result = Vec::with_capacity(numbers.len());\n    for x in\
    \ numbers {\n        result.push((x - min) / diff);\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled = numbers.clone();\n    let smallest = rescaled.iter().fold(1e20,\
    \ |a, x| a.min(*x));\n    let largest = rescaled.iter().fold(-1e20, |a, x| a.max(*x));\n\
    \    for el in rescaled.iter_mut() {\n        *el = (*el - smallest) / (largest\
    \ - smallest);\n    }\n    rescaled\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0689]: can't call method `min` on ambiguous numeric type `{float}`\n\
    \ --> /tmp/tmphggth9i1.rs:5:56\n  |\n5 |     let smallest = rescaled.iter().fold(1e20,\
    \ |a, x| a.min(*x));\n  |                                                -   \
    \    ^^^\n  |                                                |\n  |          \
    \                                      you must specify a type for this binding,\
    \ like `f32`\n\nerror[E0689]: can't call method `max` on ambiguous numeric type\
    \ `{float}`\n --> /tmp/tmphggth9i1.rs:6:56\n  |\n6 |     let largest = rescaled.iter().fold(-1e20,\
    \ |a, x| a.max(*x));\n  |                                                -   \
    \    ^^^\n  |                                                |\n  |          \
    \                                      you must specify a type for this binding,\
    \ like `f32`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0689`.\n"
  stdout: ''
  timestamp: 1659822482
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ (min, max) = (numbers.iter().cloned().min().unwrap(), numbers.iter().cloned().max().unwrap());\n\
    \    let mut scaled_numbers = Vec::with_capacity(numbers.len());\n    let (a,\
    \ b) = if min == max {\n        warn!(\"Cannot rescale to unit, min and max are\
    \ equal: {}\", min);\n        (0.0, 1.0)\n    } else {\n        (1.0 / (max -\
    \ min), -min / (max - min))\n    };\n    for number in numbers {\n        scaled_numbers.push(a\
    \ * number + b);\n    }\n    scaled_numbers\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error: cannot find macro `warn` in this scope\n --> /tmp/tmpkns2_sz5.rs:7:9\n\
    \  |\n7 |         warn!(\"Cannot rescale to unit, min and max are equal: {}\"\
    , min);\n  |         ^^^^\n  |\n  = note: `warn` is in scope, but it is an attribute:\
    \ `#[warn]`\n\nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n -->\
    \ /tmp/tmpkns2_sz5.rs:4:47\n  |\n4 |     let (min, max) = (numbers.iter().cloned().min().unwrap(),\
    \ numbers.iter().cloned().max().unwrap());\n  |                              \
    \                 ^^^ the trait `Ord` is not implemented for `f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpkns2_sz5.rs:4:87\n\
    \  |\n4 |     let (min, max) = (numbers.iter().cloned().min().unwrap(), numbers.iter().cloned().max().unwrap());\n\
    \  |                                                                         \
    \              ^^^ the trait `Ord` is not implemented for `f64`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822482
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min_number = numbers.iter().cloned().fold(f64::MAX, f64::min);\n    let max_number\
    \ = numbers.iter().cloned().fold(f64::MIN, f64::max);\n    let rescale_factor\
    \ = 1.0 / (max_number - min_number);\n    numbers.iter().map(|n| (*n - min_number)\
    \ * rescale_factor).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|x| (x - min) / (max - min)).collect()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp0elozmva.rs:4:30\n\
    \  |\n4 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp0elozmva.rs:5:30\n\
    \  |\n5 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822482
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    // find\
    \ the smallest and largest number in the list\n    let min = numbers.iter().fold(f64::INFINITY,\
    \ |acc, &x| acc.min(x));\n    let max = numbers.iter().fold(f64::NEG_INFINITY,\
    \ |acc, &x| acc.max(x));\n\n    // then, for each number in the list, rescale\
    \ it according to the formula\n    numbers.iter().map(|x| (x - min) / (max - min)).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    // error\
    \ here:\n    let min = *numbers.iter().min().unwrap();\n    let max = *numbers.iter().max().unwrap();\n\
    \    let mut result = vec![];\n    for num in numbers {\n        result.push((num\
    \ - min) / (max - min));\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp6w0lwm9w.rs:5:31\n\
    \  |\n5 |     let min = *numbers.iter().min().unwrap();\n  |                 \
    \              ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp6w0lwm9w.rs:6:31\n\
    \  |\n6 |     let max = *numbers.iter().max().unwrap();\n  |                 \
    \              ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822482
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().cloned().fold(std::f64::MAX, f64::min);\n    let max =\
    \ numbers.iter().cloned().fold(std::f64::MIN, f64::max);\n    let scale = (max\
    \ - min).recip();\n    numbers.iter().map(|&x| scale * (x - min)).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min_number = numbers.iter().min().unwrap();\n    let max_number = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|x| (x - min_number) / (max_number - min_number)).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpn4iiazuq.rs:4:37\n\
    \  |\n4 |     let min_number = numbers.iter().min().unwrap();\n  |           \
    \                          ^^^ the trait `Ord` is not implemented for `f64`\n\
    \  |\n  = note: required because of the requirements on the impl of `Ord` for\
    \ `&f64`\n\nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpn4iiazuq.rs:5:37\n\
    \  |\n5 |     let max_number = numbers.iter().max().unwrap();\n  |           \
    \                          ^^^ the trait `Ord` is not implemented for `f64`\n\
    \  |\n  = note: required because of the requirements on the impl of `Ord` for\
    \ `&f64`\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822482
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|&x| (x - min) / (max - min)).collect()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpq0_l7o9c.rs:4:30\n\
    \  |\n4 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpq0_l7o9c.rs:5:30\n\
    \  |\n5 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822482
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ max = numbers.iter().fold(f64::NEG_INFINITY, |prev, curr| if prev > *curr {\
    \ prev } else { *curr });\n    let min = numbers.iter().fold(f64::INFINITY, |prev,\
    \ curr| if prev < *curr { prev } else { *curr });\n    let scale = max - min;\n\
    \    numbers.iter().map(|n| (n - min) / scale).collect()\n}\n\nfn main() {\n \
    \   let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let diff = max - min;\n    numbers.iter().map(|x| (*x - min) / diff).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp0o36hs_5.rs:4:30\n\
    \  |\n4 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp0o36hs_5.rs:5:30\n\
    \  |\n5 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822482
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = *numbers.iter().min().unwrap();\n    let max = *numbers.iter().max().unwrap();\n\
    \    let range = max - min;\n    numbers.iter().map(|x| (x - min) / range).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpovlkvw5r.rs:4:31\n\
    \  |\n4 |     let min = *numbers.iter().min().unwrap();\n  |                 \
    \              ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpovlkvw5r.rs:5:31\n\
    \  |\n5 |     let max = *numbers.iter().max().unwrap();\n  |                 \
    \              ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822482
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let range = max - min;\n    numbers.iter().map(|number| (number - min) /\
    \ range).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n \
    \   assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpx5n1x_rq.rs:4:30\n\
    \  |\n4 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpx5n1x_rq.rs:5:30\n\
    \  |\n5 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822482
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let size = max - min;\n    numbers.iter().map(|&x| (x - min) / size).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp20ngr6sl.rs:4:30\n\
    \  |\n4 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp20ngr6sl.rs:5:30\n\
    \  |\n5 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut clone = numbers.clone();\n    let mut max = clone[0];\n    let mut min =\
    \ clone[0];\n    for n in &mut clone {\n        if *n > max {\n            max\
    \ = *n;\n        }\n        if *n < min {\n            min = *n;\n        }\n\
    \    }\n    for n in &mut clone {\n        *n = (*n - min) / (max - min);\n  \
    \  }\n    clone\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    assert!(numbers.len()\
    \ >= 2);\n    let (min, max) = numbers.iter().fold((numbers[0], numbers[0]), |(min,\
    \ max), &x| {\n        (min.min(x), max.max(x))\n    });\n    numbers.iter().map(|x|\
    \ (x - min) / (max - min)).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    assert!(numbers.len()\
    \ >= 2);\n    let (min, max) = numbers.iter().fold((numbers[0], numbers[0]), |(min,\
    \ max), x| {\n        (min.min(*x), max.max(*x))\n    });\n    let factor = 1.0\
    \ / (max - min);\n    numbers.iter().map(|&x| (x - min) * factor).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let delta = max - min;\n    numbers.iter().map(|x| (x - min) / delta).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp7grvbc_j.rs:4:30\n\
    \  |\n4 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp7grvbc_j.rs:5:30\n\
    \  |\n5 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ max_number = numbers.iter().cloned().fold(0.0 / 0.0, f64::max);\n    let min_number\
    \ = numbers.iter().cloned().fold(0.0 / 0.0, f64::min);\n    let dist = max_number\
    \ - min_number;\n    let mut ret = Vec::new();\n    for n in numbers {\n     \
    \   ret.push((n - min_number) / dist);\n    }\n    ret\n}\n\nfn main() {\n   \
    \ let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ max = numbers.iter().cloned().fold(0./0., f64::max);\n    let min = numbers.iter().cloned().fold(0./0.,\
    \ f64::min);\n    let diff = max - min;\n    numbers.iter().map(|&n| (n - min)\
    \ / diff).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    if numbers.len()\
    \ < 2 {\n        panic!(\"List length must be at least 2\")\n    }\n\n    let\
    \ min = numbers.iter().cloned().fold(f64::MAX, f64::min);\n    let max = numbers.iter().cloned().fold(f64::MIN,\
    \ f64::max);\n\n    if min == max {\n        panic!(\"Numbers are all the same\"\
    )\n    }\n\n    numbers.iter().map(|&x| (x - min) / (max - min)).collect()\n}\n\
    \nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ (min, max) = numbers.iter().fold((numbers[0], numbers[0]), |acc, x| {\n    \
    \    (acc.0.min(*x), acc.1.max(*x))\n    });\n    let factor = 1.0 / (max - min);\n\
    \    numbers.iter().map(|x| (x - min) * factor).collect()\n}\n\nfn main() {\n\
    \    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ (min, max) = numbers.iter().fold((numbers[0], numbers[0]), |(min, max), &n|\
    \ {\n        (\n            if n < min { n } else { min },\n            if n >\
    \ max { n } else { max },\n        )\n    });\n    let scale = 1.0 / (max - min);\n\
    \    numbers.iter().map(|&n| (n - min) * scale).collect()\n}\n\nfn main() {\n\
    \    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut numbers_rescaled = numbers.clone();\n    let min = numbers.iter().cloned().fold(f64::INFINITY,\
    \ f64::min);\n    let max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n\
    \    for i in 0..numbers.len() {\n        numbers_rescaled[i] = (numbers[i] -\
    \ min) / (max - min);\n    }\n    numbers_rescaled\n}\n\nfn main() {\n    let\
    \ candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0,\
    \ 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min_n = numbers.iter().min().unwrap();\n    let max_n = numbers.iter().max().unwrap();\n\
    \    let scale = 1.0 / (max_n - min_n);\n    let offset = -min_n;\n    numbers.iter().map(|n|\
    \ (n + offset) * scale).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpibhqni2t.rs:4:32\n\
    \  |\n4 |     let min_n = numbers.iter().min().unwrap();\n  |                \
    \                ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpibhqni2t.rs:5:32\n\
    \  |\n5 |     let max_n = numbers.iter().max().unwrap();\n  |                \
    \                ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    // find\
    \ the smallest and largest number\n    let (min, max) = numbers.iter().fold((*numbers.first().unwrap(),\
    \ *numbers.first().unwrap()), |acc, v| (acc.0.min(*v), acc.1.max(*v)));\n    numbers.iter().map(|v|\
    \ (*v - min) / (max - min)).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().cloned().fold(0.0 / 0.0, f64::min);\n    let max = numbers.iter().cloned().fold(0.0\
    \ / 0.0, f64::max);\n    let diff = max - min;\n    if diff < 0.00001 {\n    \
    \    numbers\n    } else {\n        numbers.iter().map(|x| (x - min) / diff).collect()\n\
    \    }\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|&n| (n - min) / (max - min)).collect()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp1ltxtup9.rs:4:30\n\
    \  |\n4 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp1ltxtup9.rs:5:30\n\
    \  |\n5 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|n| (*n - min) / (max - min)).collect()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp2sqe2ls4.rs:4:30\n\
    \  |\n4 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp2sqe2ls4.rs:5:30\n\
    \  |\n5 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|&x| (x - min) / (max - min)).collect()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpq0_l7o9c.rs:4:30\n\
    \  |\n4 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpq0_l7o9c.rs:5:30\n\
    \  |\n5 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822482
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = *numbers.iter().min().unwrap();\n    let max = *numbers.iter().max().unwrap();\n\
    \    let len = numbers.len() as f64;\n    numbers.iter().map(|n| ((n - min) /\
    \ (max - min)) * (len - 1.0)).collect()\n}\n\nfn main() {\n    let candidate =\
    \ rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpm0h5uk9u.rs:4:31\n\
    \  |\n4 |     let min = *numbers.iter().min().unwrap();\n  |                 \
    \              ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpm0h5uk9u.rs:5:31\n\
    \  |\n5 |     let max = *numbers.iter().max().unwrap();\n  |                 \
    \              ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n    let max =\
    \ numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n    let number_range\
    \ = max - min;\n    let unit_range = 1.0 - 0.0;\n    numbers.iter().map(|number|\
    \ (number - min) * unit_range / number_range).collect()\n}\n\nfn main() {\n  \
    \  let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min_val = numbers.iter().cloned().fold(0.0/0.0, f64::min);\n    let max_val\
    \ = numbers.iter().cloned().fold(0.0/0.0, f64::max);\n    let diff = max_val -\
    \ min_val;\n    if diff > 0.0 {\n        numbers.iter().map(|x| (*x - min_val)\
    \ / diff).collect()\n    } else {\n        numbers\n    }\n}\n\nfn main() {\n\
    \    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    assert!(numbers.len()\
    \ >= 2);\n    let mut result = numbers.clone();\n    let max = *result.iter().max().unwrap();\n\
    \    let min = *result.iter().min().unwrap();\n    let max_min = max - min;\n\
    \    for i in 0..result.len() {\n        result[i] = (result[i] - min) / max_min;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n \
    \   assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp9l5ne6wl.rs:6:30\n\
    \  |\n6 |     let max = *result.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp9l5ne6wl.rs:7:30\n\
    \  |\n7 |     let min = *result.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ max_value = numbers.iter().cloned().fold(0.0 / 0.0, f64::max);\n    let min_value\
    \ = numbers.iter().cloned().fold(0.0 / 0.0, f64::min);\n    numbers.iter().map(|&x|\
    \ (x - min_value) / (max_value - min_value)).collect()\n}\n\nfn main() {\n   \
    \ let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|&x| (x - min) / (max - min)).collect()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpq0_l7o9c.rs:4:30\n\
    \  |\n4 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpq0_l7o9c.rs:5:30\n\
    \  |\n5 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822482
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut scaled = numbers.clone();\n    let min = scaled.iter().cloned().fold(f64::INFINITY,\
    \ f64::min);\n    let max = scaled.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n\
    \    let scaler = |x: f64| (x - min) / (max - min);\n    scaled.iter_mut().for_each(|x|\
    \ *x = scaler(*x));\n    scaled\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    assert!(numbers.len()\
    \ >= 2);\n    let max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n\
    \    let min = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n    numbers.iter().map(|&x|\
    \ (x - min) / (max - min)).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let span = max - min;\n    numbers.iter().map(|num| (num - min) / span).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpohbh6xv6.rs:4:30\n\
    \  |\n4 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpohbh6xv6.rs:5:30\n\
    \  |\n5 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let numbers = numbers.iter().map(|&x| (x - min) / (max - min)).collect();\n\
    \    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpqs4p6qo4.rs:4:30\n\
    \  |\n4 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpqs4p6qo4.rs:5:30\n\
    \  |\n5 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n    let min\
    \ = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n    numbers.iter().map(|x|\
    \ (*x - min) / (max - min)).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min_number = numbers.iter().min().unwrap();\n    let max_number = numbers.iter().max().unwrap();\n\
    \    let range = max_number - min_number;\n    numbers.iter().map(|x| (x - min_number)\
    \ / range).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpqyed6mvs.rs:4:37\n\
    \  |\n4 |     let min_number = numbers.iter().min().unwrap();\n  |           \
    \                          ^^^ the trait `Ord` is not implemented for `f64`\n\
    \  |\n  = note: required because of the requirements on the impl of `Ord` for\
    \ `&f64`\n\nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpqyed6mvs.rs:5:37\n\
    \  |\n5 |     let max_number = numbers.iter().max().unwrap();\n  |           \
    \                          ^^^ the trait `Ord` is not implemented for `f64`\n\
    \  |\n  = note: required because of the requirements on the impl of `Ord` for\
    \ `&f64`\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut max = numbers[0];\n    let mut min = numbers[0];\n    for number in numbers.iter()\
    \ {\n        if *number > max {\n            max = *number;\n        }\n     \
    \   if *number < min {\n            min = *number;\n        }\n    }\n    let\
    \ mut rescaled = Vec::new();\n    for number in numbers.iter() {\n        rescaled.push((number\
    \ - min) / (max - min));\n    }\n    rescaled\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ length = numbers.len();\n    let (mut min, mut max) = (numbers[0], numbers[0]);\n\
    \    for i in 1..length {\n        if numbers[i] < min {\n            min = numbers[i];\n\
    \        }\n        if numbers[i] > max {\n            max = numbers[i];\n   \
    \     }\n    }\n    let mut result = Vec::with_capacity(length);\n    for i in\
    \ 0..length {\n        result.push((numbers[i] - min) / (max - min));\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut result = Vec::new();\n    let mut max = numbers[0];\n    let mut min = numbers[0];\n\
    \    for i in 0..numbers.len() {\n        if numbers[i] > max {\n            max\
    \ = numbers[i];\n        }\n        if numbers[i] < min {\n            min = numbers[i];\n\
    \        }\n    }\n    for i in 0..numbers.len() {\n        result.push((numbers[i]\
    \ - min) / (max - min));\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    assert!(numbers.len()\
    \ >= 2);\n    let min = numbers.iter().cloned().fold(numbers[0], f64::min);\n\
    \    let max = numbers.iter().cloned().fold(numbers[0], f64::max);\n    let delta\
    \ = max - min;\n    numbers.iter().map(|x| (x - min) / delta).collect()\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min_val = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n    let max_val\
    \ = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n    numbers.iter().map(|x|\
    \ (x - min_val) / (max_val - min_val)).collect()\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ (min, max) = min_max(&numbers);\n    let len = numbers.len();\n    let mut result\
    \ = vec![0.0; len];\n    for i in 0..len {\n        result[i] = (numbers[i] -\
    \ min) / (max - min);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `min_max` in this scope\n --> /tmp/tmp_snv4i00.rs:4:22\n\
    \  |\n4 |     let (min, max) = min_max(&numbers);\n  |                      ^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().cloned().fold(f64::MAX, f64::min);\n    let max = numbers.iter().cloned().fold(f64::MIN,\
    \ f64::max);\n    let scaling_factor = 1.0 / (max - min);\n    let translation_factor\
    \ = -min;\n    numbers.iter().map(|number| (number + translation_factor) * scaling_factor).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ n = numbers.len();\n    let mut f = numbers.clone();\n    let min = f.iter().fold(1e20,\
    \ |s, &x| cmp::min(s, x));\n    let max = f.iter().fold(-1e20, |s, &x| cmp::max(s,\
    \ x));\n    for i in 0..n {\n        f[i] = (f[i] - min) / (max - min);\n    }\n\
    \    f\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \ --> /tmp/tmp8hpt1hen.rs:6:43\n  |\n6 |     let min = f.iter().fold(1e20, |s,\
    \ &x| cmp::min(s, x));\n  |                                           ^^^ use\
    \ of undeclared crate or module `cmp`\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared crate or module `cmp`\n --> /tmp/tmp8hpt1hen.rs:7:44\n  |\n7 |\
    \     let max = f.iter().fold(-1e20, |s, &x| cmp::max(s, x));\n  |           \
    \                                 ^^^ use of undeclared crate or module `cmp`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min_value = numbers.iter().cloned().fold(1000000f64, f64::min);\n    let max_value\
    \ = numbers.iter().cloned().fold(-1000000f64, f64::max);\n    let spread = max_value\
    \ - min_value;\n    numbers.iter().map(|n| (n - min_value) / spread).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    if numbers.len()\
    \ < 2 {\n        panic!(\"Cannot scale less than two numbers\");\n    }\n\n  \
    \  let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \n    numbers.iter().map(|number| (number - min) / (max - min)).collect()\n}\n\
    \nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp3bjrp7lq.rs:8:30\n\
    \  |\n8 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp3bjrp7lq.rs:9:30\n\
    \  |\n9 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ max = numbers.iter().cloned().fold(0.0 / 0.0, f64::max);\n    let min = numbers.iter().cloned().fold(0.0\
    \ / 0.0, f64::min);\n    let range = max - min;\n    if range == 0.0 {\n     \
    \   vec![0.0; numbers.len()]\n    } else {\n        numbers.iter().map(|&x| (x\
    \ - min) / range).collect()\n    }\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().cloned().fold(f64::MAX, f64::min);\n    let max = numbers.iter().cloned().fold(f64::MIN,\
    \ f64::max);\n    let range = max - min;\n    numbers.iter().map(|n| (n - min)\
    \ / range).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n    let max =\
    \ numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n    numbers.iter().map(|x|\
    \ (x - min) / (max - min)).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ len = numbers.len();\n    let min = numbers.iter().min().unwrap();\n    let\
    \ max = numbers.iter().max().unwrap();\n    let range = max - min;\n    if range\
    \ == 0.0 {\n        vec![0.0; len]\n    } else {\n        numbers.iter().map(|&number|\
    \ (number - min) / range).collect()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp3lfj5ty1.rs:5:30\n\
    \  |\n5 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp3lfj5ty1.rs:6:30\n\
    \  |\n6 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ (min, max) = (numbers.iter().min().unwrap(), numbers.iter().max().unwrap());\n\
    \    numbers.iter().map(|x| (x - min) / (max - min)).collect()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpj8t2uz1k.rs:4:38\n\
    \  |\n4 |     let (min, max) = (numbers.iter().min().unwrap(), numbers.iter().max().unwrap());\n\
    \  |                                      ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n  |\n  = note: required because of the requirements on the impl of\
    \ `Ord` for `&f64`\n\nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n\
    \ --> /tmp/tmpj8t2uz1k.rs:4:69\n  |\n4 |     let (min, max) = (numbers.iter().min().unwrap(),\
    \ numbers.iter().max().unwrap());\n  |                                       \
    \                              ^^^ the trait `Ord` is not implemented for `f64`\n\
    \  |\n  = note: required because of the requirements on the impl of `Ord` for\
    \ `&f64`\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|n| (n - min) / (max - min)).collect()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpa0e_6xfh.rs:4:30\n\
    \  |\n4 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpa0e_6xfh.rs:5:30\n\
    \  |\n5 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    assert!(numbers.len()\
    \ >= 2);\n    let mut result = Vec::with_capacity(numbers.len());\n    let max\
    \ = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n    let min =\
    \ numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n    for n in numbers\
    \ {\n        if max == min {\n            result.push(0.0);\n        } else {\n\
    \            result.push((n - min) / (max - min));\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    if max != min {\n        numbers.iter().map(|n| (n - min) / (max - min)).collect()\n\
    \    } else {\n        numbers\n    }\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpf7djslyd.rs:4:30\n\
    \  |\n4 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpf7djslyd.rs:5:30\n\
    \  |\n5 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut scaled_list = numbers.clone();\n    let (min, max) = find_min_max(&scaled_list);\n\
    \    scaled_list.iter_mut().for_each(|x| {\n        *x = (*x - min) / (max - min);\n\
    \    });\n    scaled_list\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_min_max` in this scope\n --> /tmp/tmpz8lisdyb.rs:5:22\n\
    \  |\n5 |     let (min, max) = find_min_max(&scaled_list);\n  |              \
    \        ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ minimum = numbers.iter().min().unwrap();\n    let maximum = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|n| (n - minimum) / (maximum - minimum)).collect()\n}\n\
    \nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpmqx23dnv.rs:4:34\n\
    \  |\n4 |     let minimum = numbers.iter().min().unwrap();\n  |              \
    \                    ^^^ the trait `Ord` is not implemented for `f64`\n  |\n \
    \ = note: required because of the requirements on the impl of `Ord` for `&f64`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpmqx23dnv.rs:5:34\n\
    \  |\n5 |     let maximum = numbers.iter().max().unwrap();\n  |              \
    \                    ^^^ the trait `Ord` is not implemented for `f64`\n  |\n \
    \ = note: required because of the requirements on the impl of `Ord` for `&f64`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|x| (*x - min) / (max - min)).collect()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp66i6b26q.rs:4:30\n\
    \  |\n4 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp66i6b26q.rs:5:30\n\
    \  |\n5 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n    let min\
    \ = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n    let factor = 1.0\
    \ / (max - min);\n    numbers.iter().map(|x| factor * (x - min)).collect()\n}\n\
    \nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822484
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let numbers = numbers.iter().map(|n| *n * (1.0 / (*max - *min)) - *min).collect();\n\
    \    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpzpaqe7r6.rs:4:30\n\
    \  |\n4 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpzpaqe7r6.rs:5:30\n\
    \  |\n5 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ scale = 1.0 / (numbers.iter().max().unwrap() - numbers.iter().min().unwrap());\n\
    \    numbers.iter().map(|x| (x - numbers.iter().min().unwrap()) * scale).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpap1ri1n2.rs:4:39\n\
    \  |\n4 |     let scale = 1.0 / (numbers.iter().max().unwrap() - numbers.iter().min().unwrap());\n\
    \  |                                       ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n  |\n  = note: required because of the requirements on the impl of\
    \ `Ord` for `&f64`\n\nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n\
    \ --> /tmp/tmpap1ri1n2.rs:4:71\n  |\n4 |     let scale = 1.0 / (numbers.iter().max().unwrap()\
    \ - numbers.iter().min().unwrap());\n  |                                     \
    \                                  ^^^ the trait `Ord` is not implemented for\
    \ `f64`\n  |\n  = note: required because of the requirements on the impl of `Ord`\
    \ for `&f64`\n\nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n -->\
    \ /tmp/tmpap1ri1n2.rs:5:48\n  |\n5 |     numbers.iter().map(|x| (x - numbers.iter().min().unwrap())\
    \ * scale).collect()\n  |                                                ^^^ the\
    \ trait `Ord` is not implemented for `f64`\n  |\n  = note: required because of\
    \ the requirements on the impl of `Ord` for `&f64`\n\nerror: aborting due to 3\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ smallest = *numbers.iter().min().unwrap();\n    let largest = *numbers.iter().max().unwrap();\n\
    \    let diff = largest - smallest;\n    numbers.iter().map(|&x| (x - smallest)\
    \ / diff).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpnserk6z2.rs:4:36\n\
    \  |\n4 |     let smallest = *numbers.iter().min().unwrap();\n  |            \
    \                        ^^^ the trait `Ord` is not implemented for `f64`\n  |\n\
    \  = note: required because of the requirements on the impl of `Ord` for `&f64`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpnserk6z2.rs:5:35\n\
    \  |\n5 |     let largest = *numbers.iter().max().unwrap();\n  |             \
    \                      ^^^ the trait `Ord` is not implemented for `f64`\n  |\n\
    \  = note: required because of the requirements on the impl of `Ord` for `&f64`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    if numbers.len()\
    \ < 2 {\n        panic!(\"Cannot rescale a list containing less than two elements\"\
    );\n    }\n\n    let max = numbers.iter().cloned().fold(std::f64::NEG_INFINITY,\
    \ f64::max);\n    let min = numbers.iter().cloned().fold(std::f64::INFINITY, f64::min);\n\
    \n    numbers\n        .iter()\n        .map(|&x| (x - min) / (max - min))\n \
    \       .collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n \
    \   assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822484
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ max_val = numbers.iter().fold(f64::NEG_INFINITY, |acc, &x| {\n        acc.max(x)\n\
    \    });\n    let min_val = numbers.iter().fold(f64::INFINITY, |acc, &x| {\n \
    \       acc.min(x)\n    });\n    let range = max_val - min_val;\n    if range\
    \ == 0.0 {\n        // already unit value, just return it\n        return numbers\n\
    \    }\n    numbers.iter().map(|x| (*x - min_val) / range).collect()\n}\n\nfn\
    \ main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822484
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ max_val = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n    let\
    \ min_val = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n    let scaling_factor\
    \ = (max_val - min_val).recip();\n    numbers.iter().map(|x| (x - min_val) * scaling_factor).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822484
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ max = numbers.iter().fold(numbers[0], |acc, val| acc.max(*val));\n    let min\
    \ = numbers.iter().fold(numbers[0], |acc, val| acc.min(*val));\n    numbers.iter().map(|x|\
    \ (*x - min) / (max - min)).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822484
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ (min, max) = get_min_max(numbers);\n    numbers.iter().map(|number| (number\
    \ - min) / (max - min)).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_min_max` in this scope\n --> /tmp/tmpmhlpz9dh.rs:4:22\n\
    \  |\n4 |     let (min, max) = get_min_max(numbers);\n  |                    \
    \  ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut out = Vec::with_capacity(numbers.len());\n    let max = numbers.iter().cloned().fold(0.0\
    \ / 0.0, f64::max);\n    let min = numbers.iter().cloned().fold(0.0 / 0.0, f64::min);\n\
    \    for num in numbers {\n        out.push((num - min) / (max - min));\n    }\n\
    \    out\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822484
- exit_code: 101
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut numbers_copy = numbers.clone();\n    numbers_copy.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    numbers_copy.iter().map(|&x| (x - numbers_copy[0]) / (numbers_copy[numbers_copy.len()\
    \ - 1] - numbers_copy[0])).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0.0, 1.0]`,\n right: `[1.0, 0.0]`', /tmp/tmplthh7bqz.rs:12:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822484
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().cloned().fold(f64::MAX, f64::min);\n    let max = numbers.iter().cloned().fold(f64::MIN,\
    \ f64::max);\n    let range = max - min;\n    numbers.iter().map(|x| (x - min)\
    \ / range).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822484
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ max = numbers.iter().fold(f64::NEG_INFINITY, |acc, x| acc.max(*x));\n    let\
    \ min = numbers.iter().fold(f64::INFINITY, |acc, x| acc.min(*x));\n    let diff\
    \ = max - min;\n    numbers.iter().map(|x| {\n        if diff > 0.0 {\n      \
    \      (*x - min) / diff\n        } else {\n            0.0\n        }\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822484
- exit_code: 101
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut numbers = numbers;\n    let numbers_len = numbers.len();\n    assert!(numbers_len\
    \ >= 2);\n\n    numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\n    let\
    \ smallest = numbers[0];\n    let largest = numbers[numbers_len - 1];\n\n    let\
    \ scale = largest - smallest;\n\n    numbers.iter().map(|n| (n - smallest) / scale).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0.0, 1.0]`,\n right: `[1.0, 0.0]`', /tmp/tmphadtnpqz.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822484
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    if numbers.len()\
    \ == 0 {\n        return vec![];\n    }\n\n    let min = numbers.iter().fold(f64::MAX,\
    \ |x, y| x.min(*y));\n    let max = numbers.iter().fold(f64::MIN, |x, y| x.max(*y));\n\
    \n    numbers.iter().map(|&x| (x - min) / (max - min)).collect()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822484
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|n| n - min).map(|n| n / (max - min)).collect()\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpq7edvds_.rs:4:30\n\
    \  |\n4 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpq7edvds_.rs:5:30\n\
    \  |\n5 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822484
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    assert!(numbers.len()\
    \ >= 2);\n    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let range = max - min;\n    let range = if range == 0.0 { 1.0 } else { range\
    \ };\n    let offset = *min;\n    numbers.iter().map(|number| (number - offset)\
    \ / range).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpnijg4e1f.rs:5:30\n\
    \  |\n5 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpnijg4e1f.rs:6:30\n\
    \  |\n6 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822484
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ (min, max) = numbers.iter().fold((numbers[0], numbers[0]), |(min, max), &num|\
    \ {\n        (min.min(num), max.max(num))\n    });\n    let (mut min, mut max)\
    \ = (min, max);\n    if max == min {\n        max = min + 1.0;\n    }\n    //\
    \ apply transform\n    numbers.iter().map(|&num| {\n        (num - min) / (max\
    \ - min)\n    }).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822484
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    assert!(numbers.len()\
    \ >= 2);\n    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    assert!(max > min);\n    let factor = 1.0 / (max - min);\n    let add = -min;\n\
    \    let offset = add * factor;\n    let scaled: Vec<f64> = numbers.iter().map(|n|\
    \ (*n * factor) + offset).collect();\n    assert!(scaled.iter().all(|n| n >= &0.0));\n\
    \    assert!(scaled.iter().all(|n| n <= &1.0));\n    scaled\n}\n\nfn main() {\n\
    \    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpqkcsjz8w.rs:5:30\n\
    \  |\n5 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpqkcsjz8w.rs:6:30\n\
    \  |\n6 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822484
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ (min, max) = find_min_max(&numbers);\n    let a = 1.0 / (max - min);\n    let\
    \ b = -a * min;\n    numbers.iter().map(|x| a * x + b).collect()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_min_max` in this scope\n --> /tmp/tmp0w9cprax.rs:4:22\n\
    \  |\n4 |     let (min, max) = find_min_max(&numbers);\n  |                  \
    \    ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822484
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut numbers = numbers;\n    let min = numbers.iter().cloned().fold(f64::MAX,\
    \ f64::min);\n    let max = numbers.iter().cloned().fold(f64::MIN, f64::max);\n\
    \    numbers = numbers.iter().map(|&x| (x - min) / (max - min)).collect();\n \
    \   numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822484
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let range = max - min;\n    numbers.iter().map(|x| (x - min) / range).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp8js_vzza.rs:4:30\n\
    \  |\n4 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp8js_vzza.rs:5:30\n\
    \  |\n5 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822484
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ (mut min, mut max) = (numbers[0], numbers[0]);\n    for number in numbers.iter()\
    \ {\n        if *number < min {\n            min = *number;\n        }\n     \
    \   if *number > max {\n            max = *number;\n        }\n    }\n    let\
    \ (min, max) = (min, max);\n    let scale = 1.0 / (max - min);\n    numbers.iter().map(|number|\
    \ (number - min) * scale).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822484
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min_number = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n    let\
    \ max_number = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n  \
    \  let diff = max_number - min_number;\n    let coeff = 1.0 / diff;\n    let mut\
    \ scaled_numbers = Vec::new();\n    for n in numbers {\n        scaled_numbers.push((n\
    \ - min_number) * coeff);\n    }\n    scaled_numbers\n}\n\nfn main() {\n    let\
    \ candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0,\
    \ 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822484
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().cloned().fold(f64::MAX, f64::min);\n    let max = numbers.iter().cloned().fold(f64::MIN,\
    \ f64::max);\n    let range = max - min;\n    numbers.iter().map(|&x| (x - min)\
    \ / range).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822484
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    assert!(numbers.len()\
    \ >= 2);\n    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|n| (n - min) / (max - min)).collect()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpi3ywrwl4.rs:5:30\n\
    \  |\n5 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpi3ywrwl4.rs:6:30\n\
    \  |\n6 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822484
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut result = Vec::with_capacity(numbers.len());\n    let max = *numbers.iter().max().unwrap();\n\
    \    let min = *numbers.iter().min().unwrap();\n    for number in numbers {\n\
    \        result.push((number - min) / (max - min));\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpyg5k1vc6.rs:5:31\n\
    \  |\n5 |     let max = *numbers.iter().max().unwrap();\n  |                 \
    \              ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpyg5k1vc6.rs:6:31\n\
    \  |\n6 |     let min = *numbers.iter().min().unwrap();\n  |                 \
    \              ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822484
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let denom = max - min;\n    let mut output = Vec::with_capacity(numbers.len());\n\
    \    for number in numbers {\n        output.push((number - min) / denom);\n \
    \   }\n    output\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n  \
    \  assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpm1dvsdak.rs:4:30\n\
    \  |\n4 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpm1dvsdak.rs:5:30\n\
    \  |\n5 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822484
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut numbers = numbers;\n    let max = numbers.iter().max().unwrap();\n    let\
    \ min = numbers.iter().min().unwrap();\n    let width = max - min;\n    for n\
    \ in numbers.iter_mut() {\n        *n = (n - min) / width;\n    }\n    numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpi91qd8ao.rs:5:30\n\
    \  |\n5 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpi91qd8ao.rs:6:30\n\
    \  |\n6 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0369]:\
    \ cannot subtract `&f64` from `&mut f64`\n --> /tmp/tmpi91qd8ao.rs:9:17\n  |\n\
    9 |         *n = (n - min) / width;\n  |               - ^ --- &f64\n  |     \
    \          |\n  |               &mut f64\n  |\nhelp: `-` can be used on `f64`,\
    \ you can dereference `n`\n  |\n9 |         *n = (*n - min) / width;\n  |    \
    \           +\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0369.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822484
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let scale = 1.0 / (max - min);\n    let mut result = Vec::new();\n    for\
    \ number in numbers {\n        result.push((number - min) * scale);\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpyxw6_0lw.rs:4:30\n\
    \  |\n4 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpyxw6_0lw.rs:5:30\n\
    \  |\n5 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822484
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n    let max =\
    \ numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n    // println!(\"\
    min = {}\", min);\n    // println!(\"max = {}\", max);\n    numbers.iter().map(|x|\
    \ (x - min) / (max - min)).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822484
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut result = numbers.clone();\n    let min = *result.iter().min().unwrap();\n\
    \    let max = *result.iter().max().unwrap();\n    for n in result.iter_mut()\
    \ {\n        *n = (*n - min) / (max - min);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmppb1cmoun.rs:5:30\n\
    \  |\n5 |     let min = *result.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmppb1cmoun.rs:6:30\n\
    \  |\n6 |     let max = *result.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822484
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n    let max =\
    \ numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n    numbers.iter().map(|n|\
    \ (n - min) / (max - min)).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822484
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    // Get\
    \ the range of the numbers\n    let min = numbers.iter().min().unwrap();\n   \
    \ let max = numbers.iter().max().unwrap();\n    let range = max - min;\n\n   \
    \ // Scale the numbers so that the minimum is 0 and the maximum is 1\n    numbers.iter().map(|n|\
    \ (n - min) / range).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpmxl8g4_2.rs:5:30\n\
    \  |\n5 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpmxl8g4_2.rs:6:30\n\
    \  |\n6 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822484
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let range = max - min;\n    numbers.iter().map(|x| (x - min) / range).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp8js_vzza.rs:4:30\n\
    \  |\n4 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp8js_vzza.rs:5:30\n\
    \  |\n5 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822484
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ max = numbers.iter().fold(f64::NEG_INFINITY, |cur_max, x| cur_max.max(*x));\n\
    \    let min = numbers.iter().fold(f64::INFINITY, |cur_min, x| cur_min.min(*x));\n\
    \    let scale = max - min;\n    numbers.iter().map(|n| (n - min) / scale).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822484
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = Vec::new();\n    let (smallest, largest) = \n       \
    \ match numbers.iter().minmax() {\n            MinMaxResult::MinMax(smallest,\
    \ largest) => (smallest, largest),\n            _ => panic!(\"This will never\
    \ happen\"),\n        };\n    let length = largest - smallest;\n    for number\
    \ in numbers {\n        rescaled_numbers.push((number - smallest) / length);\n\
    \    }\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `MinMaxResult`\n\
    \ --> /tmp/tmp5ogds371.rs:7:13\n  |\n7 |             MinMaxResult::MinMax(smallest,\
    \ largest) => (smallest, largest),\n  |             ^^^^^^^^^^^^ use of undeclared\
    \ type `MinMaxResult`\n\nerror[E0599]: no method named `minmax` found for struct\
    \ `std::slice::Iter` in the current scope\n --> /tmp/tmp5ogds371.rs:6:30\n  |\n\
    6 |         match numbers.iter().minmax() {\n  |                             \
    \ ^^^^^^ method not found in `std::slice::Iter<'_, f64>`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0433, E0599.\n\
    For more information about an error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659822484
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ (min, max) = get_min_max(&numbers);\n    numbers.iter().map(|n| (n - min) /\
    \ (max - min)).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_min_max` in this scope\n --> /tmp/tmp55bf1236.rs:4:22\n\
    \  |\n4 |     let (min, max) = get_min_max(&numbers);\n  |                   \
    \   ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822484
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    // find\
    \ the max & min values\n    let mut max = numbers[0];\n    let mut min = numbers[0];\n\
    \    for number in numbers.iter() {\n        if *number > max {\n            max\
    \ = *number;\n        }\n        if *number < min {\n            min = *number;\n\
    \        }\n    }\n\n    let length = max - min;\n\n    // rescale them all\n\
    \    numbers.iter().map(|x| (*x - min) / length).collect()\n}\n\nfn main() {\n\
    \    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822484
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    // Find\
    \ the smallest and largest numbers\n    let smallest = numbers.iter().fold(f64::MAX,\
    \ |acc, &x| acc.min(x));\n    let largest = numbers.iter().fold(f64::MIN, |acc,\
    \ &x| acc.max(x));\n\n    // Compute the scale & offset we need to apply\n   \
    \ let scale = 1.0 / (largest - smallest);\n    let offset = -smallest;\n\n   \
    \ // Return the scaled list\n    numbers.iter().map(|&x| (x + offset) * scale).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822484
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    // Find\
    \ smallest and largest in the list of numbers\n    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n\n    // Apply linear transform\
    \ to all elements in the list\n    numbers.iter().map(|x| (x - min) / (max - min)).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpiurjhrka.rs:5:30\n\
    \  |\n5 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpiurjhrka.rs:6:30\n\
    \  |\n6 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822484
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ max = numbers.iter().fold(f64::NEG_INFINITY, |m, &n| m.max(n));\n    let min\
    \ = numbers.iter().fold(f64::INFINITY, |m, &n| m.min(n));\n    let scale = max\
    \ - min;\n    let offset = min;\n    numbers.iter().map(|&x| (x - offset) / scale).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822484
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|x| ((x - min) / (max - min))).collect()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp5puzkybj.rs:4:30\n\
    \  |\n4 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp5puzkybj.rs:5:30\n\
    \  |\n5 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822484
- exit_code: 101
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n    let max =\
    \ numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n    let diff = max\
    \ - min;\n    let mut rescaled = numbers.iter().cloned().map(|x| (x - min) / diff).collect::<Vec<f64>>();\n\
    \    rescaled.reverse();\n    rescaled\n}\n\nfn main() {\n    let candidate =\
    \ rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1.0, 0.0]`,\n right: `[0.0, 1.0]`', /tmp/tmp0i_nsynh.rs:14:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822484
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let minmax_diff = max - min;\n    numbers.iter().map(|x| (x - min) / minmax_diff).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp17wodz61.rs:4:30\n\
    \  |\n4 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp17wodz61.rs:5:30\n\
    \  |\n5 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822484
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n    let max =\
    \ numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n    numbers.iter().map(|x|\
    \ (x - min) / (max - min)).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822483
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ (min, max) = get_min_max(&numbers);\n    if max - min > 0.0 {\n        numbers.iter().map(|&x|\
    \ (x - min) / (max - min)).collect()\n    } else {\n        numbers\n    }\n}\n\
    \nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_min_max` in this scope\n --> /tmp/tmp6mskdaog.rs:4:22\n\
    \  |\n4 |     let (min, max) = get_min_max(&numbers);\n  |                   \
    \   ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822484
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ smallest = *numbers.iter().min().unwrap();\n    let largest = *numbers.iter().max().unwrap();\n\
    \    let scale = largest - smallest;\n    if scale == 0.0 {\n        // Prevent\
    \ division by zero\n        vec![0.0; numbers.len()]\n    } else {\n        numbers.iter().map(|x|\
    \ (x - smallest) / scale).collect()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp1r_gju3e.rs:4:36\n\
    \  |\n4 |     let smallest = *numbers.iter().min().unwrap();\n  |            \
    \                        ^^^ the trait `Ord` is not implemented for `f64`\n  |\n\
    \  = note: required because of the requirements on the impl of `Ord` for `&f64`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp1r_gju3e.rs:5:35\n\
    \  |\n5 |     let largest = *numbers.iter().max().unwrap();\n  |             \
    \                      ^^^ the trait `Ord` is not implemented for `f64`\n  |\n\
    \  = note: required because of the requirements on the impl of `Ord` for `&f64`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822484
- exit_code: 101
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut numbers = numbers;\n    numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    let min = numbers[0];\n    let max = numbers[numbers.len() - 1];\n    let\
    \ diff = max - min;\n    let l = numbers.len();\n    let mut result = Vec::with_capacity(l);\n\
    \    for (i, value) in numbers.iter().enumerate() {\n        result.push((value\
    \ - min) / diff);\n    }\n    result\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0.0, 1.0]`,\n right: `[1.0, 0.0]`', /tmp/tmp_aia1sv6.rs:20:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822484
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    assert!(numbers.len()\
    \ >= 2);\n    let max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n\
    \    let min = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n    let\
    \ range = max - min;\n    numbers.iter().map(|x| (*x - min) / range).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822484
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    // TODO:\
    \ this should be done inplace, to avoid making unnecessary copies\n    let min\
    \ = numbers.iter().cloned().fold(numbers[0], f64::min);\n    let max = numbers.iter().cloned().fold(numbers[0],\
    \ f64::max);\n    let diff = max - min;\n    numbers.iter().map(|n| (n - min)\
    \ / diff).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822484
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled_numbers = numbers.clone();\n    let mut largest = rescaled_numbers[0];\n\
    \    let mut smallest = rescaled_numbers[0];\n    let mut index = 0;\n    while\
    \ index < rescaled_numbers.len() {\n        let number = rescaled_numbers[index];\n\
    \        if number > largest {\n            largest = number;\n        }\n   \
    \     if number < smallest {\n            smallest = number;\n        }\n    \
    \    index += 1;\n    }\n    let scale = 1.0 / (largest - smallest);\n    index\
    \ = 0;\n    while index < rescaled_numbers.len() {\n        rescaled_numbers[index]\
    \ = (rescaled_numbers[index] - smallest) * scale;\n        index += 1;\n    }\n\
    \    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822484
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|&n| (n - min) / (max - min)).collect()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp1ltxtup9.rs:4:30\n\
    \  |\n4 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp1ltxtup9.rs:5:30\n\
    \  |\n5 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ (min, max) = find_min_max(&numbers);\n    apply_linear_transform(&numbers, min,\
    \ max)\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_min_max` in this scope\n --> /tmp/tmpjjyxzch7.rs:4:22\n\
    \  |\n4 |     let (min, max) = find_min_max(&numbers);\n  |                  \
    \    ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `apply_linear_transform` in this scope\n --> /tmp/tmpjjyxzch7.rs:5:5\n  |\n\
    5 |     apply_linear_transform(&numbers, min, max)\n  |     ^^^^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822484
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut numbers_iter = numbers.into_iter();\n    let min = numbers_iter.clone().min().unwrap();\n\
    \    let max = numbers_iter.max().unwrap();\n    if max - min < 0.001 {\n    \
    \    vec![0.5; numbers.len()]\n    } else {\n        numbers.into_iter().map(|x|\
    \ (x - min) / (max - min)).collect()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpx_txa1sn.rs:5:36\n\
    \  |\n5 |     let min = numbers_iter.clone().min().unwrap();\n  |            \
    \                        ^^^ the trait `Ord` is not implemented for `f64`\n\n\
    error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpx_txa1sn.rs:6:28\n\
    \  |\n6 |     let max = numbers_iter.max().unwrap();\n  |                    \
    \        ^^^ the trait `Ord` is not implemented for `f64`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659822484
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    assert!(numbers.len()\
    \ >= 2);\n    let (min, max) = numbers.iter().fold((f64::MAX, f64::MIN), |(a,\
    \ b), &x| {\n        (a.min(x), b.max(x))\n    });\n    numbers.iter().map(|x|\
    \ (*x - min) / (max - min)).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822484
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = *numbers.iter().min().unwrap();\n    let max = *numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|n| (*n - min) / (max - min)).collect()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpwomzo8k5.rs:4:31\n\
    \  |\n4 |     let min = *numbers.iter().min().unwrap();\n  |                 \
    \              ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpwomzo8k5.rs:5:31\n\
    \  |\n5 |     let max = *numbers.iter().max().unwrap();\n  |                 \
    \              ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822484
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    assert!(numbers.len()\
    \ >= 2);\n    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|number| {\n        if max - min <= 0.0 {\n          \
    \  return 0.0;\n        }\n        (number - min) / (max - min)\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpoo9dh26h.rs:5:30\n\
    \  |\n5 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpoo9dh26h.rs:6:30\n\
    \  |\n6 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822484
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ m = numbers.iter().min().unwrap();\n    let M = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|x| (x - m) / (M - m)).collect()\n}\n\nfn main() {\n \
    \   let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpiw_dnxlw.rs:4:28\n\
    \  |\n4 |     let m = numbers.iter().min().unwrap();\n  |                    \
    \        ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note: required\
    \ because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpiw_dnxlw.rs:5:28\n\
    \  |\n5 |     let M = numbers.iter().max().unwrap();\n  |                    \
    \        ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note: required\
    \ because of the requirements on the impl of `Ord` for `&f64`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822484
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ lowest = numbers.iter().min().unwrap();\n    let highest = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|x| (x - lowest) / (highest - lowest)).collect()\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp0uva7gyk.rs:4:33\n\
    \  |\n4 |     let lowest = numbers.iter().min().unwrap();\n  |               \
    \                  ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  =\
    \ note: required because of the requirements on the impl of `Ord` for `&f64`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp0uva7gyk.rs:5:34\n\
    \  |\n5 |     let highest = numbers.iter().max().unwrap();\n  |              \
    \                    ^^^ the trait `Ord` is not implemented for `f64`\n  |\n \
    \ = note: required because of the requirements on the impl of `Ord` for `&f64`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822484
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut result = numbers.clone();\n    let max = result.iter().max().unwrap();\n\
    \    let min = result.iter().min().unwrap();\n    let delta = *max - *min;\n \
    \   for i in 0..result.len() {\n        result[i] = (result[i] - *min) / delta;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n \
    \   assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpz9hayqcm.rs:5:29\n\
    \  |\n5 |     let max = result.iter().max().unwrap();\n  |                   \
    \          ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note: required\
    \ because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpz9hayqcm.rs:6:29\n\
    \  |\n6 |     let min = result.iter().min().unwrap();\n  |                   \
    \          ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note: required\
    \ because of the requirements on the impl of `Ord` for `&f64`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822484
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ smallest = numbers.iter().fold(f64::MAX, |m, &n| m.min(n));\n    let largest\
    \ = numbers.iter().fold(f64::MIN, |m, &n| m.max(n));\n    let denominator = largest\
    \ - smallest;\n    let mut result = Vec::with_capacity(numbers.len());\n    for\
    \ n in numbers {\n        let transformed = (n - smallest) / denominator;\n  \
    \      result.push(transformed);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0,\
    \ 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822484
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    assert!(numbers.len()\
    \ >= 2);\n    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|n| (n - min) / (max - min)).collect()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpi3ywrwl4.rs:5:30\n\
    \  |\n5 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpi3ywrwl4.rs:6:30\n\
    \  |\n6 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822484
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n    let min\
    \ = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n    let range = max\
    \ - min;\n    numbers.iter().map(|n| (n - min) / range).collect()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|x| (x - min) / (max - min)).collect()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp0elozmva.rs:4:30\n\
    \  |\n4 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp0elozmva.rs:5:30\n\
    \  |\n5 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822482
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    // TODO\
    \ refactor to get rid of copy\n    let mut res = Vec::new();\n    let mut smallest_num\
    \ = numbers[0];\n    let mut largest_num = numbers[0];\n    for number in numbers.iter()\
    \ {\n        if number < &smallest_num {\n            smallest_num = *number;\n\
    \        }\n        if number > &largest_num {\n            largest_num = *number;\n\
    \        }\n    }\n    let range = largest_num - smallest_num;\n    for number\
    \ in numbers.iter() {\n        let x = (number - &smallest_num) / &range;\n  \
    \      res.push(x);\n    }\n    res\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ num_numbers = numbers.len();\n    let mut rescaled_numbers = Vec::with_capacity(num_numbers);\n\
    \n    // Find min and max value of the input vector\n    let mut max_value = numbers[0];\n\
    \    let mut min_value = numbers[0];\n    for &x in numbers.iter() {\n       \
    \ if x > max_value {\n            max_value = x;\n        }\n        if x < min_value\
    \ {\n            min_value = x;\n        }\n    }\n\n    // Rescale the input\
    \ vector to [0; 1]\n    for x in numbers.iter() {\n        let scaled_x = (x -\
    \ min_value) / (max_value - min_value);\n        rescaled_numbers.push(scaled_x);\n\
    \    }\n\n    rescaled_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ smallest = numbers.iter().min().unwrap();\n    let largest = numbers.iter().max().unwrap();\n\
    \    let scale = largest - smallest;\n    let shift = *smallest;\n    let mut\
    \ rescaled_list = numbers.clone();\n    rescaled_list.iter_mut().for_each(|x|\
    \ *x = (*x - shift) / scale);\n    rescaled_list\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpyaqnjo6n.rs:4:35\n\
    \  |\n4 |     let smallest = numbers.iter().min().unwrap();\n  |             \
    \                      ^^^ the trait `Ord` is not implemented for `f64`\n  |\n\
    \  = note: required because of the requirements on the impl of `Ord` for `&f64`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpyaqnjo6n.rs:5:34\n\
    \  |\n5 |     let largest = numbers.iter().max().unwrap();\n  |              \
    \                    ^^^ the trait `Ord` is not implemented for `f64`\n  |\n \
    \ = note: required because of the requirements on the impl of `Ord` for `&f64`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822484
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut min_value = f64::MAX;\n    let mut max_value = f64::MIN;\n\n    for n in\
    \ numbers.iter() {\n        if *n < min_value {\n            min_value = *n;\n\
    \        }\n\n        if *n > max_value {\n            max_value = *n;\n     \
    \   }\n    }\n\n    let mut result = Vec::new();\n\n    for n in numbers.iter()\
    \ {\n        result.push((*n - min_value) / (max_value - min_value));\n    }\n\
    \n    result\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822484
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|n| (n - min) / (max - min)).collect()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpa0e_6xfh.rs:4:30\n\
    \  |\n4 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpa0e_6xfh.rs:5:30\n\
    \  |\n5 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    // for\
    \ each of the inputs we want to transform it to x and then return the result\n\
    \    numbers\n        .iter()\n        .map(|x| rescale_to_unit_single(*x, numbers.as_slice()))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `rescale_to_unit_single` in this scope\n\
    \ --> /tmp/tmpitp5mw0s.rs:7:18\n  |\n7 |         .map(|x| rescale_to_unit_single(*x,\
    \ numbers.as_slice()))\n  |                  ^^^^^^^^^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822484
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut v = numbers.clone();\n    let min = v.iter().min().unwrap();\n    let max\
    \ = v.iter().max().unwrap();\n    let divisor = max - min;\n    v.iter_mut().for_each(|x|\
    \ *x = (*x - min) / divisor);\n    v\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp6lroeug1.rs:5:24\n\
    \  |\n5 |     let min = v.iter().min().unwrap();\n  |                        ^^^\
    \ the trait `Ord` is not implemented for `f64`\n  |\n  = note: required because\
    \ of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]: the trait\
    \ bound `f64: Ord` is not satisfied\n --> /tmp/tmp6lroeug1.rs:6:24\n  |\n6 | \
    \    let max = v.iter().max().unwrap();\n  |                        ^^^ the trait\
    \ `Ord` is not implemented for `f64`\n  |\n  = note: required because of the requirements\
    \ on the impl of `Ord` for `&f64`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822484
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut rescaled = numbers.clone();\n    let min_number = rescaled.iter().min().unwrap();\n\
    \    let max_number = rescaled.iter().max().unwrap();\n    let mut range = max_number\
    \ - min_number;\n    if range == 0.0 {\n        range = 1.0;\n    }\n    for i\
    \ in 0..rescaled.len() {\n        rescaled[i] = (rescaled[i] - min_number) / range;\n\
    \    }\n    rescaled\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpq29txcfa.rs:5:38\n\
    \  |\n5 |     let min_number = rescaled.iter().min().unwrap();\n  |          \
    \                            ^^^ the trait `Ord` is not implemented for `f64`\n\
    \  |\n  = note: required because of the requirements on the impl of `Ord` for\
    \ `&f64`\n\nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpq29txcfa.rs:6:38\n\
    \  |\n6 |     let max_number = rescaled.iter().max().unwrap();\n  |          \
    \                            ^^^ the trait `Ord` is not implemented for `f64`\n\
    \  |\n  = note: required because of the requirements on the impl of `Ord` for\
    \ `&f64`\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822484
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().cloned().fold(f64::MAX, f64::min);\n    let max = numbers.iter().cloned().fold(f64::MIN,\
    \ f64::max);\n    let range = max - min;\n    let scale = if range == 0.0 {\n\
    \        1.0\n    } else {\n        1.0 / range\n    };\n    numbers.iter().map(|x|\
    \ (x - min) * scale).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().cloned().fold(f64::MAX, f64::min);\n    let max = numbers.iter().cloned().fold(f64::MIN,\
    \ f64::max);\n    let range = max - min;\n    let mut list = Vec::new();\n   \
    \ for num in numbers {\n        list.push((num - min) / range);\n    }\n    list\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|n| (*n - min) / (max - min)).collect()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp2sqe2ls4.rs:4:30\n\
    \  |\n4 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp2sqe2ls4.rs:5:30\n\
    \  |\n5 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822483
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let abs_diff = (max - min).abs();\n    numbers.iter().map(|x| (x - min) /\
    \ abs_diff).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpm31tw86s.rs:4:30\n\
    \  |\n4 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpm31tw86s.rs:5:30\n\
    \  |\n5 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822484
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    if numbers.len()\
    \ < 2 {\n        println!(\"At least two numbers must be provided\");\n      \
    \  panic!(\"Not enough numbers\");\n    }\n\n    let min_x = numbers.iter().min().unwrap();\n\
    \    let max_x = numbers.iter().max().unwrap();\n\n    let c = 1.0 / (max_x -\
    \ min_x);\n    let b = -min_x * c;\n\n    numbers.iter().map(|x| c * x + b).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp2kszwtwv.rs:9:32\n\
    \  |\n9 |     let min_x = numbers.iter().min().unwrap();\n  |                \
    \                ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n  --> /tmp/tmp2kszwtwv.rs:10:32\n\
    \   |\n10 |     let max_x = numbers.iter().max().unwrap();\n   |             \
    \                   ^^^ the trait `Ord` is not implemented for `f64`\n   |\n \
    \  = note: required because of the requirements on the impl of `Ord` for `&f64`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ num_min = numbers.iter().cloned().fold(numbers[0], f64::min);\n    let num_max\
    \ = numbers.iter().cloned().fold(numbers[0], f64::max);\n    let scale = (num_max\
    \ - num_min).recip();\n    let offset = -num_min;\n    numbers.iter().map(|&x|\
    \ (x + offset) * scale).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ numbers_max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n \
    \   let numbers_min = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n\
    \    let scale = numbers_max - numbers_min;\n    let shift = numbers_min;\n  \
    \  numbers.iter().map(|x| (x - shift) / scale).collect()\n}\n\nfn main() {\n \
    \   let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ (min, max) = (numbers.iter().min().unwrap(), numbers.iter().max().unwrap());\n\
    \    let f = 1.0 / (max - min);\n    numbers.iter().map(|x| f * (x - min)).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmprw41p1ir.rs:4:38\n\
    \  |\n4 |     let (min, max) = (numbers.iter().min().unwrap(), numbers.iter().max().unwrap());\n\
    \  |                                      ^^^ the trait `Ord` is not implemented\
    \ for `f64`\n  |\n  = note: required because of the requirements on the impl of\
    \ `Ord` for `&f64`\n\nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n\
    \ --> /tmp/tmprw41p1ir.rs:4:69\n  |\n4 |     let (min, max) = (numbers.iter().min().unwrap(),\
    \ numbers.iter().max().unwrap());\n  |                                       \
    \                              ^^^ the trait `Ord` is not implemented for `f64`\n\
    \  |\n  = note: required because of the requirements on the impl of `Ord` for\
    \ `&f64`\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822485
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut scale_factor = 1.0;\n    let max = numbers.iter().max_by(|x, y| x.partial_cmp(y).unwrap()).unwrap();\n\
    \    let min = numbers.iter().min_by(|x, y| x.partial_cmp(y).unwrap()).unwrap();\n\
    \    scale_factor = 1.0 / (*max - *min);\n    let mut rescaled = numbers.clone();\n\
    \    rescaled.iter_mut().for_each(|x| *x = (x - min) * scale_factor);\n    rescaled\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot subtract `&f64` from `&mut f64`\n --> /tmp/tmpej9zimaq.rs:9:46\n\
    \  |\n9 |     rescaled.iter_mut().for_each(|x| *x = (x - min) * scale_factor);\n\
    \  |                                            - ^ --- &f64\n  |            \
    \                                |\n  |                                      \
    \      &mut f64\n  |\nhelp: `-` can be used on `f64`, you can dereference `x`\n\
    \  |\n9 |     rescaled.iter_mut().for_each(|x| *x = (*x - min) * scale_factor);\n\
    \  |                                            +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659822484
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    if numbers.len()\
    \ < 2 {\n        panic!(\"at least two numbers are required to rescale the list\"\
    )\n    }\n\n    let min_value = numbers.iter().min().unwrap();\n    let max_value\
    \ = numbers.iter().max().unwrap();\n\n    let domain = max_value - min_value;\n\
    \n    numbers.iter().map(|n| {\n        (n - min_value) / domain\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp96fg527y.rs:8:36\n\
    \  |\n8 |     let min_value = numbers.iter().min().unwrap();\n  |            \
    \                        ^^^ the trait `Ord` is not implemented for `f64`\n  |\n\
    \  = note: required because of the requirements on the impl of `Ord` for `&f64`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp96fg527y.rs:9:36\n\
    \  |\n9 |     let max_value = numbers.iter().max().unwrap();\n  |            \
    \                        ^^^ the trait `Ord` is not implemented for `f64`\n  |\n\
    \  = note: required because of the requirements on the impl of `Ord` for `&f64`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822485
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut result = Vec::with_capacity(numbers.len());\n    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n    let delta = max - min;\n  \
    \  for n in numbers {\n        result.push((n - min) / delta);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmplmviivu1.rs:5:30\n\
    \  |\n5 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmplmviivu1.rs:6:30\n\
    \  |\n6 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822485
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut result = Vec::new();\n    let mut max_number = 0.0;\n    let mut min_number\
    \ = 1000000.0;\n\n    for num in numbers {\n        if num > max_number {\n  \
    \          max_number = num;\n        }\n        if num < min_number {\n     \
    \       min_number = num;\n        }\n    }\n\n    let slope = 1.0 / (max_number\
    \ - min_number);\n    let offset = -min_number;\n\n    for num in numbers {\n\
    \        result.push(slope * (num + offset));\n    }\n\n    result\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpl_sjrigz.rs:20:16\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n8   |     for num in numbers {\n \
    \   |                -------\n    |                |\n    |                `numbers`\
    \ moved due to this implicit call to `.into_iter()`\n    |                help:\
    \ consider borrowing to avoid moving into the for loop: `&numbers`\n...\n20  |\
    \     for num in numbers {\n    |                ^^^^^^^ value used here after\
    \ move\n    |\nnote: this function takes ownership of the receiver `self`, which\
    \ moves `numbers`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822485
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    if numbers.len()\
    \ < 2 {\n        panic!(\"Only works with lists of at least two elements\");\n\
    \    }\n\n    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \n    if min == max {\n        return numbers.iter().map(|&number| 1.0).collect();\n\
    \    }\n\n    numbers.iter().map(|&number| (number - min) / (max - min)).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpw8bxdxg7.rs:8:30\n\
    \  |\n8 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpw8bxdxg7.rs:9:30\n\
    \  |\n9 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n    let max =\
    \ numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n    numbers.iter().map(|value|\
    \ (value - min) / (max - min)).collect()\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut numbers = numbers;\n    let max = numbers.iter().cloned().fold(f64::NEG_INFINITY,\
    \ f64::max);\n    let min = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n\
    \    for n in numbers.iter_mut() {\n        *n = (*n - min) / (max - min);\n \
    \   }\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n \
    \   assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = *numbers.iter().min().unwrap();\n    let max = *numbers.iter().max().unwrap();\n\
    \    let range = max - min;\n    numbers.iter().map(|&x| (x - min) / range).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpjsfcksdj.rs:4:31\n\
    \  |\n4 |     let min = *numbers.iter().min().unwrap();\n  |                 \
    \              ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpjsfcksdj.rs:5:31\n\
    \  |\n5 |     let max = *numbers.iter().max().unwrap();\n  |                 \
    \              ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ max = numbers.iter().cloned().fold(0./0., f64::max);\n    let min = numbers.iter().cloned().fold(0./0.,\
    \ f64::min);\n    let denominator = max - min;\n    numbers.iter().map(|x| (x\
    \ - min) / denominator).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().cloned().fold(f64::MAX, f64::min);\n    let max = numbers.iter().cloned().fold(f64::MIN,\
    \ f64::max);\n    let factor = 1.0 / (max - min);\n    let offset = -min;\n  \
    \  numbers.iter().map(|x| (x + offset) * factor).collect()\n}\n\nfn main() {\n\
    \    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    if numbers.len()\
    \ < 2 {\n        panic!(\"Cannot rescale less than two numbers\");\n    }\n\n\
    \    let minimum = numbers.iter().min().unwrap();\n    let maximum = numbers.iter().max().unwrap();\n\
    \n    let mut rescaled = Vec::new();\n    for n in numbers {\n        let scaled\
    \ = (n - minimum) / (maximum - minimum);\n        rescaled.push(scaled);\n   \
    \ }\n\n    rescaled\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpbhxnpnx8.rs:8:34\n\
    \  |\n8 |     let minimum = numbers.iter().min().unwrap();\n  |              \
    \                    ^^^ the trait `Ord` is not implemented for `f64`\n  |\n \
    \ = note: required because of the requirements on the impl of `Ord` for `&f64`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpbhxnpnx8.rs:9:34\n\
    \  |\n9 |     let maximum = numbers.iter().max().unwrap();\n  |              \
    \                    ^^^ the trait `Ord` is not implemented for `f64`\n  |\n \
    \ = note: required because of the requirements on the impl of `Ord` for `&f64`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822485
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = *numbers.iter().min().unwrap();\n    let max = *numbers.iter().max().unwrap();\n\
    \    let delta = max - min;\n    numbers.iter().map(|&x| (x - min) / delta).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpzlo3xg44.rs:4:31\n\
    \  |\n4 |     let min = *numbers.iter().min().unwrap();\n  |                 \
    \              ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpzlo3xg44.rs:5:31\n\
    \  |\n5 |     let max = *numbers.iter().max().unwrap();\n  |                 \
    \              ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().cloned().fold(std::f64::MAX, f64::min);\n    let max =\
    \ numbers.iter().cloned().fold(std::f64::MIN, f64::max);\n    let scale = max\
    \ - min;\n    numbers.iter().map(|n| (*n - min) / scale).collect()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let mut output: Vec<f64> = Vec::new();\n    for number in numbers {\n   \
    \     output.push((number - min) / (max - min));\n    }\n    output\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpzb5xupjh.rs:4:30\n\
    \  |\n4 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpzb5xupjh.rs:5:30\n\
    \  |\n5 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822485
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    if max - min > 0.0 {\n        numbers.iter().map(|n| (n - min) / (max - min)).collect()\n\
    \    } else {\n        numbers\n    }\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpfzlovmwj.rs:4:30\n\
    \  |\n4 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpfzlovmwj.rs:5:30\n\
    \  |\n5 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822485
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut result = numbers.clone();\n    let min = result.iter().min().unwrap();\n\
    \    let max = result.iter().max().unwrap();\n    for x in result.iter_mut() {\n\
    \        *x = (*x - min) / (max - min);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]),\
    \ vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5,\
    \ 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
    \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
    \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpc85xq8um.rs:5:29\n\
    \  |\n5 |     let min = result.iter().min().unwrap();\n  |                   \
    \          ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note: required\
    \ because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpc85xq8um.rs:6:29\n\
    \  |\n6 |     let max = result.iter().max().unwrap();\n  |                   \
    \          ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note: required\
    \ because of the requirements on the impl of `Ord` for `&f64`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().cloned().fold(0.0/0.0, f64::min);\n    let max = numbers.iter().cloned().fold(0.0/0.0,\
    \ f64::max);\n    if max == min {\n        vec![1.0; numbers.len()]\n    } else\
    \ {\n        numbers.iter().map(|x| (x - min) / (max - min)).collect()\n    }\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    // Find\
    \ largest and smallest element of the list\n    let (min, max) = numbers.iter().fold((numbers[0],\
    \ numbers[0]), |acc, x| {\n        (acc.0.min(*x), acc.1.max(*x))\n    });\n\n\
    \    // Apply the transformation\n    numbers.iter().map(|x| (*x - min) / (max\
    \ - min)).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n    let max =\
    \ numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n    let scale =\
    \ 1.0 / (max - min);\n    numbers.iter().map(|x| scale * (x - min)).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    // TODO:\
    \ test that we have at least two elements\n    let smallest = numbers.iter().min().unwrap();\n\
    \    let largest = numbers.iter().max().unwrap();\n    numbers.iter().map(|n|\
    \ (*n - smallest) / (largest - smallest)).collect()\n}\n\nfn main() {\n    let\
    \ candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0,\
    \ 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp_x24qo_0.rs:5:35\n\
    \  |\n5 |     let smallest = numbers.iter().min().unwrap();\n  |             \
    \                      ^^^ the trait `Ord` is not implemented for `f64`\n  |\n\
    \  = note: required because of the requirements on the impl of `Ord` for `&f64`\n\
    \nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp_x24qo_0.rs:6:34\n\
    \  |\n6 |     let largest = numbers.iter().max().unwrap();\n  |              \
    \                    ^^^ the trait `Ord` is not implemented for `f64`\n  |\n \
    \ = note: required because of the requirements on the impl of `Ord` for `&f64`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822485
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ (min, max) = min_max(&numbers);\n    let change = max - min;\n    if change\
    \ == 0.0 {\n        numbers\n    } else {\n        numbers.iter().map(|num| (num\
    \ - min) / change).collect()\n    }\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `min_max` in this scope\n --> /tmp/tmpw7e1zw0f.rs:4:22\n\
    \  |\n4 |     let (min, max) = min_max(&numbers);\n  |                      ^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut numbers = numbers;\n    let minimum = numbers.iter().cloned().fold(std::f64::MAX,\
    \ f64::min);\n    let maximum = numbers.iter().cloned().fold(std::f64::MIN, f64::max);\n\
    \    let diff = maximum - minimum;\n    numbers.iter_mut().for_each(|x| *x = (*x\
    \ - minimum) / diff);\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ max_number = numbers.iter().fold(0.0, |max, n| n.max(max));\n    let min_number\
    \ = numbers.iter().fold(std::f64::MAX, |min, n| n.min(min));\n    let range =\
    \ max_number - min_number;\n    let denominator = range;\n    numbers.iter().map(|n|\
    \ (*n - min_number) / denominator).collect()\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut numbers = numbers;\n    let largest = numbers.iter().cloned().fold(f64::NEG_INFINITY,\
    \ f64::max);\n    let smallest = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n\
    \    let diff = largest - smallest;\n    if diff == 0.0 {\n        let diff =\
    \ largest;\n        numbers = numbers.iter().map(|x| *x / diff).collect();\n \
    \   } else {\n        numbers = numbers.iter().map(|x| (*x - smallest) / diff).collect();\n\
    \    }\n    numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ mut result = Vec::with_capacity(numbers.len());\n    let (mut max, mut min)\
    \ = (numbers[0], numbers[0]);\n    for number in numbers {\n        if number\
    \ > max {\n            max = number;\n        }\n        if number < min {\n \
    \           min = number;\n        }\n    }\n    let range = max - min;\n    for\
    \ number in numbers {\n        result.push((number - min) / range);\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmp6nurgvik.rs:15:19\n\
    \    |\n3   | fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    |     \
    \               ------- move occurs because `numbers` has type `Vec<f64>`, which\
    \ does not implement the `Copy` trait\n...\n6   |     for number in numbers {\n\
    \    |                   -------\n    |                   |\n    |           \
    \        `numbers` moved due to this implicit call to `.into_iter()`\n    |  \
    \                 help: consider borrowing to avoid moving into the for loop:\
    \ `&numbers`\n...\n15  |     for number in numbers {\n    |                  \
    \ ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `numbers`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    assert!(numbers.len()\
    \ >= 2);\n    let min_max = [numbers.iter().min_by(|a, b| a.partial_cmp(b).unwrap()).unwrap(),\n\
    \        numbers.iter().max_by(|a, b| a.partial_cmp(b).unwrap()).unwrap()];\n\
    \    // given list of numbers in some range, compute new numbers, such that smallest\
    \ number\n    // is 0 and the largest is 1\n    numbers.iter().map(|x| (x - min_max[0])\
    \ / (min_max[1] - min_max[0])).collect()\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n    let min\
    \ = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n    let range = max\
    \ - min;\n    numbers.iter().map(|x| (*x - min) / range).collect()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    assert!(numbers.len()\
    \ >= 2);\n    let mut result = numbers.clone();\n    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n    for x in result.iter_mut()\
    \ {\n        *x = (*x - min) / (max - min);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp_zyn8vyr.rs:6:30\n\
    \  |\n6 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp_zyn8vyr.rs:7:30\n\
    \  |\n7 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822485
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ (min, max) = min_max(numbers.clone());\n    numbers.iter().map(|n| ((n - min)\
    \ / (max - min))).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `min_max` in this scope\n --> /tmp/tmpfmoledmm.rs:4:22\n\
    \  |\n4 |     let (min, max) = min_max(numbers.clone());\n  |                \
    \      ^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().cloned().fold(f64::MAX, f64::min);\n    let max = numbers.iter().cloned().fold(f64::MIN,\
    \ f64::max);\n    let delta = max - min;\n    numbers.iter().map(|n| (n - min)\
    \ / delta).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ max = numbers.iter().fold(std::f64::NEG_INFINITY, |a, b| a.max(*b));\n    let\
    \ min = numbers.iter().fold(std::f64::INFINITY, |a, b| a.min(*b));\n    let difference\
    \ = max - min;\n    numbers.iter().map(|number| (*number - min) / difference).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ smallest = numbers.iter().fold(f64::MAX, |a, &b| a.min(b));\n    let largest\
    \ = numbers.iter().fold(f64::MIN, |a, &b| a.max(b));\n    let scale = largest\
    \ - smallest;\n    return numbers.iter().map(|&x| (x - smallest) / scale).collect();\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|x| (x - min) / (max - min)).collect()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp0elozmva.rs:4:30\n\
    \  |\n4 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp0elozmva.rs:5:30\n\
    \  |\n5 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822482
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ largest = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n    let\
    \ smallest = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n    let range\
    \ = largest - smallest;\n    return numbers.iter().map(|x| (x - smallest) / range).collect();\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n    let max =\
    \ numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n    numbers.iter().map(|n|\
    \ (n - min) / (max - min)).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822484
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let range = max - min;\n    numbers.iter().map(|x| (x - min) / range).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp8js_vzza.rs:4:30\n\
    \  |\n4 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp8js_vzza.rs:5:30\n\
    \  |\n5 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822484
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ (min, max) = numbers.iter().fold((numbers[0], numbers[0]), |(a, b), &c| {\n\
    \        if c < a {\n            (c, b)\n        } else if c > b {\n         \
    \   (a, c)\n        } else {\n            (a, b)\n        }\n    });\n    let\
    \ range = max - min;\n    numbers.iter().map(|&x| (x - min) / range).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let slope = 1.0 / (max - min);\n    let mut res = Vec::with_capacity(numbers.len());\n\
    \    for number in numbers {\n        res.push((number - min) * slope);\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp4mgjge7g.rs:4:30\n\
    \  |\n4 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp4mgjge7g.rs:5:30\n\
    \  |\n5 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    // small\
    \ helper, that returns smallest and largest element in one step\n    let (min,\
    \ max) = numbers.iter().fold((numbers[0], numbers[0]), |(min, max), &x| {\n  \
    \      (f64::min(min, x), f64::max(max, x))\n    });\n\n    // do the actual rescaling\n\
    \    numbers.iter().map(|&x| (x - min) / (max - min)).collect()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().cloned().fold(f64::MAX, f64::min);\n    let max = numbers.iter().cloned().fold(f64::MIN,\
    \ f64::max);\n    numbers.iter().map(|n| (n - min) / (max - min)).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let mut result = Vec::new();\n    for x in numbers {\n        let y = (x\
    \ - min) / (max - min);\n        result.push(y);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmplbfker0u.rs:4:30\n\
    \  |\n4 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmplbfker0u.rs:5:30\n\
    \  |\n5 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822485
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let diff = max - min;\n    numbers.iter().map(|x| (x - min) / diff).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpwhcbgf7f.rs:4:30\n\
    \  |\n4 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpwhcbgf7f.rs:5:30\n\
    \  |\n5 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822485
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    assert!(numbers.len()\
    \ >= 2);\n    let mut output: Vec<f64> = numbers.clone();\n    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n    let range = max - min;\n  \
    \  output.iter_mut().for_each(|n| *n = (*n - min) / range);\n    output\n}\n\n\
    fn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpx1mtqiup.rs:6:30\n\
    \  |\n6 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpx1mtqiup.rs:7:30\n\
    \  |\n7 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822485
- exit_code: 0
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n    let min\
    \ = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n    let difference\
    \ = max - min;\n    numbers.iter().map(|&n| (n - min) / difference).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822485
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min_number = numbers.iter().min().unwrap();\n    let max_number = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|number| (number - min_number) / (max_number - min_number)).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpso3u0kzg.rs:4:37\n\
    \  |\n4 |     let min_number = numbers.iter().min().unwrap();\n  |           \
    \                          ^^^ the trait `Ord` is not implemented for `f64`\n\
    \  |\n  = note: required because of the requirements on the impl of `Ord` for\
    \ `&f64`\n\nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpso3u0kzg.rs:5:37\n\
    \  |\n5 |     let max_number = numbers.iter().max().unwrap();\n  |           \
    \                          ^^^ the trait `Ord` is not implemented for `f64`\n\
    \  |\n  = note: required because of the requirements on the impl of `Ord` for\
    \ `&f64`\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822485
- exit_code: 1
  program: "/// Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n/// such that the smallest number will become 0 and the largest\
    \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let\
    \ min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let span = max - min;\n    if span < 1.0e-9 {\n        // This is a bit hacky.\
    \ It's designed for the case where the numbers are all\n        // close enough\
    \ to each other that the min and max are equal. In that case,\n        // the\
    \ span would be zero, and the loop below would divide by zero.\n        // So\
    \ instead, the loop below is bypassed and the rescaling is done manually.\n  \
    \      let mid = (min + max) / 2.0;\n        numbers.iter().map(|&x| (x - mid)\
    \ / mid).collect()\n    } else {\n        numbers.iter().map(|&x| (x - min) /\
    \ span).collect()\n    }\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpnqy4uga0.rs:4:30\n\
    \  |\n4 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpnqy4uga0.rs:5:30\n\
    \  |\n5 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822485
