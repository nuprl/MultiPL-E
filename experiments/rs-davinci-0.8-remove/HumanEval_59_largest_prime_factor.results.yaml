language: rs
name: HumanEval_59_largest_prime_factor
results:
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let upper_bound = (n as f64).sqrt()\
    \ as isize + 1;\n    for i in (2..upper_bound).rev() {\n        if n % i == 0\
    \ && is_prime(i) {\n            return i;\n        }\n    }\n    panic!(\"The\
    \ largest prime factor of {} is larger than {}.\", n, upper_bound);\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmp0jjdqshu.rs:5:26\n\
    \  |\n5 |         if n % i == 0 && is_prime(i) {\n  |                        \
    \  ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822548
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut largest = 0;\n    let\
    \ mut i = 2;\n    while i * i <= n {\n        if n % i == 0 {\n            while\
    \ n % i == 0 {\n                n /= i;\n            }\n            largest =\
    \ i;\n        }\n        i += 1;\n    }\n    if n > 1 {\n        return n;\n \
    \   }\n    largest\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n --> /tmp/tmpsjgjskip.rs:8:17\n\
    \  |\n2 | fn largest_prime_factor(n: isize) -> isize {\n  |                  \
    \       - help: consider making this binding mutable: `mut n`\n...\n8 |      \
    \           n /= i;\n  |                 ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659822548
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut largest_prime = 0;\n\
    \    let mut factor = 2;\n    let mut remainder = n;\n    while remainder > 1\
    \ {\n        while remainder % factor == 0 {\n            remainder /= factor;\n\
    \            largest_prime = factor;\n        }\n        factor += 1;\n    }\n\
    \    largest_prime\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822548
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut r = n;\n    let mut\
    \ p = 2;\n    while p * p <= r {\n        if r % p == 0 {\n            r /= p;\n\
    \        } else {\n            p += 1;\n        }\n    }\n    r\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822548
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut factor = 2;\n    let\
    \ mut n = n;\n    while n > 1 {\n        if n % factor == 0 {\n            n /=\
    \ factor;\n        } else {\n            factor += 1;\n        }\n    }\n    factor\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822548
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n  // Only odd numbers can be a factor\
    \ of n, and there are no primes\n  // between 2 and 6.\n  for i in (3..)\n   \
    \      .step_by(2)\n         .take_while(|&i| i * i <= n) {\n    if n % i == 0\
    \ {\n      return largest_prime_factor(n / i);\n    }\n  }\n  n\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `22`,\n right: `11`', /tmp/tmpgbpsnu1n.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822548
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    for p in (2..).take_while(|x|\
    \ x*x <= n) {\n        if n % p == 0 {\n            return largest_prime_factor(n\
    \ / p);\n        }\n    }\n    n\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822548
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    (2..n).filter(|i| is_prime(*i)\
    \ && n % i == 0).max().unwrap()\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmpsnbic_xo.rs:3:23\n\
    \  |\n3 |     (2..n).filter(|i| is_prime(*i) && n % i == 0).max().unwrap()\n \
    \ |                       ^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659822548
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut number = n;\n    let\
    \ mut i = 2;\n    while i < number {\n        if is_prime(i) && number % i ==\
    \ 0 {\n            number /= i;\n        }\n        i += 1;\n    }\n    number\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmp24wkzkyt.rs:6:12\n\
    \  |\n6 |         if is_prime(i) && number % i == 0 {\n  |            ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822548
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut largest_factor = 2;\n\
    \    let mut num = n;\n    while num % 2 == 0 {\n        num /= 2;\n    }\n  \
    \  let mut factor = 3;\n    while num > 1 {\n        if num % factor == 0 {\n\
    \            num /= factor;\n            largest_factor = factor;\n        } else\
    \ {\n            factor += 2;\n        }\n    }\n    largest_factor\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822548
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut tmp = n;\n    for i\
    \ in 2..(n as f64).sqrt() as isize + 1 {\n        if tmp % i == 0 {\n        \
    \    tmp /= i;\n            while tmp % i == 0 {\n                tmp /= i;\n\
    \            }\n        }\n    }\n    tmp\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `3`', /tmp/tmpo9hqfhbq.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822548
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut t = n;\n    let mut\
    \ i = 2;\n    while i <= t {\n        if t % i == 0 {\n            t /= i;\n \
    \       } else {\n            i += 1;\n        }\n    }\n    return i;\n}\n\n\
    fn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822548
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    for i in (2..).take_while(|&i|\
    \ i * i <= n) {\n        if n % i == 0 {\n            return largest_prime_factor(n\
    \ / i);\n        }\n    }\n    n\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822548
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut current_factor = 2;\n\
    \    let mut copy = n;\n    while copy > 1 {\n        if is_prime(current_factor)\
    \ && copy % current_factor == 0 {\n            copy /= current_factor;\n     \
    \   } else {\n            current_factor += 1;\n        }\n    }\n    current_factor\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmptvl9gscb.rs:6:12\n\
    \  |\n6 |         if is_prime(current_factor) && copy % current_factor == 0 {\n\
    \  |            ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822548
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    if is_prime(n) {\n        return\
    \ n;\n    }\n\n    let largest_factor = prime_factors(n).iter().max().unwrap();\n\
    \    *largest_factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmpeyfbbp5x.rs:3:8\n\
    \  |\n3 |     if is_prime(n) {\n  |        ^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find function `prime_factors` in this scope\n --> /tmp/tmpeyfbbp5x.rs:7:26\n\
    \  |\n7 |     let largest_factor = prime_factors(n).iter().max().unwrap();\n \
    \ |                          ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822548
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut smallest_prime_factor\
    \ = 2;\n    let mut factors = Vec::new();\n    let mut number = n;\n    loop {\n\
    \        if smallest_prime_factor * smallest_prime_factor > number {\n       \
    \     break;\n        }\n        if number % smallest_prime_factor == 0 {\n  \
    \          number /= smallest_prime_factor;\n            factors.push(smallest_prime_factor);\n\
    \        } else {\n            smallest_prime_factor += 1;\n        }\n    }\n\
    \    factors.push(number);\n    println!(\"Factors are {:?}\", factors);\n   \
    \ factors.iter().max().unwrap().clone()\n}\n\nfn main() {\n    let candidate =\
    \ largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: OK
  stderr: ''
  stdout: 'Factors are [3, 5]

    Factors are [3, 3, 3]

    Factors are [3, 3, 7]

    Factors are [2, 3, 5, 11]

    Factors are [5, 7, 13, 29]

    '
  timestamp: 1659822549
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    // We only have to check up\
    \ to the square root of n.\n    let max = (n as f64).sqrt() as isize;\n    //\
    \ start with the smallest prime, which is 2\n    let mut factor = 2;\n    while\
    \ factor <= max {\n        if n % factor == 0 {\n            // If there's a factor\
    \ of n, then that factor is prime,\n            // so it must be the largest prime\
    \ factor we're looking for.\n            return n / factor;\n        }\n     \
    \   // we only need to check for the smallest prime factors,\n        // so we\
    \ only have to check every other number\n        factor += 1;\n    }\n    // No\
    \ prime factors found. n must be prime.\n    return n;\n}\n\nfn main() {\n   \
    \ let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n \
    \   assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `3`', /tmp/tmpvmn_xhd1.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822548
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    for i in (1..).map(|x| x * 2\
    \ + 1).take_while(|&x| x * x <= n) {\n        if n % i == 0 {\n            return\
    \ largest_prime_factor(n / i);\n        }\n    }\n    n\n}\n\nfn main() {\n  \
    \  let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `22`,\n right: `11`', /tmp/tmp5d3_yq6f.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822549
- exit_code: -1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let mut\
    \ p = 3;\n    while n > 1 {\n        if n % p == 0 {\n            n /= p;\n  \
    \      } else {\n            p += 2;\n        }\n    }\n    p\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659822553
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut current = n;\n    let\
    \ mut largest_prime = 2;\n    let mut factor = 2;\n    while current > 1 {\n \
    \       if current % factor == 0 {\n            current /= factor;\n         \
    \   if factor > largest_prime {\n                largest_prime = factor;\n   \
    \         }\n        } else {\n            factor += 1;\n        }\n    }\n  \
    \  largest_prime\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822548
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut factor = 2;\n    let\
    \ mut n = n;\n    while n > 1 {\n        if n % factor == 0 {\n            while\
    \ n % factor == 0 {\n                n /= factor;\n            }\n        }\n\
    \        factor += 1;\n    }\n    factor - 1\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822548
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut p = 2;\n    let mut\
    \ n = n;\n    while n > 1 {\n        if n % p == 0 {\n            n /= p;\n  \
    \      } else {\n            p += 1;\n        }\n    }\n    p\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822548
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut factor = n / 2;\n  \
    \  while ! is_prime(factor) {\n        factor -= 1;\n    }\n    factor\n}\n\n\
    fn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmp6i6lpf07.rs:4:13\n\
    \  |\n4 |     while ! is_prime(factor) {\n  |             ^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822548
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut factor = 2;\n    let\
    \ mut n = n;\n    while n % factor != 0 {\n        factor += 1;\n    }\n    n\
    \ / factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `3`', /tmp/tmpx3lx1izb.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822549
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut result = 1;\n    let\
    \ mut div = 2;\n    let mut temp = n;\n    while temp > 1 {\n        if is_prime(div)\
    \ && temp % div == 0 {\n            temp /= div;\n            result = div;\n\
    \        }\n        div += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmp_610duza.rs:7:12\n\
    \  |\n7 |         if is_prime(div) && temp % div == 0 {\n  |            ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822548
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    let mut\
    \ largest = n;\n    while i < largest {\n        if n % i == 0 {\n           \
    \ largest = n / i;\n        }\n        i += 1;\n    }\n    largest\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `3`', /tmp/tmp6h0v8s2m.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822549
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    // Check divisibility by primes\
    \ starting with 2. (The largest prime\n    // factor of any composite is always\
    \ <= n / 2).\n    let mut i = 2;\n    while i * i <= n {\n        // Get rid of\
    \ multiples of i, so that i will be prime.\n        while n % i == 0 {\n     \
    \       n /= i;\n        }\n        i += 1;\n    }\n    n\n}\n\nfn main() {\n\
    \    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n --> /tmp/tmpck7yxa5c.rs:9:13\n\
    \  |\n2 | fn largest_prime_factor(n: isize) -> isize {\n  |                  \
    \       - help: consider making this binding mutable: `mut n`\n...\n9 |      \
    \       n /= i;\n  |             ^^^^^^ cannot assign to immutable argument\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659822548
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    for i in (2..).take_while(|&i|\
    \ i * i <= n) {\n        if n % i == 0 {\n            return largest_prime_factor(n\
    \ / i);\n        }\n    }\n    n\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822548
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut f = (1..).find(|&x|\
    \ n % x == 0).unwrap();\n    let m = n / f;\n    if is_prime(m) { m } else { largest_prime_factor(m)\
    \ }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmp83yeglnk.rs:5:8\n\
    \  |\n5 |     if is_prime(m) { m } else { largest_prime_factor(m) }\n  |     \
    \   ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822548
- exit_code: -1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    if n % 2 == 0 {\n        return\
    \ largest_prime_factor(n / 2);\n    }\n    for d in (3..).step_by(2) {\n     \
    \   if n % d == 0 {\n            return largest_prime_factor(n / d);\n       \
    \ }\n    }\n    return 0;\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659822554
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    for i in\
    \ (2..).take_while(|&x| x * x <= n) {\n        while n % i == 0 {\n          \
    \  n /= i;\n        }\n    }\n    n\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0506]: cannot assign to `n` because it is borrowed\n --> /tmp/tmp5b1ghp_9.rs:6:13\n\
    \  |\n4 |     for i in (2..).take_while(|&x| x * x <= n) {\n  |              ---------------------------------\n\
    \  |              |                |             |\n  |              |       \
    \         |             borrow occurs due to use in closure\n  |             \
    \ |                borrow of `n` occurs here\n  |              borrow later used\
    \ here\n5 |         while n % i == 0 {\n6 |             n /= i;\n  |         \
    \    ^^^^^^ assignment to borrowed `n` occurs here\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0506`.\n"
  stdout: ''
  timestamp: 1659822548
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    // let mut n = n;\n    let mut\
    \ i = 2;\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i;\n\
    \        } else {\n            i += 1;\n        }\n    }\n    n\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n --> /tmp/tmp5uwibrxd.rs:7:13\n\
    \  |\n2 | fn largest_prime_factor(n: isize) -> isize {\n  |                  \
    \       - help: consider making this binding mutable: `mut n`\n...\n7 |      \
    \       n /= i;\n  |             ^^^^^^ cannot assign to immutable argument\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659822549
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    // try 2...sqrt(n)\n    let\
    \ n_sqrt = (n as f64).sqrt() as isize;\n    let mut i = n_sqrt;\n    while i >\
    \ 1 {\n        if n % i == 0 && is_prime(i) {\n            return i;\n       \
    \ }\n        i -= 1;\n    }\n    panic!(\"largest_prime_factor failed\");\n}\n\
    \nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmppsw0_a8x.rs:7:26\n\
    \  |\n7 |         if n % i == 0 && is_prime(i) {\n  |                        \
    \  ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822549
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let limit = (n as f64).sqrt()\
    \ as isize;\n    let mut p = 3;\n    while p <= limit {\n        if n % p == 0\
    \ {\n            return largest_prime_factor(n / p);\n        }\n        p +=\
    \ 2;\n    }\n    n\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `22`,\n right: `11`', /tmp/tmp6vm5aq1u.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822549
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    // Start at the lowest prime\n\
    \    let mut f = 2;\n    let mut n = n;\n    // Loop until all the factors are\
    \ exhausted\n    while n > 1 {\n        // If f divides n, remove all factors\
    \ of f\n        if n % f == 0 {\n            while n % f == 0 {\n            \
    \    n /= f;\n            }\n        }\n        // Get the next prime\n      \
    \  f = get_next_prime(f);\n    }\n    // Return the largest factor\n    f\n}\n\
    \nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_next_prime` in this scope\n  -->\
    \ /tmp/tmpkq22l8yj.rs:15:13\n   |\n15 |         f = get_next_prime(f);\n   | \
    \            ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659822549
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    for i in (2..n).rev() {\n  \
    \      if i.is_prime() && n % i == 0 {\n            return i;\n        }\n   \
    \ }\n    unreachable!()\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_prime` found for type `isize` in the\
    \ current scope\n --> /tmp/tmpfzmxfx7i.rs:4:14\n  |\n4 |         if i.is_prime()\
    \ && n % i == 0 {\n  |              ^^^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659822549
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut k = 2;\n    let mut\
    \ factor = 0;\n    while k * k <= n {\n        if n % k == 0 {\n            factor\
    \ = k;\n            while n % k == 0 {\n                n /= k;\n            }\n\
    \        }\n        k += 1;\n    }\n    if n > 1 {\n        factor = n;\n    }\n\
    \    factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n   \
    \ assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n --> /tmp/tmphwnxbkf_.rs:9:17\n\
    \  |\n2 | fn largest_prime_factor(n: isize) -> isize {\n  |                  \
    \       - help: consider making this binding mutable: `mut n`\n...\n9 |      \
    \           n /= k;\n  |                 ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659822549
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut factor = 3;\n    while\
    \ n % factor != 0 {\n        factor += 2;\n    }\n    while n % factor == 0 {\n\
    \        n /= factor;\n    }\n    if n > 1 {\n        largest_prime_factor(n)\n\
    \    } else {\n        factor\n    }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n --> /tmp/tmpzkvtzvkt.rs:8:9\n\
    \  |\n2 | fn largest_prime_factor(n: isize) -> isize {\n  |                  \
    \       - help: consider making this binding mutable: `mut n`\n...\n8 |      \
    \   n /= factor;\n  |         ^^^^^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659822549
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    for i in 2..=n {\n        if\
    \ is_prime(i) && n % i == 0 {\n            return largest_prime_factor(n / i);\n\
    \        }\n    }\n    return n;\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmpuz8b8ic4.rs:4:12\n\
    \  |\n4 |         if is_prime(i) && n % i == 0 {\n  |            ^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822549
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut factor = n;\n    let\
    \ mut factor_set = HashSet::new();\n    let mut i = 2;\n    while i * i <= factor\
    \ {\n        if factor % i == 0 {\n            factor_set.insert(i);\n       \
    \     factor /= i;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    if factor != 1 {\n        factor_set.insert(factor);\n    }\n    factor_set.into_iter().max().unwrap()\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n -->\
    \ /tmp/tmppiu6e0ot.rs:4:26\n  |\n4 |     let mut factor_set = HashSet::new();\n\
    \  |                          ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659822549
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut largest = 0;\n    for\
    \ i in 2..(n/2 + 1) {\n        if n % i == 0 && is_prime(i) {\n            largest\
    \ = i;\n        }\n    }\n    largest\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmpnojveeah.rs:5:26\n\
    \  |\n5 |         if n % i == 0 && is_prime(i) {\n  |                        \
    \  ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822549
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut curr_factor = 2;\n \
    \   let mut num = n;\n    while num > 1 {\n        if num % curr_factor == 0 {\n\
    \            num /= curr_factor;\n        } else {\n            curr_factor +=\
    \ 1;\n        }\n    }\n    curr_factor\n}\n\nfn main() {\n    let candidate =\
    \ largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822549
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let mut\
    \ p: isize = 2;\n    while n % p != 0 {\n        p += 1;\n    }\n    while n %\
    \ p == 0 {\n        n /= p;\n    }\n    if n == 1 {\n        p\n    } else {\n\
    \        largest_prime_factor(n)\n    }\n}\n\nfn main() {\n    let candidate =\
    \ largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822549
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let mut\
    \ i = 2;\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i;\n\
    \        } else {\n            i += 1;\n        }\n    }\n    n\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822549
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    while i\
    \ <= n {\n        if is_prime(i) && (n % i == 0) {\n            return largest_prime_factor(n\
    \ / i);\n        }\n        i += 1;\n    }\n    panic!(\"The largest prime factor\
    \ must be less than or equal to n.\")\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmp0kmxwk0p.rs:5:12\n\
    \  |\n5 |         if is_prime(i) && (n % i == 0) {\n  |            ^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822549
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let n_sqrt = (n as f64).sqrt()\
    \ as isize;\n    let mut factor = 2;\n    while factor <= n_sqrt {\n        if\
    \ n % factor == 0 {\n            return largest_prime_factor(n / factor);\n  \
    \      }\n        factor += 1;\n    }\n    n\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822549
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut prime_factors = Vec::new();\n\
    \    let mut n = n;\n    let mut n_factors = factors(n);\n    while n_factors.len()\
    \ > 1 {\n        let mut is_prime = true;\n        for n_factor in n_factors.iter()\
    \ {\n            let factor_factors = factors(*n_factor);\n            if factor_factors.len()\
    \ > 1 {\n                is_prime = false;\n                break;\n         \
    \   }\n        }\n        if is_prime {\n            prime_factors.extend(n_factors);\n\
    \            break;\n        } else {\n            for n_factor in n_factors.iter()\
    \ {\n                if *n_factor < n {\n                    n = *n_factor;\n\
    \                    break;\n                }\n            }\n            n_factors\
    \ = factors(n);\n        }\n    }\n    *prime_factors.iter().max().unwrap()\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `factors` in this scope\n --> /tmp/tmpl0tfohca.rs:5:25\n\
    \  |\n5 |     let mut n_factors = factors(n);\n  |                         ^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `factors` in this\
    \ scope\n --> /tmp/tmpl0tfohca.rs:9:34\n  |\n9 |             let factor_factors\
    \ = factors(*n_factor);\n  |                                  ^^^^^^^ help: a\
    \ local variable with a similar name exists: `n_factors`\n\nerror[E0425]: cannot\
    \ find function `factors` in this scope\n  --> /tmp/tmpl0tfohca.rs:25:25\n   |\n\
    25 |             n_factors = factors(n);\n   |                         ^^^^^^^\
    \ help: a local variable with a similar name exists: `n_factors`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822549
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    if n < 2 {\n        return 0;\n\
    \    }\n    let mut factor = 2;\n    let mut n = n;\n    while n > 1 {\n     \
    \   if n % factor == 0 {\n            n /= factor;\n        } else {\n       \
    \     factor += 1;\n        }\n    }\n    factor\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822549
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut curr = n;\n    let mut\
    \ i = 2;\n    let mut largest = 2;\n    while i <= curr / i {\n        if curr\
    \ % i == 0 {\n            largest = i;\n            while curr % i == 0 {\n  \
    \              curr /= i;\n            }\n        }\n        i += 1;\n    }\n\
    \    if curr > largest {\n        curr\n    } else {\n        largest\n    }\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822549
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut candidate = n / 2;\n\
    \    loop {\n        if is_prime(candidate) && (n % candidate == 0) {\n      \
    \      return candidate;\n        }\n        candidate -= 1;\n    }\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmph6a1220y.rs:5:12\n\
    \  |\n5 |         if is_prime(candidate) && (n % candidate == 0) {\n  |      \
    \      ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822549
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut largest_prime_factor\
    \ = 1;\n    let mut prime_factors = HashSet::new();\n    let mut next_prime =\
    \ 2;\n    let mut num = n;\n    loop {\n        if num == 1 {\n            break;\n\
    \        }\n        // if num is divisible by next_prime, add it to the set\n\
    \        if num % next_prime == 0 {\n            largest_prime_factor = next_prime;\n\
    \            prime_factors.insert(next_prime);\n            num /= next_prime;\n\
    \        } else {\n            // otherwise, get the next prime number\n     \
    \       next_prime = next_prime_after(next_prime);\n        }\n    }\n    largest_prime_factor\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n -->\
    \ /tmp/tmpkptv_an8.rs:4:29\n  |\n4 |     let mut prime_factors = HashSet::new();\n\
    \  |                             ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0425]:\
    \ cannot find function `next_prime_after` in this scope\n  --> /tmp/tmpkptv_an8.rs:18:26\n\
    \   |\n18 |             next_prime = next_prime_after(next_prime);\n   |     \
    \                     ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0425, E0433.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822549
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n  let mut prime_factors = (2..).filter(|i|\
    \ is_prime(*i)).take_while(|i| i * i <= n);\n  let mut largest_factor = *prime_factors.next().unwrap();\n\
    \  while n % largest_factor != 0 {\n    largest_factor = *prime_factors.next().unwrap();\n\
    \  }\n  largest_factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmpmtffcgy9.rs:3:44\n\
    \  |\n3 |   let mut prime_factors = (2..).filter(|i| is_prime(*i)).take_while(|i|\
    \ i * i <= n);\n  |                                            ^^^^^^^^ not found\
    \ in this scope\n\nerror[E0614]: type `isize` cannot be dereferenced\n --> /tmp/tmpmtffcgy9.rs:4:28\n\
    \  |\n4 |   let mut largest_factor = *prime_factors.next().unwrap();\n  |    \
    \                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0614]: type\
    \ `isize` cannot be dereferenced\n --> /tmp/tmpmtffcgy9.rs:6:22\n  |\n6 |    \
    \ largest_factor = *prime_factors.next().unwrap();\n  |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0614.\nFor more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822549
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    for i in 2..n {\n        if\
    \ n % i == 0 {\n            return largest_prime_factor(n / i);\n        }\n \
    \   }\n    panic!(\"largest_prime_factor: n is a prime number\");\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''largest_prime_factor: n is a prime number'',
    /tmp/tmp7hl9fynd.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822549
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut largest = 1;\n    let\
    \ mut test = 2;\n    let mut num = n;\n    while num > 1 {\n        while num\
    \ % test == 0 {\n            largest = test;\n            num /= test;\n     \
    \   }\n        test += 1;\n    }\n    largest\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822549
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut current_factor = 2;\n\
    \    let mut remainder = n;\n    let mut largest_factor = 1;\n\n    while remainder\
    \ > 1 {\n        if remainder % current_factor == 0 {\n            remainder /=\
    \ current_factor;\n            largest_factor = current_factor;\n        } else\
    \ {\n            current_factor += 1;\n        }\n    }\n\n    largest_factor\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822549
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    for factor in (2..(n as f64).sqrt()\
    \ as isize + 1).rev() {\n        if n % factor == 0 && is_prime(factor) {\n  \
    \          return factor;\n        }\n    }\n    panic!(\"Invalid arguments\"\
    );\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmplxgnk1qq.rs:4:31\n\
    \  |\n4 |         if n % factor == 0 && is_prime(factor) {\n  |              \
    \                 ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822549
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    for i in (2..(n/2 + 1)).rev()\
    \ {\n        if n % i == 0 && is_prime(i) {\n            return i;\n        }\n\
    \    }\n    panic!(\"No largest prime factor found\");\n}\n\nfn main() {\n   \
    \ let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n \
    \   assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmpme0i4ubb.rs:4:26\n\
    \  |\n4 |         if n % i == 0 && is_prime(i) {\n  |                        \
    \  ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822549
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    while i\
    \ * i <= n {\n        if n % i == 0 {\n            return largest_prime_factor(n\
    \ / i);\n        }\n        i += 1;\n    }\n    n\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822549
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    // Append primes to our prime\
    \ list as we need them.\n    let mut primes = vec![2];\n    let mut p = 2;\n \
    \   while n > 1 {\n        while n % p == 0 {\n            n /= p;\n        }\n\
    \        p = next_prime(p);\n        primes.push(p);\n    }\n    primes.pop().unwrap()\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `next_prime` in this scope\n  --> /tmp/tmpnsdhs_0c.rs:10:13\n\
    \   |\n10 |         p = next_prime(p);\n   |             ^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822549
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let mut\
    \ candidate = 2;\n    while n > 1 {\n        if n % candidate == 0 {\n       \
    \     n /= candidate;\n        } else {\n            candidate += 1;\n       \
    \ }\n    }\n    candidate\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822549
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n  for f in (2..).filter(|&x| is_prime(x)).take_while(|&x|\
    \ x <= n) {\n    if n % f == 0 {\n      return largest_prime_factor(n / f);\n\
    \    }\n  }\n  unreachable!();\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmpuxzp2ngj.rs:3:30\n\
    \  |\n3 |   for f in (2..).filter(|&x| is_prime(x)).take_while(|&x| x <= n) {\n\
    \  |                              ^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659822549
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    // TODO: implement\n    return\
    \ 0;\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `5`', /tmp/tmp081j2mt9.rs:9:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822549
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n  let mut prime = 2;\n  let mut\
    \ k = n;\n  while k % prime == 0 {\n    k /= prime;\n  }\n  let mut divisor =\
    \ 3;\n  while k > 1 {\n    if k % divisor == 0 {\n      prime = divisor;\n   \
    \   k /= divisor;\n    } else {\n      divisor += 2;\n    }\n  }\n  prime\n}\n\
    \nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822549
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    // We can skip 2, 3 and 5 because\
    \ they are the only primes below 10.\n    // If n is composite and is divisible\
    \ by one of them, then n is divisible\n    // by some other prime.\n    let prime_multiples\
    \ = vec![\n        // 2\n        vec![2, 4, 6, 8],\n        // 3\n        vec![3,\
    \ 9],\n        // 5\n        vec![5],\n    ];\n\n    let mut largest_prime_factor\
    \ = 1;\n    for prime in (7..n).filter(|x| is_prime(*x)) {\n        if n % prime\
    \ == 0 {\n            largest_prime_factor = prime;\n        }\n    }\n\n    if\
    \ largest_prime_factor > 1 {\n        largest_prime_factor\n    } else {\n   \
    \     // if n is not divisible by any of the primes > 5, it is a prime > 5.\n\
    \        n\n    }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp0jg3isy7.rs:16:36\n\
    \   |\n16 |     for prime in (7..n).filter(|x| is_prime(*x)) {\n   |         \
    \                           ^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659822549
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    for i in 2..((n as f64).sqrt()\
    \ as isize + 1) {\n        if n % i == 0 {\n            return largest_prime_factor(n\
    \ / i);\n        }\n    }\n    n\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822549
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let mut\
    \ factor = 2;\n    while n % factor != 0 {\n        factor += 1;\n    }\n    n\
    \ / factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `3`', /tmp/tmpjpx4_xmh.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822549
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    // Take advantage of the fact\
    \ that if a number can be expressed as a product of\n    // two prime numbers,\
    \ at least one of them is <= sqrt(n).\n\n    let mut i = 2;\n    while i <= (n\
    \ as f64).sqrt() as isize {\n        if n % i == 0 {\n            return largest_prime_factor(n\
    \ / i);\n        }\n        i += 1;\n    }\n    n\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822549
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut d = 2;\n    while n\
    \ % d != 0 {\n        d += 1;\n    }\n    let q = n / d;\n    if q == 1 {\n  \
    \      d\n    } else {\n        largest_prime_factor(q)\n    }\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822549
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let mut\
    \ divisor = 2;\n    while n > 1 {\n        if n % divisor == 0 {\n           \
    \ n /= divisor;\n        } else {\n            divisor += 1;\n        }\n    }\n\
    \    divisor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n  \
    \  assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822549
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    let mut\
    \ n = n;\n    let mut max_factor = 1;\n    while i * i <= n {\n        if n %\
    \ i == 0 {\n            n /= i;\n            max_factor = i;\n        } else {\n\
    \            i += 1;\n        }\n    }\n    if n > 1 {\n        max_factor = n;\n\
    \    }\n    max_factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822549
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut prime = 2;\n    let\
    \ mut factor = n;\n    while factor % prime == 0 {\n        factor /= prime;\n\
    \    }\n    prime += 1;\n    while factor > 1 {\n        while factor % prime\
    \ == 0 {\n            factor /= prime;\n        }\n        prime += 2;\n    }\n\
    \    prime - 2\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822549
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    // We can immediately eliminate\
    \ 1, 2, and 3 from the set of possible\n    // solutions because they are all\
    \ prime.\n    let mut largest = 4;\n    let mut running = n;\n    while running\
    \ % 2 == 0 {\n        largest = 2;\n        running /= 2;\n    }\n    // This\
    \ range is where all the prime factors will be.\n    for p in (3..isize::sqrt(n)\
    \ + 1).step_by(2) {\n        if running % p == 0 {\n            largest = p;\n\
    \            running /= p;\n        }\n    }\n    largest\n}\n\nfn main() {\n\
    \    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no function or associated item named `sqrt` found for type\
    \ `isize` in the current scope\n  --> /tmp/tmp824buq0_.rs:12:25\n   |\n12 |  \
    \   for p in (3..isize::sqrt(n) + 1).step_by(2) {\n   |                      \
    \   ^^^^ function or associated item not found in `isize`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659822549
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut factor = 2;\n    let\
    \ mut n = n;\n    while n > 1 {\n        if n % factor == 0 {\n            n /=\
    \ factor;\n        } else {\n            factor += 1;\n        }\n    }\n    factor\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822548
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut a = 2;\n    let mut\
    \ b = n;\n    while a * a <= b {\n        if b % a == 0 {\n            b /= a;\n\
    \        } else {\n            a += 1;\n        }\n    }\n    b\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822549
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    for i in (2..).take_while(|&i|\
    \ i * i <= n) {\n        if n % i == 0 {\n            return largest_prime_factor(n\
    \ / i);\n        }\n    }\n    n\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822548
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    for i in (2..).take_while(|&i|\
    \ i * i <= n) {\n        if n % i == 0 {\n            return largest_prime_factor(n\
    \ / i);\n        }\n    }\n    n\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822548
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let mut\
    \ factor = 2;\n    while n % factor != 0 {\n        factor += 1;\n    }\n    while\
    \ n % factor == 0 {\n        n /= factor;\n    }\n    if n == 1 {\n        factor\n\
    \    } else {\n        largest_prime_factor(n)\n    }\n}\n\nfn main() {\n    let\
    \ candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822549
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut factor = 0;\n    let\
    \ mut i = 2;\n    let mut n = n;\n    while i <= n {\n        if n % i == 0 {\n\
    \            factor = i;\n            n /= i;\n            while n % i == 0 {\n\
    \                n /= i;\n            }\n        }\n        i += 1;\n    }\n \
    \   factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822549
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut prime_factors = Vec::new();\n\
    \    let mut dividend = n;\n    let mut divisor = 2;\n    while dividend > 1 {\n\
    \        if dividend % divisor == 0 {\n            prime_factors.push(divisor);\n\
    \            dividend /= divisor;\n        } else {\n            divisor += 1;\n\
    \        }\n    }\n    prime_factors.iter().max().unwrap().clone()\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822549
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut f = 2;\n    while n\
    \ % f != 0 {\n        f += 1;\n    }\n    let quotient = n / f;\n    if is_prime(quotient)\
    \ {\n        quotient\n    } else {\n        largest_prime_factor(quotient)\n\
    \    }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmpp6lwhqwm.rs:8:8\n\
    \  |\n8 |     if is_prime(quotient) {\n  |        ^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822549
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut primes = Primes::new();\n\
    \    loop {\n        let p = primes.next().unwrap();\n        if n % p == 0 {\n\
    \            return p;\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Primes`\n -->\
    \ /tmp/tmp6m7z5nu9.rs:3:22\n  |\n3 |     let mut primes = Primes::new();\n  |\
    \                      ^^^^^^ use of undeclared type `Primes`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659822549
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    while i\
    \ < n / 2 {\n        if n % i == 0 {\n            return largest_prime_factor(n\
    \ / i);\n        }\n        i += 1;\n    }\n    n\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822549
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    for p in factors(n) {\n    \
    \    if is_prime(p) {\n            return p;\n        }\n    }\n    panic!(\"\
    No prime factor\");\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `factors` in this scope\n --> /tmp/tmp1wxe385q.rs:3:14\n\
    \  |\n3 |     for p in factors(n) {\n  |              ^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmp1wxe385q.rs:4:12\n\
    \  |\n4 |         if is_prime(p) {\n  |            ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822549
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut factor = 2;\n    let\
    \ mut n = n;\n    while n % factor != 0 {\n        factor += 1;\n    }\n    n\
    \ / factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `3`', /tmp/tmpx3lx1izb.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822549
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    if is_prime(n) {\n        return\
    \ n;\n    }\n\n    // Find the smallest factor.\n    let mut factor = 2;\n   \
    \ while n % factor != 0 {\n        factor += 1;\n    }\n\n    // Return the largest\
    \ prime factor of n / factor.\n    largest_prime_factor(n / factor)\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmpyzj6362y.rs:3:8\n\
    \  |\n3 |     if is_prime(n) {\n  |        ^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822549
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    while i\
    \ * i <= n {\n        if n % i == 0 {\n            // If i is not prime, then\
    \ the largest prime factor is not in the\n            // range [2,i].\n      \
    \      if !is_prime(i) {\n                return largest_prime_factor(n / i);\n\
    \            }\n            return n / i;\n        }\n        i += 1;\n    }\n\
    \    // n is prime\n    n\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmp5tk25wuq.rs:8:17\n\
    \  |\n8 |             if !is_prime(i) {\n  |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822549
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut current = n;\n    let\
    \ mut result = 0;\n    while current % 2 == 0 {\n        current /= 2;\n    }\n\
    \    if current == 1 {\n        return 2;\n    }\n    for d in (3..).step_by(2)\
    \ {\n        while current % d == 0 {\n            current /= d;\n           \
    \ result = d;\n        }\n        if current == 1 {\n            return result;\n\
    \        }\n    }\n    unreachable!();\n}\n\nfn main() {\n    let candidate =\
    \ largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822549
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    if n < 2 {\n        panic!(\"\
    largest_prime_factor of {} is invalid\", n);\n    }\n\n    // We only check up\
    \ to the square root of n.\n    let factor_limit = (n as f64).sqrt() as isize;\n\
    \n    // Start checking primes at 5, since 2 and 3 are the only primes < 5.\n\
    \    let mut test_factor = 5;\n\n    // Check for whether n is divisible by any\
    \ smaller primes first.\n    for p in 2..factor_limit {\n        if n % p == 0\
    \ {\n            return largest_prime_factor(n / p);\n        }\n    }\n\n   \
    \ // Try all the odd numbers from 5 to factor_limit.\n    while test_factor <=\
    \ factor_limit {\n        if n % test_factor == 0 {\n            return largest_prime_factor(n\
    \ / test_factor);\n        }\n        test_factor += 2;\n    }\n\n    // None\
    \ of the smaller primes or odd numbers worked, so n must be prime.\n    return\
    \ n;\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `15`,\n right: `5`', /tmp/tmplx9t5lwv.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822549
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut largest_prime_factor\
    \ = 1;\n    let mut remaining = n;\n    let mut current_prime = 2;\n    while\
    \ remaining > 1 {\n        if remaining % current_prime == 0 {\n            remaining\
    \ /= current_prime;\n            largest_prime_factor = current_prime;\n     \
    \   } else {\n            current_prime = next_prime(current_prime);\n       \
    \ }\n    }\n    largest_prime_factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `next_prime` in this scope\n  --> /tmp/tmpvzg9jzhg.rs:11:29\n\
    \   |\n11 |             current_prime = next_prime(current_prime);\n   |     \
    \                        ^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659822549
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut largest_prime = 1;\n\
    \    let mut cur = n;\n    let mut i = 2;\n    while i <= cur {\n        if cur\
    \ % i == 0 {\n            largest_prime = i;\n            cur /= i;\n        }\
    \ else {\n            i += 1;\n        }\n    }\n    largest_prime\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822549
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut biggest = 1;\n    let\
    \ mut i = 2;\n    while i * i <= n {\n        if n % i == 0 {\n            biggest\
    \ = i;\n            n /= i;\n        } else {\n            i += 1;\n        }\n\
    \    }\n    if n > 1 {\n        biggest = n;\n    }\n    biggest\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n --> /tmp/tmpvkzhjke3.rs:8:13\n\
    \  |\n2 | fn largest_prime_factor(n: isize) -> isize {\n  |                  \
    \       - help: consider making this binding mutable: `mut n`\n...\n8 |      \
    \       n /= i;\n  |             ^^^^^^ cannot assign to immutable argument\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659822549
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let mut\
    \ p = 2;\n    while n % p != 0 {\n        p += 1;\n    }\n    n /= p;\n    while\
    \ !is_prime(n) {\n        p = largest_prime_factor(n);\n        n /= p;\n    }\n\
    \    n\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmpki187abi.rs:9:12\n\
    \  |\n9 |     while !is_prime(n) {\n  |            ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822549
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    if is_prime(n) {\n        return\
    \ n;\n    }\n\n    let mut d = 2;\n    while d * d <= n {\n        if n % d ==\
    \ 0 {\n            return largest_prime_factor(n / d);\n        }\n        d +=\
    \ 1;\n    }\n\n    n\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmpyw2h_les.rs:3:8\n\
    \  |\n3 |     if is_prime(n) {\n  |        ^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822549
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    assert!(n > 1);\n    let mut\
    \ n = n;\n    let mut largest_factor = 1;\n    for factor in 2..n {\n        if\
    \ n % factor == 0 {\n            largest_factor = factor;\n            n /= factor;\n\
    \            while n % factor == 0 {\n                n /= factor;\n         \
    \   }\n        }\n    }\n    if n > 1 {\n        largest_factor = n;\n    }\n\
    \    largest_factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822549
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let sqrt_n = (n as f64).sqrt()\
    \ as isize;\n    let mut i = sqrt_n;\n    while i > 1 {\n        if n % i == 0\
    \ && is_prime(i) {\n            return i;\n        }\n        i -= 1;\n    }\n\
    \    n\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmp8uirhnhx.rs:6:26\n\
    \  |\n6 |         if n % i == 0 && is_prime(i) {\n  |                        \
    \  ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822549
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut largest_prime_factor\
    \ = 0;\n    let mut i = 2;\n    while i * i <= n {\n        if n % i == 0 {\n\
    \            largest_prime_factor = i;\n            while n % i == 0 {\n     \
    \           n /= i;\n            }\n        }\n        i += 1;\n    }\n    if\
    \ n > 1 {\n        largest_prime_factor = n;\n    }\n    largest_prime_factor\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n --> /tmp/tmp9xl2yawi.rs:9:17\n\
    \  |\n2 | fn largest_prime_factor(n: isize) -> isize {\n  |                  \
    \       - help: consider making this binding mutable: `mut n`\n...\n9 |      \
    \           n /= i;\n  |                 ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659822549
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    let mut\
    \ res = n;\n    while i * i <= n {\n        if res % i == 0 {\n            res\
    \ /= i;\n        } else {\n            i += 1;\n        }\n    }\n    res\n}\n\
    \nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `3`', /tmp/tmpr4skf2r_.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822549
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let mut\
    \ d = 2;\n    while n > 1 {\n        while n % d == 0 {\n            n /= d;\n\
    \        }\n        d += 1;\n    }\n    d - 1\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822549
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut divisor = 2;\n    let\
    \ mut remaining = n;\n    while divisor * divisor <= remaining {\n        if remaining\
    \ % divisor == 0 {\n            remaining /= divisor;\n        } else {\n    \
    \        divisor += 1;\n        }\n    }\n    remaining\n}\n\nfn main() {\n  \
    \  let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822549
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    while i\
    \ * i <= n {\n        if n % i == 0 {\n            return largest_prime_factor(n\
    \ / i);\n        }\n        i += 1;\n    }\n    return n;\n}\n\nfn main() {\n\
    \    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822549
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut prime = 2;\n    let\
    \ mut max_prime = 2;\n    let max = (n as f64).sqrt() as isize;\n    while prime\
    \ <= max {\n        if n % prime == 0 {\n            max_prime = largest_prime_factor(n\
    \ / prime);\n            break;\n        }\n        prime += 1;\n    }\n    max_prime\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `5`', /tmp/tmpskfp5uq9.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822549
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut k = n / 2;\n    while\
    \ k > 1 {\n        if n % k == 0 && is_prime(k) {\n            return k;\n   \
    \     }\n        k -= 1;\n    }\n    unreachable!();\n}\n\nfn main() {\n    let\
    \ candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmp592suntp.rs:5:26\n\
    \  |\n5 |         if n % k == 0 && is_prime(k) {\n  |                        \
    \  ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822549
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut d = 2;\n    let mut\
    \ n = n;\n    while n % d != 0 {\n        d += 1;\n    }\n    let p = n / d;\n\
    \    let mut d = 2;\n    while p % d != 0 {\n        d += 1;\n    }\n    return\
    \ n / d;\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmp3ll8zrez.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822550
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let mut\
    \ i = 2;\n    let mut prime = 1;\n    while i <= n {\n        if n % i == 0 {\n\
    \            n /= i;\n            prime = i;\n        } else {\n            i\
    \ += 1;\n        }\n    }\n    prime\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822550
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut limit = (n as f64).sqrt()\
    \ as isize;\n    if limit % 2 == 0 {\n        limit -= 1;\n    }\n    for i in\
    \ (3..=limit).step_by(2) {\n        if n % i == 0 {\n            return largest_prime_factor(n\
    \ / i);\n        }\n    }\n    n\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `22`,\n right: `11`', /tmp/tmpa8i0vtqd.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822550
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    for factor in (2..).take_while(|&x|\
    \ x * x <= n) {\n        if n % factor == 0 {\n            return largest_prime_factor(n\
    \ / factor);\n        }\n    }\n    n\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822550
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    let mut\
    \ m = n;\n    while i * i <= m {\n        if m % i == 0 {\n            m /= i;\n\
    \        } else {\n            i += 1;\n        }\n    }\n    m\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822550
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut largest = 1;\n    let\
    \ mut factor = 2;\n    let mut num = n;\n    while num > 1 {\n        if num %\
    \ factor == 0 {\n            largest = factor;\n            num /= factor;\n \
    \           while num % factor == 0 {\n                num /= factor;\n      \
    \      }\n        }\n        factor += 1;\n    }\n    largest\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822550
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let largest_prime_factor = (2..n).rev().find(|&x|\
    \ is_prime(x) && n % x == 0).unwrap();\n    largest_prime_factor\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmp2rit6ipi.rs:3:55\n\
    \  |\n3 |     let largest_prime_factor = (2..n).rev().find(|&x| is_prime(x) &&\
    \ n % x == 0).unwrap();\n  |                                                 \
    \      ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822549
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut largest = 1;\n    let\
    \ mut i = 2;\n    let mut m = n;\n    while i <= m {\n        if m % i == 0 {\n\
    \            largest = i;\n            m /= i;\n        } else {\n           \
    \ i += 1;\n        }\n    }\n    largest\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822550
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    while i\
    \ * i <= n {\n        if n % i == 0 {\n            return largest_prime_factor(n\
    \ / i);\n        }\n        i += 1;\n    }\n    n\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822549
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    // This algorithm is \"brute\
    \ force\". It's not the fastest way of solving the problem, but\n    // it is\
    \ conceptually easy to understand.\n\n    // Guard against anything that is not\
    \ a positive integer.\n    assert!(n > 1);\n\n    // Iterate over a range of possible\
    \ factors.\n    for i in (2..n).rev() {\n        // We only care about prime factors.\n\
    \        if !is_prime(i) {\n            continue;\n        }\n\n        // If\
    \ i is a factor, then i is the largest prime factor of n.\n        if n % i ==\
    \ 0 {\n            return i;\n        }\n    }\n\n    // This should never happen.\n\
    \    panic!(\"Failed to find largest prime factor of {}\", n);\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpjx7w_m8p.rs:12:13\n\
    \   |\n12 |         if !is_prime(i) {\n   |             ^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822549
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let s = math::square_root(n)\
    \ as isize;\n    let (mut res, mut i) = (1, 2);\n    loop {\n        if (n % i)\
    \ == 0 {\n            res = i;\n            break;\n        }\n        i += 1;\n\
    \        if i > s {\n            res = n;\n            break;\n        }\n   \
    \ }\n    res\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n  \
    \  assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `math`\n\
    \ --> /tmp/tmpgokor4am.rs:3:13\n  |\n3 |     let s = math::square_root(n) as isize;\n\
    \  |             ^^^^ use of undeclared crate or module `math`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659822549
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let mut\
    \ result = 1;\n    let mut i = 2;\n    while i <= n {\n        if n % i == 0 {\n\
    \            n /= i;\n            result = i;\n        } else {\n            i\
    \ += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822550
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut num = n;\n    let mut\
    \ factor = 2;\n    while num > 1 {\n        while num % factor == 0 {\n      \
    \      num /= factor;\n        }\n        factor += 1;\n    }\n    factor - 1\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822550
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n  for x in n..1 {\n    if (n % x\
    \ == 0) && is_prime(x) {\n      return x;\n    }\n  }\n  0\n}\n\nfn main() {\n\
    \    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmpiftjp8z5.rs:4:24\n\
    \  |\n4 |     if (n % x == 0) && is_prime(x) {\n  |                        ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822549
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let sqrt_n = (n as f64).sqrt()\
    \ as isize;\n    let mut p = 2;\n    while p <= sqrt_n {\n        if n % p ==\
    \ 0 {\n            return largest_prime_factor(n / p);\n        }\n        p +=\
    \ 1;\n    }\n    n\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822550
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    let mut\
    \ largest = 1;\n    while i * i <= n {\n        if n % i == 0 {\n            while\
    \ n % i == 0 {\n                n /= i;\n            }\n            largest =\
    \ i;\n        }\n        i += 1;\n    }\n    if n > 1 {\n        largest = n;\n\
    \    }\n    largest\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n --> /tmp/tmp0rhg6c1l.rs:8:17\n\
    \  |\n2 | fn largest_prime_factor(n: isize) -> isize {\n  |                  \
    \       - help: consider making this binding mutable: `mut n`\n...\n8 |      \
    \           n /= i;\n  |                 ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659822550
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    for i in (2..).map(|x| x * x).take_while(|&x|\
    \ x <= n) {\n        if n % i == 0 {\n            return largest_prime_factor(n\
    \ / i);\n        }\n    }\n    n\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `15`,\n right: `5`', /tmp/tmpitbc1dsh.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822550
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    for i in (1..).map(|x| x * 2)\
    \ {\n        if n % i == 0 {\n            if is_prime(n / i) {\n             \
    \   return n / i;\n            }\n        }\n    }\n    unreachable!();\n}\n\n\
    fn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmpcjuohjhs.rs:5:16\n\
    \  |\n5 |             if is_prime(n / i) {\n  |                ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822550
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut largest_prime_factor\
    \ = 0;\n    let mut value = n;\n    while value % 2 == 0 {\n        largest_prime_factor\
    \ = 2;\n        value /= 2;\n    }\n    let mut divisor = 3;\n    while value\
    \ > 1 {\n        while value % divisor == 0 {\n            largest_prime_factor\
    \ = divisor;\n            value /= divisor;\n        }\n        divisor += 2;\n\
    \    }\n    largest_prime_factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822550
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let mut\
    \ prime = 2;\n    while n % prime == 0 {\n        n /= prime;\n    }\n    prime\
    \ += 1;\n    while n > 1 {\n        while n % prime == 0 {\n            n /= prime;\n\
    \        }\n        prime += 2;\n    }\n    prime - 2\n}\n\nfn main() {\n    let\
    \ candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822550
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    for i in (2..=n).rev() {\n \
    \       if n % i == 0 && is_prime(i) {\n            return i;\n        }\n   \
    \ }\n    unreachable!();\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmp4d2dlvkt.rs:4:26\n\
    \  |\n4 |         if n % i == 0 && is_prime(i) {\n  |                        \
    \  ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822550
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let upper_bound = (n as f64).sqrt()\
    \ as isize + 1;\n    for i in (2..upper_bound).rev() {\n        if is_prime(i)\
    \ && n % i == 0 {\n            return i;\n        }\n    }\n    1\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmpt254648j.rs:5:12\n\
    \  |\n5 |         if is_prime(i) && n % i == 0 {\n  |            ^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822550
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut max = 0;\n    let mut\
    \ i = 2;\n    while i * i <= n {\n        if n % i == 0 {\n            max = i;\n\
    \            while n % i == 0 {\n                n /= i;\n            }\n    \
    \    }\n        i += 1;\n    }\n    if n > 1 {\n        max = n;\n    }\n    max\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n --> /tmp/tmpvpce8hm9.rs:9:17\n\
    \  |\n2 | fn largest_prime_factor(n: isize) -> isize {\n  |                  \
    \       - help: consider making this binding mutable: `mut n`\n...\n9 |      \
    \           n /= i;\n  |                 ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659822550
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let mut\
    \ d = 2;\n    while n % d != 0 {\n        d += 1;\n    }\n    n /= d;\n    if\
    \ n == 1 {\n        d\n    } else {\n        largest_prime_factor(n)\n    }\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822550
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    while i\
    \ * i <= n {\n        if n % i == 0 {\n            return largest_prime_factor(n\
    \ / i);\n        } else {\n            i += 1;\n        }\n    }\n    n\n}\n\n\
    fn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822550
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut m = n;\n    for i in\
    \ 2.. {\n        if m == 1 {\n            break;\n        }\n        if i * i\
    \ > m {\n            return m;\n        }\n        if m % i == 0 {\n         \
    \   m /= i;\n        }\n    }\n    unreachable!();\n}\n\nfn main() {\n    let\
    \ candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `3`', /tmp/tmppld_lde5.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822550
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    for i in (2..n).rev() {\n  \
    \      if is_prime(i) && n % i == 0 {\n            return i;\n        }\n    }\n\
    \    unreachable!();\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmpvik2r97v.rs:4:12\n\
    \  |\n4 |         if is_prime(i) && n % i == 0 {\n  |            ^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822550
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    if is_prime(n) {\n        return\
    \ n;\n    }\n\n    let mut i = 2;\n    let mut factors = vec![];\n    let mut\
    \ is_divisible = false;\n    while i <= n {\n        if is_divisible {\n     \
    \       if n % i == 0 {\n                factors.push(i);\n                is_divisible\
    \ = false;\n            }\n        } else {\n            if n % i == 0 {\n   \
    \             is_divisible = true;\n            }\n        }\n        i += 1;\n\
    \    }\n\n    let mut max = 0;\n    for x in factors {\n        if x > max {\n\
    \            max = x;\n        }\n    }\n    max\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmph_1lm4nh.rs:3:8\n\
    \  |\n3 |     if is_prime(n) {\n  |        ^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822550
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let factors = primes::factors(n);\n\
    \    factors[factors.len() - 1]\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `primes`\n\
    \ --> /tmp/tmp4ftg8u9j.rs:3:19\n  |\n3 |     let factors = primes::factors(n);\n\
    \  |                   ^^^^^^ use of undeclared crate or module `primes`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659822550
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut p = 2;\n    let mut\
    \ n = n;\n    while n % p != 0 {\n        p += 1;\n    }\n    let q = n / p;\n\
    \    if q == 1 {\n        p\n    } else {\n        largest_prime_factor(q)\n \
    \   }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822550
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let factors = prime_factors(n);\n\
    \    *factors.iter().max().unwrap()\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `prime_factors` in this scope\n -->\
    \ /tmp/tmpgduq8seq.rs:3:19\n  |\n3 |     let factors = prime_factors(n);\n  |\
    \                   ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659822550
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let mut\
    \ i = 2;\n    while i < n {\n        if n % i == 0 {\n            n /= i;\n  \
    \      } else {\n            i += 1;\n        }\n    }\n    n\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822550
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let mut\
    \ largest_factor = 1;\n    let mut factor = 2;\n    while n > 1 {\n        while\
    \ n % factor == 0 {\n            n /= factor;\n            largest_factor = factor;\n\
    \        }\n        factor += 1;\n    }\n    largest_factor\n}\n\nfn main() {\n\
    \    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822550
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut largest_factor = 0;\n\
    \    for i in 2..n {\n        if n % i == 0 {\n            largest_factor = largest_prime_factor(n\
    \ / i);\n            break;\n        }\n    }\n    if largest_factor == 0 {\n\
    \        n\n    } else {\n        largest_factor\n    }\n}\n\nfn main() {\n  \
    \  let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822550
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut factors = vec![];\n\
    \    find_all_factors(n, 2, &mut factors);\n    factors.pop().unwrap()\n}\n\n\
    fn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_all_factors` in this scope\n -->\
    \ /tmp/tmpa3y5fup6.rs:4:5\n  |\n4 |     find_all_factors(n, 2, &mut factors);\n\
    \  |     ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822550
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut largest = 0;\n    let\
    \ mut i = 2;\n    while i * i <= n {\n        if n % i == 0 {\n            while\
    \ n % i == 0 {\n                n /= i;\n            }\n            largest =\
    \ i;\n        }\n        i += 1;\n    }\n    if n > 1 {\n        largest = n;\n\
    \    }\n    largest\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n --> /tmp/tmpsxuz1dqo.rs:8:17\n\
    \  |\n2 | fn largest_prime_factor(n: isize) -> isize {\n  |                  \
    \       - help: consider making this binding mutable: `mut n`\n...\n8 |      \
    \           n /= i;\n  |                 ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659822550
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut p = 2;\n    while p\
    \ <= n {\n        if n % p == 0 {\n            return largest_prime_factor(n /\
    \ p);\n        }\n        p += 1;\n    }\n    unreachable!();\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''internal error: entered unreachable code'',
    /tmp/tmpl6sqdblx.rs:10:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822550
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut f = 3;\n    let mut\
    \ last_f = 2;\n    let mut max_f = 1;\n    while n > max_f {\n        if n % f\
    \ == 0 {\n            max_f = f;\n            while n % f == 0 {\n           \
    \     n /= f;\n            }\n        }\n        last_f = f;\n        f += 2;\n\
    \        while f <= last_f {\n            f += 2;\n        }\n    }\n    max_f\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "warning: value assigned to `last_f` is never read\n --> /tmp/tmprk2k6gtp.rs:4:13\n\
    \  |\n4 |     let mut last_f = 2;\n  |             ^^^^^^\n  |\n  = note: `#[warn(unused_assignments)]`\
    \ on by default\n  = help: maybe it is overwritten before being read?\n\nerror[E0384]:\
    \ cannot assign to immutable argument `n`\n  --> /tmp/tmprk2k6gtp.rs:10:17\n \
    \  |\n2  | fn largest_prime_factor(n: isize) -> isize {\n   |                \
    \         - help: consider making this binding mutable: `mut n`\n...\n10 |   \
    \              n /= f;\n   |                 ^^^^^^ cannot assign to immutable\
    \ argument\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor\
    \ more information about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659822550
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut i = n;\n    loop {\n\
    \        if is_prime(i) {\n            return i;\n        }\n        i -= 1;\n\
    \    }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmpl_3fdv7w.rs:5:12\n\
    \  |\n5 |         if is_prime(i) {\n  |            ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822550
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let largest_prime_factor = n;\n\
    \    // Using (2..n) to iterate because we know the largest prime factor cannot\
    \ be larger than n.\n    for i in (2..n).rev() {\n        if is_prime(i) && n\
    \ % i == 0 {\n            largest_prime_factor = i;\n            break;\n    \
    \    }\n    }\n    largest_prime_factor\n}\n\nfn main() {\n    let candidate =\
    \ largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmp3mn75qog.rs:6:12\n\
    \  |\n6 |         if is_prime(i) && n % i == 0 {\n  |            ^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822550
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    // if n is not even, try n-1,\
    \ n-2, n-3, ... until 1.\n    if n % 2 != 0 {\n        for i in (1..n).rev() {\n\
    \            if (n % i == 0) && is_prime(i) {\n                return i;\n   \
    \         }\n        }\n    }\n\n    // if n is even, try n/2, n/3, n/4, ... until\
    \ 1.\n    for i in (1..n).rev() {\n        if (n % i == 0) && is_prime(i) {\n\
    \            return i;\n        }\n    }\n\n    0\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmpjslgx9xi.rs:6:32\n\
    \  |\n6 |             if (n % i == 0) && is_prime(i) {\n  |                  \
    \              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `is_prime` in this scope\n  --> /tmp/tmpjslgx9xi.rs:14:28\n   |\n14 |      \
    \   if (n % i == 0) && is_prime(i) {\n   |                            ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822550
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut m = n;\n    let mut\
    \ p = 2;\n    while m > 1 {\n        if m % p == 0 {\n            m /= p;\n  \
    \      } else {\n            p += 1;\n        }\n    }\n    p\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822550
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let mut\
    \ factor = 2;\n    while n % factor != 0 {\n        factor += 1;\n    }\n    if\
    \ n == factor {\n        factor\n    } else {\n        largest_prime_factor(n\
    \ / factor)\n    }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822550
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut prime_factors = Vec::new();\n\
    \    let mut n = n;\n    while n % 2 == 0 {\n        prime_factors.push(2);\n\
    \        n /= 2;\n    }\n    let mut k = 3;\n    while k * k <= n {\n        while\
    \ n % k == 0 {\n            prime_factors.push(k);\n            n /= k;\n    \
    \    }\n        k += 2;\n    }\n    if n > 2 {\n        prime_factors.push(n);\n\
    \    }\n    prime_factors.last().unwrap().clone()\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822550
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut prime = 2;\n    while\
    \ prime <= n {\n        if n % prime == 0 {\n            return largest_prime_factor(n\
    \ / prime);\n        } else {\n            prime += 1;\n        }\n    }\n   \
    \ prime\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `5`', /tmp/tmpmvlpehwg.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822550
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut j = n;\n    for i in\
    \ (2..n + 1).rev() {\n        if n % i == 0 && is_prime(i) {\n            j =\
    \ i;\n            break;\n        }\n    }\n    j\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmpp_17wtxy.rs:5:26\n\
    \  |\n5 |         if n % i == 0 && is_prime(i) {\n  |                        \
    \  ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822550
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut x = n;\n    for i in\
    \ 2..n {\n        if is_prime(i) && x % i == 0 {\n            x /= i;\n      \
    \  }\n    }\n    x\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmpu6go4b8o.rs:5:12\n\
    \  |\n5 |         if is_prime(i) && x % i == 0 {\n  |            ^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822550
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut remaining = n;\n   \
    \ let mut factor = 2;\n    while remaining > 1 {\n        if remaining % factor\
    \ == 0 {\n            while remaining % factor == 0 {\n                remaining\
    \ /= factor;\n            }\n        }\n        factor += 1;\n    }\n    factor\
    \ - 1\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822550
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut current_factor = 2;\n\
    \    let mut remaining = n;\n    while remaining % current_factor == 0 {\n   \
    \     remaining /= current_factor;\n    }\n    while remaining != 1 {\n      \
    \  current_factor += 1;\n        while remaining % current_factor == 0 {\n   \
    \         remaining /= current_factor;\n        }\n    }\n    current_factor\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822550
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let mut\
    \ largest_prime = 2;\n    while n > largest_prime {\n        if n % largest_prime\
    \ == 0 {\n            n /= largest_prime;\n        } else {\n            largest_prime\
    \ += 1;\n        }\n    }\n    largest_prime\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822550
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    // Note: the largest prime factor\
    \ is at most the square root of n.\n    let mut i = 2;\n    let max = ((n as f64).sqrt()\
    \ as isize) + 1;\n    while i < max {\n        if n % i == 0 {\n            return\
    \ largest_prime_factor(n / i);\n        }\n        i += 1;\n    }\n    n\n}\n\n\
    fn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822550
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut p = 2;\n    while p\
    \ < n / p {\n        if n % p == 0 {\n            return largest_prime_factor(n\
    \ / p);\n        }\n        p += 1;\n    }\n    return n;\n}\n\nfn main() {\n\
    \    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `3`', /tmp/tmp4fv7m00z.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822550
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    // Use a Sieve of Eratosthenes\
    \ to generate all primes up to n\n    let mut sieve = vec![true; n as usize];\n\
    \    sieve[0] = false;\n    sieve[1] = false;\n    let mut k = 2;\n    while k\
    \ < n {\n        if sieve[k as usize] {\n            let mut j = k * k;\n    \
    \        while j < n {\n                sieve[j as usize] = false;\n         \
    \       j += k;\n            }\n        }\n        k += 1;\n    }\n\n    // Divide\
    \ n by primes in decreasing order until we find the largest factor\n    let mut\
    \ i = n - 1;\n    while i > 1 {\n        if sieve[i as usize] && n % i == 0 {\n\
    \            return i;\n        }\n        i -= 1;\n    }\n    unreachable!();\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822550
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    for i in (2..).take_while(|x|\
    \ x * x <= n) {\n        if n % i == 0 {\n            return largest_prime_factor(n\
    \ / i);\n        }\n    }\n    n\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822550
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut x = n;\n    let mut\
    \ factor = 2;\n    while x > 1 {\n        if is_prime(factor) && x % factor ==\
    \ 0 {\n            x /= factor;\n        }\n        factor += 1;\n    }\n    factor\
    \ - 1\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmp0ge7d3gm.rs:6:12\n\
    \  |\n6 |         if is_prime(factor) && x % factor == 0 {\n  |            ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822550
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut f = 2;\n    let mut\
    \ lpf = 0;\n    while f * f <= n {\n        if n % f == 0 {\n            lpf =\
    \ f;\n            while n % f == 0 {\n                n /= f;\n            }\n\
    \        }\n        f += 1;\n    }\n    if n > 1 {\n        lpf = n;\n    }\n\
    \    lpf\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n --> /tmp/tmpk6e0zp7o.rs:9:17\n\
    \  |\n2 | fn largest_prime_factor(n: isize) -> isize {\n  |                  \
    \       - help: consider making this binding mutable: `mut n`\n...\n9 |      \
    \           n /= f;\n  |                 ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659822550
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let mut\
    \ i = 2;\n    while i < n {\n        if n % i == 0 {\n            n /= i;\n  \
    \      } else {\n            i += 1;\n        }\n    }\n    n\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822550
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut p = 2;\n    let mut\
    \ n = n;\n    while n > 1 {\n        if n % p == 0 {\n            n /= p;\n  \
    \      } else {\n            p += 1;\n        }\n    }\n    p\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822548
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut factors = Vec::new();\n\
    \    let mut k = n;\n    for i in 2..n {\n        if k % i == 0 {\n          \
    \  factors.push(i);\n            k /= i;\n        }\n    }\n    *factors.last().unwrap()\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `3`', /tmp/tmp72zsmj5f.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822550
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    for i in (2..).take_while(|x|\
    \ x * x <= n) {\n        if n % i == 0 {\n            return largest_prime_factor(n\
    \ / i);\n        }\n    }\n    n\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822550
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut largest_factor = 1;\n\
    \    let mut factor = 2;\n    let mut divisor = n;\n    while divisor != 1 {\n\
    \        if divisor % factor == 0 {\n            if factor > largest_factor {\n\
    \                largest_factor = factor;\n            }\n            divisor\
    \ /= factor;\n        } else {\n            factor += 1;\n        }\n    }\n \
    \   largest_factor\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822550
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    for i in (2..).take_while(|i|\
    \ i * i <= n) {\n        if n % i == 0 {\n            return largest_prime_factor(n\
    \ / i);\n        }\n    }\n    n\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822550
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut result = 0;\n    let\
    \ mut d = 2;\n    let mut n = n;\n    while n > 1 {\n        while n % d == 0\
    \ {\n            result = d;\n            n /= d;\n        }\n        d += 1;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822550
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    for i in\
    \ 2..((n as f64).sqrt() as isize + 1) {\n        if n % i == 0 {\n           \
    \ n /= i;\n            while n % i == 0 {\n                n /= i;\n         \
    \   }\n        }\n    }\n    n\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `3`', /tmp/tmpoflhcufn.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822550
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let ceiling = (n as f64).sqrt()\
    \ as isize;\n    for i in (2..ceiling).rev() {\n        if n % i == 0 && is_prime(i)\
    \ {\n            return i;\n        }\n    }\n    panic!(\"Cannot find largest\
    \ prime factor\");\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmph6zqyrqk.rs:5:26\n\
    \  |\n5 |         if n % i == 0 && is_prime(i) {\n  |                        \
    \  ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822550
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    // upper bound on the largest\
    \ prime factor is the square root of n\n    let limit = isize::sqrt(n);\n    //\
    \ try all odd numbers between 3 and the square root of n\n    for possible_factor\
    \ in (3..limit).step_by(2) {\n        if n % possible_factor == 0 {\n        \
    \    // if n is divisible by a number in the range, return the largest prime factor\n\
    \            return largest_prime_factor(n / possible_factor);\n        }\n  \
    \  }\n    // if no factor was found, we return n\n    n\n}\n\nfn main() {\n  \
    \  let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no function or associated item named `sqrt` found for type\
    \ `isize` in the current scope\n --> /tmp/tmp0n_r6bha.rs:4:24\n  |\n4 |     let\
    \ limit = isize::sqrt(n);\n  |                        ^^^^ function or associated\
    \ item not found in `isize`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659822550
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut i = 3;\n    while i\
    \ <= (n as f64).sqrt() as isize {\n        if n % i == 0 {\n            return\
    \ largest_prime_factor(n / i);\n        }\n        i += 2;\n    }\n    n\n}\n\n\
    fn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `22`,\n right: `11`', /tmp/tmpvnj45dn1.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822550
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let max = n / 2;\n    let mut\
    \ n = n;\n    let mut i = 2;\n    while i <= max {\n        while n % i == 0 {\n\
    \            n /= i;\n        }\n        i += 1;\n    }\n    n\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `5`', /tmp/tmpa71woke6.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822550
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut largest_prime = -1;\n\
    \    let max = (n as f64).sqrt() as isize;\n    for i in 2..max {\n        if\
    \ n % i == 0 {\n            if is_prime(i) {\n                largest_prime =\
    \ i;\n            }\n        }\n    }\n    largest_prime\n}\n\nfn main() {\n \
    \   let candidate = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n\
    \    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330),\
    \ 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmpuwppvurp.rs:7:16\n\
    \  |\n7 |             if is_prime(i) {\n  |                ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822550
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut cur = n;\n    let mut\
    \ prime = 2;\n    while prime <= cur {\n        if cur % prime == 0 {\n      \
    \      cur /= prime;\n        } else {\n            prime += 1;\n        }\n \
    \   }\n    prime\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822550
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    for x in (2..).take_while(|x|\
    \ x * x <= n) {\n        if n % x == 0 {\n            return largest_prime_factor(n\
    \ / x);\n        }\n    }\n    n\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822550
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    // If a number is a multiple\
    \ of two, then it is not a prime.\n    // If it is not a multiple of two, then\
    \ it is not a multiple of four.\n    let mut lpf = 0;\n    let mut num = n;\n\
    \    if num % 2 == 0 {\n        num /= 2;\n        lpf = 2;\n    }\n    // We\
    \ start checking prime numbers at 3, because 2 is the smallest prime\n    // number\
    \ and we have already checked that.\n    let mut i = 3;\n    while num != 1 {\n\
    \        if num % i == 0 {\n            num /= i;\n            lpf = i;\n    \
    \    } else {\n            i += 2;\n        }\n    }\n    lpf\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822550
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut i = 3;\n    while i\
    \ * i <= n {\n        if n % i == 0 {\n            return largest_prime_factor(n\
    \ / i);\n        }\n        i += 2;\n    }\n    n\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `22`,\n right: `11`', /tmp/tmptta3oe9b.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822550
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let mut\
    \ i = 2;\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i;\n\
    \        } else {\n            i += 1;\n        }\n    }\n    n\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822549
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    for divisor in (2..).take_while(|d|\
    \ d * d <= n) {\n        if n % divisor == 0 {\n            return largest_prime_factor(n\
    \ / divisor);\n        }\n    }\n    n\n}\n\nfn main() {\n    let candidate =\
    \ largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822550
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let mut\
    \ factor = 2;\n    let max_factor = (n as f64).sqrt() as isize;\n    while factor\
    \ <= max_factor {\n        if n % factor == 0 {\n            n /= factor;\n  \
    \          while n % factor == 0 {\n                n /= factor;\n           \
    \ }\n        }\n        factor += 1;\n    }\n    if n > 1 {\n        n\n    }\
    \ else {\n        factor - 1\n    }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `3`', /tmp/tmpukwziiy6.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822550
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut factors = Vec::new();\n\
    \    let mut d = 2;\n    let mut m = n;\n    while m > 1 {\n        if m % d ==\
    \ 0 {\n            factors.push(d);\n            m /= d;\n        } else {\n \
    \           d += 1;\n        }\n    }\n    factors.last().unwrap().clone()\n}\n\
    \nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822550
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut p = 2;\n    let mut\
    \ m = n;\n    while p * p <= m {\n        if m % p == 0 {\n            m /= p;\n\
    \        } else {\n            p += 1;\n        }\n    }\n    m\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822550
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    while i\
    \ <= n {\n        if n % i == 0 {\n            return largest_prime_factor(n /\
    \ i);\n        }\n        i += 1;\n    }\n    panic!(\"Cannot find largest prime\
    \ factor of {}\", n);\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''Cannot find largest prime factor of 1'',
    /tmp/tmptirrih8s.rs:10:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822550
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    let mut\
    \ res = 0;\n    while i * i <= n {\n        if n % i == 0 {\n            res =\
    \ i;\n            while n % i == 0 {\n                n /= i;\n            }\n\
    \        }\n        i += 1;\n    }\n    if n > 1 {\n        res = n;\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n --> /tmp/tmp5urflays.rs:9:17\n\
    \  |\n2 | fn largest_prime_factor(n: isize) -> isize {\n  |                  \
    \       - help: consider making this binding mutable: `mut n`\n...\n9 |      \
    \           n /= i;\n  |                 ^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659822550
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    for p in (1..(n as f64).sqrt()\
    \ as isize + 1).rev() {\n        if n % p == 0 && is_prime(p) {\n            return\
    \ p;\n        }\n    }\n    unreachable!();\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmprs9rwna0.rs:4:26\n\
    \  |\n4 |         if n % p == 0 && is_prime(p) {\n  |                        \
    \  ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822550
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    for i in (2..n).rev() {\n  \
    \      if is_prime(i) && n % i == 0 {\n            return i;\n        }\n    }\n\
    \    panic!(\"Should never happen!\");\n}\n\nfn main() {\n    let candidate =\
    \ largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmpeev9a0oa.rs:4:12\n\
    \  |\n4 |         if is_prime(i) && n % i == 0 {\n  |            ^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822550
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut result = 1;\n    let\
    \ mut div = 2;\n    let mut n = n;\n    while n > 1 {\n        if n % div == 0\
    \ {\n            result = div;\n            n /= div;\n            // divide out\
    \ all instances of div\n            while n % div == 0 {\n                n /=\
    \ div;\n            }\n        }\n        div += 1;\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822550
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut possible_factor = n\
    \ / 2;\n    loop {\n        if is_prime(possible_factor) && is_factor(possible_factor,\
    \ n) {\n            return possible_factor;\n        }\n        possible_factor\
    \ -= 1;\n    }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmp9zrwdo7v.rs:5:12\n\
    \  |\n5 |         if is_prime(possible_factor) && is_factor(possible_factor, n)\
    \ {\n  |            ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `is_factor` in this scope\n --> /tmp/tmp9zrwdo7v.rs:5:41\n  |\n5 |\
    \         if is_prime(possible_factor) && is_factor(possible_factor, n) {\n  |\
    \                                         ^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822550
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n  let (max_prime, n) = largest_prime_factor_recursive(n,\
    \ 2);\n  assert!(is_prime(n));\n  max_prime\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `largest_prime_factor_recursive` in\
    \ this scope\n --> /tmp/tmpwj1r9hog.rs:3:24\n  |\n3 |   let (max_prime, n) = largest_prime_factor_recursive(n,\
    \ 2);\n  |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find function `is_prime` in this scope\n\
    \ --> /tmp/tmpwj1r9hog.rs:4:11\n  |\n4 |   assert!(is_prime(n));\n  |        \
    \   ^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822550
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let limit = (n as f64).sqrt()\
    \ as isize;\n    //println!(\"limit = {}\", limit);\n    let mut p = 2;\n    while\
    \ p <= limit {\n        //println!(\"p = {}\", p);\n        if n % p == 0 {\n\
    \            return largest_prime_factor(n / p);\n        }\n        p += 1;\n\
    \    }\n    n\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n \
    \   assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822551
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut factors = vec![];\n\
    \    let mut rem = n;\n    while rem % 2 == 0 {\n        factors.push(2);\n  \
    \      rem /= 2;\n    }\n    let mut factor = 3;\n    while rem > 1 {\n      \
    \  while rem % factor == 0 {\n            factors.push(factor);\n            rem\
    \ /= factor;\n        }\n        factor += 2;\n    }\n    *factors.last().unwrap()\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822551
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut largest_prime_factor\
    \ = n;\n    for i in 2..n {\n        if n % i == 0 {\n            largest_prime_factor\
    \ = largest_prime_factor(n / i);\n            break;\n        }\n    }\n    largest_prime_factor\n\
    }\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0618]: expected function, found `isize`\n --> /tmp/tmpgusck3st.rs:6:36\n\
    \  |\n3 |     let mut largest_prime_factor = n;\n  |         ------------------------\
    \ `largest_prime_factor` has type `isize`\n...\n6 |             largest_prime_factor\
    \ = largest_prime_factor(n / i);\n  |                                    ^^^^^^^^^^^^^^^^^^^^-------\n\
    \  |                                    |\n  |                               \
    \     call expression requires function\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0618`.\n"
  stdout: ''
  timestamp: 1659822550
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut i = 2;\n    let mut\
    \ val = n;\n    while i < val {\n        if val % i == 0 {\n            val /=\
    \ i;\n        } else {\n            i += 1;\n        }\n    }\n    val\n}\n\n\
    fn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822551
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let max = f64::floor(f64::sqrt(n\
    \ as f64)) as isize;\n    let mut i = 2;\n    while i <= max {\n        if n %\
    \ i == 0 {\n            return largest_prime_factor(n / i);\n        }\n     \
    \   i += 1;\n    }\n    n\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822551
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    // Keep track of the lowest\
    \ prime factor.\n    let mut lowest_factor = 2;\n    // Keep track of the remaining\
    \ value.\n    let mut remaining = n;\n    while remaining > 1 {\n        // Divide\
    \ by the lowest factor and check the remainder.\n        if remaining % lowest_factor\
    \ == 0 {\n            // The lowest factor is indeed a factor.\n            remaining\
    \ /= lowest_factor;\n        } else {\n            // The lowest factor is not\
    \ a factor.\n            lowest_factor += 1;\n        }\n    }\n    // Return\
    \ the lowest factor, which will be the largest factor.\n    lowest_factor\n}\n\
    \nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822551
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut curr = n;\n    for i\
    \ in (2..n).rev() {\n        if curr % i == 0 && is_prime(i) {\n            return\
    \ i;\n        }\n    }\n    unreachable!()\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmpii5l01s3.rs:5:29\n\
    \  |\n5 |         if curr % i == 0 && is_prime(i) {\n  |                     \
    \        ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822550
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut largest_factor = 2;\n\
    \    let mut i = 2;\n    while i <= n {\n        if n % i == 0 {\n           \
    \ largest_factor = i;\n            n /= i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    largest_factor\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n --> /tmp/tmpgfuinyc8.rs:8:13\n\
    \  |\n2 | fn largest_prime_factor(n: isize) -> isize {\n  |                  \
    \       - help: consider making this binding mutable: `mut n`\n...\n8 |      \
    \       n /= i;\n  |             ^^^^^^ cannot assign to immutable argument\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659822550
- exit_code: 1
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    // The largest possible prime\
    \ factor is the square root of n.\n    let mut p = (n as f64).sqrt() as isize;\n\
    \    loop {\n        if is_prime(p) && n % p == 0 {\n            return p;\n \
    \       }\n        p -= 1;\n    }\n}\n\nfn main() {\n    let candidate = largest_prime_factor;\n\
    \    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63),\
    \ 7);\n    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n --> /tmp/tmph3gc65s5.rs:6:12\n\
    \  |\n6 |         if is_prime(p) && n % p == 0 {\n  |            ^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822550
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut d = 2;\n    while n\
    \ % d != 0 {\n        d += 1;\n    }\n    let m = n / d;\n    if m == 1 {\n  \
    \      d\n    } else {\n        largest_prime_factor(m)\n    }\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822551
- exit_code: 101
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut n = n;\n    let mut\
    \ largest_prime = 1;\n    let mut i = 2;\n    while i < n {\n        if n % i\
    \ == 0 {\n            n /= i;\n            largest_prime = i;\n        } else\
    \ {\n            i += 1;\n        }\n    }\n    largest_prime\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmpzmsq4u1y.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822551
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut f = 2;\n    while n\
    \ % f != 0 {\n        f += 1;\n    }\n    if n / f == 1 {\n        f\n    } else\
    \ {\n        largest_prime_factor(n / f)\n    }\n}\n\nfn main() {\n    let candidate\
    \ = largest_prime_factor;\n    assert_eq!(candidate(15), 5);\n    assert_eq!(candidate(27),\
    \ 3);\n    assert_eq!(candidate(63), 7);\n    assert_eq!(candidate(330), 11);\n\
    \    assert_eq!(candidate(13195), 29);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822551
- exit_code: 0
  program: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    fn largest_prime_factor(n: isize) -> isize {\n    let mut x = n;\n    let mut\
    \ i = 2;\n    while i <= x {\n        if x % i == 0 {\n            x /= i;\n \
    \       } else {\n            i += 1;\n        }\n    }\n    i\n}\n\nfn main()\
    \ {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
    \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n\
    \    assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822551
