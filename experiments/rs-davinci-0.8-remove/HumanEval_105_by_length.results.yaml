language: rs
name: HumanEval_105_by_length
results:
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut valid_arr: Vec<isize> = arr.iter().filter(|&&x| x > 0 && x < 10).cloned().collect();\n\
    \    valid_arr.sort();\n    valid_arr.reverse();\n    valid_arr.iter().map(|&x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"8\", \"5\", \"4\", \"3\", \"2\", \"2\", \"1\", \"1\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmp1swh57ig.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821432
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut v: Vec<isize> = arr.iter().filter(|&x| x >= &1 && x <= &9).cloned().collect();\n\
    \    v.sort();\n    v.reverse();\n    v.iter().map(|x| digit_name(*x)).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `digit_name` in this scope\n  --> /tmp/tmp834y426u.rs:15:22\n\
    \   |\n15 |     v.iter().map(|x| digit_name(*x)).collect()\n   |             \
    \         ^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821432
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut sorted_arr = arr.clone();\n    sorted_arr.sort();\n    sorted_arr.dedup();\n\
    \    if sorted_arr.len() < 1 {\n        return Vec::new();\n    }\n    let mut\
    \ result = Vec::new();\n    for x in &sorted_arr {\n        if x < &1 || x > &9\
    \ {\n            continue;\n        }\n        let num_str = match x {\n     \
    \       1 => \"One\",\n            2 => \"Two\",\n            3 => \"Three\",\n\
    \            4 => \"Four\",\n            5 => \"Five\",\n            6 => \"Six\"\
    ,\n            7 => \"Seven\",\n            8 => \"Eight\",\n            9 =>\
    \ \"Nine\",\n            _ => \"\",\n        };\n        result.push(String::from(num_str));\n\
    \    }\n    result.reverse();\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"One\"]`,\n right: `[\"\
    Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`',\
    \ /tmp/tmp3ak5a5lr.rs:43:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut sort_arr = arr.iter().filter(|x| x > &&0 && x < &&10).map(|x| *x).collect::<Vec<isize>>();\n\
    \    sort_arr.sort();\n    sort_arr.reverse();\n    sort_arr.iter().map(|x|  match\
    \ x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n\
    \        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n     \
    \   7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n       \
    \ _ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut nbrs = arr.iter().filter(|&&n| n > 0 && n < 10).cloned().collect::<Vec<isize>>();\n\
    \    nbrs.sort();\n    nbrs.reverse();\n    let words = nbrs.iter().map(|&n| match\
    \ n {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n\
    \        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n     \
    \   7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n       \
    \ _ => panic!(\"Cannot happen\"),\n    }).map(|s| s.to_string()).collect::<Vec<String>>();\n\
    \    words\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.dedup();\n    arr.reverse();\n\
    \    let mut result = vec![];\n    for x in arr {\n        match x {\n       \
    \     1 => result.push(\"One\".to_string()),\n            2 => result.push(\"\
    Two\".to_string()),\n            3 => result.push(\"Three\".to_string()),\n  \
    \          4 => result.push(\"Four\".to_string()),\n            5 => result.push(\"\
    Five\".to_string()),\n            6 => result.push(\"Six\".to_string()),\n   \
    \         7 => result.push(\"Seven\".to_string()),\n            8 => result.push(\"\
    Eight\".to_string()),\n            9 => result.push(\"Nine\".to_string()),\n \
    \           _ => {},\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"One\"]`,\n right: `[\"\
    Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`',\
    \ /tmp/tmpfip4eq14.rs:36:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut copy = arr.clone();\n    copy.sort();\n    let mut res = vec![];\n\
    \    for i in copy {\n        match i {\n            1 => res.push(\"One\".to_string()),\n\
    \            2 => res.push(\"Two\".to_string()),\n            3 => res.push(\"\
    Three\".to_string()),\n            4 => res.push(\"Four\".to_string()),\n    \
    \        5 => res.push(\"Five\".to_string()),\n            6 => res.push(\"Six\"\
    .to_string()),\n            7 => res.push(\"Seven\".to_string()),\n          \
    \  8 => res.push(\"Eight\".to_string()),\n            9 => res.push(\"Nine\".to_string()),\n\
    \            _ => continue,\n        }\n    }\n    res.reverse();\n    res\n}\n\
    \nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  if arr.len() == 0 {\n        return Vec::new();\n    }\n\n    let mut arr_copy\
    \ = arr.clone();\n    arr_copy.sort();\n    arr_copy.reverse();\n\n    let mut\
    \ res: Vec<String> = Vec::new();\n    for i in arr_copy {\n        if i >= 1 &&\
    \ i <= 9 {\n            res.push(get_num_name(i));\n        }\n    }\n\n    res\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_num_name` in this scope\n  -->\
    \ /tmp/tmphbv8oc0g.rs:23:22\n   |\n23 |             res.push(get_num_name(i));\n\
    \   |                      ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659821432
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  unimplemented!();\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpb4pptpwc.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821432
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut buffer = String::new();\n    let mut v = arr.iter().filter(|&x| x >=\
    \ &1 && x <= &9).collect::<Vec<&isize>>();\n    let mut s = v.iter().map(|&x|\
    \ x.to_string()).collect::<Vec<String>>();\n    let mut v = s.iter().map(|x| match\
    \ x.as_ref() {\n        \"1\" => \"One\",\n        \"2\" => \"Two\",\n       \
    \ \"3\" => \"Three\",\n        \"4\" => \"Four\",\n        \"5\" => \"Five\",\n\
    \        \"6\" => \"Six\",\n        \"7\" => \"Seven\",\n        \"8\" => \"Eight\"\
    ,\n        \"9\" => \"Nine\",\n        _ => \"\",\n    }).collect::<Vec<&str>>();\n\
    \    v.reverse();\n    v.iter().map(|x| x.to_string()).collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Three\", \"Two\", \"Eight\", \"Five\", \"Four\", \"One\", \"One\", \"Two\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmpwypu9goh.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  // TODO\n    let mut n_arr: Vec<isize> = Vec::new();\n    let mut n_str: Vec<String>\
    \ = Vec::new();\n    for i in arr.iter() {\n        if *i >= 1 && *i <= 9 {\n\
    \            n_arr.push(*i);\n        }\n    }\n    n_arr.sort();\n    n_arr.reverse();\n\
    \    for i in n_arr.iter() {\n        match *i {\n            1 => n_str.push(\"\
    One\".to_string()),\n            2 => n_str.push(\"Two\".to_string()),\n     \
    \       3 => n_str.push(\"Three\".to_string()),\n            4 => n_str.push(\"\
    Four\".to_string()),\n            5 => n_str.push(\"Five\".to_string()),\n   \
    \         6 => n_str.push(\"Six\".to_string()),\n            7 => n_str.push(\"\
    Seven\".to_string()),\n            8 => n_str.push(\"Eight\".to_string()),\n \
    \           9 => n_str.push(\"Nine\".to_string()),\n            _ => {}\n    \
    \    }\n    }\n    n_str\n}\n\nfn main() {\n    let candidate = by_length;\n \
    \   assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"\
    ), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![1,\
    \ -1, 55]), vec![String::from(\"One\")]);\n    assert_eq!(candidate(vec![1, -1,\
    \ 3, 2]), vec![String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"Nine\"\
    ), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  let\
    \ mut arr = arr;\n  arr.sort();\n  arr.reverse();\n  arr.into_iter().map(|x| match\
    \ x {\n    1 => \"One\",\n    2 => \"Two\",\n    3 => \"Three\",\n    4 => \"\
    Four\",\n    5 => \"Five\",\n    6 => \"Six\",\n    7 => \"Seven\",\n    8 =>\
    \ \"Eight\",\n    9 => \"Nine\",\n    _ => \"None\",\n  }).collect()\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmpiiayjuvt.rs:26:6\n   |\n26 |   }).collect()\n\
    \   |      ^^^^^^^ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=&str>`\n\
    \   |\n   = help: the trait `FromIterator<&str>` is not implemented for `Vec<String>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659821432
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  arr.iter().filter(|x|\
    \ **x > 0 && **x < 10).map(|x| x.to_string()).collect::<Vec<String>>()\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"2\", \"1\", \"1\", \"4\", \"5\", \"8\", \"2\", \"3\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmpoi7yq3qz.rs:17:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821432
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut new_arr: Vec<isize> = Vec::new();\n    for i in 0..arr.len() {\n  \
    \      if arr[i] > 0 && arr[i] < 10 {\n            new_arr.push(arr[i]);\n   \
    \     }\n    }\n    new_arr.sort();\n    new_arr.reverse();\n    let mut result:\
    \ Vec<String> = Vec::new();\n    for i in 0..new_arr.len() {\n        result.push(num_to_str(new_arr[i]));\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `num_to_str` in this scope\n  --> /tmp/tmpkkt10hp2.rs:22:21\n\
    \   |\n22 |         result.push(num_to_str(new_arr[i]));\n   |               \
    \      ^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821432
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr.into_iter().filter(|&x| x >= 1 && x <= 9).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(num_to_name).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `num_to_name` in this scope\n  --> /tmp/tmpvdg99_ud.rs:15:25\n\
    \   |\n15 |     arr.into_iter().map(num_to_name).collect()\n   |             \
    \            ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut temp: Vec<isize> = Vec::new();\n    let mut result: Vec<String> = Vec::new();\n\
    \    let names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"\
    Seven\", \"Eight\", \"Nine\"];\n    for i in 0..arr.len() {\n        if arr[i]\
    \ >= 1 && arr[i] <= 9 {\n            temp.push(arr[i]);\n        }\n    }\n  \
    \  temp.sort();\n    temp.reverse();\n    for i in 0..temp.len() {\n        result.push(names[(temp[i]\
    \ - 1) as usize].to_string());\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  fn get_name(n: usize) -> String {\n        let names = vec![\"One\", \"Two\"\
    , \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"];\n \
    \       names[n - 1].to_string()\n    }\n\n    fn reverse(arr: Vec<isize>) ->\
    \ Vec<isize> {\n        let mut clone = arr.clone();\n        clone.reverse();\n\
    \        clone\n    }\n\n    fn sort(arr: Vec<isize>) -> Vec<isize> {\n      \
    \  let mut clone = arr.clone();\n        clone.sort();\n        clone\n    }\n\
    \n    fn to_name(arr: Vec<isize>) -> Vec<String> {\n        arr.iter().map(|n|\
    \ get_name(*n as usize)).collect()\n    }\n\n    fn ignore_less_than_1(arr: Vec<isize>)\
    \ -> Vec<isize> {\n        arr.iter().filter(|n| *n >= &1).map(|n| *n).collect()\n\
    \    }\n\n    fn ignore_greater_than_9(arr: Vec<isize>) -> Vec<isize> {\n    \
    \    arr.iter().filter(|n| *n <= &9).map(|n| *n).collect()\n    }\n\n    let sorted\
    \ = sort(ignore_greater_than_9(ignore_less_than_1(arr)));\n    let reversed =\
    \ reverse(sorted);\n    to_name(reversed)\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut sorted = arr.clone();\n    sorted.sort();\n    let mut vec: Vec<String>\
    \ = vec![];\n    for x in &sorted {\n        if 1 <= *x && *x <= 9 {\n       \
    \     match x {\n                1 => vec.push(\"One\".to_string()),\n       \
    \         2 => vec.push(\"Two\".to_string()),\n                3 => vec.push(\"\
    Three\".to_string()),\n                4 => vec.push(\"Four\".to_string()),\n\
    \                5 => vec.push(\"Five\".to_string()),\n                6 => vec.push(\"\
    Six\".to_string()),\n                7 => vec.push(\"Seven\".to_string()),\n \
    \               8 => vec.push(\"Eight\".to_string()),\n                9 => vec.push(\"\
    Nine\".to_string()),\n                _ => continue,\n            }\n        }\n\
    \    }\n    vec.reverse();\n    vec\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut sorted_arr = arr.clone();\n    sorted_arr.sort();\n    let mut s_vec\
    \ = Vec::new();\n    for item in sorted_arr {\n        match item {\n        \
    \    1 => s_vec.push(\"One\".to_string()),\n            2 => s_vec.push(\"Two\"\
    .to_string()),\n            3 => s_vec.push(\"Three\".to_string()),\n        \
    \    4 => s_vec.push(\"Four\".to_string()),\n            5 => s_vec.push(\"Five\"\
    .to_string()),\n            6 => s_vec.push(\"Six\".to_string()),\n          \
    \  7 => s_vec.push(\"Seven\".to_string()),\n            8 => s_vec.push(\"Eight\"\
    .to_string()),\n            9 => s_vec.push(\"Nine\".to_string()),\n         \
    \   _ => {}\n        }\n    }\n    s_vec.reverse();\n    s_vec\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result = arr.iter().map(|x| x.to_string()).collect::<Vec<String>>();\n\
    \    result.sort();\n    result.reverse();\n    let dic = map!{\n        \"1\"\
    \ => \"One\",\n        \"2\" => \"Two\",\n        \"3\" => \"Three\",\n      \
    \  \"4\" => \"Four\",\n        \"5\" => \"Five\",\n        \"6\" => \"Six\",\n\
    \        \"7\" => \"Seven\",\n        \"8\" => \"Eight\",\n        \"9\" => \"\
    Nine\"\n    };\n    result.iter().map(|x| {\n        if x.parse::<isize>().unwrap()\
    \ < 1 || x.parse::<isize>().unwrap() > 9 {\n            return \"\".to_string();\n\
    \        }\n        dic.get(&x.to_string()).unwrap().to_string()\n    }).filter(|x|\
    \ x != \"\").collect::<Vec<String>>()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: cannot find macro `map` in this scope\n  --> /tmp/tmpczr_cle7.rs:15:15\n\
    \   |\n15 |     let dic = map!{\n   |               ^^^\n\nerror: aborting due\
    \ to previous error\n\n"
  stdout: ''
  timestamp: 1659821432
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  arr.iter()\n        .filter(|x| **x >= 1 && **x <= 9)\n        .map(|x| match\
    \ x {\n            1 => \"One\",\n            2 => \"Two\",\n            3 =>\
    \ \"Three\",\n            4 => \"Four\",\n            5 => \"Five\",\n       \
    \     6 => \"Six\",\n            7 => \"Seven\",\n            8 => \"Eight\",\n\
    \            9 => \"Nine\",\n            _ => panic!(\"Strange number!\"),\n \
    \       })\n        .rev()\n        .map(|s| s.to_string())\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Three\", \"Two\", \"Eight\", \"Five\", \"Four\", \"One\", \"One\", \"Two\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmpjkj60rz1.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821432
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  // ...\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmphi_s7dau.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821432
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  // TODO\n    let mut res = Vec::new();\n    let mut map = HashMap::new();\n\
    \    map.insert(1, \"One\");\n    map.insert(2, \"Two\");\n    map.insert(3, \"\
    Three\");\n    map.insert(4, \"Four\");\n    map.insert(5, \"Five\");\n    map.insert(6,\
    \ \"Six\");\n    map.insert(7, \"Seven\");\n    map.insert(8, \"Eight\");\n  \
    \  map.insert(9, \"Nine\");\n    for i in arr {\n        if i > 0 && i < 10 {\n\
    \            match map.get(&i) {\n                Some(n) => res.push(n.to_string()),\n\
    \                None => println!(\"None\"),\n            }\n        }\n    }\n\
    \    res.reverse();\n    res\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpxi1st6ah.rs:14:19\n   |\n14 |     let mut map = HashMap::new();\n  \
    \ |                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659821432
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().filter(|x|\
    \ *x > 0 && *x < 10).map(digit_to_name).collect()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `digit_to_name` in this scope\n  --> /tmp/tmpfs99k0py.rs:15:55\n\
    \   |\n15 |     arr.into_iter().filter(|x| *x > 0 && *x < 10).map(digit_to_name).collect()\n\
    \   |                                                       ^^^^^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut sorted_arr = arr.iter().filter(|&&x| x >= 1 && x <= 9).cloned().collect::<Vec<isize>>();\n\
    \    sorted_arr.sort();\n    sorted_arr.reverse();\n    sorted_arr.iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut res = arr.iter().cloned().filter(|x| *x >= 1 && *x <= 9).collect::<Vec<isize>>();\n\
    \    res.sort();\n    res.reverse();\n    res.iter().map(|x| match x {\n     \
    \   1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 =>\
    \ \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\"\
    ,\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => panic!(\"Unexpected\
    \ value\")\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut num = arr.into_iter().filter(|x| *x >= 1 && *x <= 9).collect::<Vec<isize>>();\n\
    \    num.sort();\n    num.reverse();\n    num.into_iter().map(|x| match x {\n\
    \        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n     \
    \   4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 =>\
    \ \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => panic!(\"\
    Bad input\")\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut vec: Vec<String> = vec![];\n    for i in 0..arr.len() {\n        if\
    \ arr[i] > 0 && arr[i] < 10 {\n            match arr[i] {\n                1 =>\
    \ vec.push(\"One\".to_string()),\n                2 => vec.push(\"Two\".to_string()),\n\
    \                3 => vec.push(\"Three\".to_string()),\n                4 => vec.push(\"\
    Four\".to_string()),\n                5 => vec.push(\"Five\".to_string()),\n \
    \               6 => vec.push(\"Six\".to_string()),\n                7 => vec.push(\"\
    Seven\".to_string()),\n                8 => vec.push(\"Eight\".to_string()),\n\
    \                9 => vec.push(\"Nine\".to_string()),\n                _ => (),\n\
    \            }\n        }\n    }\n    vec.sort();\n    vec.reverse();\n    vec\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Two\", \"Two\", \"Three\", \"One\", \"One\", \"Four\", \"Five\", \"Eight\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmpv0g7p1qu.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821432
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  unimplemented!()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmprm15cuvw.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut temp = arr.clone();\n    temp.sort();\n    let mut res = vec![];\n\
    \    for i in temp {\n        if i > 0 && i < 10 {\n            res.push(i.to_string());\n\
    \        }\n    }\n    res.reverse();\n    let mut ret = vec![];\n    for i in\
    \ res {\n        let s = match i.parse::<i32>() {\n            Ok(num) => num,\n\
    \            Err(_) => continue,\n        };\n        let temp = match s {\n \
    \           1 => \"One\",\n            2 => \"Two\",\n            3 => \"Three\"\
    ,\n            4 => \"Four\",\n            5 => \"Five\",\n            6 => \"\
    Six\",\n            7 => \"Seven\",\n            8 => \"Eight\",\n           \
    \ 9 => \"Nine\",\n            _ => continue,\n        };\n        ret.push(temp.to_string());\n\
    \    }\n    ret\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result: Vec<String> = Vec::new();\n    let mut sorted_arr: Vec<isize>\
    \ = arr.clone();\n    sorted_arr.sort();\n    for e in sorted_arr {\n        if\
    \ (e > 0) && (e < 10) {\n            result.push(\n                match e {\n\
    \                    1 => \"One\",\n                    2 => \"Two\",\n      \
    \              3 => \"Three\",\n                    4 => \"Four\",\n         \
    \           5 => \"Five\",\n                    6 => \"Six\",\n              \
    \      7 => \"Seven\",\n                    8 => \"Eight\",\n                \
    \    9 => \"Nine\",\n                    _ => \"\",\n                }.to_string(),\n\
    \            );\n        }\n    }\n    result.reverse();\n    result\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut numbers: Vec<String> = Vec::new();\n    let mut num_list: Vec<String>\
    \ = vec![\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\",\
    \ \"Eight\", \"Nine\"];\n    for num in arr {\n        if (1..=9).contains(&num)\
    \ {\n            numbers.push(num_list[(num - 1) as usize].to_string());\n   \
    \     }\n    }\n    numbers.sort();\n    numbers.reverse();\n    numbers\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4ky7oh90.rs:13:42\n   |\n\
    13 |     let mut num_list: Vec<String> = vec![\"One\", \"Two\", \"Three\", \"\
    Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"];\n   |            \
    \                              ^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                                          |\n   |                       \
    \                   expected struct `String`, found `&str`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659821432
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut sorted = arr.iter().filter(|x| **x >= 1 && **x <= 9).map(|x| x.to_string()).collect::<Vec<String>>();\n\
    \    sorted.sort();\n    sorted.reverse();\n    sorted\n}\n\nfn main() {\n   \
    \ let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"8\", \"5\", \"4\", \"3\", \"2\", \"2\", \"1\", \"1\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmp3oh7mize.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut sort_arr = arr.clone();\n    sort_arr.sort();\n    let arr_length =\
    \ sort_arr.len();\n    let mut r\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpaj0d8k1f.rs:15:14\n   |\n\
    15 |     let mut r\n   |              ^ help: add `;` here\n16 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpaj0d8k1f.rs:11:34\n \
    \  |\n11 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |    --------- \
    \                    ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659821432
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  arr.iter()\n        .filter(|n| **n > 0 && **n < 10)\n        .cloned()\n \
    \       .collect::<Vec<isize>>()\n        .sort()\n        .reverse()\n      \
    \  .iter()\n        .map(|n| n.to_string())\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for unit type `()` in the\
    \ current scope\n  --> /tmp/tmp8_a8hze0.rs:17:10\n   |\n17 |         .reverse()\n\
    \   |          ^^^^^^^ method not found in `()`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659821432
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  unimplemented!();\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpb4pptpwc.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821432
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    let mut result\
    \ = Vec::new();\n    for i in arr {\n        if i >= 1 && i <= 9 {\n         \
    \   result.push(number_to_string(i));\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `number_to_string` in this scope\n \
    \ --> /tmp/tmpsrig899a.rs:18:25\n   |\n18 |             result.push(number_to_string(i));\n\
    \   |                         ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821432
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  if arr.len() == 0 {\n        return Vec::new();\n    }\n\n    let mut result:\
    \ Vec<String> = Vec::new();\n    let mut dict: Vec<(isize, String)> = vec![\n\
    \        (1, \"One\".to_string()),\n        (2, \"Two\".to_string()),\n      \
    \  (3, \"Three\".to_string()),\n        (4, \"Four\".to_string()),\n        (5,\
    \ \"Five\".to_string()),\n        (6, \"Six\".to_string()),\n        (7, \"Seven\"\
    .to_string()),\n        (8, \"Eight\".to_string()),\n        (9, \"Nine\".to_string()),\n\
    \    ];\n\n    let mut odd_arr: Vec<isize> = Vec::new();\n    let mut even_arr:\
    \ Vec<isize> = Vec::new();\n\n    for num in arr {\n        if num % 2 == 0 {\n\
    \            even_arr.push(num);\n        } else {\n            odd_arr.push(num);\n\
    \        }\n    }\n\n    odd_arr.sort();\n    even_arr.sort();\n\n    for num\
    \ in odd_arr.iter().rev() {\n        if *num <= 9 && *num >= 1 {\n           \
    \ result.push(\n                dict.iter()\n                    .find(|x| x.0\
    \ == *num)\n                    .unwrap()\n                    .1\n          \
    \          .clone(),\n            );\n        }\n    }\n\n    for num in even_arr.iter().rev()\
    \ {\n        if *num <= 9 && *num >= 1 {\n            result.push(\n         \
    \       dict.iter()\n                    .find(|x| x.0 == *num)\n            \
    \        .unwrap()\n                    .1\n                    .clone(),\n  \
    \          );\n        }\n    }\n\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Five\", \"Three\", \"One\", \"One\", \"Eight\", \"Four\", \"Two\", \"Two\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmpyvmy1hu5.rs:72:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut res: Vec<String> = vec![];\n    let mut to_sort: Vec<usize> = vec![];\n\
    \    for v in arr {\n        if v > 0 && v < 10 {\n            to_sort.push(v\
    \ as usize);\n        }\n    }\n    to_sort.sort();\n    for v in to_sort.iter().rev()\
    \ {\n        match v {\n            1 => res.push(\"One\".to_string()),\n    \
    \        2 => res.push(\"Two\".to_string()),\n            3 => res.push(\"Three\"\
    .to_string()),\n            4 => res.push(\"Four\".to_string()),\n           \
    \ 5 => res.push(\"Five\".to_string()),\n            6 => res.push(\"Six\".to_string()),\n\
    \            7 => res.push(\"Seven\".to_string()),\n            8 => res.push(\"\
    Eight\".to_string()),\n            9 => res.push(\"Nine\".to_string()),\n    \
    \        _ => (),\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<_> = arr.into_iter().filter(|i| *i >= 1 && *i <= 9).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|i| {\n        match\
    \ i {\n            1 => \"One\",\n            2 => \"Two\",\n            3 =>\
    \ \"Three\",\n            4 => \"Four\",\n            5 => \"Five\",\n       \
    \     6 => \"Six\",\n            7 => \"Seven\",\n            8 => \"Eight\",\n\
    \            9 => \"Nine\",\n            _ => unreachable!()\n        }.to_string()\n\
    \    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut sorted_nums: Vec<String> =\n        arr.into_iter()\n           .filter(|&x|\
    \ x > 0 && x < 10)\n           .map(|x| x.to_string())\n           .collect();\n\
    \    sorted_nums.sort();\n    sorted_nums.reverse();\n    let mut result: Vec<String>\
    \ = Vec::new();\n    for num in sorted_nums {\n        result.push(num_to_name(num));\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `num_to_name` in this scope\n  --> /tmp/tmplfzaefpq.rs:21:21\n\
    \   |\n21 |         result.push(num_to_name(num));\n   |                     ^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut v: Vec<isize> = arr.iter().filter(|x| **x > 0 && **x < 10).cloned().collect();\n\
    \    v.sort();\n    v.reverse();\n    let w: Vec<String> = v.iter().map(|n| match\
    \ n {\n            1 => \"One\".to_string(),\n            2 => \"Two\".to_string(),\n\
    \            3 => \"Three\".to_string(),\n            4 => \"Four\".to_string(),\n\
    \            5 => \"Five\".to_string(),\n            6 => \"Six\".to_string(),\n\
    \            7 => \"Seven\".to_string(),\n            8 => \"Eight\".to_string(),\n\
    \            9 => \"Nine\".to_string(),\n            _ => unreachable!(),\n  \
    \      }).collect();\n    w\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut tmp: Vec<isize> = Vec::new();\n    let mut count: usize = 0;\n    for\
    \ i in arr {\n        if (1 <= i) && (i <= 9) {\n            tmp.push(i);\n  \
    \          count += 1;\n        }\n    }\n    let mut res: Vec<String> = Vec::new();\n\
    \    for i in tmp {\n        match i {\n            1 => res.push(\"One\".to_string()),\n\
    \            2 => res.push(\"Two\".to_string()),\n            3 => res.push(\"\
    Three\".to_string()),\n            4 => res.push(\"Four\".to_string()),\n    \
    \        5 => res.push(\"Five\".to_string()),\n            6 => res.push(\"Six\"\
    .to_string()),\n            7 => res.push(\"Seven\".to_string()),\n          \
    \  8 => res.push(\"Eight\".to_string()),\n            9 => res.push(\"Nine\".to_string()),\n\
    \            _ => res.push(\"\".to_string()),\n        }\n    }\n    res.sort();\n\
    \    let mut rres: Vec<String> = Vec::new();\n    for i in count..res.len() {\n\
    \        rres.push(res[i].clone());\n    }\n    for i in 0..count {\n        rres.push(res[i].clone());\n\
    \    }\n    rres\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Eight\", \"Five\", \"Four\", \"One\", \"One\", \"Three\", \"Two\", \"Two\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmpmm3yn39e.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<usize> = arr.into_iter().filter(|x| *x > 0 && *x < 10).map(|x|\
    \ x as usize).collect();\n    arr.sort();\n    arr.reverse();\n    let digits\
    \ = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\"\
    , \"Nine\"];\n    arr.into_iter().map(|x| digits[x - 1].to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result = vec![];\n    let mut sorted_arr = arr.clone();\n    sorted_arr.sort();\n\
    \    for i in sorted_arr {\n        match i {\n            1 => result.push(\"\
    One\".to_string()),\n            2 => result.push(\"Two\".to_string()),\n    \
    \        3 => result.push(\"Three\".to_string()),\n            4 => result.push(\"\
    Four\".to_string()),\n            5 => result.push(\"Five\".to_string()),\n  \
    \          6 => result.push(\"Six\".to_string()),\n            7 => result.push(\"\
    Seven\".to_string()),\n            8 => result.push(\"Eight\".to_string()),\n\
    \            9 => result.push(\"Nine\".to_string()),\n            _ => {}\n  \
    \      }\n    }\n    result.reverse();\n    result\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut v = arr.clone();\n    v.sort();\n    v.reverse();\n    let mut result\
    \ = Vec::new();\n    for i in v {\n        match i {\n            1 => result.push(\"\
    One\".to_string()),\n            2 => result.push(\"Two\".to_string()),\n    \
    \        3 => result.push(\"Three\".to_string()),\n            4 => result.push(\"\
    Four\".to_string()),\n            5 => result.push(\"Five\".to_string()),\n  \
    \          6 => result.push(\"Six\".to_string()),\n            7 => result.push(\"\
    Seven\".to_string()),\n            8 => result.push(\"Eight\".to_string()),\n\
    \            9 => result.push(\"Nine\".to_string()),\n            _ => continue,\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut new_array: Vec<String> = Vec::new();\n    for i in arr {\n        if\
    \ i > 0 && i < 10 {\n            new_array.push(digit_to_word(i as u8))\n    \
    \    }\n    }\n    new_array.reverse();\n    new_array\n}\n\nfn main() {\n   \
    \ let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `digit_to_word` in this scope\n  -->\
    \ /tmp/tmphym_joab.rs:15:28\n   |\n15 |             new_array.push(digit_to_word(i\
    \ as u8))\n   |                            ^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result: Vec<String> = vec![];\n    let mut ns: Vec<isize> = vec![];\n\
    \    for n in arr {\n        if n > 0 && n < 10 {\n            ns.push(n);\n \
    \       }\n    }\n    ns.sort();\n    ns.reverse();\n    for n in ns {\n     \
    \   result.push(format!(\"{}\", match n {\n            1 => \"One\",\n       \
    \     2 => \"Two\",\n            3 => \"Three\",\n            4 => \"Four\",\n\
    \            5 => \"Five\",\n            6 => \"Six\",\n            7 => \"Seven\"\
    ,\n            8 => \"Eight\",\n            9 => \"Nine\",\n            _ => \"\
    \",\n        }));\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut items = arr.into_iter().filter(|&a| a >= 1 && a <= 9).collect::<Vec<isize>>();\n\
    \    items.sort();\n    items.reverse();\n    items.into_iter().map(|a| {\n  \
    \      match a {\n            1 => \"One\",\n            2 => \"Two\",\n     \
    \       3 => \"Three\",\n            4 => \"Four\",\n            5 => \"Five\"\
    ,\n            6 => \"Six\",\n            7 => \"Seven\",\n            8 => \"\
    Eight\",\n            9 => \"Nine\",\n            _ => unreachable!(),\n     \
    \   }.to_string()\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr_cloned = arr.clone();\n    arr_cloned.sort();\n    let mut str_arr:\
    \ Vec<String> = Vec::new();\n    for i in arr_cloned {\n        match i {\n  \
    \          1 => str_arr.push(\"One\".to_string()),\n            2 => str_arr.push(\"\
    Two\".to_string()),\n            3 => str_arr.push(\"Three\".to_string()),\n \
    \           4 => str_arr.push(\"Four\".to_string()),\n            5 => str_arr.push(\"\
    Five\".to_string()),\n            6 => str_arr.push(\"Six\".to_string()),\n  \
    \          7 => str_arr.push(\"Seven\".to_string()),\n            8 => str_arr.push(\"\
    Eight\".to_string()),\n            9 => str_arr.push(\"Nine\".to_string()),\n\
    \            _ => (),\n        }\n    }\n    str_arr.reverse();\n    str_arr\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut sorted_arr = arr;\n    sorted_arr.sort();\n    sorted_arr.reverse();\n\
    \    let res = sorted_arr.iter().fold(vec![], |mut acc, x| {\n        match x\
    \ {\n            &1 => acc.push(\"One\".to_string()),\n            &2 => acc.push(\"\
    Two\".to_string()),\n            &3 => acc.push(\"Three\".to_string()),\n    \
    \        &4 => acc.push(\"Four\".to_string()),\n            &5 => acc.push(\"\
    Five\".to_string()),\n            &6 => acc.push(\"Six\".to_string()),\n     \
    \       &7 => acc.push(\"Seven\".to_string()),\n            &8 => acc.push(\"\
    Eight\".to_string()),\n            &9 => acc.push(\"Nine\".to_string()),\n   \
    \         _ => (),\n        }\n        acc\n    });\n    res\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    let mut res =\
    \ Vec::new();\n    for i in arr {\n        if i == 1 {\n            res.push(\"\
    One\".to_string());\n        } else if i == 2 {\n            res.push(\"Two\"\
    .to_string());\n        } else if i == 3 {\n            res.push(\"Three\".to_string());\n\
    \        } else if i == 4 {\n            res.push(\"Four\".to_string());\n   \
    \     } else if i == 5 {\n            res.push(\"Five\".to_string());\n      \
    \  } else if i == 6 {\n            res.push(\"Six\".to_string());\n        } else\
    \ if i == 7 {\n            res.push(\"Seven\".to_string());\n        } else if\
    \ i == 8 {\n            res.push(\"Eight\".to_string());\n        } else if i\
    \ == 9 {\n            res.push(\"Nine\".to_string());\n        }\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr;\n    arr.sort();\n    arr.reverse();\n    let\
    \ mut res: Vec<String> = Vec::new();\n    for x in arr {\n        match x {\n\
    \            1 => res.push(\"One\".to_string()),\n            2 => res.push(\"\
    Two\".to_string()),\n            3 => res.push(\"Three\".to_string()),\n     \
    \       4 => res.push(\"Four\".to_string()),\n            5 => res.push(\"Five\"\
    .to_string()),\n            6 => res.push(\"Six\".to_string()),\n            7\
    \ => res.push(\"Seven\".to_string()),\n            8 => res.push(\"Eight\".to_string()),\n\
    \            9 => res.push(\"Nine\".to_string()),\n            _ => {},\n    \
    \    }\n    }\n    res\n}\n\nfn main() {\n    let candidate = by_length;\n   \
    \ assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"\
    ), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![1,\
    \ -1, 55]), vec![String::from(\"One\")]);\n    assert_eq!(candidate(vec![1, -1,\
    \ 3, 2]), vec![String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"Nine\"\
    ), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.dedup();\n    arr.iter().filter(|i|\
    \ i.is_positive() && i < &10).map(|i| number_to_string(*i)).collect()\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `number_to_string` in this scope\n \
    \ --> /tmp/tmpa3s7k2qe.rs:15:63\n   |\n15 |     arr.iter().filter(|i| i.is_positive()\
    \ && i < &10).map(|i| number_to_string(*i)).collect()\n   |                  \
    \                                             ^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa3s7k2qe.rs:15:50\n \
    \  |\n15 |     arr.iter().filter(|i| i.is_positive() && i < &10).map(|i| number_to_string(*i)).collect()\n\
    \   |                                                  ^^^ expected `&isize`,\
    \ found integer\n   |\n   = note: expected reference `&&isize`\n             \
    \ found reference `&{integer}`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut res = arr.iter().filter(|&x| 0 < *x && *x < 10).map(|&i| i as usize).collect::<Vec<usize>>();\n\
    \    res.sort();\n    res.reverse();\n    res.iter().map(|&i| match i {\n    \
    \    1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4\
    \ => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"\
    Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => panic!(\"\
    Should not happen\"),\n    }).map(|&s| s.to_string()).collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmphhx1bgtt.rs:26:14\n   |\n26 |     }).map(|&s| s.to_string()).collect::<Vec<String>>()\n\
    \   |              ^ doesn't have a size known at compile-time\n   |\n   = help:\
    \ the trait `Sized` is not implemented for `str`\n   = note: all local variables\
    \ must have a statically known size\n   = help: unsized locals are gated as an\
    \ unstable feature\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr_1_9: Vec<isize> = Vec::new();\n    for i in &arr {\n        if\
    \ *i >= 1 && *i <= 9 {\n            arr_1_9.push(*i);\n        }\n    }\n    arr_1_9.sort();\n\
    \    arr_1_9.reverse();\n    let mut re_vec: Vec<String> = Vec::new();\n    for\
    \ i in &arr_1_9 {\n        match i {\n            1 => re_vec.push(\"One\".to_string()),\n\
    \            2 => re_vec.push(\"Two\".to_string()),\n            3 => re_vec.push(\"\
    Three\".to_string()),\n            4 => re_vec.push(\"Four\".to_string()),\n \
    \           5 => re_vec.push(\"Five\".to_string()),\n            6 => re_vec.push(\"\
    Six\".to_string()),\n            7 => re_vec.push(\"Seven\".to_string()),\n  \
    \          8 => re_vec.push(\"Eight\".to_string()),\n            9 => re_vec.push(\"\
    Nine\".to_string()),\n            _ => continue,\n        }\n    }\n    re_vec\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  // your code\n    arr.into_iter().filter(|x| *x > 0 && *x < 10).collect::<Vec<isize>>().into_iter().map(|x|\
    \ get_numbers(x)).collect::<Vec<String>>()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_numbers` in this scope\n  --> /tmp/tmp493sfthn.rs:13:95\n\
    \   |\n13 |     arr.into_iter().filter(|x| *x > 0 && *x < 10).collect::<Vec<isize>>().into_iter().map(|x|\
    \ get_numbers(x)).collect::<Vec<String>>()\n   |                             \
    \                                                                  ^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  //unimplemented!();\n    let mut arr = arr;\n    let mut new_arr: Vec<String>\
    \ = Vec::new();\n    arr.sort();\n    arr.reverse();\n    for a in arr {\n   \
    \     if a > 0 && a < 10 {\n            match a {\n                1 => new_arr.push(\"\
    One\".to_string()),\n                2 => new_arr.push(\"Two\".to_string()),\n\
    \                3 => new_arr.push(\"Three\".to_string()),\n                4\
    \ => new_arr.push(\"Four\".to_string()),\n                5 => new_arr.push(\"\
    Five\".to_string()),\n                6 => new_arr.push(\"Six\".to_string()),\n\
    \                7 => new_arr.push(\"Seven\".to_string()),\n                8\
    \ => new_arr.push(\"Eight\".to_string()),\n                9 => new_arr.push(\"\
    Nine\".to_string()),\n                _ => (),\n            }\n        }\n   \
    \ }\n    new_arr\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut r = arr.iter().filter(|&n| n > &0 && n < &10).map(|&n| n.to_string()).collect::<Vec<String>>();\n\
    \    r.sort();\n    r.reverse();\n    let tmp = r.clone();\n    for (i, s) in\
    \ tmp.iter().enumerate() {\n        r[i] = match s.as_ref() {\n            \"\
    1\" => \"One\".to_string(),\n            \"2\" => \"Two\".to_string(),\n     \
    \       \"3\" => \"Three\".to_string(),\n            \"4\" => \"Four\".to_string(),\n\
    \            \"5\" => \"Five\".to_string(),\n            \"6\" => \"Six\".to_string(),\n\
    \            \"7\" => \"Seven\".to_string(),\n            \"8\" => \"Eight\".to_string(),\n\
    \            \"9\" => \"Nine\".to_string(),\n            _ => \"Error\".to_string(),\n\
    \        }\n    }\n    r\n}\n\nfn main() {\n    let candidate = by_length;\n \
    \   assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"\
    ), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![1,\
    \ -1, 55]), vec![String::from(\"One\")]);\n    assert_eq!(candidate(vec![1, -1,\
    \ 3, 2]), vec![String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"Nine\"\
    ), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  unimplemented!()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmprm15cuvw.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821432
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  unimplemented!()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmprm15cuvw.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821432
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  arr.iter()\n        .filter(|&x| *x > 0 && *x < 10)\n        .map(|&x| x.to_string())\n\
    \        .collect::<Vec<String>>()\n        .iter()\n        .rev()\n        .map(|&x|\
    \ match x.as_ref() {\n            \"1\" => \"One\",\n            \"2\" => \"Two\"\
    ,\n            \"3\" => \"Three\",\n            \"4\" => \"Four\",\n         \
    \   \"5\" => \"Five\",\n            \"6\" => \"Six\",\n            \"7\" => \"\
    Seven\",\n            \"8\" => \"Eight\",\n            \"9\" => \"Nine\",\n  \
    \          _ => \"\",\n        })\n        .filter(|&x| x != \"\")\n        .map(|x|\
    \ x.to_string())\n        .collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of a shared reference\n  --> /tmp/tmpq0uxq60p.rs:18:15\n\
    \   |\n18 |         .map(|&x| match x.as_ref() {\n   |               ^-\n   |\
    \               ||\n   |               |data moved here\n   |               |move\
    \ occurs because `x` has type `String`, which does not implement the `Copy` trait\n\
    \   |               help: consider removing the `&`: `x`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0507`.\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut vec: Vec<isize> = arr.iter().filter(|x| **x >= 1 && **x <= 9).map(|x|\
    \ *x).collect();\n    vec.sort();\n    vec.reverse();\n    vec.iter().map(|x|\
    \ *x as u8).map(|x| match x {\n        1 => \"One\",\n        2 => \"Two\",\n\
    \        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n   \
    \     6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n      \
    \  9 => \"Nine\",\n        _ => \"\",\n    }).map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut transformed: Vec<String> = Vec::new();\n    let mut sorted_arr: Vec<isize>\
    \ = arr.clone();\n    sorted_arr.sort();\n    sorted_arr.reverse();\n    println!(\"\
    {:?}\", sorted_arr);\n    for i in sorted_arr {\n        match i {\n         \
    \   1 => transformed.push(\"One\".to_string()),\n            2 => transformed.push(\"\
    Two\".to_string()),\n            3 => transformed.push(\"Three\".to_string()),\n\
    \            4 => transformed.push(\"Four\".to_string()),\n            5 => transformed.push(\"\
    Five\".to_string()),\n            6 => transformed.push(\"Six\".to_string()),\n\
    \            7 => transformed.push(\"Seven\".to_string()),\n            8 => transformed.push(\"\
    Eight\".to_string()),\n            9 => transformed.push(\"Nine\".to_string()),\n\
    \            _ => ()\n        }\n    }\n    transformed\n}\n\nfn main() {\n  \
    \  let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: '[8, 5, 4, 3, 2, 2, 1, 1]

    []

    [55, 1, -1]

    [3, 2, 1, -1]

    [9, 8, 4]

    '
  timestamp: 1659821433
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr.into_iter().filter(|&x| x >= 1 && x <= 9).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x| match x {\n\
    \        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n     \
    \   4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 =>\
    \ \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => panic!(\"\
    {}\", x),\n    }).map(|x| x.to_string()).collect()\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut res = arr.clone();\n    let mut res_dict = arr.clone();\n    res.sort();\n\
    \    res_dict.sort();\n    let mut map = HashMap::new();\n    map.insert(1, \"\
    One\");\n    map.insert(2, \"Two\");\n    map.insert(3, \"Three\");\n    map.insert(4,\
    \ \"Four\");\n    map.insert(5, \"Five\");\n    map.insert(6, \"Six\");\n    map.insert(7,\
    \ \"Seven\");\n    map.insert(8, \"Eight\");\n    map.insert(9, \"Nine\");\n \
    \   let mut result = Vec::new();\n    let mut i = 0;\n    for x in res_dict.into_iter()\
    \ {\n        if x > 0 && x < 10 {\n            for (_, val) in map.iter() {\n\
    \                if x == res[i] {\n                    result.push(val.to_string());\n\
    \                    i += 1;\n                }\n            }\n        }\n  \
    \  }\n    result.reverse();\n    result\n}\n\nfn main() {\n    let candidate =\
    \ by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpxrwqo3b8.rs:16:19\n   |\n16 |     let mut map = HashMap::new();\n  \
    \ |                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut ans: Vec<String> = Vec::new();\n    let mut v: Vec<isize> = arr.clone();\n\
    \    v.sort();\n    for &i in v.iter() {\n        if i >= 1 && i <= 9 {\n    \
    \        match i {\n                1 => ans.push(\"One\".to_string()),\n    \
    \            2 => ans.push(\"Two\".to_string()),\n                3 => ans.push(\"\
    Three\".to_string()),\n                4 => ans.push(\"Four\".to_string()),\n\
    \                5 => ans.push(\"Five\".to_string()),\n                6 => ans.push(\"\
    Six\".to_string()),\n                7 => ans.push(\"Seven\".to_string()),\n \
    \               8 => ans.push(\"Eight\".to_string()),\n                9 => ans.push(\"\
    Nine\".to_string()),\n                _ => { }\n            }\n        }\n   \
    \ }\n    ans.reverse();\n    ans\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  //\
    \ If the array is empty, return an empty array\n  if arr.len() == 0 {\n    return\
    \ Vec::new();\n  }\n\n  // Sort 1-9, reverse and convert to string\n  let mut\
    \ arr: Vec<isize> = arr.into_iter().filter(|x| x > &0 && x < &10).collect();\n\
    \  arr.sort();\n  arr.reverse();\n  let mut res: Vec<String> = arr.into_iter().map(|x|\
    \ match x {\n    1 => \"One\".to_string(),\n    2 => \"Two\".to_string(),\n  \
    \  3 => \"Three\".to_string(),\n    4 => \"Four\".to_string(),\n    5 => \"Five\"\
    .to_string(),\n    6 => \"Six\".to_string(),\n    7 => \"Seven\".to_string(),\n\
    \    8 => \"Eight\".to_string(),\n    9 => \"Nine\".to_string(),\n    _ => panic!(\"\
    Unable to convert\")\n  }).collect();\n\n  res\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result = arr.iter().filter(|&x| *x >= 1 && *x <= 9).cloned().collect::<Vec<isize>>();\n\
    \    result.sort();\n    result.reverse();\n    result.iter().map(|x| match x\
    \ {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n \
    \       4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n      \
    \  7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _\
    \ => panic!(\"Incorrect input to by_length()\"),\n    }).cloned().collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `str: Clone` is not satisfied\n  --> /tmp/tmp2r4voixi.rs:26:8\n\
    \   |\n26 |     }).cloned().collect::<Vec<String>>()\n   |        ^^^^^^ the trait\
    \ `Clone` is not implemented for `str`\n\nerror[E0599]: the method `collect` exists\
    \ for struct `Cloned<Map<std::slice::Iter<'_, isize>, [closure@/tmp/tmp2r4voixi.rs:15:23:\
    \ 26:6]>>`, but its trait bounds were not satisfied\n  --> /tmp/tmp2r4voixi.rs:26:17\n\
    \   |\n26 |       }).cloned().collect::<Vec<String>>()\n   |                 \
    \  ^^^^^^^ method cannot be called on `Cloned<Map<std::slice::Iter<'_, isize>,\
    \ [closure@/tmp/tmp2r4voixi.rs:15:23: 26:6]>>` due to unsatisfied trait bounds\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `Cloned<Map<std::slice::Iter<'_,\
    \ isize>, [closure@/tmp/tmp2r4voixi.rs:15:23: 26:6]>>: Iterator`\n           which\
    \ is required by `&mut Cloned<Map<std::slice::Iter<'_, isize>, [closure@/tmp/tmp2r4voixi.rs:15:23:\
    \ 26:6]>>: Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut vec = arr;\n    vec.sort();\n    let mut result = vec![];\n    for\
    \ i in vec {\n        match i {\n            1 => result.push(\"One\".to_string()),\n\
    \            2 => result.push(\"Two\".to_string()),\n            3 => result.push(\"\
    Three\".to_string()),\n            4 => result.push(\"Four\".to_string()),\n \
    \           5 => result.push(\"Five\".to_string()),\n            6 => result.push(\"\
    Six\".to_string()),\n            7 => result.push(\"Seven\".to_string()),\n  \
    \          8 => result.push(\"Eight\".to_string()),\n            9 => result.push(\"\
    Nine\".to_string()),\n            _ => {},\n        }\n    }\n    result.reverse();\n\
    \    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut number_vector: Vec<String> = vec![];\n    for number in arr {\n   \
    \     if number > 0 && number < 10 {\n            match number {\n           \
    \     1 => number_vector.push(\"One\".to_string()),\n                2 => number_vector.push(\"\
    Two\".to_string()),\n                3 => number_vector.push(\"Three\".to_string()),\n\
    \                4 => number_vector.push(\"Four\".to_string()),\n            \
    \    5 => number_vector.push(\"Five\".to_string()),\n                6 => number_vector.push(\"\
    Six\".to_string()),\n                7 => number_vector.push(\"Seven\".to_string()),\n\
    \                8 => number_vector.push(\"Eight\".to_string()),\n           \
    \     9 => number_vector.push(\"Nine\".to_string()),\n                _ => (),\n\
    \            }\n        }\n    }\n    number_vector.sort();\n    number_vector.reverse();\n\
    \    number_vector\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Two\", \"Two\", \"Three\", \"One\", \"One\", \"Four\", \"Five\", \"Eight\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmpguvqn6m5.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut v: Vec<String> = Vec::new();\n    let mut n: Vec<isize> = Vec::new();\n\
    \    for i in arr {\n        if i > 0 && i < 10 {\n            n.push(i);\n  \
    \      }\n    }\n    n.sort();\n    n.reverse();\n    for i in n {\n        match\
    \ i {\n            1 => v.push(\"One\".to_string()),\n            2 => v.push(\"\
    Two\".to_string()),\n            3 => v.push(\"Three\".to_string()),\n       \
    \     4 => v.push(\"Four\".to_string()),\n            5 => v.push(\"Five\".to_string()),\n\
    \            6 => v.push(\"Six\".to_string()),\n            7 => v.push(\"Seven\"\
    .to_string()),\n            8 => v.push(\"Eight\".to_string()),\n            9\
    \ => v.push(\"Nine\".to_string()),\n            _ => (),\n        }\n    }\n \
    \   v\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut new_arr: Vec<String> = vec![];\n    let mut arr_len = arr.len();\n\
    \    let mut arr_copy = arr.clone();\n    arr_copy.sort();\n    for i in 0..arr_len\
    \ {\n        if arr_copy[i] == 1 {\n            new_arr.push(\"One\".to_string());\n\
    \        } else if arr_copy[i] == 2 {\n            new_arr.push(\"Two\".to_string());\n\
    \        } else if arr_copy[i] == 3 {\n            new_arr.push(\"Three\".to_string());\n\
    \        } else if arr_copy[i] == 4 {\n            new_arr.push(\"Four\".to_string());\n\
    \        } else if arr_copy[i] == 5 {\n            new_arr.push(\"Five\".to_string());\n\
    \        } else if arr_copy[i] == 6 {\n            new_arr.push(\"Six\".to_string());\n\
    \        } else if arr_copy[i] == 7 {\n            new_arr.push(\"Seven\".to_string());\n\
    \        } else if arr_copy[i] == 8 {\n            new_arr.push(\"Eight\".to_string());\n\
    \        } else if arr_copy[i] == 9 {\n            new_arr.push(\"Nine\".to_string());\n\
    \        }\n    }\n    new_arr.reverse();\n    new_arr\n}\n\nfn main() {\n   \
    \ let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut new_arr: Vec<_> = arr.into_iter().filter(|x| *x >= 1 && *x <= 9).collect();\n\
    \    new_arr.sort();\n    new_arr.reverse();\n    new_arr.into_iter().map(|x|\
    \ match x {\n        1 => \"One\".to_string(),\n        2 => \"Two\".to_string(),\n\
    \        3 => \"Three\".to_string(),\n        4 => \"Four\".to_string(),\n   \
    \     5 => \"Five\".to_string(),\n        6 => \"Six\".to_string(),\n        7\
    \ => \"Seven\".to_string(),\n        8 => \"Eight\".to_string(),\n        9 =>\
    \ \"Nine\".to_string(),\n        _ => \"\".to_string(),\n    }).collect()\n}\n\
    \nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut valid_numbers: Vec<isize> = arr.iter().filter(|n| **n > 0 && **n <\
    \ 10).cloned().collect();\n    valid_numbers.sort();\n    valid_numbers.reverse();\n\
    \    valid_numbers.iter().map(|n| number_to_str(*n)).collect()\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `number_to_str` in this scope\n  -->\
    \ /tmp/tmp91xmpmuh.rs:15:34\n   |\n15 |     valid_numbers.iter().map(|n| number_to_str(*n)).collect()\n\
    \   |                                  ^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<usize> = arr.into_iter().filter(|x| 0 < *x && *x < 10).map(|x|\
    \ x as usize).collect();\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmpunxtfrmc.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut unsorted = arr;\n    unsorted.sort();\n    let mut sorted = Vec::new();\n\
    \    for num in unsorted {\n        match num {\n            1 => sorted.push(\"\
    One\".to_string()),\n            2 => sorted.push(\"Two\".to_string()),\n    \
    \        3 => sorted.push(\"Three\".to_string()),\n            4 => sorted.push(\"\
    Four\".to_string()),\n            5 => sorted.push(\"Five\".to_string()),\n  \
    \          6 => sorted.push(\"Six\".to_string()),\n            7 => sorted.push(\"\
    Seven\".to_string()),\n            8 => sorted.push(\"Eight\".to_string()),\n\
    \            9 => sorted.push(\"Nine\".to_string()),\n            _ => continue,\n\
    \        }\n    }\n    sorted.reverse();\n    sorted\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr_new: Vec<isize> = arr.clone();\n    arr_new.sort();\n    arr_new.dedup();\n\
    \    let mut result: Vec<String> = Vec::new();\n    for i in 0..arr_new.len()\
    \ {\n        if arr_new[i] == 1 {\n            result.push(\"One\".to_string());\n\
    \        } else if arr_new[i] == 2 {\n            result.push(\"Two\".to_string());\n\
    \        } else if arr_new[i] == 3 {\n            result.push(\"Three\".to_string());\n\
    \        } else if arr_new[i] == 4 {\n            result.push(\"Four\".to_string());\n\
    \        } else if arr_new[i] == 5 {\n            result.push(\"Five\".to_string());\n\
    \        } else if arr_new[i] == 6 {\n            result.push(\"Six\".to_string());\n\
    \        } else if arr_new[i] == 7 {\n            result.push(\"Seven\".to_string());\n\
    \        } else if arr_new[i] == 8 {\n            result.push(\"Eight\".to_string());\n\
    \        } else if arr_new[i] == 9 {\n            result.push(\"Nine\".to_string());\n\
    \        }\n    }\n    result.reverse();\n    result\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"One\"]`,\n right: `[\"\
    Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`',\
    \ /tmp/tmpw5jz6dq6.rs:43:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut ret: Vec<String> = Vec::new();\n    for i in arr {\n        match i\
    \ {\n            1 => ret.push(\"One\".to_string()),\n            2 => ret.push(\"\
    Two\".to_string()),\n            3 => ret.push(\"Three\".to_string()),\n     \
    \       4 => ret.push(\"Four\".to_string()),\n            5 => ret.push(\"Five\"\
    .to_string()),\n            6 => ret.push(\"Six\".to_string()),\n            7\
    \ => ret.push(\"Seven\".to_string()),\n            8 => ret.push(\"Eight\".to_string()),\n\
    \            9 => ret.push(\"Nine\".to_string()),\n            _ => (),\n    \
    \    }\n    }\n    ret.sort();\n    ret.reverse();\n    ret\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Two\", \"Two\", \"Three\", \"One\", \"One\", \"Four\", \"Five\", \"Eight\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmps_u4dmx_.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut v = arr.clone();\n    v.sort();\n    v.dedup();\n    v.reverse();\n\
    \    let mut result = Vec::new();\n    for i in v {\n        if i > 0 && i < 10\
    \ {\n            result.push(match i {\n                1 => \"One\",\n      \
    \          2 => \"Two\",\n                3 => \"Three\",\n                4 =>\
    \ \"Four\",\n                5 => \"Five\",\n                6 => \"Six\",\n \
    \               7 => \"Seven\",\n                8 => \"Eight\",\n           \
    \     9 => \"Nine\",\n                _ => \"\",\n            }.to_string());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"One\"]`,\n right: `[\"\
    Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`',\
    \ /tmp/tmp_ttw49g5.rs:38:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result: Vec<String> = Vec::new();\n    //\n    let mut sorted_arr:\
    \ Vec<isize> = arr.clone();\n    sorted_arr.sort();\n    //\n    for i in sorted_arr\
    \ {\n        match i {\n            1...9 => result.push(i.to_string()),\n   \
    \         _ => (),\n        }\n    }\n    //\n    let mut reversed_result: Vec<String>\
    \ = Vec::new();\n    for i in result.iter().rev() {\n        match i.as_ref()\
    \ {\n            \"1\" => reversed_result.push(\"One\".to_string()),\n       \
    \     \"2\" => reversed_result.push(\"Two\".to_string()),\n            \"3\" =>\
    \ reversed_result.push(\"Three\".to_string()),\n            \"4\" => reversed_result.push(\"\
    Four\".to_string()),\n            \"5\" => reversed_result.push(\"Five\".to_string()),\n\
    \            \"6\" => reversed_result.push(\"Six\".to_string()),\n           \
    \ \"7\" => reversed_result.push(\"Seven\".to_string()),\n            \"8\" =>\
    \ reversed_result.push(\"Eight\".to_string()),\n            \"9\" => reversed_result.push(\"\
    Nine\".to_string()),\n            _ => (),\n        }\n    }\n    reversed_result\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  if arr.len() == 0 {\n        return vec![];\n    }\n    let mut result = vec![];\n\
    \    for num in arr {\n        if num >= 1 && num <= 9 {\n            result.push(num);\n\
    \        }\n    }\n    result.sort();\n    result.reverse();\n    let mut new_result\
    \ = vec![];\n    for n in result {\n        match n {\n            1 => new_result.push(\"\
    One\".to_string()),\n            2 => new_result.push(\"Two\".to_string()),\n\
    \            3 => new_result.push(\"Three\".to_string()),\n            4 => new_result.push(\"\
    Four\".to_string()),\n            5 => new_result.push(\"Five\".to_string()),\n\
    \            6 => new_result.push(\"Six\".to_string()),\n            7 => new_result.push(\"\
    Seven\".to_string()),\n            8 => new_result.push(\"Eight\".to_string()),\n\
    \            9 => new_result.push(\"Nine\".to_string()),\n            _ => ()\n\
    \        }\n    }\n    new_result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut res = Vec::<String>::new();\n    for i in &arr {\n        if *i > 0\
    \ && *i < 10 {\n            res.push(match *i {\n                1 => \"One\"\
    .to_string(),\n                2 => \"Two\".to_string(),\n                3 =>\
    \ \"Three\".to_string(),\n                4 => \"Four\".to_string(),\n       \
    \         5 => \"Five\".to_string(),\n                6 => \"Six\".to_string(),\n\
    \                7 => \"Seven\".to_string(),\n                8 => \"Eight\".to_string(),\n\
    \                9 => \"Nine\".to_string(),\n                _ => panic!(\"bad\
    \ input\"),\n            });\n        }\n    }\n    res.sort();\n    res.reverse();\n\
    \    res\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Two\", \"Two\", \"Three\", \"One\", \"One\", \"Four\", \"Five\", \"Eight\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmpsg3o25c3.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  if arr.len() == 0 {\n        return vec![];\n    }\n\n    let mut converted:\
    \ Vec<String> = arr.iter().map(|x| x.to_string()).collect();\n    converted.sort();\n\
    \    converted.reverse();\n    let length = converted.len();\n    for i in 0..length\
    \ {\n        match converted[i].as_ref() {\n            \"1\" => converted[i]\
    \ = \"One\".to_string(),\n            \"2\" => converted[i] = \"Two\".to_string(),\n\
    \            \"3\" => converted[i] = \"Three\".to_string(),\n            \"4\"\
    \ => converted[i] = \"Four\".to_string(),\n            \"5\" => converted[i] =\
    \ \"Five\".to_string(),\n            \"6\" => converted[i] = \"Six\".to_string(),\n\
    \            \"7\" => converted[i] = \"Seven\".to_string(),\n            \"8\"\
    \ => converted[i] = \"Eight\".to_string(),\n            \"9\" => converted[i]\
    \ = \"Nine\".to_string(),\n            _ => (),\n        }\n    }\n    converted\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"55\", \"One\", \"-1\"]`,\n right: `[\"One\"]`', /tmp/tmpd_35t4sw.rs:41:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut new_arr: Vec<String> = vec![];\n    for i in arr {\n        if i >\
    \ 0 && i < 10 {\n            new_arr.push(i.to_string());\n        }\n    }\n\
    \    new_arr.sort();\n    new_arr.reverse();\n    for i in 0..new_arr.len() {\n\
    \        match new_arr[i].as_ref() {\n            \"1\" => new_arr[i] = \"One\"\
    .to_string(),\n            \"2\" => new_arr[i] = \"Two\".to_string(),\n      \
    \      \"3\" => new_arr[i] = \"Three\".to_string(),\n            \"4\" => new_arr[i]\
    \ = \"Four\".to_string(),\n            \"5\" => new_arr[i] = \"Five\".to_string(),\n\
    \            \"6\" => new_arr[i] = \"Six\".to_string(),\n            \"7\" =>\
    \ new_arr[i] = \"Seven\".to_string(),\n            \"8\" => new_arr[i] = \"Eight\"\
    .to_string(),\n            \"9\" => new_arr[i] = \"Nine\".to_string(),\n     \
    \       _ => (),\n        }\n    }\n    new_arr\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut ans = Vec::new();\n    for i in arr {\n        if i > 0 && i < 10 {\n\
    \            ans.push(i);\n        }\n    }\n    ans.sort();\n    ans.reverse();\n\
    \    ans.iter().map(|&i| num_to_str(i)).collect()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `num_to_str` in this scope\n  --> /tmp/tmpvu60h7mu.rs:20:25\n\
    \   |\n20 |     ans.iter().map(|&i| num_to_str(i)).collect()\n   |           \
    \              ^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr;\n    arr.sort();\n    arr.reverse();\n    let\
    \ mut ret: Vec<String> = Vec::new();\n    for i in arr {\n        if i < 1 ||\
    \ i > 9 {\n            continue;\n        }\n        match i {\n            1\
    \ => ret.push(\"One\".to_string()),\n            2 => ret.push(\"Two\".to_string()),\n\
    \            3 => ret.push(\"Three\".to_string()),\n            4 => ret.push(\"\
    Four\".to_string()),\n            5 => ret.push(\"Five\".to_string()),\n     \
    \       6 => ret.push(\"Six\".to_string()),\n            7 => ret.push(\"Seven\"\
    .to_string()),\n            8 => ret.push(\"Eight\".to_string()),\n          \
    \  9 => ret.push(\"Nine\".to_string()),\n            _ => continue,\n        }\n\
    \    }\n    ret\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  unimplemented!()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmprm15cuvw.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821432
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut list = arr.iter().filter(|x| x < &&9 && x > &&0).cloned().collect::<Vec<isize>>();\n\
    \    list.sort();\n    list.reverse();\n    list.iter().map(|x| match x {\n  \
    \      1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n       \
    \ 4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 =>\
    \ \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\
    ???\",\n    }).cloned().collect::<Vec<String>>()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `str: Clone` is not satisfied\n  --> /tmp/tmp64krvxgp.rs:26:8\n\
    \   |\n26 |     }).cloned().collect::<Vec<String>>()\n   |        ^^^^^^ the trait\
    \ `Clone` is not implemented for `str`\n\nerror[E0599]: the method `collect` exists\
    \ for struct `Cloned<Map<std::slice::Iter<'_, isize>, [closure@/tmp/tmp64krvxgp.rs:15:21:\
    \ 26:6]>>`, but its trait bounds were not satisfied\n  --> /tmp/tmp64krvxgp.rs:26:17\n\
    \   |\n26 |       }).cloned().collect::<Vec<String>>()\n   |                 \
    \  ^^^^^^^ method cannot be called on `Cloned<Map<std::slice::Iter<'_, isize>,\
    \ [closure@/tmp/tmp64krvxgp.rs:15:21: 26:6]>>` due to unsatisfied trait bounds\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `Cloned<Map<std::slice::Iter<'_,\
    \ isize>, [closure@/tmp/tmp64krvxgp.rs:15:21: 26:6]>>: Iterator`\n           which\
    \ is required by `&mut Cloned<Map<std::slice::Iter<'_, isize>, [closure@/tmp/tmp64krvxgp.rs:15:21:\
    \ 26:6]>>: Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  if arr.len() == 0 {\n        return vec![];\n    }\n\n    let mut ret = arr.clone();\n\
    \    ret.sort();\n    ret.reverse();\n    ret.iter().map(|i| number_to_string(*i)).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `number_to_string` in this scope\n \
    \ --> /tmp/tmpvrrajnbb.rs:19:24\n   |\n19 |     ret.iter().map(|i| number_to_string(*i)).collect()\n\
    \   |                        ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result = Vec::new();\n    let mut int_vec = Vec::new();\n    for i\
    \ in arr {\n        if i >= 1 && i <= 9 {\n            int_vec.push(i);\n    \
    \    }\n    }\n    int_vec.sort();\n    int_vec.reverse();\n    for i in int_vec\
    \ {\n        result.push(match i {\n            1 => \"One\",\n            2 =>\
    \ \"Two\",\n            3 => \"Three\",\n            4 => \"Four\",\n        \
    \    5 => \"Five\",\n            6 => \"Six\",\n            7 => \"Seven\",\n\
    \            8 => \"Eight\",\n            9 => \"Nine\",\n            _ => \"\"\
    ,\n        }.to_string());\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut sorted = arr.clone();\n    sorted.sort();\n    sorted.iter().filter(|x|\
    \ *x > &0 && *x < &10).map(|x| match x {\n        1 => \"One\",\n        2 =>\
    \ \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\"\
    ,\n        6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n \
    \       9 => \"Nine\",\n        _ => panic!(\"Not a valid number\"),\n    }).rev().map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  let\
    \ mut r = vec![];\n  let mut i = 0;\n  while i < arr.len() {\n    match arr[i]\
    \ {\n      1 => r.push(\"One\".to_string()),\n      2 => r.push(\"Two\".to_string()),\n\
    \      3 => r.push(\"Three\".to_string()),\n      4 => r.push(\"Four\".to_string()),\n\
    \      5 => r.push(\"Five\".to_string()),\n      6 => r.push(\"Six\".to_string()),\n\
    \      7 => r.push(\"Seven\".to_string()),\n      8 => r.push(\"Eight\".to_string()),\n\
    \      9 => r.push(\"Nine\".to_string()),\n      _ => (),\n    }\n    i += 1;\n\
    \  }\n  r.sort();\n  r.reverse();\n  r\n}\n\nfn main() {\n    let candidate =\
    \ by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Two\", \"Two\", \"Three\", \"One\", \"One\", \"Four\", \"Five\", \"Eight\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmpspno__qm.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<isize> = arr;\n    arr.sort();\n    arr.reverse();\n    let\
    \ mut names: Vec<String> = Vec::new();\n    for i in arr {\n        if i == 1\
    \ {\n            names.push(\"One\".to_string());\n        } else if i == 2 {\n\
    \            names.push(\"Two\".to_string());\n        } else if i == 3 {\n  \
    \          names.push(\"Three\".to_string());\n        } else if i == 4 {\n  \
    \          names.push(\"Four\".to_string());\n        } else if i == 5 {\n   \
    \         names.push(\"Five\".to_string());\n        } else if i == 6 {\n    \
    \        names.push(\"Six\".to_string());\n        } else if i == 7 {\n      \
    \      names.push(\"Seven\".to_string());\n        } else if i == 8 {\n      \
    \      names.push(\"Eight\".to_string());\n        } else if i == 9 {\n      \
    \      names.push(\"Nine\".to_string());\n        }\n    }\n    names\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result = Vec::new();\n    for item in arr {\n        if 1 <= item &&\
    \ item <= 9 {\n            result.push(item);\n        }\n    }\n    result.sort();\n\
    \    result.reverse();\n    let mut strings = Vec::new();\n    for item in result\
    \ {\n        match item {\n            1 => strings.push(\"One\".to_string()),\n\
    \            2 => strings.push(\"Two\".to_string()),\n            3 => strings.push(\"\
    Three\".to_string()),\n            4 => strings.push(\"Four\".to_string()),\n\
    \            5 => strings.push(\"Five\".to_string()),\n            6 => strings.push(\"\
    Six\".to_string()),\n            7 => strings.push(\"Seven\".to_string()),\n \
    \           8 => strings.push(\"Eight\".to_string()),\n            9 => strings.push(\"\
    Nine\".to_string()),\n            _ => (),\n        }\n    }\n    strings\n}\n\
    \nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut numbers = arr.clone();\n    numbers.sort();\n    numbers.dedup();\n\
    \    let mut result = Vec::new();\n    for x in numbers {\n        match x {\n\
    \            1 => result.push(\"One\".to_string()),\n            2 => result.push(\"\
    Two\".to_string()),\n            3 => result.push(\"Three\".to_string()),\n  \
    \          4 => result.push(\"Four\".to_string()),\n            5 => result.push(\"\
    Five\".to_string()),\n            6 => result.push(\"Six\".to_string()),\n   \
    \         7 => result.push(\"Seven\".to_string()),\n            8 => result.push(\"\
    Eight\".to_string()),\n            9 => result.push(\"Nine\".to_string()),\n \
    \           _ => {},\n        }\n    }\n    result.reverse();\n    result\n}\n\
    \nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"One\"]`,\n right: `[\"\
    Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`',\
    \ /tmp/tmpr_r182h6.rs:36:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut ret: Vec<String> = vec![];\n    let mut vec_1_9: Vec<isize> = vec![];\n\
    \    for i in &arr {\n        if *i >= 1 && *i <= 9 {\n            vec_1_9.push(*i);\n\
    \        }\n    }\n    let mut vec_1_9_sort = vec_1_9.clone();\n    vec_1_9_sort.sort();\n\
    \    vec_1_9_sort.reverse();\n    for i in &vec_1_9_sort {\n        ret.push(match\
    \ i {\n            1 => \"One\".to_string(),\n            2 => \"Two\".to_string(),\n\
    \            3 => \"Three\".to_string(),\n            4 => \"Four\".to_string(),\n\
    \            5 => \"Five\".to_string(),\n            6 => \"Six\".to_string(),\n\
    \            7 => \"Seven\".to_string(),\n            8 => \"Eight\".to_string(),\n\
    \            9 => \"Nine\".to_string(),\n            _ => panic!(\"should not\
    \ go here\"),\n        });\n    }\n    ret\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut numbers = vec![];\n    for num in arr {\n        if num > 0 && num\
    \ < 10 {\n            numbers.push(num);\n        }\n    }\n    numbers.sort();\n\
    \    numbers.reverse();\n    let mut res = vec![];\n    for num in numbers {\n\
    \        match num {\n            1 => res.push(\"One\".to_string()),\n      \
    \      2 => res.push(\"Two\".to_string()),\n            3 => res.push(\"Three\"\
    .to_string()),\n            4 => res.push(\"Four\".to_string()),\n           \
    \ 5 => res.push(\"Five\".to_string()),\n            6 => res.push(\"Six\".to_string()),\n\
    \            7 => res.push(\"Seven\".to_string()),\n            8 => res.push(\"\
    Eight\".to_string()),\n            9 => res.push(\"Nine\".to_string()),\n    \
    \        _ => res.push(\"\".to_string()),\n        }\n    }\n    res\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut numbers: Vec<usize> = arr.iter().filter(|x| **x >= 1 && **x <= 9).map(|x|\
    \ *x as usize).collect();\n    numbers.sort();\n    numbers.reverse();\n    let\
    \ names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\"];\n    numbers.iter().map(|x| names[*x - 1].to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut nums = arr.iter().filter(|&x| x >= &1 && x <= &9).cloned().collect::<Vec<isize>>();\n\
    \    nums.sort();\n    nums.reverse();\n    nums.iter().map(|x| x.to_string()).collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"8\", \"5\", \"4\", \"3\", \"2\", \"2\", \"1\", \"1\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmpzlmltn_h.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut temp = arr.clone();\n    temp.sort();\n    temp.reverse();\n    let\
    \ mut result: Vec<String> = Vec::new();\n    for item in temp {\n        match\
    \ item {\n            1 => result.push(\"One\".to_string()),\n            2 =>\
    \ result.push(\"Two\".to_string()),\n            3 => result.push(\"Three\".to_string()),\n\
    \            4 => result.push(\"Four\".to_string()),\n            5 => result.push(\"\
    Five\".to_string()),\n            6 => result.push(\"Six\".to_string()),\n   \
    \         7 => result.push(\"Seven\".to_string()),\n            8 => result.push(\"\
    Eight\".to_string()),\n            9 => result.push(\"Nine\".to_string()),\n \
    \           _ => continue,\n        }\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut temp: Vec<isize> = Vec::new();\n    for x in arr {\n        if x >=\
    \ 1 && x <= 9 {\n            temp.push(x);\n        }\n    }\n    temp.sort();\n\
    \    temp.reverse();\n    let mut temp2: Vec<String> = Vec::new();\n    for x\
    \ in temp {\n        match x {\n            1 => temp2.push(\"One\".to_string()),\n\
    \            2 => temp2.push(\"Two\".to_string()),\n            3 => temp2.push(\"\
    Three\".to_string()),\n            4 => temp2.push(\"Four\".to_string()),\n  \
    \          5 => temp2.push(\"Five\".to_string()),\n            6 => temp2.push(\"\
    Six\".to_string()),\n            7 => temp2.push(\"Seven\".to_string()),\n   \
    \         8 => temp2.push(\"Eight\".to_string()),\n            9 => temp2.push(\"\
    Nine\".to_string()),\n            _ => panic!(\"Invalid input\"),\n        }\n\
    \    }\n    temp2\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut tmp: Vec<String> = arr.iter().filter(|x| *x >= &1 && *x <= &9).map(|x|\
    \ x.to_string()).collect();\n    tmp.sort();\n    tmp.reverse();\n    tmp.iter().map(|x|\
    \ match x.as_ref() {\n        \"1\" => \"One\",\n        \"2\" => \"Two\",\n \
    \       \"3\" => \"Three\",\n        \"4\" => \"Four\",\n        \"5\" => \"Five\"\
    ,\n        \"6\" => \"Six\",\n        \"7\" => \"Seven\",\n        \"8\" => \"\
    Eight\",\n        \"9\" => \"Nine\",\n        _ => panic!(\"Wrong input!\"),\n\
    \    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmphb159njk.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result: Vec<String> = vec![];\n    if arr.len() != 0 {\n        let\
    \ mut vec: Vec<_> = arr.iter().filter(|x| 1 <= **x && **x <= 9).collect();\n \
    \       vec.sort();\n        vec.reverse();\n        result = vec.iter().map(|x|\
    \ match x {\n            1 => \"One\",\n            2 => \"Two\",\n          \
    \  3 => \"Three\",\n            4 => \"Four\",\n            5 => \"Five\",\n \
    \           6 => \"Six\",\n            7 => \"Seven\",\n            8 => \"Eight\"\
    ,\n            9 => \"Nine\",\n            _ => \"\",\n        }).filter(|x| *x\
    \ != \"\").map(|x| x.to_string()).collect();\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  if arr.len() == 0 {\n        return vec![];\n    }\n    let mut tmp: Vec<usize>\
    \ = vec![];\n    for i in 0..arr.len() {\n        if arr[i] < 10 && arr[i] > 0\
    \ {\n            tmp.push(arr[i] as usize);\n        }\n    }\n    tmp.sort();\n\
    \    tmp.reverse();\n    let mut result: Vec<String> = vec![];\n    for i in 0..tmp.len()\
    \ {\n        match tmp[i] {\n            1 => result.push(\"One\".to_string()),\n\
    \            2 => result.push(\"Two\".to_string()),\n            3 => result.push(\"\
    Three\".to_string()),\n            4 => result.push(\"Four\".to_string()),\n \
    \           5 => result.push(\"Five\".to_string()),\n            6 => result.push(\"\
    Six\".to_string()),\n            7 => result.push(\"Seven\".to_string()),\n  \
    \          8 => result.push(\"Eight\".to_string()),\n            9 => result.push(\"\
    Nine\".to_string()),\n            _ => result.push(\"\".to_string()),\n      \
    \  }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n  \
    \  assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"\
    ), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![1,\
    \ -1, 55]), vec![String::from(\"One\")]);\n    assert_eq!(candidate(vec![1, -1,\
    \ 3, 2]), vec![String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"Nine\"\
    ), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result: Vec<String> = Vec::new();\n    let mut new: Vec<isize> = Vec::new();\n\
    \    for i in 0..arr.len() {\n        if arr[i] > 0 && arr[i] < 10 {\n       \
    \     new.push(arr[i]);\n        }\n    }\n    new.sort();\n    for j in (0..new.len()).rev()\
    \ {\n        match new[j] {\n            1 => result.push(\"One\".to_string()),\n\
    \            2 => result.push(\"Two\".to_string()),\n            3 => result.push(\"\
    Three\".to_string()),\n            4 => result.push(\"Four\".to_string()),\n \
    \           5 => result.push(\"Five\".to_string()),\n            6 => result.push(\"\
    Six\".to_string()),\n            7 => result.push(\"Seven\".to_string()),\n  \
    \          8 => result.push(\"Eight\".to_string()),\n            9 => result.push(\"\
    Nine\".to_string()),\n            _ => println!(\"Number not in range\"),\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result = arr.clone();\n    result.sort();\n    result.reverse();\n\
    \    let result: Vec<String> = result.iter().map(|n| match n {\n        1 => \"\
    One\".to_string(),\n        2 => \"Two\".to_string(),\n        3 => \"Three\"\
    .to_string(),\n        4 => \"Four\".to_string(),\n        5 => \"Five\".to_string(),\n\
    \        6 => \"Six\".to_string(),\n        7 => \"Seven\".to_string(),\n    \
    \    8 => \"Eight\".to_string(),\n        9 => \"Nine\".to_string(),\n       \
    \ _ => \"\".to_string(),\n    }).filter(|n| !n.is_empty()).collect();\n    result\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  // TODO: Implement the solution here\n    arr.iter().filter(|n| *n > 0 && *n\
    \ < 10).sorted().rev().map(|n| {\n        match n {\n            1 => \"One\"\
    ,\n            2 => \"Two\",\n            3 => \"Three\",\n            4 => \"\
    Four\",\n            5 => \"Five\",\n            6 => \"Six\",\n            7\
    \ => \"Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\",\n   \
    \         _ => panic!(\"n is not a number between 1 and 9\"),\n        }.to_string()\n\
    \    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptivs12j9.rs:13:32\n   |\n\
    13 |     arr.iter().filter(|n| *n > 0 && *n < 10).sorted().rev().map(|n| {\n \
    \  |                                ^\n   |                                |\n\
    \   |                                expected `&isize`, found integer\n   |  \
    \                              help: consider borrowing here: `&0`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptivs12j9.rs:13:42\n   |\n13 |     arr.iter().filter(|n|\
    \ *n > 0 && *n < 10).sorted().rev().map(|n| {\n   |                          \
    \                ^^\n   |                                          |\n   |   \
    \                                       expected `&isize`, found integer\n   |\
    \                                          help: consider borrowing here: `&10`\n\
    \nerror[E0599]: no method named `sorted` found for struct `Filter` in the current\
    \ scope\n  --> /tmp/tmptivs12j9.rs:13:46\n   |\n13 |     arr.iter().filter(|n|\
    \ *n > 0 && *n < 10).sorted().rev().map(|n| {\n   |                          \
    \                    ^^^^^^ method not found in `Filter<std::slice::Iter<'_, isize>,\
    \ [closure@/tmp/tmptivs12j9.rs:13:23: 13:44]>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr: Vec<_> = arr.into_iter().filter(|x| x.is_positive() && *x < 10).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"8\", \"5\", \"4\", \"3\", \"2\", \"2\", \"1\", \"1\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmp9i9satjw.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let only_digits = arr.iter().filter(|n| **n >= 1 && **n <= 9).collect::<Vec<_>>();\n\
    \    let mut sorted = only_digits.clone();\n    sorted.sort();\n    sorted.reverse();\n\
    \    sorted.iter().map(|n| n.to_string()).collect()\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"8\", \"5\", \"4\", \"3\", \"2\", \"2\", \"1\", \"1\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmpr6mf854n.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    // Implement your solution here\n    return arr.iter().map(|i|\
    \ format!(\"{}\", i)).collect();\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"2\", \"1\", \"1\", \"4\", \"5\", \"8\", \"2\", \"3\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmp0l1uctho.rs:19:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut sorted_vec = arr.iter().filter(|x| x.is_positive() && *x < 10).cloned().collect::<Vec<isize>>();\n\
    \    sorted_vec.sort();\n    sorted_vec.reverse();\n    sorted_vec.iter().map(|x|\
    \ number_to_string(*x)).collect::<Vec<String>>()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `number_to_string` in this scope\n \
    \ --> /tmp/tmpnlbh989n.rs:15:31\n   |\n15 |     sorted_vec.iter().map(|x| number_to_string(*x)).collect::<Vec<String>>()\n\
    \   |                               ^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnlbh989n.rs:12:72\n   |\n12 |\
    \     let mut sorted_vec = arr.iter().filter(|x| x.is_positive() && *x < 10).cloned().collect::<Vec<isize>>();\n\
    \   |                                                                        ^^\n\
    \   |                                                                        |\n\
    \   |                                                                        expected\
    \ `&isize`, found integer\n   |                                              \
    \                          help: consider borrowing here: `&10`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut res = vec![];\n    for i in arr {\n        if i < 1 || i > 9 {\n  \
    \          continue;\n        }\n        match i {\n            1 => res.push(\"\
    One\".to_string()),\n            2 => res.push(\"Two\".to_string()),\n       \
    \     3 => res.push(\"Three\".to_string()),\n            4 => res.push(\"Four\"\
    .to_string()),\n            5 => res.push(\"Five\".to_string()),\n           \
    \ 6 => res.push(\"Six\".to_string()),\n            7 => res.push(\"Seven\".to_string()),\n\
    \            8 => res.push(\"Eight\".to_string()),\n            9 => res.push(\"\
    Nine\".to_string()),\n            _ => (),\n        }\n    }\n    res.reverse();\n\
    \    res\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Three\", \"Two\", \"Eight\", \"Five\", \"Four\", \"One\", \"One\", \"Two\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmpqktfew30.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    let mut result\
    \ = Vec::new();\n    for i in &arr {\n        if *i > 0 && *i < 10 {\n       \
    \     result.push(number_to_string(*i))\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `number_to_string` in this scope\n \
    \ --> /tmp/tmptsgeod4i.rs:18:25\n   |\n18 |             result.push(number_to_string(*i))\n\
    \   |                         ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut new_arr: Vec<isize> = arr.clone();\n    new_arr.sort();\n    new_arr.reverse();\n\
    \    new_arr.iter().filter(|x| **x <= 9 && **x >= 1).map(|x| number_to_string(*x)).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `number_to_string` in this scope\n \
    \ --> /tmp/tmpmsm9g0g1.rs:15:61\n   |\n15 |     new_arr.iter().filter(|x| **x\
    \ <= 9 && **x >= 1).map(|x| number_to_string(*x)).collect()\n   |            \
    \                                                 ^^^^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut array = arr.clone();\n    array.sort();\n    let mut array = reverse_vec(array);\n\
    \    let mut ret = Vec::new();\n    for _i in array {\n        match _i {\n  \
    \          1 => ret.push(\"One\".to_string()),\n            2 => ret.push(\"Two\"\
    .to_string()),\n            3 => ret.push(\"Three\".to_string()),\n          \
    \  4 => ret.push(\"Four\".to_string()),\n            5 => ret.push(\"Five\".to_string()),\n\
    \            6 => ret.push(\"Six\".to_string()),\n            7 => ret.push(\"\
    Seven\".to_string()),\n            8 => ret.push(\"Eight\".to_string()),\n   \
    \         9 => ret.push(\"Nine\".to_string()),\n            _ => continue,\n \
    \       }\n    }\n    ret\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `reverse_vec` in this scope\n  --> /tmp/tmpnijedjp5.rs:14:21\n\
    \   |\n14 |     let mut array = reverse_vec(array);\n   |                    \
    \ ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  return vec![];\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"]`', /tmp/tmp99phifuq.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result: Vec<isize> = Vec::new();\n    let mut res: Vec<String> = Vec::new();\n\
    \    for i in arr {\n        if i >= 1 && i <= 9 {\n            result.push(i);\n\
    \        }\n    }\n    result.sort();\n    result.reverse();\n    for j in result\
    \ {\n        match j {\n            1 => res.push(\"One\".to_string()),\n    \
    \        2 => res.push(\"Two\".to_string()),\n            3 => res.push(\"Three\"\
    .to_string()),\n            4 => res.push(\"Four\".to_string()),\n           \
    \ 5 => res.push(\"Five\".to_string()),\n            6 => res.push(\"Six\".to_string()),\n\
    \            7 => res.push(\"Seven\".to_string()),\n            8 => res.push(\"\
    Eight\".to_string()),\n            9 => res.push(\"Nine\".to_string()),\n    \
    \        _ => res.push(\"\".to_string()),\n        }\n    }\n    res\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let num = arr.iter().filter(|x| 0 < **x && **x < 10).collect::<Vec<&isize>>();\n\
    \    num.iter().map(|n| num_to_name(*n)).collect::<Vec<String>>()\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `num_to_name` in this scope\n  --> /tmp/tmpro4w9c7_.rs:13:24\n\
    \   |\n13 |     num.iter().map(|n| num_to_name(*n)).collect::<Vec<String>>()\n\
    \   |                        ^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut map = HashMap::new();\n    map.insert(1, \"One\");\n    map.insert(2,\
    \ \"Two\");\n    map.insert(3, \"Three\");\n    map.insert(4, \"Four\");\n   \
    \ map.insert(5, \"Five\");\n    map.insert(6, \"Six\");\n    map.insert(7, \"\
    Seven\");\n    map.insert(8, \"Eight\");\n    map.insert(9, \"Nine\");\n    let\
    \ mut temp = arr.iter().filter(|&x| *x >= 1 && *x <= 9).cloned().collect::<Vec<isize>>();\n\
    \    temp.sort();\n    temp.reverse();\n    temp.iter().map(|x| String::from(map.get(x).unwrap())).collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmptk7mz3yn.rs:12:19\n   |\n12 |     let mut map = HashMap::new();\n  \
    \ |                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp3ws6ze7d.rs:12:3

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821434
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut mut_arr = arr;\n    let mut result: Vec<String> = Vec::new();\n   \
    \ mut_arr.sort();\n    mut_arr.reverse();\n    for num in mut_arr {\n        if\
    \ num > 0 && num < 10 {\n            result.push(convert_to_string(num))\n   \
    \     }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `convert_to_string` in this scope\n\
    \  --> /tmp/tmp9qtkcu1g.rs:18:25\n   |\n18 |             result.push(convert_to_string(num))\n\
    \   |                         ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result: Vec<isize> = arr.clone();\n    result.sort();\n    result.reverse();\n\
    \    let nums = vec![\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\"\
    , \"Seven\", \"Eight\", \"Nine\"];\n    result.iter().filter(|&x| *x >= 1 && *x\
    \ <= 9).map(|&x| nums[(x - 1) as usize].to_string()).collect()\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result = vec![];\n    if arr.len() == 0 {\n        return result;\n\
    \    }\n\n    let mut replaced_array = arr.iter().map(|i| number_to_word(*i as\
    \ isize)).collect::<Vec<String>>();\n    replaced_array.sort();\n    replaced_array.reverse();\n\
    \    result = replaced_array;\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `number_to_word` in this scope\n  -->\
    \ /tmp/tmpfset2kim.rs:17:49\n   |\n17 |     let mut replaced_array = arr.iter().map(|i|\
    \ number_to_word(*i as isize)).collect::<Vec<String>>();\n   |               \
    \                                  ^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  unimplemented!()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmprm15cuvw.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821432
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  // Your code here!\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpljm4raze.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  // your code\n    let mut new_arr = arr.clone();\n    let mut final_arr = vec![];\n\
    \    let strings = vec![\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\"\
    , \"Seven\", \"Eight\", \"Nine\"];\n    new_arr.sort();\n    new_arr.reverse();\n\
    \    for i in new_arr.iter() {\n        if (1..=9).contains(i) {\n           \
    \ final_arr.push(strings[*i as usize - 1].to_string());\n        }\n    }\n  \
    \  final_arr\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  arr.iter()\n        .filter(|&i| 1 <= *i && *i <= 9)\n        .sorted()\n \
    \       .rev()\n        .map(|i| match i {\n            1 => \"One\",\n      \
    \      2 => \"Two\",\n            3 => \"Three\",\n            4 => \"Four\",\n\
    \            5 => \"Five\",\n            6 => \"Six\",\n            7 => \"Seven\"\
    ,\n            8 => \"Eight\",\n            9 => \"Nine\",\n            _ => unreachable!(),\n\
    \        })\n        .map(|s| s.to_string())\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sorted` found for struct `Filter` in the\
    \ current scope\n  --> /tmp/tmpgmcayhgj.rs:14:10\n   |\n14 |         .sorted()\n\
    \   |          ^^^^^^ method not found in `Filter<std::slice::Iter<'_, isize>,\
    \ [closure@/tmp/tmpgmcayhgj.rs:13:17: 13:40]>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  let\
    \ mut arr2 = arr.clone();\n  arr2.sort();\n  arr2.reverse();\n  let mut result\
    \ = Vec::new();\n  for item in arr2 {\n    if item < 1 || item > 9 {\n      continue;\n\
    \    }\n    match item {\n      1 => result.push(\"One\".to_string()),\n     \
    \ 2 => result.push(\"Two\".to_string()),\n      3 => result.push(\"Three\".to_string()),\n\
    \      4 => result.push(\"Four\".to_string()),\n      5 => result.push(\"Five\"\
    .to_string()),\n      6 => result.push(\"Six\".to_string()),\n      7 => result.push(\"\
    Seven\".to_string()),\n      8 => result.push(\"Eight\".to_string()),\n      9\
    \ => result.push(\"Nine\".to_string()),\n      _ => continue,\n    }\n  }\n  result\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  // TODO: implement the function\n    let mut results: Vec<isize> = vec![];\n\
    \    let mut sorted_results: Vec<isize> = vec![];\n    let mut final_results:\
    \ Vec<String> = vec![];\n    for _number in arr {\n        if _number > 0 && _number\
    \ < 10 {\n            results.push(_number);\n        }\n    }\n    sorted_results\
    \ = insertion_sort(results);\n    for _result in sorted_results {\n        final_results.push(to_name(_result));\n\
    \    }\n    final_results\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `insertion_sort` in this scope\n  -->\
    \ /tmp/tmpqh_ztyho.rs:21:22\n   |\n21 |     sorted_results = insertion_sort(results);\n\
    \   |                      ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `to_name` in this scope\n  --> /tmp/tmpqh_ztyho.rs:23:28\n\
    \   |\n23 |         final_results.push(to_name(_result));\n   |              \
    \              ^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut res = arr.iter().filter(|&x| x > &0 && x < &10).map(|&x| x as usize).collect::<Vec<usize>>();\n\
    \    res.sort();\n    res.reverse();\n    res.iter().map(|&x| match x {\n    \
    \    1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4\
    \ => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"\
    Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => panic!(\"\
    Unknown number {}\", x),\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  if arr.len() == 0 {\n        return vec![]\n    }\n\n    let arr = arr.into_iter().filter(|x|\
    \ *x > 0 && *x < 10).collect::<Vec<isize>>();\n    let mut arr = arr.into_iter().filter(|x|\
    \ *x > 0 && *x < 10).collect::<Vec<isize>>();\n    arr.sort();\n    arr.reverse();\n\
    \    let mut ret = Vec::new();\n    for num in arr {\n        ret.push(match num\
    \ {\n            1 => \"One\",\n            2 => \"Two\",\n            3 => \"\
    Three\",\n            4 => \"Four\",\n            5 => \"Five\",\n           \
    \ 6 => \"Six\",\n            7 => \"Seven\",\n            8 => \"Eight\",\n  \
    \          9 => \"Nine\",\n            _ => unreachable!()\n        }.to_string());\n\
    \    }\n    ret\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    let mut result = vec![];\n    for\
    \ a in arr {\n        match a {\n            1...9 => result.push(a.to_string()),\n\
    \            _ => (),\n        }\n    }\n    result.reverse();\n    let dict =\
    \ dict_for_num();\n    let result: Vec<String> = result.iter().map(|n| dict[n].to_string()).collect();\n\
    \    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `dict_for_num` in this scope\n  -->\
    \ /tmp/tmpatlnyd8m.rs:22:16\n   |\n22 |     let dict = dict_for_num();\n   | \
    \               ^^^^^^^^^^^^ not found in this scope\n\nwarning: `...` range patterns\
    \ are deprecated\n  --> /tmp/tmpatlnyd8m.rs:17:14\n   |\n17 |             1...9\
    \ => result.push(a.to_string()),\n   |              ^^^ help: use `..=` for an\
    \ inclusive range\n   |\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]`\
    \ on by default\n   = warning: this is accepted in the current edition (Rust 2015)\
    \ but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nerror: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut sort_arr = arr.clone();\n    sort_arr.sort();\n    let mut new_arr\
    \ = Vec::new();\n    for num in sort_arr {\n        if num > 0 && num < 10 {\n\
    \            new_arr.push(num.to_string());\n        }\n    }\n    new_arr.reverse();\n\
    \    for number in &mut new_arr {\n        let text = match number.parse::<isize>().unwrap()\
    \ {\n            1 => \"One\",\n            2 => \"Two\",\n            3 => \"\
    Three\",\n            4 => \"Four\",\n            5 => \"Five\",\n           \
    \ 6 => \"Six\",\n            7 => \"Seven\",\n            8 => \"Eight\",\n  \
    \          9 => \"Nine\",\n            _ => \"None\",\n        };\n        number.clone_from(text);\n\
    \    }\n    new_arr\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpouj34rjj.rs:34:27\n   |\n\
    34 |         number.clone_from(text);\n   |                           ^^^^ expected\
    \ struct `String`, found `str`\n   |\n   = note: expected reference `&String`\n\
    \              found reference `&str`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut new_arr: Vec<String> = vec![];\n    let mut arr_for_sort: Vec<isize>\
    \ = vec![];\n    let mut sorted_arr: Vec<isize> = vec![];\n    for i in arr {\n\
    \        if i > 0 && i < 10 {\n            arr_for_sort.push(i);\n        }\n\
    \    }\n    sorted_arr = sort_arr(&arr_for_sort);\n    let mut reverse_arr: Vec<isize>\
    \ = vec![];\n    for i in 0..sorted_arr.len() {\n        reverse_arr.push(sorted_arr[sorted_arr.len()\
    \ - 1 - i]);\n    }\n    let dict: HashMap<isize, &str> = [\n        (1, \"One\"\
    ),\n        (2, \"Two\"),\n        (3, \"Three\"),\n        (4, \"Four\"),\n \
    \       (5, \"Five\"),\n        (6, \"Six\"),\n        (7, \"Seven\"),\n     \
    \   (8, \"Eight\"),\n        (9, \"Nine\"),\n    ]\n    .iter()\n    .cloned()\n\
    \    .collect();\n    for i in reverse_arr {\n        match dict.get(&i) {\n \
    \           Some(x) => new_arr.push(x.to_string()),\n            None => {}\n\
    \        }\n    }\n    new_arr\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sort_arr` in this scope\n  --> /tmp/tmp6j0oyfjh.rs:20:18\n\
    \   |\n20 |     sorted_arr = sort_arr(&arr_for_sort);\n   |                  ^^^^^^^^\
    \ help: a local variable with a similar name exists: `sorted_arr`\n\nerror[E0412]:\
    \ cannot find type `HashMap` in this scope\n  --> /tmp/tmp6j0oyfjh.rs:25:15\n\
    \   |\n25 |     let dict: HashMap<isize, &str> = [\n   |               ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashMap;\n   |\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0412, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr_isize: Vec<isize> = Vec::new();\n    let mut arr_str: Vec<String>\
    \ = Vec::new();\n    for i in arr {\n        if i >= 1 && i <= 9 {\n         \
    \   arr_isize.push(i);\n        }\n    }\n    arr_isize.sort();\n    for j in\
    \ arr_isize.iter().rev() {\n        let num = *j;\n        match num {\n     \
    \       1 => arr_str.push(\"One\".to_string()),\n            2 => arr_str.push(\"\
    Two\".to_string()),\n            3 => arr_str.push(\"Three\".to_string()),\n \
    \           4 => arr_str.push(\"Four\".to_string()),\n            5 => arr_str.push(\"\
    Five\".to_string()),\n            6 => arr_str.push(\"Six\".to_string()),\n  \
    \          7 => arr_str.push(\"Seven\".to_string()),\n            8 => arr_str.push(\"\
    Eight\".to_string()),\n            9 => arr_str.push(\"Nine\".to_string()),\n\
    \            _ => (),\n        }\n    }\n    arr_str\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result = Vec::new();\n    let mut odd_values = Vec::new();\n    let\
    \ mut even_values = Vec::new();\n    for num in arr {\n        if num < 1 || num\
    \ > 9 {\n            continue;\n        }\n        if num % 2 == 0 {\n       \
    \     even_values.push(num);\n        } else {\n            odd_values.push(num);\n\
    \        }\n    }\n    odd_values.sort();\n    even_values.sort();\n    odd_values.reverse();\n\
    \    even_values.reverse();\n    for elem in odd_values {\n        result.push(get_digit_name(elem));\n\
    \    }\n    for elem in even_values {\n        result.push(get_digit_name(elem));\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_digit_name` in this scope\n  -->\
    \ /tmp/tmpb30_q7y1.rs:30:21\n   |\n30 |         result.push(get_digit_name(elem));\n\
    \   |                     ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `get_digit_name` in this scope\n  --> /tmp/tmpb30_q7y1.rs:33:21\n\
    \   |\n33 |         result.push(get_digit_name(elem));\n   |                 \
    \    ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result = arr.iter().filter(|&x| *x > 0 && *x < 10).map(|x| x.to_string()).collect::<Vec<String>>();\n\
    \    result.sort();\n    result.reverse();\n    let mapping = vec![\"One\", \"\
    Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\
    ];\n    result.iter().map(|x| mapping[x.parse::<usize>().unwrap() - 1].to_string()).collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  if arr.len() == 0 {\n        return vec![];\n    }\n\n    let mut arr = arr.clone();\n\
    \    arr.sort();\n    arr.reverse();\n\n    arr.iter()\n        .map(|&x|\n  \
    \          match x {\n                1 => \"One\",\n                2 => \"Two\"\
    ,\n                3 => \"Three\",\n                4 => \"Four\",\n         \
    \       5 => \"Five\",\n                6 => \"Six\",\n                7 => \"\
    Seven\",\n                8 => \"Eight\",\n                9 => \"Nine\",\n  \
    \              _ => \"\",\n            }\n        )\n        .filter(|&x| !x.is_empty())\n\
    \        .map(|&x| x.to_string())\n        .collect()\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmpxcb84wdb.rs:36:16\n   |\n36 |         .map(|&x| x.to_string())\n\
    \   |                ^ doesn't have a size known at compile-time\n   |\n   = help:\
    \ the trait `Sized` is not implemented for `str`\n   = note: all local variables\
    \ must have a statically known size\n   = help: unsized locals are gated as an\
    \ unstable feature\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut sorted = arr.iter().filter(|x| **x > 0 && **x < 10).map(|x| *x).collect::<Vec<isize>>();\n\
    \    sorted.sort();\n    sorted.reverse();\n    sorted.iter().map(|x| match x\
    \ {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n \
    \       4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n      \
    \  7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _\
    \ => \"\",\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  if arr.len() == 0 {\n        return vec![];\n    }\n\n    let mut sorted_arr\
    \ = arr.iter().filter(|&x| *x >= 1 && *x <= 9).map(|&x| x).collect::<Vec<isize>>();\n\
    \    sorted_arr.sort();\n    sorted_arr.reverse();\n\n    sorted_arr.iter().map(|&x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => panic!(\"{} is not between 1 and 9 inclusive\", x),\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result = vec![];\n    for x in arr {\n        match x {\n         \
    \   1 => result.push(\"One\".to_string()),\n            2 => result.push(\"Two\"\
    .to_string()),\n            3 => result.push(\"Three\".to_string()),\n       \
    \     4 => result.push(\"Four\".to_string()),\n            5 => result.push(\"\
    Five\".to_string()),\n            6 => result.push(\"Six\".to_string()),\n   \
    \         7 => result.push(\"Seven\".to_string()),\n            8 => result.push(\"\
    Eight\".to_string()),\n            9 => result.push(\"Nine\".to_string()),\n \
    \           _ => continue,\n        }\n    }\n    result.sort();\n    result.reverse();\n\
    \    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Two\", \"Two\", \"Three\", \"One\", \"One\", \"Four\", \"Five\", \"Eight\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmpy05zgk9n.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  return match arr.iter().filter(|x| *x > &0 && *x < &10).collect::<Vec<&isize>>().len()\
    \ {\n        0 => vec![],\n        _ => {\n            let mut ans = vec![];\n\
    \            for i in arr.iter().filter(|x| *x > &0 && *x < &10) {\n         \
    \       ans.push(\n                    match i {\n                        1 =>\
    \ \"One\",\n                        2 => \"Two\",\n                        3 =>\
    \ \"Three\",\n                        4 => \"Four\",\n                       \
    \ 5 => \"Five\",\n                        6 => \"Six\",\n                    \
    \    7 => \"Seven\",\n                        8 => \"Eight\",\n              \
    \          9 => \"Nine\",\n                        _ => \"\",\n              \
    \      }.to_string(),\n                );\n            }\n            ans.sort();\n\
    \            ans.reverse();\n            ans\n        }\n    };\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Two\", \"Two\", \"Three\", \"One\", \"One\", \"Four\", \"Five\", \"Eight\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmpvsp2z9_9.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  return vec![\"One\".to_string()];\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"One\"]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"]`', /tmp/tmpa5k0skf3.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  arr.iter()\n        .filter(|x| **x > 0 && **x < 10)\n        .map(|x| match\
    \ x {\n            1 => \"One\",\n            2 => \"Two\",\n            3 =>\
    \ \"Three\",\n            4 => \"Four\",\n            5 => \"Five\",\n       \
    \     6 => \"Six\",\n            7 => \"Seven\",\n            8 => \"Eight\",\n\
    \            9 => \"Nine\",\n            _ => \"\",\n        })\n        .rev()\n\
    \        .filter(|x| x != &\"\")\n        .map(|x| x.to_string())\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Three\", \"Two\", \"Eight\", \"Five\", \"Four\", \"One\", \"One\", \"Two\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmpjds04mer.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut sorted = arr;\n    sorted.sort();\n    sorted.reverse();\n    sorted.iter().map(|n|\
    \ match n {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).filter(|n| *n != \"\").map(|n| n.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut v = arr;\n    v.sort();\n    v.reverse();\n    v.into_iter().filter(|x|\
    \ *x >= 1 && *x <= 9).map(|x| match x {\n        1 => \"One\",\n        2 => \"\
    Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\"\
    ,\n        6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n \
    \       9 => \"Nine\",\n        _ => unreachable!(),\n    }).collect()\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmp6di1174m.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.dedup();\n    let mut res: Vec<String>\
    \ = vec![];\n    for i in arr {\n        match i {\n            9 => res.push(\"\
    Nine\".to_string()),\n            8 => res.push(\"Eight\".to_string()),\n    \
    \        7 => res.push(\"Seven\".to_string()),\n            6 => res.push(\"Six\"\
    .to_string()),\n            5 => res.push(\"Five\".to_string()),\n           \
    \ 4 => res.push(\"Four\".to_string()),\n            3 => res.push(\"Three\".to_string()),\n\
    \            2 => res.push(\"Two\".to_string()),\n            1 => res.push(\"\
    One\".to_string()),\n            _ => (),\n        }\n    }\n    res.reverse();\n\
    \    res\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"One\"]`,\n right: `[\"\
    Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`',\
    \ /tmp/tmp91gdwgiw.rs:36:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  if arr.len() == 0 {\n        vec![]\n    } else {\n        let mut s = \"One\
    \ Two Three Four Five Six Seven Eight Nine\".split_whitespace().collect::<Vec<&str>>();\n\
    \        s.reverse();\n        let mut res = arr.into_iter().filter(|&x| x >=\
    \ 1 && x <= 9).collect::<Vec<isize>>();\n        res.sort();\n        res.reverse();\n\
    \        res.into_iter().map(|x| String::from(s[(x - 1) as usize])).collect::<Vec<String>>()\n\
    \    }\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Two\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Eight\", \"Nine\", \"\
    Nine\"]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"]`', /tmp/tmp5br96xr9.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  let\
    \ valid_values = arr.into_iter().filter(|&a| (a > 0) && (a < 10));\n  let mut\
    \ digit_names: Vec<String> = vec![\"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\"];\n  let mut result: Vec<String> = valid_values.map(|n|\
    \ digit_names[(n - 1) as usize].clone()).collect();\n  result.sort();\n  result.reverse();\n\
    \  result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprmm_0nxr.rs:13:43\n   |\n\
    13 |   let mut digit_names: Vec<String> = vec![\"One\", \"Two\", \"Three\", \"\
    Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"];\n   |            \
    \                               ^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                                           |\n   |                      \
    \                     expected struct `String`, found `&str`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut v: Vec<usize> = Vec::new();\n    for i in arr {\n        if i >= 1\
    \ && i <= 9 {\n            v.push(i as usize);\n        }\n    }\n    v.sort();\n\
    \    v.reverse();\n    let res: Vec<String> = v.iter().map(|i| format!(\"{}\"\
    , i)).collect();\n    res\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"8\", \"5\", \"4\", \"3\", \"2\", \"2\", \"1\", \"1\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmplq922iod.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let s: Vec<String> = arr.into_iter().filter(|&x| x >= 1 && x <= 9).collect();\n\
    \    let mut v = s.into_iter().map(|x| x.parse::<isize>().unwrap()).collect::<Vec<isize>>();\n\
    \    v.sort();\n    v.reverse();\n    let s: Vec<String> = v.into_iter().map(|x|\
    \ {\n        match x {\n            1 => \"One\",\n            2 => \"Two\",\n\
    \            3 => \"Three\",\n            4 => \"Four\",\n            5 => \"\
    Five\",\n            6 => \"Six\",\n            7 => \"Seven\",\n            8\
    \ => \"Eight\",\n            9 => \"Nine\",\n            _ => \"Bug\",\n     \
    \   }.to_string()\n    }).collect();\n    s\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `isize`\n  --> /tmp/tmp6nh1nsc0.rs:12:72\n   |\n12 | \
    \    let s: Vec<String> = arr.into_iter().filter(|&x| x >= 1 && x <= 9).collect();\n\
    \   |                                                                        ^^^^^^^\
    \ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=isize>`\n\
    \   |\n   = help: the trait `FromIterator<isize>` is not implemented for `Vec<String>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut filtered = arr.iter().filter(|&&x| x > 0 && x < 10).cloned().collect::<Vec<isize>>();\n\
    \    filtered.sort();\n    filtered.reverse();\n    filtered.iter().map(|&x| match\
    \ x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n\
    \        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n     \
    \   7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n       \
    \ _ => unreachable!(),\n    }).map(|x| x.to_string()).collect()\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  arr.iter()\n        .filter(|&x| 1 <= *x && *x <= 9)\n        .rev()\n    \
    \    .map(|x| match x {\n            1 => \"One\",\n            2 => \"Two\",\n\
    \            3 => \"Three\",\n            4 => \"Four\",\n            5 => \"\
    Five\",\n            6 => \"Six\",\n            7 => \"Seven\",\n            8\
    \ => \"Eight\",\n            9 => \"Nine\",\n            _ => \"\",\n        })\n\
    \        .map(String::from)\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Three\", \"Two\", \"Eight\", \"Five\", \"Four\", \"One\", \"One\", \"Two\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmp22rq4l_7.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut v: Vec<String> = arr.into_iter().filter(|&x| x > 0 && x < 10).map(|&x|\
    \ x.to_string()).collect();\n    v.sort();\n    v.reverse();\n    v.iter().map(|x|\
    \ match x.as_ref() {\n        \"1\" => \"One\",\n        \"2\" => \"Two\",\n \
    \       \"3\" => \"Three\",\n        \"4\" => \"Four\",\n        \"5\" => \"Five\"\
    ,\n        \"6\" => \"Six\",\n        \"7\" => \"Seven\",\n        \"8\" => \"\
    Eight\",\n        \"9\" => \"Nine\",\n        _ => unreachable!()\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy1hal2pm.rs:12:80\n   |\n\
    12 |     let mut v: Vec<String> = arr.into_iter().filter(|&x| x > 0 && x < 10).map(|&x|\
    \ x.to_string()).collect();\n   |                                            \
    \                                    ^--\n   |                               \
    \                                                 ||\n   |                   \
    \                                                             |expected due to\
    \ this\n   |                                                                 \
    \               expected `isize`, found reference\n   |                      \
    \                                                          help: did you mean\
    \ `x`: `&isize`\n   |\n   = note:   expected type `isize`\n           found reference\
    \ `&_`\n\nerror[E0277]: a value of type `Vec<String>` cannot be built from an\
    \ iterator over elements of type `&str`\n  --> /tmp/tmpy1hal2pm.rs:26:8\n   |\n\
    26 |     }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    let mut ret = vec![];\n    for i in\
    \ arr {\n        if i < 1 || i > 9 {\n            continue;\n        }\n     \
    \   ret.push(digit_name(i));\n    }\n    ret.reverse();\n    ret\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `digit_name` in this scope\n  --> /tmp/tmpjiifdzsg.rs:19:18\n\
    \   |\n19 |         ret.push(digit_name(i));\n   |                  ^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut nums: Vec<usize> = Vec::new();\n    for num in arr {\n        if 1\
    \ <= num && num <= 9 {\n            nums.push(num as usize);\n        }\n    }\n\
    \    nums.sort();\n    nums.reverse();\n    let mut names: Vec<String> = Vec::new();\n\
    \    for num in nums {\n        match num {\n            1 => names.push(\"One\"\
    .to_string()),\n            2 => names.push(\"Two\".to_string()),\n          \
    \  3 => names.push(\"Three\".to_string()),\n            4 => names.push(\"Four\"\
    .to_string()),\n            5 => names.push(\"Five\".to_string()),\n         \
    \   6 => names.push(\"Six\".to_string()),\n            7 => names.push(\"Seven\"\
    .to_string()),\n            8 => names.push(\"Eight\".to_string()),\n        \
    \    9 => names.push(\"Nine\".to_string()),\n            _ => {}\n        }\n\
    \    }\n    names\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  // TODO: Implement me!\n    arr.into_iter().filter(|x| x > &0 && x < &10).collect::<Vec<isize>>().reverse().into_iter().map(|x|\
    \ get_name(x)).collect::<Vec<String>>()\n}\n\nfn main() {\n    let candidate =\
    \ by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_name` in this scope\n  --> /tmp/tmpjnsebjy8.rs:13:105\n\
    \   |\n13 | ...lect::<Vec<isize>>().reverse().into_iter().map(|x| get_name(x)).collect::<Vec<String>>()\n\
    \   |                                                       ^^^^^^^^ not found\
    \ in this scope\n\nerror[E0599]: the method `into_iter` exists for unit type `()`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmpjnsebjy8.rs:13:85\n \
    \  |\n13 | ...ect::<Vec<isize>>().reverse().into_iter().map(|x| get_name(x)).collect::<Vec<String>>()\n\
    \   |                                  ^^^^^^^^^ method cannot be called on `()`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `(): Iterator`\n           which is required\
    \ by `(): IntoIterator`\n           `&(): Iterator`\n           which is required\
    \ by `&(): IntoIterator`\n           `&mut (): Iterator`\n           which is\
    \ required by `&mut (): IntoIterator`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    let mut filtered\
    \ = Vec::new();\n    for elem in arr {\n        if elem < 1 || elem > 9 {\n  \
    \          continue;\n        }\n        filtered.push(elem);\n    }\n    let\
    \ result = filtered.iter().map(|elem| {\n        match elem {\n            1 =>\
    \ String::from(\"One\"),\n            2 => String::from(\"Two\"),\n          \
    \  3 => String::from(\"Three\"),\n            4 => String::from(\"Four\"),\n \
    \           5 => String::from(\"Five\"),\n            6 => String::from(\"Six\"\
    ),\n            7 => String::from(\"Seven\"),\n            8 => String::from(\"\
    Eight\"),\n            9 => String::from(\"Nine\"),\n            _ => String::from(\"\
    Error\"),\n        }\n    }).collect();\n    result\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut temp = Vec::new();\n    for i in arr {\n        match i {\n       \
    \     1...9 => temp.push(i),\n            _ => continue,\n        }\n    }\n \
    \   temp.sort();\n    temp.reverse();\n    let mut result = Vec::new();\n    for\
    \ i in temp {\n        match i {\n            1 => result.push(\"One\".to_string()),\n\
    \            2 => result.push(\"Two\".to_string()),\n            3 => result.push(\"\
    Three\".to_string()),\n            4 => result.push(\"Four\".to_string()),\n \
    \           5 => result.push(\"Five\".to_string()),\n            6 => result.push(\"\
    Six\".to_string()),\n            7 => result.push(\"Seven\".to_string()),\n  \
    \          8 => result.push(\"Eight\".to_string()),\n            9 => result.push(\"\
    Nine\".to_string()),\n            _ => continue,\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let filtered = arr.into_iter().filter(|&x| x > 0 && x < 10).collect::<Vec<isize>>();\n\
    \    let mut sorted = filtered.clone();\n    sorted.sort();\n    sorted.reverse();\n\
    \    sorted.into_iter().map(|x| get_num_name(x)).collect::<Vec<String>>()\n}\n\
    \nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_num_name` in this scope\n  -->\
    \ /tmp/tmp6cad6f48.rs:16:32\n   |\n16 |     sorted.into_iter().map(|x| get_num_name(x)).collect::<Vec<String>>()\n\
    \   |                                ^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  arr.iter()\n        .filter(|&x| *x > 0 && *x < 10)\n        .map(|&x| x.to_string())\n\
    \        .collect::<Vec<String>>()\n        .iter()\n        .rev()\n        .map(|x|\
    \ x.clone())\n        .collect::<Vec<String>>()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"3\", \"2\", \"8\", \"5\", \"4\", \"1\", \"1\", \"2\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmpkgfojv5o.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut a = arr.clone();\n    a.sort();\n    a.reverse();\n    a.iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"Error\"\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n  --> /tmp/tmpn3zn65b6.rs:26:8\n   |\n26 |   \
    \  }).collect()\n   |        ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n   |\n   = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result = arr.iter().cloned().filter(|&x| x > 0 && x < 10).collect::<Vec<isize>>();\n\
    \    result.sort();\n    result.reverse();\n    let words = [\"Zero\", \"One\"\
    , \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\
    ];\n    result.iter().map(|&x| words[x as usize].to_string()).collect()\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut v = Vec::new();\n    for i in arr {\n        if i > 0 && i < 10 {\n\
    \            v.push(i);\n        }\n    }\n    v.sort();\n    v.reverse();\n \
    \   let mut result = Vec::new();\n    for i in v {\n        match i {\n      \
    \      1 => result.push(\"One\".to_string()),\n            2 => result.push(\"\
    Two\".to_string()),\n            3 => result.push(\"Three\".to_string()),\n  \
    \          4 => result.push(\"Four\".to_string()),\n            5 => result.push(\"\
    Five\".to_string()),\n            6 => result.push(\"Six\".to_string()),\n   \
    \         7 => result.push(\"Seven\".to_string()),\n            8 => result.push(\"\
    Eight\".to_string()),\n            9 => result.push(\"Nine\".to_string()),\n \
    \           _ => panic!(\"\"),\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut new_arr: Vec<String> = Vec::new();\n    for num in arr {\n        match\
    \ num {\n            1 => new_arr.push(\"One\".to_string()),\n            2 =>\
    \ new_arr.push(\"Two\".to_string()),\n            3 => new_arr.push(\"Three\"\
    .to_string()),\n            4 => new_arr.push(\"Four\".to_string()),\n       \
    \     5 => new_arr.push(\"Five\".to_string()),\n            6 => new_arr.push(\"\
    Six\".to_string()),\n            7 => new_arr.push(\"Seven\".to_string()),\n \
    \           8 => new_arr.push(\"Eight\".to_string()),\n            9 => new_arr.push(\"\
    Nine\".to_string()),\n            _ => continue,\n        }\n    }\n    new_arr.sort();\n\
    \    new_arr.reverse();\n    new_arr\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Two\", \"Two\", \"Three\", \"One\", \"One\", \"Four\", \"Five\", \"Eight\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmpcowxk7a_.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut output: Vec<isize> = Vec::new();\n    for num in arr {\n        if\
    \ num > 0 && num < 10 {\n            output.push(num);\n        }\n    }\n   \
    \ output.sort();\n    output.reverse();\n    let v = output.iter().map(|n| numbers_to_strings(*n)).collect();\n\
    \    v\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `numbers_to_strings` in this scope\n\
    \  --> /tmp/tmpoeimrqa2.rs:20:35\n   |\n20 |     let v = output.iter().map(|n|\
    \ numbers_to_strings(*n)).collect();\n   |                                   ^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  unimplemented!();\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpb4pptpwc.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821432
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut numbers = arr.iter().cloned().filter(|&x| (1..=9).contains(&x)).collect::<Vec<isize>>();\n\
    \    numbers.sort();\n    numbers.reverse();\n    numbers.iter().map(|n| num_to_name(*n)).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `num_to_name` in this scope\n  --> /tmp/tmp47a1x3l0.rs:15:28\n\
    \   |\n15 |     numbers.iter().map(|n| num_to_name(*n)).collect()\n   |      \
    \                      ^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut sorted = arr.clone();\n    sorted.sort();\n    sorted.reverse();\n\
    \    sorted.iter().filter(|x| **x > 0 && **x < 10).map(|x| format!(\"{}\", x)).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"8\", \"5\", \"4\", \"3\", \"2\", \"2\", \"1\", \"1\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmph55hijza.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  if arr.len() == 0 {\n        return vec![];\n    }\n    let mut tmp: Vec<isize>\
    \ = arr.clone();\n    tmp.sort();\n    tmp.reverse();\n    let mut res: Vec<String>\
    \ = vec![];\n    for i in tmp {\n        if i >= 1 && i <= 9 {\n            res.push(number_to_string(i));\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `number_to_string` in this scope\n \
    \ --> /tmp/tmpn_ad1caf.rs:21:22\n   |\n21 |             res.push(number_to_string(i));\n\
    \   |                      ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let sorted = arr.iter().filter(|x| (1..10).contains(x)).cloned().collect::<Vec<isize>>();\n\
    \    let sorted = sorted.iter().map(|&x| x.to_string()).collect::<Vec<String>>();\n\
    \    let mut result = sorted.clone();\n    result.reverse();\n    result\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `{integer}` with `&isize`\n  --> /tmp/tmppnkhb_6s.rs:12:48\n\
    \   |\n12 |     let sorted = arr.iter().filter(|x| (1..10).contains(x)).cloned().collect::<Vec<isize>>();\n\
    \   |                                                ^^^^^^^^ no implementation\
    \ for `{integer} < &isize` and `{integer} > &isize`\n   |\n   = help: the trait\
    \ `PartialOrd<&isize>` is not implemented for `{integer}`\n\nerror[E0277]: can't\
    \ compare `&isize` with `{integer}`\n  --> /tmp/tmppnkhb_6s.rs:12:57\n   |\n12\
    \ |     let sorted = arr.iter().filter(|x| (1..10).contains(x)).cloned().collect::<Vec<isize>>();\n\
    \   |                                                         ^ no implementation\
    \ for `&isize < {integer}` and `&isize > {integer}`\n   |\n   = help: the trait\
    \ `PartialOrd<{integer}>` is not implemented for `&isize`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  // TODO\n    let mut v: Vec<String> = vec![];\n    let mut v2: Vec<isize> =\
    \ vec![];\n    for i in 0..arr.len() {\n        if (arr[i] < 10) && (arr[i] >\
    \ 0) {\n            v2.push(arr[i]);\n        }\n    }\n    v2.sort();\n    v2.reverse();\n\
    \    for i in 0..v2.len() {\n        match v2[i] {\n            1 => v.push(\"\
    One\".to_string()),\n            2 => v.push(\"Two\".to_string()),\n         \
    \   3 => v.push(\"Three\".to_string()),\n            4 => v.push(\"Four\".to_string()),\n\
    \            5 => v.push(\"Five\".to_string()),\n            6 => v.push(\"Six\"\
    .to_string()),\n            7 => v.push(\"Seven\".to_string()),\n            8\
    \ => v.push(\"Eight\".to_string()),\n            9 => v.push(\"Nine\".to_string()),\n\
    \            _ => (),\n        }\n    }\n    v\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  if arr.len() == 0 {\n        return Vec::new();\n    }\n\n    let numbers =\
    \ arr.into_iter().filter(|x| x > &0 && x < &10).collect::<Vec<isize>>();\n   \
    \ let mut sorted_numbers = numbers.clone();\n    sorted_numbers.sort();\n    let\
    \ mut result: Vec<String> = sorted_numbers.into_iter().map(|x| number_to_string(x)).collect();\n\
    \    result.reverse();\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `number_to_string` in this scope\n \
    \ --> /tmp/tmp6kg956me.rs:19:70\n   |\n19 |     let mut result: Vec<String> =\
    \ sorted_numbers.into_iter().map(|x| number_to_string(x)).collect();\n   |   \
    \                                                                   ^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  unimplemented!()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmprm15cuvw.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821432
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  arr.iter()\n        .filter(|x| *x >= 1 && *x <= 9)\n        .rev()\n     \
    \   .map(|x| match x {\n            1 => \"One\",\n            2 => \"Two\",\n\
    \            3 => \"Three\",\n            4 => \"Four\",\n            5 => \"\
    Five\",\n            6 => \"Six\",\n            7 => \"Seven\",\n            8\
    \ => \"Eight\",\n            9 => \"Nine\",\n            _ => unreachable!(),\n\
    \        })\n        .map(|x| x.to_string())\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps955c9k8.rs:13:27\n   |\n\
    13 |         .filter(|x| *x >= 1 && *x <= 9)\n   |                           ^\n\
    \   |                           |\n   |                           expected `&isize`,\
    \ found integer\n   |                           help: consider borrowing here:\
    \ `&1`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps955c9k8.rs:13:38\n  \
    \ |\n13 |         .filter(|x| *x >= 1 && *x <= 9)\n   |                      \
    \                ^\n   |                                      |\n   |        \
    \                              expected `&isize`, found integer\n   |        \
    \                              help: consider borrowing here: `&9`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  if arr.len() == 0 {\n        return vec![];\n    }\n    let mut arr: Vec<isize>\
    \ = arr.into_iter().filter(|x| *x > 0 && *x < 10).collect();\n    arr.sort();\n\
    \    arr.reverse();\n    let mut res: Vec<String> = vec![];\n    for i in arr\
    \ {\n        res.push(name_of_number(i));\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `name_of_number` in this scope\n  -->\
    \ /tmp/tmpj5rnmvgs.rs:20:18\n   |\n20 |         res.push(name_of_number(i));\n\
    \   |                  ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  // TODO: write code here.\n    let a : Vec<isize> = arr.into_iter().filter(|&x|\
    \ x > 0 && x < 10).collect();\n    let mut a = a.into_iter().map(|x| x as u32).collect::<Vec<u32>>();\n\
    \    a.sort();\n    a.reverse();\n    a.into_iter().map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"8\", \"5\", \"4\", \"3\", \"2\", \"2\", \"1\", \"1\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmpaelfnjfk.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    let mut digits\
    \ = Vec::new();\n    for i in arr {\n        if i > 0 && i < 10 {\n          \
    \  match i {\n                1 => digits.push(\"One\".to_string()),\n       \
    \         2 => digits.push(\"Two\".to_string()),\n                3 => digits.push(\"\
    Three\".to_string()),\n                4 => digits.push(\"Four\".to_string()),\n\
    \                5 => digits.push(\"Five\".to_string()),\n                6 =>\
    \ digits.push(\"Six\".to_string()),\n                7 => digits.push(\"Seven\"\
    .to_string()),\n                8 => digits.push(\"Eight\".to_string()),\n   \
    \             9 => digits.push(\"Nine\".to_string()),\n                _ => (),\n\
    \            }\n        }\n    }\n    digits\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result = vec![];\n    for number in arr {\n        if number < 1 ||\
    \ number > 9 {\n            continue;\n        }\n        result.push(number);\n\
    \    }\n    result.sort();\n    result.reverse();\n    result.iter().map(|i| format!(\"\
    {}\", convert_number_to_string(*i))).collect()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `convert_number_to_string` in this scope\n\
    \  --> /tmp/tmpehd7fcer.rs:21:41\n   |\n21 |     result.iter().map(|i| format!(\"\
    {}\", convert_number_to_string(*i))).collect()\n   |                         \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  // TODO: Implement me!\n    let mut numbers: Vec<isize> = arr.clone();\n  \
    \  numbers.sort();\n    numbers.dedup();\n    numbers.retain(|&x| x <= 9 && x\
    \ >= 1);\n    numbers.reverse();\n    numbers.iter().map(|&x| format!(\"{}\",\
    \ x)).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"8\", \"5\", \"4\", \"3\", \"2\", \"1\"]`,\n right: `[\"Eight\", \"Five\"\
    , \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmpntxz_6d4.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut nums = arr.clone();\n    nums.sort();\n    let mut strings = Vec::new();\n\
    \    for i in nums {\n        if i < 1 || i > 9 {\n            continue;\n   \
    \     }\n        match i {\n            1 => strings.push(\"One\".to_string()),\n\
    \            2 => strings.push(\"Two\".to_string()),\n            3 => strings.push(\"\
    Three\".to_string()),\n            4 => strings.push(\"Four\".to_string()),\n\
    \            5 => strings.push(\"Five\".to_string()),\n            6 => strings.push(\"\
    Six\".to_string()),\n            7 => strings.push(\"Seven\".to_string()),\n \
    \           8 => strings.push(\"Eight\".to_string()),\n            9 => strings.push(\"\
    Nine\".to_string()),\n            _ => continue,\n        }\n    }\n    strings.reverse();\n\
    \    strings\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut sorted = arr.clone();\n    sorted.sort();\n    let mut result = Vec::new();\n\
    \    for i in sorted {\n        if i >= 1 && i <= 9 {\n            result.push(get_digit_name(i\
    \ as usize));\n        }\n    }\n    result.reverse();\n    result\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_digit_name` in this scope\n  -->\
    \ /tmp/tmpvegm_xph.rs:17:25\n   |\n17 |             result.push(get_digit_name(i\
    \ as usize));\n   |                         ^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result: Vec<String> = Vec::new();\n    let mut digits = arr.clone();\n\
    \    digits.sort();\n    digits.dedup();\n    digits.reverse();\n    for i in\
    \ digits {\n        if i < 1 || i > 9 {\n            continue;\n        }\n  \
    \      result.push(match i {\n            1 => \"One\".to_string(),\n        \
    \    2 => \"Two\".to_string(),\n            3 => \"Three\".to_string(),\n    \
    \        4 => \"Four\".to_string(),\n            5 => \"Five\".to_string(),\n\
    \            6 => \"Six\".to_string(),\n            7 => \"Seven\".to_string(),\n\
    \            8 => \"Eight\".to_string(),\n            9 => \"Nine\".to_string(),\n\
    \            _ => panic!(\"Unable to convert {} to string.\", i),\n        });\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"One\"]`,\n right: `[\"\
    Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`',\
    \ /tmp/tmpl71iu_hs.rs:39:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr = arr;\n    let mut sorted = vec![];\n    if arr.len() > 0 {\n\
    \        arr.sort();\n        let mut count = 1;\n        let mut prev = arr[0];\n\
    \        for i in arr {\n            if i > 0 && i < 10 {\n                sorted.push(i);\n\
    \            }\n        }\n        let mut reversed = vec![];\n        let mut\
    \ ordered = vec![];\n        for i in sorted {\n            reversed.push(i);\n\
    \        }\n        reversed.reverse();\n        for i in reversed {\n       \
    \     match i {\n                1 => ordered.push(\"One\".to_string()),\n   \
    \             2 => ordered.push(\"Two\".to_string()),\n                3 => ordered.push(\"\
    Three\".to_string()),\n                4 => ordered.push(\"Four\".to_string()),\n\
    \                5 => ordered.push(\"Five\".to_string()),\n                6 =>\
    \ ordered.push(\"Six\".to_string()),\n                7 => ordered.push(\"Seven\"\
    .to_string()),\n                8 => ordered.push(\"Eight\".to_string()),\n  \
    \              9 => ordered.push(\"Nine\".to_string()),\n                _ =>\
    \ continue,\n            }\n        }\n        return ordered;\n    }\n    vec![]\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut nums: Vec<isize> = arr.iter().filter(|n| **n > 0 && **n < 10).cloned().collect();\n\
    \    nums.sort();\n    nums.reverse();\n    let mut strs: Vec<String> = nums.iter().map(|&num|\
    \ match num {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => panic!(\"Invalid number {}\", num),\n    }).map(String::from).collect();\n\
    \    strs\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut r: Vec<String> = Vec::new();\n    let mut vector: Vec<isize> = Vec::new();\n\
    \    let mut vector_valid: Vec<isize> = Vec::new();\n    for a in &arr {\n   \
    \     vector.push(*a);\n    }\n    for v in &vector {\n        if *v > 0 && *v\
    \ < 10 {\n            vector_valid.push(*v);\n        }\n    }\n    vector_valid.sort();\n\
    \    vector_valid.reverse();\n    for v in &vector_valid {\n        match *v {\n\
    \            1 => r.push(\"One\".to_string()),\n            2 => r.push(\"Two\"\
    .to_string()),\n            3 => r.push(\"Three\".to_string()),\n            4\
    \ => r.push(\"Four\".to_string()),\n            5 => r.push(\"Five\".to_string()),\n\
    \            6 => r.push(\"Six\".to_string()),\n            7 => r.push(\"Seven\"\
    .to_string()),\n            8 => r.push(\"Eight\".to_string()),\n            9\
    \ => r.push(\"Nine\".to_string()),\n            _ => (),\n        }\n    }\n \
    \   r\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result: Vec<String> = vec![];\n    let mut temp: Vec<isize> = vec![];\n\
    \    for num in arr {\n        if num > 0 && num < 10 {\n            temp.push(num);\n\
    \        }\n    }\n    temp.sort();\n    temp.reverse();\n    for num in temp\
    \ {\n        result.push(num_to_word(num));\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `num_to_word` in this scope\n  --> /tmp/tmpo8j4_mdy.rs:22:21\n\
    \   |\n22 |         result.push(num_to_word(num));\n   |                     ^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut ret = vec![];\n    for i in arr {\n        if i > 0 && i < 10 {\n \
    \           ret.push(i);\n        }\n    }\n    ret.sort();\n    ret.reverse();\n\
    \    ret.iter().map(|e| match e {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"Unknown\",\n    }).map(|e| e.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut sorted = arr;\n    sorted.sort();\n    sorted.reverse();\n    let mut\
    \ result = Vec::new();\n    for i in sorted {\n        match i {\n           \
    \ 1 => result.push(\"One\".to_string()),\n            2 => result.push(\"Two\"\
    .to_string()),\n            3 => result.push(\"Three\".to_string()),\n       \
    \     4 => result.push(\"Four\".to_string()),\n            5 => result.push(\"\
    Five\".to_string()),\n            6 => result.push(\"Six\".to_string()),\n   \
    \         7 => result.push(\"Seven\".to_string()),\n            8 => result.push(\"\
    Eight\".to_string()),\n            9 => result.push(\"Nine\".to_string()),\n \
    \           _ => continue,\n        }\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut v: Vec<isize> = Vec::new();\n    for i in arr {\n        if i > 0 &&\
    \ i < 10 {\n            v.push(i);\n        }\n    }\n    v.sort();\n    v.reverse();\n\
    \    let mut res: Vec<String> = Vec::new();\n    for i in v {\n        match i\
    \ {\n            1 => res.push(\"One\".to_string()),\n            2 => res.push(\"\
    Two\".to_string()),\n            3 => res.push(\"Three\".to_string()),\n     \
    \       4 => res.push(\"Four\".to_string()),\n            5 => res.push(\"Five\"\
    .to_string()),\n            6 => res.push(\"Six\".to_string()),\n            7\
    \ => res.push(\"Seven\".to_string()),\n            8 => res.push(\"Eight\".to_string()),\n\
    \            9 => res.push(\"Nine\".to_string()),\n            _ => (),\n    \
    \    }\n    }\n    res\n}\n\nfn main() {\n    let candidate = by_length;\n   \
    \ assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"\
    ), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![1,\
    \ -1, 55]), vec![String::from(\"One\")]);\n    assert_eq!(candidate(vec![1, -1,\
    \ 3, 2]), vec![String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"Nine\"\
    ), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  unimplemented!()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmprm15cuvw.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut _arr: Vec<isize> = Vec::new();\n    for &i in arr.iter() {\n      \
    \  if i <= 9 && i >= 1 {\n            _arr.push(i);\n        }\n    }\n    _arr.sort();\n\
    \    _arr.reverse();\n    let mut names: Vec<String> = Vec::new();\n    for &i\
    \ in _arr.iter() {\n        match i {\n            1 => names.push(\"One\".to_string()),\n\
    \            2 => names.push(\"Two\".to_string()),\n            3 => names.push(\"\
    Three\".to_string()),\n            4 => names.push(\"Four\".to_string()),\n  \
    \          5 => names.push(\"Five\".to_string()),\n            6 => names.push(\"\
    Six\".to_string()),\n            7 => names.push(\"Seven\".to_string()),\n   \
    \         8 => names.push(\"Eight\".to_string()),\n            9 => names.push(\"\
    Nine\".to_string()),\n            _ => names.push(\"\".to_string()),\n       \
    \ }\n    }\n    names\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut s_arr: Vec<&str> = arr.iter().filter(|&x| x >= &1 && x <= &9).map(|x|\
    \ x.to_string()).collect();\n    s_arr.sort();\n    s_arr.reverse();\n    let\
    \ mut f_arr: Vec<String> = Vec::new();\n    for s in s_arr {\n        match s.as_ref()\
    \ {\n            \"1\" => f_arr.push(\"One\".to_string()),\n            \"2\"\
    \ => f_arr.push(\"Two\".to_string()),\n            \"3\" => f_arr.push(\"Three\"\
    .to_string()),\n            \"4\" => f_arr.push(\"Four\".to_string()),\n     \
    \       \"5\" => f_arr.push(\"Five\".to_string()),\n            \"6\" => f_arr.push(\"\
    Six\".to_string()),\n            \"7\" => f_arr.push(\"Seven\".to_string()),\n\
    \            \"8\" => f_arr.push(\"Eight\".to_string()),\n            \"9\" =>\
    \ f_arr.push(\"Nine\".to_string()),\n            _ => ()\n        }\n    }\n \
    \   f_arr\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<&str>` cannot be built from an iterator\
    \ over elements of type `String`\n  --> /tmp/tmpzzm7_mm9.rs:12:98\n   |\n12 |\
    \     let mut s_arr: Vec<&str> = arr.iter().filter(|&x| x >= &1 && x <= &9).map(|x|\
    \ x.to_string()).collect();\n   |                                            \
    \                                                      ^^^^^^^ value of type `Vec<&str>`\
    \ cannot be built from `std::iter::Iterator<Item=String>`\n   |\n   = help: the\
    \ trait `FromIterator<String>` is not implemented for `Vec<&str>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut new_arr: Vec<isize> = Vec::new();\n    for i in arr {\n        if i\
    \ >= 1 && i <= 9 {\n            new_arr.push(i);\n        }\n    }\n    new_arr.sort();\n\
    \    new_arr.reverse();\n    let mut result: Vec<String> = Vec::new();\n    for\
    \ i in new_arr {\n        match i {\n            1 => result.push(\"One\".to_string()),\n\
    \            2 => result.push(\"Two\".to_string()),\n            3 => result.push(\"\
    Three\".to_string()),\n            4 => result.push(\"Four\".to_string()),\n \
    \           5 => result.push(\"Five\".to_string()),\n            6 => result.push(\"\
    Six\".to_string()),\n            7 => result.push(\"Seven\".to_string()),\n  \
    \          8 => result.push(\"Eight\".to_string()),\n            9 => result.push(\"\
    Nine\".to_string()),\n            _ => (),\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  if arr.len() == 0 {\n        vec![]\n    } else {\n        let mut list = arr.clone();\n\
    \        list.sort();\n        list.reverse();\n        list.iter().filter(|&x|\
    \ *x > 0 && *x < 10).map(|x|\n                match x {\n                    1\
    \ => \"One\",\n                    2 => \"Two\",\n                    3 => \"\
    Three\",\n                    4 => \"Four\",\n                    5 => \"Five\"\
    ,\n                    6 => \"Six\",\n                    7 => \"Seven\",\n  \
    \                  8 => \"Eight\",\n                    9 => \"Nine\",\n     \
    \               _ => \"\",\n                }.to_string()\n            ).collect()\n\
    \    }\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut ret: Vec<String> = vec![];\n    let mut tmp: Vec<isize> = vec![];\n\
    \    let int_to_str = |n: isize| match n {\n        1 => String::from(\"One\"\
    ),\n        2 => String::from(\"Two\"),\n        3 => String::from(\"Three\"),\n\
    \        4 => String::from(\"Four\"),\n        5 => String::from(\"Five\"),\n\
    \        6 => String::from(\"Six\"),\n        7 => String::from(\"Seven\"),\n\
    \        8 => String::from(\"Eight\"),\n        9 => String::from(\"Nine\"),\n\
    \        _ => String::from(\"\"),\n    };\n    for i in arr {\n        if i >=\
    \ 1 && i <= 9 {\n            tmp.push(i);\n        }\n    }\n    tmp.sort();\n\
    \    tmp.reverse();\n    for i in tmp {\n        ret.push(int_to_str(i));\n  \
    \  }\n    ret\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let len = arr.len();\n    let mut arr: Vec<_> = arr.into_iter().filter(|x|\
    \ x > &0 && x < &10).collect();\n    arr.sort();\n    arr.reverse();\n    let\
    \ mut res = Vec::with_capacity(len);\n    for i in arr {\n        res.push(number_to_string(i\
    \ as u8));\n    }\n    res\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `number_to_string` in this scope\n \
    \ --> /tmp/tmpbj2ewe9h.rs:18:18\n   |\n18 |         res.push(number_to_string(i\
    \ as u8));\n   |                  ^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut result = vec![];\n    for i in arr {\n        if i >= 1 && i <= 9 {\n\
    \            result.push(i);\n        }\n    }\n    result.sort();\n    result.reverse();\n\
    \    let mut result2 = vec![];\n    for i in result {\n        match i {\n   \
    \         1 => result2.push(\"One\".to_string()),\n            2 => result2.push(\"\
    Two\".to_string()),\n            3 => result2.push(\"Three\".to_string()),\n \
    \           4 => result2.push(\"Four\".to_string()),\n            5 => result2.push(\"\
    Five\".to_string()),\n            6 => result2.push(\"Six\".to_string()),\n  \
    \          7 => result2.push(\"Seven\".to_string()),\n            8 => result2.push(\"\
    Eight\".to_string()),\n            9 => result2.push(\"Nine\".to_string()),\n\
    \            _ => (),\n        }\n    }\n    result2\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length([2,\
    \ 1, 1, 4, 5, 8, 2, 3])   \n/// [\"Eight\", \"Five\", \"Four\", \"Three\", \"\
    Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return an empty\
    \ array:\n/// If the array has any strange number ignore it:\n/// >>> by_length([1,\
    \ -1 , 55]) \n/// ['One']\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n  \
    \  let mut arr_final: Vec<String> = Vec::new();\n    let mut numbers: Vec<isize>\
    \ = Vec::new();\n    for i in arr {\n        if i > 0 && i < 10 {\n          \
    \  numbers.push(i);\n        }\n    }\n    numbers.sort();\n    numbers.reverse();\n\
    \    for i in numbers {\n        match i {\n            1 => arr_final.push(\"\
    One\".to_string()),\n            2 => arr_final.push(\"Two\".to_string()),\n \
    \           3 => arr_final.push(\"Three\".to_string()),\n            4 => arr_final.push(\"\
    Four\".to_string()),\n            5 => arr_final.push(\"Five\".to_string()),\n\
    \            6 => arr_final.push(\"Six\".to_string()),\n            7 => arr_final.push(\"\
    Seven\".to_string()),\n            8 => arr_final.push(\"Eight\".to_string()),\n\
    \            9 => arr_final.push(\"Nine\".to_string()),\n            _ => {}\n\
    \        }\n    }\n    arr_final\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821436
