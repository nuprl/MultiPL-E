name: HumanEval_127_intersection
language: rs
prompt: "/// You are given two intervals,\n/// where each interval is a pair of integers.\
  \ For example, interval = (start, end) = (1, 2).\n/// The given intervals are closed\
  \ which means that the interval (start, end)\n/// includes both start and end.\n\
  /// For each given interval, it is assumed that its start is less or equal its end.\n\
  /// Your task is to determine whether the length of intersection of these two \n\
  /// intervals is a prime number.\n/// Example, the intersection of the intervals\
  \ (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which not a prime number.\n\
  /// If the length of the intersection is a prime number, return \"YES\",\n/// otherwise,\
  \ return \"NO\".\n/// If the two intervals don't intersect, return \"NO\".\n///\
  \ [input/output] samples:\nfn intersection(interval1: (isize, isize), interval2:\
  \ (isize, isize)) -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
  \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
  \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
  YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
  \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
  \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
  \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
  NO\"));\n}\n"
completions: ["    let (start, end) = match (interval1.0, interval1.1, interval2.0,\
    \ interval2.1) {\n        (a, b, c, d) if a > b => (b, a),\n        (a, b, c,\
    \ d) if c > d => (d, c),\n        (a, b, c, d) if a <= c && c <= b && b <= d =>\
    \ (c, b),\n        (a, b, c, d) if a <= c && c <= d && d <= b => (c, d),\n   \
    \     (a, b, c, d) if c <= a && a <= d && d <= b => (a, d),\n        (a, b, c,\
    \ d) if c <= a && a <= b && b <= d => (a, b),\n        _ => (0, 0),\n    };\n\
    \    let mut primes = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43,\
    \ 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    primes.retain(|p| start <=\
    \ *p && *p <= end);\n    if primes.len() > 0 {\n        \"YES\".to_string()\n\
    \    } else {\n        \"NO\".to_string()\n    }", "    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    let mut start = 0;\n    let mut end = 0;\n \
    \   let mut result = \"NO\";\n    if b >= c && d >= a {\n        start = a > c\
    \ ? a : c;\n        end = b < d ? b : d;\n        let len = end - start + 1;\n\
    \        if len > 1 {\n            let mut is_prime = true;\n            for i\
    \ in 2..len {\n                if len % i == 0 {\n                    is_prime\
    \ = false;\n                    break;\n                }\n            }\n   \
    \         if is_prime {\n                result = \"YES\";\n            }\n  \
    \      }\n    }\n    result.to_string()", "    if interval1.0 > interval2.1 ||\
    \ interval2.0 > interval1.1 {\n        return \"NO\".to_string();\n    }\n   \
    \ let mut arr = [0; 50];\n    let mut i = 0;\n    for j in 2..50 {\n        if\
    \ arr[j] == 0 {\n            arr[i] = j;\n            i += 1;\n            let\
    \ mut k = j * 2;\n            while k < 50 {\n                arr[k] = 1;\n  \
    \              k += j;\n            }\n        }\n    }\n    let mut max: isize\
    \ = 0;\n    let mut min: isize = isize::max_value();\n    let mut interval_length\
    \ = 0;\n    if interval1.0 > interval2.0 {\n        max = interval1.0;\n     \
    \   min = interval2.1;\n    } else {\n        max = interval2.0;\n        min\
    \ = interval1.1;\n    }\n    interval_length = min - max;\n    for a in 0..i {\n\
    \        if arr[a] as isize == interval_length {\n            return \"YES\".to_string();\n\
    \        }\n    }\n    \"NO\".to_string()", "    let mut i1 = interval1;\n   \
    \ let mut i2 = interval2;\n    i1.0 = std::cmp::max(i1.0, i2.0);\n    i1.1 = std::cmp::min(i1.1,\
    \ i2.1);\n    if i1.0 > i1.1 {\n        return \"NO\".to_string();\n    }\n  \
    \  is_prime(i1.1 - i1.0 + 1)", "    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = if start1 > start2 { start1 } else { start2\
    \ };\n    let end = if end1 < end2 { end1 } else { end2 };\n    let diff = if\
    \ start <= end { end - start } else { 0 };\n    if diff == 1 {\n        return\
    \ \"NO\".to_string();\n    }\n    for i in 2..diff {\n        if diff % i == 0\
    \ {\n            return \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()",
  "    let (interval1_min, interval1_max) = interval1;\n    let (interval2_min, interval2_max)\
    \ = interval2;\n    if interval1_min > interval2_max || interval2_min > interval1_max\
    \ {\n        return \"NO\".to_string();\n    }\n    let (interval_min, interval_max)\
    \ = (\n        interval1_min.max(interval2_min),\n        interval1_max.min(interval2_max),\n\
    \    );\n    if is_prime(interval_max - interval_min) {\n        \"YES\".to_string()\n\
    \    } else {\n        \"NO\".to_string()\n    }", "    if interval1.0 > interval2.1\
    \ || interval2.0 > interval1.1 {\n        return \"NO\".to_string();\n    }\n\
    \    let start = std::cmp::max(interval1.0, interval2.0);\n    let end = std::cmp::min(interval1.1,\
    \ interval2.1);\n    if start > end {\n        return \"NO\".to_string();\n  \
    \  }\n    if is_prime(end - start + 1) {\n        return \"YES\".to_string();\n\
    \    }\n    return \"NO\".to_string();", "    let start = max(interval1.0, interval2.0);\n\
    \    let end = min(interval1.1, interval2.1);\n    if start <= end {\n       \
    \ if primes::is_prime(end - start + 1) {\n            return \"YES\".to_string();\n\
    \        }\n    }\n    \"NO\".to_string()", "    let (start1, end1) = interval1;\n\
    \    let (start2, end2) = interval2;\n    if start1 > end2 || start2 > end1 {\n\
    \        return \"NO\".to_string();\n    }\n    let start = start1.max(start2);\n\
    \    let end = end1.min(end2);\n    if is_prime(end - start + 1) {\n        \"\
    YES\".to_string()\n    } else {\n        \"NO\".to_string()\n    }", "    let\
    \ mut start = interval1.0;\n    let mut end = interval1.1;\n    let mut result\
    \ = 0;\n    if interval2.0 > interval1.0 {\n        start = interval2.0;\n   \
    \ }\n    if interval2.1 < interval1.1 {\n        end = interval2.1;\n    }\n \
    \   if start > end {\n        return \"NO\".to_string();\n    }\n    result =\
    \ end - start;\n    if result < 2 {\n        return \"NO\".to_string();\n    }\n\
    \    for i in 2..result-1 {\n        if result % i == 0 {\n            return\
    \ \"NO\".to_string();\n        }\n    }\n    return \"YES\".to_string();", " \
    \   let (start1, end1) = interval1;\n    let (start2, end2) = interval2;\n   \
    \ if end1 < start2 || end2 < start1 {\n        return \"NO\".to_string();\n  \
    \  }\n    let start = if start1 > start2 { start1 } else { start2 };\n    let\
    \ end = if end1 < end2 { end1 } else { end2 };\n    (end - start + 1).is_prime().to_string()",
  "    let mut res = \"NO\";\n    let (mut min1, mut max1) = (interval1.0, interval1.1);\n\
    \    let (mut min2, mut max2) = (interval2.0, interval2.1);\n    if min1 > max1\
    \ {\n        std::mem::swap(&mut min1, &mut max1);\n    }\n    if min2 > max2\
    \ {\n        std::mem::swap(&mut min2, &mut max2);\n    }\n    if min1 < min2\
    \ {\n        std::mem::swap(&mut min1, &mut min2);\n        std::mem::swap(&mut\
    \ max1, &mut max2);\n    }\n    if min1 <= max2 {\n        let mut length = max2\
    \ - min1 + 1;\n        if max1 < max2 {\n            length = max1 - min1 + 1;\n\
    \        }\n        let mut is_prime = true;\n        for i in 2..(length + 1)\
    \ {\n            if length % i == 0 {\n                is_prime = false;\n   \
    \             break;\n            }\n        }\n        if is_prime {\n      \
    \      res = \"YES\";\n        }\n    }\n    res.to_string()", "    let (interval1_start,\
    \ interval1_end) = interval1;\n    let (interval2_start, interval2_end) = interval2;\n\
    \    let intersection_start = interval1_start.max(interval2_start);\n    let intersection_end\
    \ = interval1_end.min(interval2_end);\n    let intersection_len = (intersection_end\
    \ - intersection_start + 1).abs();\n    if intersection_len < 2 {\n        return\
    \ \"NO\".to_string();\n    }\n    for i in 2..intersection_len {\n        if intersection_len\
    \ % i == 0 {\n            return \"NO\".to_string();\n        }\n    }\n    \"\
    YES\".to_string()", "    let (mut i1_start, mut i1_end) = interval1;\n    let\
    \ (mut i2_start, mut i2_end) = interval2;\n    let (mut start, mut end) = (0,\
    \ 0);\n    if i1_start > i1_end {\n        std::mem::swap(&mut i1_start, &mut\
    \ i1_end);\n    }\n    if i2_start > i2_end {\n        std::mem::swap(&mut i2_start,\
    \ &mut i2_end);\n    }\n    if i1_start <= i2_start {\n        start = i2_start;\n\
    \    } else {\n        start = i1_start;\n    }\n    if i1_end >= i2_end {\n \
    \       end = i2_end;\n    } else {\n        end = i1_end;\n    }\n    if start\
    \ > end {\n        return \"NO\".to_string();\n    } else {\n        let mut length\
    \ = end - start + 1;\n        if length == 1 {\n            return \"YES\".to_string();\n\
    \        }\n        let mut prime = false;\n        let mut i = length / 2;\n\
    \        while i > 1 {\n            if length % i == 0 {\n                prime\
    \ = false;\n                break;\n            } else {\n                prime\
    \ = true;\n            }\n            i -= 1;\n        }\n        if prime {\n\
    \            return \"YES\".to_string();\n        } else {\n            return\
    \ \"NO\".to_string();\n        }\n    }", "    let mut vec = vec![];\n    if interval1.0\
    \ <= interval2.0 && interval2.0 <= interval1.1 {\n        vec.push(interval2.0);\n\
    \    }\n    if interval1.0 <= interval2.1 && interval2.1 <= interval1.1 {\n  \
    \      vec.push(interval2.1);\n    }\n    if interval2.0 <= interval1.0 && interval1.0\
    \ <= interval2.1 {\n        vec.push(interval1.0);\n    }\n    if interval2.0\
    \ <= interval1.1 && interval1.1 <= interval2.1 {\n        vec.push(interval1.1);\n\
    \    }\n    if vec.len() == 2 {\n        println!(\"{:?}\", vec);\n        let\
    \ res = vec[1] - vec[0];\n        if res == 1 {\n            return \"NO\".to_string();\n\
    \        }\n        for i in 2..res {\n            if res % i == 0 {\n       \
    \         return \"NO\".to_string();\n            }\n        }\n        return\
    \ \"YES\".to_string();\n    }\n    return \"NO\".to_string();", "    let (intersection,\
    \ result) = if interval1.0 <= interval2.0 {\n        (interval1.0..=interval2.1,\
    \ interval2.0..=interval1.1)\n    } else {\n        (interval2.0..=interval1.1,\
    \ interval1.0..=interval2.1)\n    };\n    let intersects = intersection.start\
    \ <= intersection.end;\n    if intersects {\n        if is_prime(intersection.end\
    \ - intersection.start) {\n            return \"YES\".to_string();\n        }\n\
    \    }\n    if !intersects {\n        return \"NO\".to_string();\n    }\n    if\
    \ is_prime(result.end - result.start) {\n        return \"YES\".to_string();\n\
    \    }\n    \"NO\".to_string()", "    let (min, max) = if interval1.0 > interval2.0\
    \ {\n        (interval1.0, interval2.1)\n    } else {\n        (interval2.0, interval1.1)\n\
    \    };\n    if min > max {\n        return \"NO\".to_string();\n    }\n    if\
    \ is_prime(max - min + 1) {\n        \"YES\".to_string()\n    } else {\n     \
    \   \"NO\".to_string()\n    }", "    // Find bounds of intersection\n    let (min_x,\
    \ max_x) = if interval1.0 <= interval2.0 {\n        (interval2.0, interval1.1)\n\
    \    } else {\n        (interval1.0, interval2.1)\n    };\n    let (max_x, min_x)\
    \ = if max_x <= min_x {\n        (min_x, max_x)\n    } else {\n        (max_x,\
    \ min_x)\n    };\n    // If no intersection, return no\n    if max_x < min_x {\n\
    \        return \"NO\".to_string();\n    }\n    // Get length of intersection\n\
    \    let diff = max_x - min_x;\n    // Find if prime\n    let mut is_prime = true;\n\
    \    if diff > 1 {\n        let mut i = 2;\n        while i * i <= diff {\n  \
    \          if diff % i == 0 {\n                is_prime = false;\n           \
    \     break;\n            }\n            i += 1;\n        }\n    }\n    // Return\n\
    \    if is_prime {\n        \"YES\".to_string()\n    } else {\n        \"NO\"\
    .to_string()\n    }", "    if interval1.0 > interval2.1 || interval2.0 > interval1.1\
    \ {\n        return \"NO\".to_string();\n    }\n    let mut range = Vec::new();\n\
    \    range.push(interval1.0);\n    range.push(interval1.1);\n    range.push(interval2.0);\n\
    \    range.push(interval2.1);\n    range.sort();\n    let start = range[1];\n\
    \    let end = range[2];\n    let mut length = end - start;\n    if length ==\
    \ 1 {\n        return \"NO\".to_string();\n    }\n    if length == 2 {\n     \
    \   return \"YES\".to_string();\n    }\n    while length % 2 == 0 {\n        length\
    \ /= 2;\n    }\n    while length % 3 == 0 {\n        length /= 3;\n    }\n   \
    \ while length % 5 == 0 {\n        length /= 5;\n    }\n    while length % 7 ==\
    \ 0 {\n        length /= 7;\n    }\n    if length == 1 {\n        return \"YES\"\
    .to_string();\n    }\n    return \"NO\".to_string();", "    //! Declare variables\
    \ to hold the intervals start and end values\n    let mut interval1_start = interval1.0;\n\
    \    let mut interval1_end = interval1.1;\n    let mut interval2_start = interval2.0;\n\
    \    let mut interval2_end = interval2.1;\n    //! if interval1_start > interval1_end\
    \ swap them\n    if interval1_start > interval1_end {\n        interval1_start\
    \ = interval1.1;\n        interval1_end = interval1.0;\n    }\n    //! if interval2_start\
    \ > interval2_end swap them\n    if interval2_start > interval2_end {\n      \
    \  interval2_start = interval2.1;\n        interval2_end = interval2.0;\n    }\n\
    \    //! if the two intervals don't intersect return \"NO\"\n    if interval1_end\
    \ < interval2_start || interval2_end < interval1_start {\n        return \"NO\"\
    .to_string();\n    }\n    //! Get the start and end values of the new interval\n\
    \    let start = if interval1_start > interval2_start {\n        interval1_start\n\
    \    } else {\n        interval2_start\n    };\n    let end = if interval1_end\
    \ < interval2_end {\n        interval1_end\n    } else {\n        interval2_end\n\
    \    };\n    //! Check if the length of the new interval is a prime number\n \
    \   if is_prime(end - start) {\n        \"YES\".to_string()\n    } else {\n  \
    \      \"NO\".to_string()\n    }", "    let lower = if interval1.0 > interval2.0\
    \ {\n        interval1.0\n    } else {\n        interval2.0\n    };\n    let upper\
    \ = if interval1.1 < interval2.1 {\n        interval1.1\n    } else {\n      \
    \  interval2.1\n    };\n    if lower <= upper {\n        return if is_prime(upper\
    \ - lower + 1) {\n            \"YES\".to_string()\n        } else {\n        \
    \    \"NO\".to_string()\n        };\n    }\n    \"NO\".to_string()", "    let\
    \ a = max(interval1.0, interval2.0);\n    let b = min(interval1.1, interval2.1);\n\
    \    if a > b {\n        return \"NO\".to_string();\n    }\n\n    let length =\
    \ b - a + 1;\n    if length == 2 {\n        return \"YES\".to_string();\n    }\n\
    \    if length % 2 == 0 {\n        return \"NO\".to_string();\n    }\n    for\
    \ i in 3..length + 1 {\n        if length % i == 0 {\n            return \"NO\"\
    .to_string();\n        }\n    }\n    \"YES\".to_string()", "    let (min, max)\
    \ = (cmp::max(interval1.0, interval2.0), cmp::min(interval1.1, interval2.1));\n\
    \    if min > max {\n        return \"NO\".to_string();\n    }\n    let len =\
    \ (max - min) + 1;\n    if len == 1 {\n        return \"NO\".to_string();\n  \
    \  }\n    let mut is_prime = true;\n    let mut i = 2;\n    while i < len {\n\
    \        if len % i == 0 {\n            is_prime = false;\n            break;\n\
    \        }\n        i += 1;\n    }\n    if is_prime {\n        return \"YES\"\
    .to_string();\n    }\n    \"NO\".to_string()", "    let a = interval1.0;\n   \
    \ let b = interval1.1;\n    let c = interval2.0;\n    let d = interval2.1;\n \
    \   // if (d < a || b < c) {\n    //     return \"NO\";\n    // }\n    if a >=\
    \ d || b <= c {\n        return \"NO\".to_string();\n    }\n    let start = std::cmp::max(a,\
    \ c);\n    let end = std::cmp::min(b, d);\n    let len = end - start + 1;\n  \
    \  if len == 1 {\n        return \"NO\".to_string();\n    }\n    if (2..=(len\
    \ as f64).sqrt() as isize).any(|i| len % i == 0) {\n        return \"NO\".to_string();\n\
    \    }\n    \"YES\".to_string()", "    match (interval1, interval2) {\n      \
    \  ((x, y), (a, b)) if x >= a && x <= b && y >= a && y <= b =>\n            if\
    \ (x - a + 1).is_prime() { \"YES\".to_string() } else { \"NO\".to_string() },\n\
    \        ((x, y), (a, b)) if x <= a && y >= a && y <= b =>\n            if (y\
    \ - a + 1).is_prime() { \"YES\".to_string() } else { \"NO\".to_string() },\n \
    \       ((x, y), (a, b)) if x >= a && x <= b && y >= b =>\n            if (b -\
    \ x + 1).is_prime() { \"YES\".to_string() } else { \"NO\".to_string() },\n   \
    \     ((x, y), (a, b)) if x <= a && y >= b =>\n            if (b - a + 1).is_prime()\
    \ { \"YES\".to_string() } else { \"NO\".to_string() },\n        _ => \"NO\".to_string()\n\
    \    }", "    let start = interval1.0.max(interval2.0);\n    let end = interval1.1.min(interval2.1);\n\
    \    if start >= end {\n        return \"NO\".to_string();\n    }\n    if primes::is_prime(end\
    \ - start) {\n        return \"YES\".to_string();\n    }\n    \"NO\".to_string()",
  "    let start = if interval1.0 > interval2.0 {\n        interval1.0\n    } else\
    \ {\n        interval2.0\n    };\n    let end = if interval1.1 < interval2.1 {\n\
    \        interval1.1\n    } else {\n        interval2.1\n    };\n    let length\
    \ = end - start;\n    if length < 0 {\n        \"NO\".to_string()\n    } else\
    \ {\n        if prime(length) {\n            \"YES\".to_string()\n        } else\
    \ {\n            \"NO\".to_string()\n        }\n    }", "  let (x1, x2) = interval1;\n\
    \  let (y1, y2) = interval2;\n  if x2 < y1 || y2 < x1 {\n    return \"NO\".to_string();\n\
    \  }\n  let (x_start, x_end) = if x1 <= y1 { (y1, y2) } else { (x1, x2) };\n \
    \ let x_len = x_end - x_start;\n  if x_len < 2 {\n    return \"NO\".to_string();\n\
    \  }\n  let mut i = 2;\n  while i * i <= x_len {\n    if x_len % i == 0 {\n  \
    \    return \"NO\".to_string();\n    }\n    i += 1;\n  }\n  \"YES\".to_string()",
  "    let (a, b) = interval1;\n    let (c, d) = interval2;\n    if b < c || d < a\
    \ { return \"NO\".to_string(); }\n    let interval = (cmp::max(a, c), cmp::min(b,\
    \ d));\n    is_prime(interval.1 - interval.0 + 1)", "    if interval1.0 > interval2.1\
    \ || interval2.0 > interval1.1 {\n        return \"NO\".to_string();\n    }\n\
    \    let mut min = interval1.0;\n    let mut max = interval1.1;\n    if interval2.0\
    \ > min {\n        min = interval2.0;\n    }\n    if interval2.1 < max {\n   \
    \     max = interval2.1;\n    }\n    let value = (max - min) + 1;\n    if value\
    \ <= 2 {\n        return \"NO\".to_string();\n    }\n    for i in 2..value {\n\
    \        if value % i == 0 {\n            return \"NO\".to_string();\n       \
    \ }\n    }\n    \"YES\".to_string()", "    if interval1.0 > interval2.1 || interval2.0\
    \ > interval1.1 {\n        return \"NO\".to_string();\n    }\n    let start =\
    \ interval1.0.max(interval2.0);\n    let end = interval1.1.min(interval2.1);\n\
    \    if end - start <= 1 {\n        return \"NO\".to_string();\n    }\n    for\
    \ i in 2..end {\n        if end % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()", "    let (start, end) = get_overlap(interval1,\
    \ interval2);\n    if is_prime(end - start + 1) {\n        return \"YES\".to_string();\n\
    \    }\n    \"NO\".to_string()", "  let int_len = |(mut a, mut b): (isize, isize)|\
    \ {\n    if a > b {\n      let t = a;\n      a = b;\n      b = t;\n    }\n   \
    \ let a = if a <= 0 { 1 } else { a };\n    (a..b+1).count() as isize\n  };\n \
    \ let is_prime = |x: isize| {\n    let r = (x as f64).sqrt() as isize;\n    let\
    \ mut is_prime = true;\n    for i in 2..r+1 {\n      if x % i == 0 {\n       \
    \ is_prime = false;\n        break;\n      }\n    }\n    is_prime\n  };\n  let\
    \ (mut a, mut b) = interval1;\n  let (mut c, mut d) = interval2;\n  if b < c ||\
    \ d < a {\n    return \"NO\".to_string();\n  }\n  if a > c {\n    let t = a;\n\
    \    a = c;\n    c = t;\n  }\n  if b > d {\n    let t = b;\n    b = d;\n    d\
    \ = t;\n  }\n  let interval = (a, b);\n  let interval2 = (c, d);\n  if interval\
    \ == interval2 {\n    if is_prime(int_len(interval)) {\n      return \"YES\".to_string();\n\
    \    }\n    return \"NO\".to_string();\n  }\n  let inter = (c, b);\n  if is_prime(int_len(inter))\
    \ {\n    return \"YES\".to_string();\n  }\n  return \"NO\".to_string();", "  \
    \  let (start1, end1) = interval1;\n    let (start2, end2) = interval2;\n    if\
    \ start1 >= end2 || start2 >= end1 {\n        return \"NO\".to_string();\n   \
    \ }\n    let start = if start1 > start2 { start1 } else { start2 };\n    let end\
    \ = if end1 < end2 { end1 } else { end2 };\n    let is_prime = |val: isize| ->\
    \ bool {\n        let mut i = 2;\n        while i < val {\n            if val\
    \ % i == 0 {\n                return false;\n            }\n            i += 1;\n\
    \        }\n        true\n    };\n    if is_prime(end - start) {\n        \"YES\"\
    .to_string()\n    } else {\n        \"NO\".to_string()\n    }", "    let (mut\
    \ start, mut end) = if interval1.0 < interval2.0 {\n        (interval2.0, interval1.1)\n\
    \    } else {\n        (interval1.0, interval2.1)\n    };\n    if start > end\
    \ {\n        end = start;\n    }\n    while start <= end {\n        if is_prime(start)\
    \ {\n            return \"YES\".to_string();\n        }\n        start += 1;\n\
    \    }\n    \"NO\".to_string()", "    let (i1s, i1e) = interval1;\n    let (i2s,\
    \ i2e) = interval2;\n    if i1e < i2s || i2e < i1s {\n        return \"NO\".to_string();\n\
    \    }\n    let mut range: Vec<isize> = vec![];\n    for i in i1s..=i1e {\n  \
    \      if i >= i2s && i <= i2e {\n            range.push(i);\n        }\n    }\n\
    \    for i in i2s..=i2e {\n        if i >= i1s && i <= i1e {\n            range.push(i);\n\
    \        }\n    }\n    if range.is_empty() {\n        return \"NO\".to_string();\n\
    \    }\n    let max = range.iter().max().unwrap();\n    let min = range.iter().min().unwrap();\n\
    \    let range_size = (max - min) + 1;\n    if is_prime(range_size) {\n      \
    \  return \"YES\".to_string();\n    }\n    \"NO\".to_string()", "    let (a, b)\
    \ = interval1;\n    let (c, d) = interval2;\n    let mut res = (cmp::max(a, c),\
    \ cmp::min(b, d));\n    if res.0 >= res.1 {\n        return \"NO\".to_string();\n\
    \    }\n    res.1 -= res.0;\n    if res.1 < 2 {\n        return \"NO\".to_string();\n\
    \    }\n    if res.1 == 2 {\n        return \"YES\".to_string();\n    }\n    let\
    \ mut i = 2;\n    while i * i <= res.1 {\n        if res.1 % i == 0 {\n      \
    \      return \"NO\".to_string();\n        }\n        i += 1;\n    }\n    \"YES\"\
    .to_string()", "    // Determine the first and last of the two intervals\n   \
    \ let first = interval1.0.min(interval2.0);\n    let last = interval1.1.max(interval2.1);\n\
    \    // Build a list of factors between the first and last\n    let mut factors\
    \ = Vec::new();\n    for i in first..=last {\n        if i % first == 0 && i %\
    \ last == 0 {\n            factors.push(i);\n        }\n    }\n    // Determine\
    \ if the length of the intersection is a prime number\n    if factors.len() ==\
    \ 2 {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n\
    \    }", "    if interval1.0 > interval2.1 || interval2.0 > interval1.1 {\n  \
    \      return \"NO\".to_string();\n    }\n    let start = std::cmp::max(interval1.0,\
    \ interval2.0);\n    let end = std::cmp::min(interval1.1, interval2.1);\n    if\
    \ is_prime(end - start + 1) {\n        \"YES\".to_string()\n    } else {\n   \
    \     \"NO\".to_string()\n    }", "    let low = interval1.0.max(interval2.0);\n\
    \    let high = interval1.1.min(interval2.1);\n    if low > high {\n        return\
    \ \"NO\".to_string();\n    }\n    let length = high - low + 1;\n    let half =\
    \ (length as f64).sqrt() as isize;\n    for d in 2..half {\n        if length\
    \ % d == 0 {\n            return \"NO\".to_string();\n        }\n    }\n    return\
    \ \"YES\".to_string();", "    let start = std::cmp::max(interval1.0, interval2.0);\n\
    \    let end = std::cmp::min(interval1.1, interval2.1);\n    if start >= end {\n\
    \        return \"NO\".to_string();\n    }\n    if is_prime(end - start) {\n \
    \       return \"YES\".to_string();\n    }\n    return \"NO\".to_string();", " \
    \   let (mut min, mut max) = (interval1.0, interval1.1);\n    let (mut min2, mut\
    \ max2) = (interval2.0, interval2.1);\n    // swap the order if needed\n    if\
    \ max < min {\n        let temp = min;\n        min = max;\n        max = temp;\n\
    \    }\n    if max2 < min2 {\n        let temp = min2;\n        min2 = max2;\n\
    \        max2 = temp;\n    }\n    // no intersection\n    if min > max2 || min2\
    \ > max {\n        return \"NO\".to_string();\n    }\n    // intersection\n  \
    \  if min > min2 {\n        min = min2;\n    }\n    if max < max2 {\n        max\
    \ = max2;\n    }\n    let diff = max - min;\n    let is_prime = primes::is_prime(diff\
    \ as usize);\n    if is_prime {\n        \"YES\".to_string()\n    } else {\n \
    \       \"NO\".to_string()\n    }", "  let (start1, end1) = interval1;\n  let\
    \ (start2, end2) = interval2;\n  let intersection = (\n    start1.max(start2),\n\
    \    end1.min(end2)\n  );\n  if intersection.0 >= intersection.1 {\n    return\
    \ \"NO\".to_string();\n  }\n  let mut sieve = vec![true; (intersection.1 - intersection.0)\
    \ as usize];\n  let mut i = 0;\n  while i < sieve.len() {\n    if sieve[i] {\n\
    \      let mut j = i;\n      while j < sieve.len() {\n        sieve[j] = false;\n\
    \        j += i + 1;\n      }\n    }\n    i += 1;\n  }\n  let result = if sieve[0]\
    \ { \"YES\" } else { \"NO\" };\n  result.to_string()", "    let mut start = if\
    \ interval1.0 > interval2.0 {\n        interval1.0\n    } else {\n        interval2.0\n\
    \    };\n    let mut end = if interval1.1 < interval2.1 {\n        interval1.1\n\
    \    } else {\n        interval2.1\n    };\n    if end < start {\n        return\
    \ \"NO\".to_string();\n    }\n    let mut count = 0;\n    while start <= end {\n\
    \        count += 1;\n        start += 1;\n    }\n    let mut is_prime = true;\n\
    \    for i in 2..count {\n        if count % i == 0 {\n            is_prime =\
    \ false;\n            break;\n        }\n    }\n    if is_prime {\n        \"\
    YES\".to_string()\n    } else {\n        \"NO\".to_string()\n    }", "    let\
    \ start = interval1.0.max(interval2.0);\n    let end = interval1.1.min(interval2.1);\n\
    \    if start > end {\n        \"NO\".to_string()\n    } else {\n        if is_prime(end\
    \ - start + 1) {\n            \"YES\".to_string()\n        } else {\n        \
    \    \"NO\".to_string()\n        }\n    }", "    let (x1, x2) = interval1;\n \
    \   let (y1, y2) = interval2;\n    let start = if x1 > y1 { x1 } else { y1 };\n\
    \    let end = if x2 < y2 { x2 } else { y2 };\n    if start > end { return \"\
    NO\".to_string(); }\n    let length = end - start + 1;\n    if length == 1 { return\
    \ \"NO\".to_string(); }\n    let primes = vec![2, 3, 5, 7, 11, 13, 17, 19, 23,\
    \ 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    if primes.iter().find(|&&x|\
    \ x == length) != None { return \"YES\".to_string(); }\n    return \"NO\".to_string();",
  "    let start = std::cmp::max(interval1.0, interval2.0);\n    let end = std::cmp::min(interval1.1,\
    \ interval2.1);\n    if start > end {\n        return \"NO\".to_string();\n  \
    \  }\n    if start == end {\n        return is_prime(start) ? \"YES\".to_string()\
    \ : \"NO\".to_string();\n    }\n    if is_prime(end - start + 1) {\n        return\
    \ \"YES\".to_string();\n    }\n    return \"NO\".to_string();", "    // your code\
    \ here\n    let mut result = \"NO\";\n    let (x1, y1) = interval1;\n    let (x2,\
    \ y2) = interval2;\n    if y1 >= x2 && y2 >= x1 {\n        let (a, b) = if x1\
    \ >= x2 { (x1, y2) } else { (x2, y1) };\n        if b - a == 1 {\n           \
    \ result = \"YES\";\n        }\n    }\n    result.to_string()", "    let (a, b)\
    \ = interval1;\n    let (c, d) = interval2;\n    if a > b || c > d {\n       \
    \ return \"NO\".to_string();\n    }\n    if b < c || d < a {\n        return \"\
    NO\".to_string();\n    }\n    if b < d {\n        let len = b - c + 1;\n     \
    \   if len > 1 && is_prime(len) {\n            return \"YES\".to_string();\n \
    \       }\n    } else {\n        let len = d - a + 1;\n        if len > 1 && is_prime(len)\
    \ {\n            return \"YES\".to_string();\n        }\n    }\n    \"NO\".to_string()",
  "    if interval1.0 > interval2.1 || interval2.0 > interval1.1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let (s, e) = (interval1.0.max(interval2.0),\
    \ interval1.1.min(interval2.1));\n    if (2..e).any(|x| s % x == 0 && e % x ==\
    \ 0) {\n        return \"NO\".to_string();\n    }\n    \"YES\".to_string()", " \
    \ let mut result = (0, 0);\n  if interval1.0 <= interval2.0 && interval2.0 <=\
    \ interval1.1 {\n    result.0 = interval2.0;\n  } else if interval2.0 <= interval1.0\
    \ && interval1.0 <= interval2.1 {\n    result.0 = interval1.0;\n  } else {\n \
    \   return \"NO\".to_string();\n  }\n  if interval1.0 <= interval2.1 && interval2.1\
    \ <= interval1.1 {\n    result.1 = interval2.1;\n  } else if interval2.0 <= interval1.1\
    \ && interval1.1 <= interval2.1 {\n    result.1 = interval1.1;\n  } else {\n \
    \   return \"NO\".to_string();\n  }\n  let range = result.1 - result.0;\n  if\
    \ range < 2 {\n    return \"NO\".to_string();\n  }\n  let mut is_prime = true;\n\
    \  let range_sqrt = (range as f64).sqrt().ceil() as isize;\n  for i in 2..range_sqrt\
    \ {\n    if range % i == 0 {\n      is_prime = false;\n      break;\n    }\n \
    \ }\n  if is_prime {\n    \"YES\".to_string()\n  } else {\n    \"NO\".to_string()\n\
    \  }", "    let (mut start, mut end) = (interval1.0, interval1.1);\n    if start\
    \ > end {\n        start = interval1.1;\n        end = interval1.0;\n    }\n \
    \   let (start2, end2) = (interval2.0, interval2.1);\n    let (mut start3, mut\
    \ end3) = (0, 0);\n    if start < start2 {\n        start3 = start2;\n    } else\
    \ {\n        start3 = start;\n    }\n    if end > end2 {\n        end3 = end2;\n\
    \    } else {\n        end3 = end;\n    }\n    let count = end3 - start3;\n  \
    \  if count > 1 {\n        if count == 2 {\n            return \"YES\".to_string();\n\
    \        }\n        for i in 2..count {\n            if count % i == 0 {\n   \
    \             return \"NO\".to_string();\n            }\n        }\n        return\
    \ \"YES\".to_string();\n    }\n    \"NO\".to_string()", "    let mut intervals\
    \ = vec![interval1, interval2];\n    intervals.sort_by(|a, b| a.0.cmp(&b.0));\n\
    \    let (start, end) = (intervals[0].1, intervals[1].0);\n    if start < end\
    \ {\n        if is_prime(end - start) {\n            return \"YES\".to_string();\n\
    \        }\n    }\n    \"NO\".to_string()", "    let i1s = interval1.0;\n    let\
    \ i1e = interval1.1;\n    let i2s = interval2.0;\n    let i2e = interval2.1;\n\
    \    let is = if i1s > i2s { i1s } else { i2s };\n    let ie = if i1e < i2e {\
    \ i1e } else { i2e };\n    if is > ie {\n        \"NO\".to_string()\n    } else\
    \ {\n        let len = ie - is + 1;\n        if len > 2 && (2..((len as f64).sqrt()\
    \ as isize + 1)).any(|i| len % i == 0) {\n            \"NO\".to_string()\n   \
    \     } else {\n            \"YES\".to_string()\n        }\n    }", "    // Since\
    \ the intervals are inclusive, the length of the intersection is\n    // the length\
    \ of either interval minus the distance between the intervals.\n    // There might\
    \ be a problem with negative numbers?\n    let (start, end) = intersection_range(interval1,\
    \ interval2);\n    let length = end - start + 1;\n    // println!(\"Intersection\
    \ range: ({}, {})\", start, end);\n    // println!(\"Intersection length: {}\"\
    , length);\n    if length < 0 {\n        \"NO\".to_string()\n    } else {\n  \
    \      if is_prime(length) {\n            \"YES\".to_string()\n        } else\
    \ {\n            \"NO\".to_string()\n        }\n    }", "    // get the intersection\
    \ and check if it is a prime number\n    if interval1.0 <= interval2.1 && interval2.0\
    \ <= interval1.1 {\n        return if (interval2.0 - interval1.0).abs() % 2 ==\
    \ 0 {\n            \"NO\".to_string()\n        } else {\n            \"YES\".to_string()\n\
    \        };\n    }\n    \"NO\".to_string()", "    let (mut x, mut y) = (interval1.0,\
    \ interval1.1);\n    let (mut z, mut w) = (interval2.0, interval2.1);\n    if\
    \ x > y {\n        ::std::mem::swap(&mut x, &mut y);\n    }\n    if z > w {\n\
    \        ::std::mem::swap(&mut z, &mut w);\n    }\n    if y < z || w < x {\n \
    \       return \"NO\".to_string();\n    }\n    if z <= x && w >= y {\n       \
    \ return \"YES\".to_string();\n    }\n    if x <= z && y >= w {\n        return\
    \ \"YES\".to_string();\n    }\n    if z <= x && w <= y {\n        let n = w -\
    \ x;\n        if n == 1 {\n            return \"NO\".to_string();\n        }\n\
    \        if n <= 3 {\n            return \"YES\".to_string();\n        }\n   \
    \     if n % 2 == 0 || n % 3 == 0 {\n            return \"NO\".to_string();\n\
    \        }\n        let mut i = 5;\n        while i * i <= n {\n            if\
    \ n % i == 0 || n % (i + 2) == 0 {\n                return \"NO\".to_string();\n\
    \            }\n            i += 6;\n        }\n        return \"YES\".to_string();\n\
    \    }\n    if x <= z && y <= w {\n        let n = y - z;\n        if n == 1 {\n\
    \            return \"NO\".to_string();\n        }\n        if n <= 3 {\n    \
    \        return \"YES\".to_string();\n        }\n        if n % 2 == 0 || n %\
    \ 3 == 0 {\n            return \"NO\".to_string();\n        }\n        let mut\
    \ i = 5;\n        while i * i <= n {\n            if n % i == 0 || n % (i + 2)\
    \ == 0 {\n                return \"NO\".to_string();\n            }\n        \
    \    i += 6;\n        }\n        return \"YES\".to_string();\n    }\n    unreachable!()",
  "    let mut primes = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47,\
    \ 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137,\
    \ 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227,\
    \ 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313,\
    \ 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419,\
    \ 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509,\
    \ 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617,\
    \ 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727,\
    \ 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829,\
    \ 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947,\
    \ 953, 967, 971, 977, 983, 991, 997];\n    primes.reverse();\n    let mut max\
    \ = isize::min_value();\n    let mut min = isize::max_value();\n    if (interval1.0\
    \ < interval2.0 && interval1.1 > interval2.0) || (interval2.0 < interval1.0 &&\
    \ interval2.1 > interval1.0) {\n        if interval1", "    if interval1.0 >=\
    \ interval2.1 || interval2.0 >= interval1.1 {\n        return \"NO\".to_string();\n\
    \    }\n    let mut lower = interval1.0;\n    let mut upper = interval1.1;\n \
    \   if interval2.0 > lower {\n        lower = interval2.0;\n    }\n    if interval2.1\
    \ < upper {\n        upper = interval2.1;\n    }\n    if is_prime(upper - lower)\
    \ {\n        return \"YES\".to_string();\n    }\n    return \"NO\".to_string();",
  "    let mut result = 0;\n    let (x1, y1) = interval1;\n    let (x2, y2) = interval2;\n\
    \    if x1 > y2 || x2 > y1 {\n        return \"NO\".to_string();\n    }\n    if\
    \ x1 <= x2 && y1 >= x2 {\n        result = y1 - x2 + 1;\n    } else if x2 <= x1\
    \ && y2 >= x1 {\n        result = y2 - x1 + 1;\n    } else if x1 <= x2 && y2 >=\
    \ y1 {\n        result = y1 - x2 + 1;\n    } else if x2 <= x1 && y1 >= y2 {\n\
    \        result = y2 - x1 + 1;\n    } else {\n        return \"NO\".to_string();\n\
    \    }\n    if result % 2 == 0 || result % 3 == 0 || result % 5 == 0 || result\
    \ % 7 == 0 || result % 11 == 0 || result % 13 == 0 || result % 17 == 0 || result\
    \ % 19 == 0 || result % 23 == 0 || result % 29 == 0 || result % 31 == 0 || result\
    \ % 37 == 0 || result % 41 == 0 || result % 43 == 0 || result % 47 == 0 || result\
    \ % 53 == 0 || result % 59 == 0 || result % 61 == 0 || result % 67 == 0 || result\
    \ % 71 == 0 || result % 73 == 0 || result % 79 == 0 || result % 83 == 0 || result\
    \ % 89 == 0 || result % 97 == 0 {\n        return \"NO\".to_string();\n    }\n\
    \    return \"YES\".to_string();", "    let (start1, end1) = interval1;\n    let\
    \ (start2, end2) = interval2;\n    if start1 > end2 || start2 > end1 {\n     \
    \   return \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1, start2);\n\
    \    let end = std::cmp::min(end1, end2);\n    let length = end - start + 1;\n\
    \    if length <= 1 {\n        return \"NO\".to_string();\n    }\n    if (2..length-1).all(|n|\
    \ length % n != 0) {\n        return \"YES\".to_string();\n    }\n    \"NO\".to_string()",
  "    let interval1 = interval1.0.max(interval2.0)..=interval1.1.min(interval2.1);\n\
    \    if interval1.start() > interval1.end() {\n        return \"NO\".to_string();\n\
    \    }\n    interval1.end() - interval1.start() + 1 == 2 || interval1.end() -\
    \ interval1.start() + 1 == 3", "    let (s1, e1) = interval1;\n    let (s2, e2)\
    \ = interval2;\n    let (s, e) = (s1.max(s2), e1.min(e2));\n    if s <= e {\n\
    \        if (2..(e - s + 1)).all(|x| (e - s + 1) % x != 0) {\n            \"YES\"\
    .to_string()\n        } else {\n            \"NO\".to_string()\n        }\n  \
    \  } else {\n        \"NO\".to_string()\n    }", "    if interval1.0 > interval2.1\
    \ || interval2.0 > interval1.1 {\n        return \"NO\".to_string();\n    }\n\
    \    let start = interval1.0.max(interval2.0);\n    let end = interval1.1.min(interval2.1);\n\
    \    let n = end - start + 1;\n    match n {\n        2 | 3 | 5 | 7 => \"YES\"\
    .to_string(),\n        _ => \"NO\".to_string(),\n    }", "    let (max_left, min_right)\
    \ = if interval1.0 > interval2.0 {\n        (interval1.0, interval2.1)\n    }\
    \ else {\n        (interval2.0, interval1.1)\n    };\n    if max_left > min_right\
    \ {\n        \"NO\".to_string()\n    } else {\n        let interval_size = min_right\
    \ - max_left + 1;\n        if interval_size == 2 {\n            \"YES\".to_string()\n\
    \        } else {\n            for i in 2..(interval_size as f64).sqrt() as isize\
    \ + 1 {\n                if interval_size % i == 0 {\n                    return\
    \ \"NO\".to_string();\n                }\n            }\n            \"YES\".to_string()\n\
    \        }\n    }", "  if interval1.0 < interval2.0 {\n    return match (interval2.0,\
    \ interval1.1) {\n      (start, end) if start <= end => if primes::is_prime(end\
    \ - start + 1) {\n        \"YES\".to_string()\n      } else {\n        \"NO\"\
    .to_string()\n      },\n      _ => \"NO\".to_string(),\n    };\n  } else {\n \
    \   return match (interval1.0, interval2.1) {\n      (start, end) if start <=\
    \ end => if primes::is_prime(end - start + 1) {\n        \"YES\".to_string()\n\
    \      } else {\n        \"NO\".to_string()\n      },\n      _ => \"NO\".to_string(),\n\
    \    };\n  }", "    let mut i1 = interval1;\n    let mut i2 = interval2;\n   \
    \ if i1.0 > i1.1 {\n        std::mem::swap(&mut i1.0, &mut i1.1);\n    }\n   \
    \ if i2.0 > i2.1 {\n        std::mem::swap(&mut i2.0, &mut i2.1);\n    }\n   \
    \ let mut isect = (0, 0);\n    if i1.0 > i2.1 || i2.0 > i1.1 {\n        return\
    \ \"NO\".to_string();\n    }\n    if i1.0 < i2.0 {\n        isect.0 = i2.0;\n\
    \    } else {\n        isect.0 = i1.0;\n    }\n    if i1.1 < i2.1 {\n        isect.1\
    \ = i1.1;\n    } else {\n        isect.1 = i2.1;\n    }\n    if isect.0 == isect.1\
    \ {\n        return \"YES\".to_string();\n    }\n    for i in 2..isect.1 {\n \
    \       if i as isize * i as isize > isect.1 {\n            return \"YES\".to_string();\n\
    \        }\n        if isect.0 % i == 0 || isect.1 % i == 0 {\n            return\
    \ \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()", "    let (i1_start,\
    \ i1_end) = interval1;\n    let (i2_start, i2_end) = interval2;\n    let mut start\
    \ = i1_start;\n    let mut end = i1_end;\n    if i2_start > start {\n        start\
    \ = i2_start;\n    }\n    if i2_end < end {\n        end = i2_end;\n    }\n  \
    \  if start > end {\n        return \"NO\".to_string();\n    }\n    let mut is_prime\
    \ = true;\n    for i in 2..end {\n        if start % i == 0 {\n            is_prime\
    \ = false;\n            break;\n        }\n    }\n    if is_prime {\n        \"\
    YES\".to_string()\n    } else {\n        \"NO\".to_string()\n    }", "    let\
    \ (x, y) = (interval1.0, interval1.1);\n    let (a, b) = (interval2.0, interval2.1);\n\
    \    let (mut l, mut r) = (0, 0);\n    if x <= a && a <= y {\n        l = a;\n\
    \    } else if a <= x && x <= b {\n        l = x;\n    } else {\n        return\
    \ \"NO\".to_string();\n    }\n    if x <= b && b <= y {\n        r = b;\n    }\
    \ else if a <= y && y <= b {\n        r = y;\n    } else {\n        return \"\
    NO\".to_string();\n    }\n    let mut i = 2;\n    while i < (r - l + 1) {\n  \
    \      if (r - l + 1) % i == 0 {\n            return \"NO\".to_string();\n   \
    \     }\n        i += 1;\n    }\n    \"YES\".to_string()", "    let mut start\
    \ = interval1.0;\n    let mut end = interval1.1;\n    let mut tmp;\n    if interval1.0\
    \ > interval1.1 {\n        tmp = interval1.0;\n        start = interval1.1;\n\
    \        end = tmp;\n    }\n    if interval2.0 > interval2.1 {\n        tmp =\
    \ interval2.0;\n        interval2.0 = interval2.1;\n        interval2.1 = tmp;\n\
    \    }\n    if interval2.0 < start {\n        start = interval2.0;\n    }\n  \
    \  if interval2.1 > end {\n        end = interval2.1;\n    }\n    if start >=\
    \ end {\n        return \"NO\".to_string();\n    }\n    let mut i = start;\n \
    \   let mut sum = 0;\n    while i <= end {\n        sum += i;\n        i += 1;\n\
    \    }\n    if sum == 5 || sum == 7 || sum == 13 || sum == 17 || sum == 23 ||\
    \ sum == 29 || sum == 31 {\n        return \"YES\".to_string();\n    }\n    \"\
    NO\".to_string()", "    if interval1.0 > interval2.1 || interval2.0 > interval1.1\
    \ {\n        return \"NO\".to_string();\n    }\n    let a = interval1.0.max(interval2.0);\n\
    \    let b = interval1.1.min(interval2.1);\n    let n = b - a + 1;\n    if is_prime(n)\
    \ {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n \
    \   }", "  let len = if interval1.0 <= interval2.0 {\n    if interval1.1 <= interval2.0\
    \ {\n      0\n    } else if interval1.1 <= interval2.1 {\n      interval1.1 -\
    \ interval2.0\n    } else {\n      interval2.1 - interval2.0\n    }\n  } else\
    \ {\n    if interval2.1 <= interval1.0 {\n      0\n    } else if interval2.1 <=\
    \ interval1.1 {\n      interval2.1 - interval1.0\n    } else {\n      interval1.1\
    \ - interval1.0\n    }\n  };\n  if len == 0 {\n    return \"NO\".to_string();\n\
    \  }\n  let mut count = 0;\n  for i in 2..len {\n    if len % i == 0 {\n     \
    \ count += 1;\n    }\n  }\n  if count >= 1 {\n    \"NO\".to_string()\n  } else\
    \ {\n    \"YES\".to_string()\n  }", "    if interval1.0 > interval2.1 || interval2.0\
    \ > interval1.1 {\n        return \"NO\".to_string();\n    }\n    let start =\
    \ interval1.0.max(interval2.0);\n    let end = interval1.1.min(interval2.1);\n\
    \    if start == end || (start - end).abs() == 1 {\n        return \"NO\".to_string();\n\
    \    }\n    if is_prime(end - start) {\n        return \"YES\".to_string();\n\
    \    }\n    \"NO\".to_string()", "    match intersection_imp(interval1, interval2)\
    \ {\n        None => \"NO\".to_string(),\n        Some(n) => if util::is_prime(n)\
    \ { \"YES\".to_string() } else { \"NO\".to_string() }\n    }", "    let (start1,\
    \ end1) = interval1;\n    let (start2, end2) = interval2;\n    let mut s = None;\n\
    \    let mut e = None;\n    if start1 >= start2 && start1 <= end2 {\n        s\
    \ = Some(start1);\n    } else if start2 >= start1 && start2 <= end1 {\n      \
    \  s = Some(start2);\n    }\n    if end1 >= start2 && end1 <= end2 {\n       \
    \ e = Some(end1);\n    } else if end2 >= start1 && end2 <= end1 {\n        e =\
    \ Some(end2);\n    }\n    match (s, e) {\n        (Some(s), Some(e)) => {\n  \
    \          let d = e - s;\n            let mut c = 0;\n            for i in 2..d\
    \ {\n                if d % i == 0 {\n                    c += 1;\n          \
    \      }\n            }\n            if c == 0 {\n                \"YES\".to_string()\n\
    \            } else {\n                \"NO\".to_string()\n            }\n   \
    \     }\n        _ => \"NO\".to_string(),\n    }", "    let vec = [interval1,\
    \ interval2];\n    let mut first = (0, 0);\n    let mut last = (0, 0);\n    for\
    \ &(start, end) in vec.iter() {\n        if start > last.1 {\n            first\
    \ = (start, end);\n            last = (start, end);\n        } else if start <\
    \ last.1 && end > last.1 {\n            last = (last.0, end);\n        }\n   \
    \ }\n    let mut length = 0;\n    for i in first.0..=last.1 {\n        if (first.0..=last.1).any(|x|\
    \ x == i) && (interval1.0..=interval1.1).any(|x| x == i) && (interval2.0..=interval2.1).any(|x|\
    \ x == i) {\n            length += 1;\n        }\n    }\n    if length == 0 {\n\
    \        return \"NO\".to_string();\n    }\n    if length == 1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let mut counter = 0;\n    for i in 2..length\
    \ {\n        if length % i == 0 {\n            counter += 1;\n        }\n    }\n\
    \    if counter == 0 {\n        return \"YES\".to_string();\n    }\n    return\
    \ \"NO\".to_string();", "    let start = max(interval1.0, interval2.0);\n    let\
    \ end = min(interval1.1, interval2.1);\n    if start > end {\n        return \"\
    NO\".to_string();\n    }\n\n    let len = end - start + 1;\n    if len == 2 {\n\
    \        return \"YES\".to_string();\n    }\n\n    for i in 2..len {\n       \
    \ if len % i == 0 {\n            return \"NO\".to_string();\n        }\n    }\n\
    \n    \"YES\".to_string()", "    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    if start1 > end2 || start2 > end1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let start = start1.max(start2);\n    let end\
    \ = end1.min(end2);\n    if is_prime(end - start + 1) {\n        \"YES\".to_string()\n\
    \    } else {\n        \"NO\".to_string()\n    }", "    if interval1.0 > interval2.1\
    \ || interval2.0 > interval1.1 {\n        return \"NO\".to_string();\n    }\n\
    \    let start = if interval1.0 > interval2.0 { interval1.0 } else { interval2.0\
    \ };\n    let end = if interval1.1 < interval2.1 { interval1.1 } else { interval2.1\
    \ };\n    let length = end - start + 1;\n    if length == 1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let limit = (length as f64).sqrt() as isize;\n\
    \    if length % 2 == 0 {\n        return \"NO\".to_string();\n    }\n    for\
    \ i in 3..limit {\n        if length % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()", "  let len_a = if interval1.0 < interval2.0\
    \ {\n    interval2.0 - interval1.0\n  } else {\n    interval1.0 - interval2.0\n\
    \  };\n  let len_b = if interval1.1 < interval2.1 {\n    interval2.1 - interval1.1\n\
    \  } else {\n    interval1.1 - interval2.1\n  };\n  let len = if len_a < len_b\
    \ {\n    len_a\n  } else {\n    len_b\n  };\n  if len == 0 {\n    return \"NO\"\
    .to_string();\n  }\n  if (2..=len).all(|i| len % i != 0) {\n    return \"YES\"\
    .to_string();\n  }\n  \"NO\".to_string()", "    let a = interval1.0.max(interval2.0);\n\
    \    let b = interval1.1.min(interval2.1);\n    if a <= b {\n        is_prime((b\
    \ - a + 1) as usize)\n    } else {\n        \"NO\".to_string()\n    }", "    let\
    \ start = if interval1.0 > interval2.0 {\n        interval1.0\n    } else {\n\
    \        interval2.0\n    };\n    let end = if interval1.1 < interval2.1 {\n \
    \       interval1.1\n    } else {\n        interval2.1\n    };\n    let num_of_elements\
    \ = end - start + 1;\n    if num_of_elements > 0 {\n        if num_of_elements\
    \ == 1 || num_of_elements == 2 {\n            return \"YES\".to_string();\n  \
    \      }\n        if num_of_elements % 2 == 0 {\n            return \"NO\".to_string();\n\
    \        }\n        let mut divisor = 3;\n        while divisor <= (num_of_elements\
    \ as f64).sqrt() as isize {\n            if num_of_elements % divisor == 0 {\n\
    \                return \"NO\".to_string();\n            }\n            divisor\
    \ += 2;\n        }\n        return \"YES\".to_string();\n    }\n    \"NO\".to_string()",
  "    let (i1_s, i1_e) = interval1;\n    let (i2_s, i2_e) = interval2;\n    if i1_e\
    \ < i2_s || i2_e < i1_s {\n        \"NO\".to_string()\n    } else {\n        let\
    \ start = if i1_s > i2_s { i1_s } else { i2_s };\n        let end = if i1_e <\
    \ i2_e { i1_e } else { i2_e };\n        let intersection_length = (end - start)\
    \ + 1;\n        if is_prime(intersection_length) {\n            \"YES\".to_string()\n\
    \        } else {\n            \"NO\".to_string()\n        }\n    }", "    let\
    \ start = max(interval1.0, interval2.0);\n    let end = min(interval1.1, interval2.1);\n\
    \    if start > end {\n        return \"NO\".to_string();\n    }\n    let interval\
    \ = (start, end);\n    let len = interval.1 - interval.0 + 1;\n    if is_prime(len)\
    \ {\n        return \"YES\".to_string();\n    }\n    return \"NO\".to_string();",
  "  if interval1.0 > interval2.1 || interval2.0 > interval1.1 {\n    return \"NO\"\
    .to_string();\n  }\n  let low = std::cmp::max(interval1.0, interval2.0);\n  let\
    \ high = std::cmp::min(interval1.1, interval2.1);\n  let l = (high - low) + 1;\n\
    \  if l <= 1 {\n    return \"NO\".to_string();\n  }\n  for n in 2..l {\n    if\
    \ l % n == 0 {\n      return \"NO\".to_string();\n    }\n  }\n  \"YES\".to_string()",
  "    let (start1, end1) = interval1;\n    let (start2, end2) = interval2;\n    if\
    \ start1 > end2 || start2 > end1 {\n        return \"NO\".to_string();\n    }\n\
    \    let start = isize::max(start1, start2);\n    let end = isize::min(end1, end2);\n\
    \    let length = (end - start) + 1;\n    if (2..length).any(|x| length % x ==\
    \ 0) {\n        return \"NO\".to_string();\n    }\n    \"YES\".to_string()", " \
    \   if interval1.0 > interval2.1 || interval2.0 > interval1.1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let max = isize::max(interval1.0, interval2.0);\n\
    \    let min = isize::min(interval1.1, interval2.1);\n    if min - max < 2 {\n\
    \        return \"NO\".to_string();\n    }\n    for i in 2..min - max {\n    \
    \    if (min - max) % i == 0 {\n            return \"NO\".to_string();\n     \
    \   }\n    }\n    \"YES\".to_string()", "    let (i1, i2) = if interval1.0 < interval2.0\
    \ { (interval1, interval2) } else { (interval2, interval1) };\n    if i1.1 < i2.0\
    \ {\n        \"NO\".to_string()\n    } else {\n        let mut primes = vec![];\n\
    \        let len = if i1.1 < i2.1 { i1.1 - i2.0 + 1 } else { i2.1 - i2.0 + 1 };\n\
    \        for i in 2..len {\n            if is_prime(i) {\n                primes.push(i);\n\
    \            }\n        }\n        if primes.len() == 0 {\n            \"NO\"\
    .to_string()\n        } else {\n            \"YES\".to_string()\n        }\n \
    \   }", "    let (x1, y1) = interval1;\n    let (x2, y2) = interval2;\n    //println!(\"\
    {} {} {} {}\", x1, y1, x2, y2);\n    if y1 < x2 || y2 < x1 {\n        return \"\
    NO\".to_string();\n    }\n    let a = x1.max(x2);\n    let b = y1.min(y2);\n \
    \   let c = b - a + 1;\n    if is_prime(c) {\n        return \"YES\".to_string();\n\
    \    }\n    \"NO\".to_string()", "    if interval1.0 > interval2.1 || interval2.0\
    \ > interval1.1 {\n        return \"NO\".to_string();\n    }\n    let min = interval1.0.max(interval2.0);\n\
    \    let max = interval1.1.min(interval2.1);\n    if min > max {\n        return\
    \ \"NO\".to_string();\n    }\n    let length = max - min + 1;\n    if length ==\
    \ 1 {\n        return \"NO\".to_string();\n    }\n    if length == 2 {\n     \
    \   return \"YES\".to_string();\n    }\n    if length % 2 == 0 {\n        return\
    \ \"NO\".to_string();\n    }\n    for i in 3..(length / 2 + 1) {\n        if length\
    \ % i == 0 {\n            return \"NO\".to_string();\n        }\n    }\n    \"\
    YES\".to_string()", "    let x1 = interval1.0;\n    let x2 = interval1.1;\n  \
    \  let y1 = interval2.0;\n    let y2 = interval2.1;\n    let max_left = std::cmp::max(x1,\
    \ y1);\n    let min_right = std::cmp::min(x2, y2);\n    if max_left > min_right\
    \ {\n        \"NO\".to_string()\n    } else {\n        let len = min_right - max_left\
    \ + 1;\n        if len == 2 {\n            \"YES\".to_string()\n        } else\
    \ {\n            let mut found = false;\n            for i in 2..len {\n     \
    \           if len % i == 0 {\n                    found = true;\n           \
    \         break;\n                }\n            }\n            if found {\n \
    \               \"NO\".to_string()\n            } else {\n                \"YES\"\
    .to_string()\n            }\n        }\n    }", "    let mut result = \"NO\";\n\
    \    let mut min = interval1.0;\n    let mut max = interval1.1;\n    if interval2.0\
    \ > min {\n        min = interval2.0;\n    }\n    if interval2.1 < max {\n   \
    \     max = interval2.1;\n    }\n    if max >= min {\n        let length = max\
    \ - min + 1;\n        let is_prime = (2..length-1).all(|x| length % x != 0);\n\
    \        if is_prime {\n            result = \"YES\";\n        }\n    }\n    result.to_string()",
  "    let start = max(interval1.0, interval2.0);\n    let end = min(interval1.1,\
    \ interval2.1);\n    if start > end {\n        return \"NO\".to_string();\n  \
    \  }\n    let length = end - start + 1;\n    if length == 1 {\n        return\
    \ \"NO\".to_string();\n    }\n    if length == 2 {\n        return \"YES\".to_string();\n\
    \    }\n    let mut is_prime = true;\n    for i in 2..length {\n        if length\
    \ % i == 0 {\n            is_prime = false;\n            break;\n        }\n \
    \   }\n    if is_prime {\n        \"YES\".to_string()\n    } else {\n        \"\
    NO\".to_string()\n    }", "    let interval_max_start = interval1.0.max(interval2.0);\n\
    \    let interval_min_end = interval1.1.min(interval2.1);\n    let interval_range\
    \ = interval_min_end - interval_max_start;\n    if interval_range <= 0 {\n   \
    \     return \"NO\".to_string();\n    }\n    if is_prime(interval_range) {\n \
    \       return \"YES\".to_string();\n    }\n    return \"NO\".to_string();", " \
    \   if interval1.0 <= interval2.1 && interval2.0 <= interval1.1 {\n        let\
    \ start = interval1.0.max(interval2.0);\n        let end = interval1.1.min(interval2.1);\n\
    \        (end - start + 1).is_prime().to_string()\n    } else {\n        \"NO\"\
    .to_string()\n    }", "    let (interval1_start, interval1_end) = interval1;\n\
    \    let (interval2_start, interval2_end) = interval2;\n    if interval1_end <\
    \ interval2_start || interval2_end < interval1_start {\n        return \"NO\"\
    .to_string();\n    }\n    let intersection_start = if interval1_start > interval2_start\
    \ {\n        interval1_start\n    } else {\n        interval2_start\n    };\n\
    \    let intersection_end = if interval1_end < interval2_end {\n        interval1_end\n\
    \    } else {\n        interval2_end\n    };\n    if is_prime(intersection_end\
    \ - intersection_start + 1) {\n        \"YES\".to_string()\n    } else {\n   \
    \     \"NO\".to_string()\n    }", "    let (a, b) = interval1;\n    let (c, d)\
    \ = interval2;\n    let start = std::cmp::max(a, c);\n    let end = std::cmp::min(b,\
    \ d);\n    if start > end {\n        return \"NO\".to_string();\n    }\n    let\
    \ diff = end - start + 1;\n    if is_prime(diff) {\n        return \"YES\".to_string();\n\
    \    }\n    \"NO\".to_string()", "    let start = std::cmp::max(interval1.0, interval2.0);\n\
    \    let end = std::cmp::min(interval1.1, interval2.1);\n    if start > end {\n\
    \        return \"NO\".to_string();\n    }\n    let len = end - start + 1;\n \
    \   let prime = (2..).take_while(|x| x * x <= len).all(|x| len % x != 0);\n  \
    \  if prime {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n\
    \    }", "    if interval1.0 > interval2.1 || interval2.0 > interval1.1 {\n  \
    \      return \"NO\".to_string();\n    }\n    let (a, b) = if interval1.0 > interval2.0\
    \ {\n        (interval1.0, interval2.1)\n    } else {\n        (interval2.0, interval1.1)\n\
    \    };\n    let len = b - a + 1;\n    if len <= 1 {\n        return \"NO\".to_string();\n\
    \    }\n    for i in 2..len {\n        if len % i == 0 {\n            return \"\
    NO\".to_string();\n        }\n    }\n    \"YES\".to_string()", "    let mut int_list\
    \ = vec![];\n    if interval1.0 <= interval2.0 && interval2.0 <= interval1.1 &&\
    \ interval1.1 <= interval2.1 {\n        int_list.push(interval2.0);\n        int_list.push(interval1.1);\n\
    \    } else if interval2.0 <= interval1.0 && interval1.0 <= interval2.1 && interval2.1\
    \ <= interval1.1 {\n        int_list.push(interval1.0);\n        int_list.push(interval2.1);\n\
    \    } else if interval1.0 <= interval2.0 && interval2.1 <= interval1.1 {\n  \
    \      int_list.push(interval2.0);\n        int_list.push(interval2.1);\n    }\
    \ else if interval2.0 <= interval1.0 && interval1.1 <= interval2.1 {\n       \
    \ int_list.push(interval1.0);\n        int_list.push(interval1.1);\n    } else\
    \ {\n        return \"NO\".to_string();\n    }\n    if int_list.len() == 0 {\n\
    \        return \"NO\".to_string();\n    } else {\n        if int_list[1] - int_list[0]\
    \ == 1 {\n            return \"YES\".to_string();\n        } else {\n        \
    \    return \"NO\".to_string();\n        }\n    }", "    let (start1, end1) =\
    \ interval1;\n    let (start2, end2) = interval2;\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    if start >= end {\n\
    \        return \"NO\".to_string();\n    }\n    let number = (end - start) + 1;\n\
    \    if number < 2 {\n        return \"NO\".to_string();\n    }\n    if number\
    \ == 2 {\n        return \"YES\".to_string();\n    }\n    let half = (number as\
    \ f64 / 2.0).floor() as isize;\n    for x in 2..half + 1 {\n        if number\
    \ % x == 0 {\n            return \"NO\".to_string();\n        }\n    }\n    \"\
    YES\".to_string()", "    let mut s = 0;\n    let mut e = 0;\n    if interval1.0\
    \ <= interval2.0 {\n        s = interval2.0;\n    } else {\n        s = interval1.0;\n\
    \    }\n    if interval1.1 <= interval2.1 {\n        e = interval1.1;\n    } else\
    \ {\n        e = interval2.1;\n    }\n    if s >= e {\n        return \"NO\".to_string();\n\
    \    }\n    let n = e - s + 1;\n    let mut i = 2;\n    while i * i <= n {\n \
    \       if n % i == 0 {\n            return \"NO\".to_string();\n        }\n \
    \       i += 1;\n    }\n    \"YES\".to_string()", "    if interval1.0 > interval2.1\
    \ || interval2.0 > interval1.1 {\n        \"NO\".to_string()\n    } else {\n \
    \       let mut inter = if interval1.0 > interval2.0 {\n            (interval1.0,\
    \ interval2.1)\n        } else {\n            (interval2.0, interval1.1)\n   \
    \     };\n        if inter.0 > inter.1 {\n            inter = (inter.1, inter.0);\n\
    \        }\n        if inter.1 - inter.0 == 1 {\n            \"NO\".to_string()\n\
    \        } else {\n            if is_prime(inter.1 - inter.0) {\n            \
    \    \"YES\".to_string()\n            } else {\n                \"NO\".to_string()\n\
    \            }\n        }\n    }", "    match (interval1, interval2) {\n     \
    \   ((a, b), (c, d)) if (a > d) || (b < c) => \"NO\".to_string(),\n        ((a,\
    \ b), (c, d)) => match (a..b).intersection(c..d).count() {\n            0 => \"\
    NO\".to_string(),\n            2 => \"YES\".to_string(),\n            _ => \"\
    NO\".to_string(),\n        }\n    }", "    let interval_int = (max(interval1.0,\
    \ interval2.0), min(interval1.1, interval2.1));\n    let len = interval_int.1\
    \ - interval_int.0;\n    let len = if len < 0 {0} else {len};\n    let len = len\
    \ + 1;\n    if is_prime(len) {\n        \"YES\".to_string()\n    } else {\n  \
    \      \"NO\".to_string()\n    }", "    let mut start = cmp::max(interval1.0,\
    \ interval2.0);\n    let mut end = cmp::min(interval1.1, interval2.1);\n    if\
    \ start > end {\n        return \"NO\".to_string();\n    }\n    if is_prime(end\
    \ - start + 1) {\n        return \"YES\".to_string();\n    }\n    return \"NO\"\
    .to_string();", "    let (i1a, i1b) = interval1;\n    let (i2a, i2b) = interval2;\n\
    \    if i1a > i2b || i2a > i1b {\n        return \"NO\".to_string();\n    }\n\
    \    let sorted = if i1a < i2a {\n        (i1a, i2b)\n    } else {\n        (i2a,\
    \ i1b)\n    };\n    let (sorted_start, sorted_end) = sorted;\n    let interval_length\
    \ = sorted_end - sorted_start;\n    if interval_length == 1 {\n        return\
    \ \"NO\".to_string();\n    }\n    if interval_length == 2 {\n        return \"\
    YES\".to_string();\n    }\n    let mut is_prime = true;\n    for i in 2..interval_length\
    \ - 1 {\n        if interval_length % i == 0 {\n            is_prime = false;\n\
    \            break;\n        }\n    }\n    if is_prime {\n        \"YES\".to_string()\n\
    \    } else {\n        \"NO\".to_string()\n    }", "    let (start1, end1) = interval1;\n\
    \    let (start2, end2) = interval2;\n    if start1 >= end2 || start2 >= end1\
    \ {\n        return \"NO\".to_string();\n    }\n    let (start, end) = (std::cmp::max(start1,\
    \ start2), std::cmp::min(end1, end2));\n    if is_prime(end - start) {\n     \
    \   \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n    }", " \
    \   // first check for overlap\n    let interval1_start = interval1.0;\n    let\
    \ interval1_end = interval1.1;\n    let interval2_start = interval2.0;\n    let\
    \ interval2_end = interval2.1;\n    let mut length = 0;\n    if interval1_start\
    \ > interval2_start {\n        if interval1_start > interval2_end {\n        \
    \    // no overlap\n            return \"NO\".to_string();\n        } else {\n\
    \            // overlap\n            if interval1_end < interval2_end {\n    \
    \            length = interval1_end - interval1_start;\n            } else {\n\
    \                length = interval2_end - interval1_start;\n            }\n  \
    \      }\n    } else {\n        if interval2_start > interval1_end {\n       \
    \     // no overlap\n            return \"NO\".to_string();\n        } else {\n\
    \            // overlap\n            if interval2_end < interval1_end {\n    \
    \            length = interval2_end - interval2_start;\n            } else {\n\
    \                length = interval1_end - interval2_start;\n            }\n  \
    \      }\n    }\n    // if no overlap, return \"NO\"\n    // if overlap, check\
    \ that length is prime\n    if length == 1 {\n        return \"YES\".to_string();\n\
    \    }\n    if length <= 0 {\n        return \"NO\".to_string();\n    }\n    for\
    \ i in 2..length {\n        if length % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    return \"YES\".to_string();", "    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    let start = if a > c { a } else { c };\n   \
    \ let end = if b < d { b } else { d };\n    let distance = if start > end {\n\
    \        0\n    } else {\n        end - start\n    };\n    println!(\"start {}\
    \ end {}\", start, end);\n    println!(\"distance {}\", distance);\n    if distance\
    \ < 0 {\n        \"NO\".to_string()\n    } else if distance == 0 {\n        \"\
    NO\".to_string()\n    } else if distance == 1 {\n        \"NO\".to_string()\n\
    \    } else if distance == 2 {\n        \"YES\".to_string()\n    } else if distance\
    \ == 3 {\n        \"YES\".to_string()\n    } else if distance == 5 {\n       \
    \ \"YES\".to_string()\n    } else if distance == 7 {\n        \"YES\".to_string()\n\
    \    } else if distance == 11 {\n        \"YES\".to_string()\n    } else if distance\
    \ == 13 {\n        \"YES\".to_string()\n    } else if distance == 17 {\n     \
    \   \"YES\".to_string()\n    } else if distance == 19 {\n        \"YES\".to_string()\n\
    \    } else if distance == 23 {\n        \"YES\".to_string()\n    } else if distance\
    \ == 29 {\n        \"YES\".to_string()\n    } else if distance == 31 {\n     \
    \   \"YES\".to_string()\n    } else if distance == 37 {\n        \"YES\".to_string()\n\
    \    } else if distance == 41 {\n        \"YES\".to_string()\n    } else if distance\
    \ == 43 {\n        \"YES\".to_string()\n    } else if distance == 47 {\n     \
    \   \"YES\".to_string()\n    } else if distance == 53 {\n        \"YES\".to_string()\n\
    \    } else if distance == 59 {\n        \"YES\".to_string()\n    } else if distance\
    \ == 61 {\n        \"YES\".to_string()\n    } else if distance == 67 {\n     \
    \   \"YES\".to_string()\n    } else if distance == 71 {\n        \"", "    let\
    \ start = interval1.0.max(interval2.0);\n    let end = interval1.1.min(interval2.1);\n\
    \    if start <= end {\n        (end - start + 1).is_prime().to_string()\n   \
    \ } else {\n        \"NO\".to_string()\n    }", "    let (interval1_start, interval1_end)\
    \ = interval1;\n    let (interval2_start, interval2_end) = interval2;\n    if\
    \ interval1_end < interval2_start || interval2_end < interval1_start {\n     \
    \   return \"NO\".to_string();\n    }\n    let max_start = std::cmp::max(interval1_start,\
    \ interval2_start);\n    let min_end = std::cmp::min(interval1_end, interval2_end);\n\
    \    let intersection_length = min_end - max_start + 1;\n    return if is_prime(intersection_length)\
    \ {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n \
    \   };", "    if interval1.0 > interval2.1 || interval2.0 > interval1.1 {\n  \
    \      return \"NO\".to_string();\n    }\n    let mut xs = vec![interval1.0, interval1.1,\
    \ interval2.0, interval2.1];\n    xs.sort();\n    let x = xs[1] - xs[0];\n   \
    \ if x < 2 {\n        return \"NO\".to_string();\n    }\n    if x == 2 {\n   \
    \     return \"YES\".to_string();\n    }\n    if x == 3 {\n        return \"YES\"\
    .to_string();\n    }\n    for i in 2..x {\n        if x % i == 0 {\n         \
    \   return \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()", " \
    \   let (start1, end1) = interval1;\n    let (start2, end2) = interval2;\n   \
    \ let mut start = start1;\n    let mut end = end1;\n    if start2 > start1 {\n\
    \        start = start2;\n    }\n    if end2 < end1 {\n        end = end2;\n \
    \   }\n    if start > end {\n        return \"NO\".to_string();\n    }\n    let\
    \ length = end - start + 1;\n    if length <= 2 {\n        return \"NO\".to_string();\n\
    \    }\n    let mut flag = true;\n    for i in 2..(length / 2 + 1) {\n       \
    \ if length % i == 0 {\n            flag = false;\n            break;\n      \
    \  }\n    }\n    if flag {\n        return \"YES\".to_string();\n    }\n    \"\
    NO\".to_string()", "    let mut prime = false;\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    let mut length = 0;\n    if a >= c && a <= d\
    \ || b >= c && b <= d || c >= a && c <= b || d >= a && d <= b {\n        if a\
    \ >= c && a <= d {\n            if b <= d {\n                length = b - a;\n\
    \            } else {\n                length = d - a;\n            }\n      \
    \  } else if b >= c && b <= d {\n            if a <= c {\n                length\
    \ = b - c;\n            } else {\n                length = b - a;\n          \
    \  }\n        } else if c >= a && c <= b {\n            if d <= b {\n        \
    \        length = d - c;\n            } else {\n                length = b - c;\n\
    \            }\n        } else if d >= a && d <= b {\n            if c <= a {\n\
    \                length = d - a;\n            } else {\n                length\
    \ = d - c;\n            }\n        }\n        prime = is_prime(length);\n    }\
    \ else {\n        return \"NO\".to_string();\n    }\n    if prime {\n        return\
    \ \"YES\".to_string();\n    } else {\n        return \"NO\".to_string();\n   \
    \ }", "    let (left1, right1) = interval1;\n    let (left2, right2) = interval2;\n\
    \    if left1 >= right2 || left2 >= right1 {\n        return \"NO\".to_string();\n\
    \    }\n    let is_prime = (0..left1.max(left2) - right1.min(right2)).any(|x|\
    \ x.is_prime());\n    if is_prime {\n        \"YES\".to_string()\n    } else {\n\
    \        \"NO\".to_string()\n    }", "    // Your code here\n    let mut start\
    \ = interval1.0;\n    let mut end = interval1.1;\n    if interval2.0 > start {\n\
    \        start = interval2.0;\n    }\n    if interval2.1 < end {\n        end\
    \ = interval2.1;\n    }\n    if start > end {\n        return \"NO\".to_string();\n\
    \    }\n    if is_prime(end - start + 1) {\n        return \"YES\".to_string();\n\
    \    }\n    \"NO\".to_string()", "    let i1_start = interval1.0;\n    let i1_end\
    \ = interval1.1;\n    let i2_start = interval2.0;\n    let i2_end = interval2.1;\n\
    \    let mut left = i1_start;\n    let mut right = i1_end;\n    if i2_start >\
    \ i1_start {\n        left = i2_start;\n    }\n    if i2_end < i1_end {\n    \
    \    right = i2_end;\n    }\n    let diff = right - left;\n    if diff < 0 {\n\
    \        return \"NO\".to_string();\n    }\n    let mut not_prime = false;\n \
    \   for i in 2..diff {\n        if diff % i == 0 {\n            not_prime = true;\n\
    \            break;\n        }\n    }\n    if not_prime {\n        return \"NO\"\
    .to_string();\n    }\n    return \"YES\".to_string();", "    // TODO: implement\
    \ this function\n    unimplemented!()", "    let (a, b) = interval1;\n    let\
    \ (c, d) = interval2;\n    // Interval (a, b) doesn't intersect with (c, d)\n\
    \    if a > d || b < c {\n        return \"NO\".to_string();\n    }\n    // Interval\
    \ (a, b) contains (c, d)\n    if a <= c && b >= d {\n        return is_prime(d\
    \ - c) ? \"YES\" : \"NO\";\n    }\n    // Interval (c, d) contains (a, b)\n  \
    \  if c <= a && d >= b {\n        return is_prime(b - a) ? \"YES\" : \"NO\";\n\
    \    }\n    // (a, b) is completely above (c, d)\n    if a > c && b > d {\n  \
    \      return is_prime(b - c) ? \"YES\" : \"NO\";\n    }\n    // (a, b) is completely\
    \ below (c, d)\n    if a < c && b < d {\n        return is_prime(d - a) ? \"YES\"\
    \ : \"NO\";\n    }\n    // (a, b) intersects partially with (c, d)\n    let left\
    \ = if a > c { a } else { c };\n    let right = if b < d { b } else { d };\n \
    \   return is_prime(right - left) ? \"YES\" : \"NO\";", "    let (x1, y1) = interval1;\n\
    \    let (x2, y2) = interval2;\n    if y1 < x2 || y2 < x1 {\n        return \"\
    NO\".to_string();\n    }\n    let x = std::cmp::max(x1, x2);\n    let y = std::cmp::min(y1,\
    \ y2);\n    if x >= y {\n        return \"NO\".to_string();\n    }\n    let mut\
    \ ans = \"YES\".to_string();\n    if x != 1 {\n        for i in 2..x {\n     \
    \       if x % i == 0 {\n                ans = \"NO\".to_string();\n         \
    \       break;\n            }\n        }\n    }\n    ans", "    let (i1_start,\
    \ i1_end) = interval1;\n    let (i2_start, i2_end) = interval2;\n    if i1_end\
    \ < i2_start || i2_end < i1_start {\n        return \"NO\".to_string();\n    }\n\
    \    let left = if i1_start < i2_start { i2_start } else { i1_start };\n    let\
    \ right = if i1_end < i2_end { i1_end } else { i2_end };\n    let length = (right\
    \ - left) + 1;\n    if length == 1 {\n        return \"NO\".to_string();\n   \
    \ }\n    if length == 2 {\n        return \"YES\".to_string();\n    }\n    let\
    \ mut flag = true;\n    for i in 2..length/2 {\n        if length % i == 0 {\n\
    \            flag = false;\n            break;\n        }\n    }\n    if flag\
    \ {\n        return \"YES\".to_string();\n    }\n    \"NO\".to_string()", "  \
    \  let (x1, y1) = interval1;\n    let (x2, y2) = interval2;\n    if (x1 <= x2\
    \ && x2 <= y1) || (x2 <= x1 && x1 <= y2) {\n        let max_x = isize::max(x1,\
    \ x2);\n        let min_y = isize::min(y1, y2);\n        if min_y - max_x == 1\
    \ {\n            return \"NO\".to_string();\n        }\n        let sieve = prime_sieve(min_y\
    \ - max_x);\n        if sieve[(min_y - max_x) as usize] {\n            return\
    \ \"YES\".to_string();\n        }\n    }\n    \"NO\".to_string()", "    let start\
    \ = interval1.0.max(interval2.0);\n    let end = interval1.1.min(interval2.1);\n\
    \    if start > end {\n        return \"NO\".to_string();\n    }\n    if is_prime(end\
    \ - start + 1) {\n        return \"YES\".to_string();\n    }\n    \"NO\".to_string()",
  "    let start = std::cmp::max(interval1.0, interval2.0);\n    let end = std::cmp::min(interval1.1,\
    \ interval2.1);\n    if start <= end {\n        let mut flag = true;\n       \
    \ let end_tmp = if end == 1 { 2 } else { end };\n        for i in 2..end_tmp {\n\
    \            if end % i == 0 {\n                flag = false;\n              \
    \  break;\n            }\n        }\n        if flag {\n            \"YES\".to_string()\n\
    \        } else {\n            \"NO\".to_string()\n        }\n    } else {\n \
    \       \"NO\".to_string()\n    }", "    let (a, b) = interval1;\n    let (c,\
    \ d) = interval2;\n    let (mut start, mut end) = (0, 0);\n    if a <= c && c\
    \ <= b {\n        start = c;\n    } else if c <= a && a <= d {\n        start\
    \ = a;\n    }\n    if a <= d && d <= b {\n        end = d;\n    } else if c <=\
    \ b && b <= d {\n        end = b;\n    }\n    if start == 0 || end == 0 {\n  \
    \      return \"NO\".to_string();\n    }\n    if is_prime(end - start) {\n   \
    \     return \"YES\".to_string();\n    }\n    \"NO\".to_string()", "    let mut\
    \ min_intersection = interval1.0.max(interval2.0);\n    let mut max_intersection\
    \ = interval1.1.min(interval2.1);\n    if max_intersection < min_intersection\
    \ {\n        return \"NO\".to_string();\n    }\n    let length = max_intersection\
    \ - min_intersection + 1;\n    if length == 1 {\n        return \"NO\".to_string();\n\
    \    }\n    if length == 2 {\n        return \"YES\".to_string();\n    }\n   \
    \ for i in 2..length {\n        if length % i == 0 {\n            return \"NO\"\
    .to_string();\n        }\n    }\n    \"YES\".to_string()", "    let (i1_start,\
    \ i1_end) = interval1;\n    let (i2_start, i2_end) = interval2;\n    if (i1_start\
    \ < i2_start && i1_end < i2_start) || (i2_start < i1_start && i2_end < i1_start)\
    \ {\n        return \"NO\".to_string();\n    }\n    let max_start = cmp::max(i1_start,\
    \ i2_start);\n    let min_end = cmp::min(i1_end, i2_end);\n    let len = min_end\
    \ - max_start + 1;\n    if prime_numbers::is_prime(len) {\n        return \"YES\"\
    .to_string();\n    }\n    \"NO\".to_string()", "    let mut x = interval1.0;\n\
    \    let mut y = interval1.1;\n    let (a, b) = interval2;\n    if interval1.0\
    \ > interval2.0 {\n        x = interval2.0;\n    }\n    if interval1.1 < interval2.1\
    \ {\n        y = interval2.1;\n    }\n    if x > y {\n        return \"NO\".to_string();\n\
    \    }\n    let mut primes = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut val = x;\n\
    \    let mut vec = Vec::new();\n    while val <= y {\n        vec.push(val);\n\
    \        val += 1;\n    }\n    for prime in primes {\n        if vec.contains(&prime)\
    \ {\n            return \"YES\".to_string();\n        }\n    }\n    \"NO\".to_string()",
  "    if interval1.0 > interval2.1 || interval2.0 > interval1.1 {\n        \"NO\"\
    .to_string()\n    } else {\n        let min_start = interval1.0.max(interval2.0);\n\
    \        let max_end = interval1.1.min(interval2.1);\n        let diff = (max_end\
    \ - min_start) + 1;\n        if diff > 2 && (diff as f64).sqrt().fract() == 0.0\
    \ {\n            \"NO\".to_string()\n        } else {\n            \"YES\".to_string()\n\
    \        }\n    }", "    let (i1_min, i1_max) = interval1;\n    let (i2_min, i2_max)\
    \ = interval2;\n    if i1_max < i2_min || i2_max < i1_min {\n        return \"\
    NO\".to_string();\n    }\n    let min = if i1_min < i2_min { i2_min } else { i1_min\
    \ };\n    let max = if i1_max < i2_max { i1_max } else { i2_max };\n    let inter\
    \ = (min, max);\n    let len = inter.1 - inter.0;\n    if len <= 1 {\n       \
    \ return \"NO\".to_string();\n    }\n    if is_prime(len) {\n        return \"\
    YES\".to_string();\n    }\n    \"NO\".to_string()", "    let start = if interval1.0\
    \ > interval2.0 {\n        interval1.0\n    } else {\n        interval2.0\n  \
    \  };\n    let end = if interval1.1 < interval2.1 {\n        interval1.1\n   \
    \ } else {\n        interval2.1\n    };\n    if start > end {\n        return\
    \ \"NO\".to_string();\n    }\n    for i in 2..start {\n        if start % i ==\
    \ 0 {\n            return \"NO\".to_string();\n        }\n    }\n    for i in\
    \ 2..end {\n        if end % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()", "    let start_value = interval1.0.max(interval2.0);\n\
    \    let end_value = interval1.1.min(interval2.1);\n    let diff = end_value -\
    \ start_value;\n    if diff < 0 {\n        return \"NO\".to_string();\n    }\n\
    \    let n = (2..=(diff as f64).sqrt() as isize).filter(|x| diff % x == 0).count();\n\
    \    if n == 0 {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n\
    \    }", "    let (start, end) = if interval1.0 < interval2.0 {\n        (interval2.0,\
    \ interval1.1)\n    } else {\n        (interval1.0, interval2.1)\n    };\n   \
    \ if start > end {\n        return \"NO\".to_string();\n    }\n    let diff =\
    \ end - start + 1;\n    if diff <= 1 {\n        return \"NO\".to_string();\n \
    \   }\n    if is_prime(diff) {\n        return \"YES\".to_string();\n    }\n \
    \   \"NO\".to_string()", "  let mut result = (isize::max(interval1.0, interval2.0),\
    \ isize::min(interval1.1, interval2.1));\n  if result.0 > result.1 {\n    return\
    \ \"NO\".to_string();\n  }\n  if result.1 - result.0 == 1 {\n    return \"YES\"\
    .to_string();\n  }\n  if result.1 - result.0 == 2 {\n    return \"NO\".to_string();\n\
    \  }\n  let mut i = 2;\n  while i <= result.1 {\n    if result.1 % i == 0 {\n\
    \      return \"NO\".to_string();\n    }\n    i += 1;\n  }\n  \"YES\".to_string()",
  "    let (interval1_start, interval1_end) = interval1;\n    let (interval2_start,\
    \ interval2_end) = interval2;\n    if interval1_end < interval2_start || interval2_end\
    \ < interval1_start {\n        return \"NO\".to_string();\n    }\n    let new_start\
    \ = std::cmp::max(interval1_start, interval2_start);\n    let new_end = std::cmp::min(interval1_end,\
    \ interval2_end);\n    let len = new_end - new_start + 1;\n    if len == 1 {\n\
    \        return \"NO\".to_string();\n    }\n    if len == 2 {\n        return\
    \ \"YES\".to_string();\n    }\n    let mut is_prime = true;\n    for i in 3..len\
    \ {\n        if len % i == 0 {\n            is_prime = false;\n            break;\n\
    \        }\n    }\n    if is_prime {\n        return \"YES\".to_string();\n  \
    \  }\n    return \"NO\".to_string();", "    let (x1, x2) = interval1;\n    let\
    \ (y1, y2) = interval2;\n    let left = x1.max(y1);\n    let right = x2.min(y2);\n\
    \    if left <= right {\n        if right - left == 0 {\n            return \"\
    NO\".to_string();\n        }\n        if right - left == 1 {\n            return\
    \ \"YES\".to_string();\n        }\n        let range = (2..(right - left)).collect::<Vec<isize>>();\n\
    \        let primes = range.iter().filter(|&x| {\n            let range = 2..((*x\
    \ as f64).sqrt() as isize);\n            range.all(|i| {\n                (*x\
    \ % i) != 0\n            })\n        }).collect::<Vec<&isize>>();\n        if\
    \ primes.contains(&(&(right - left))) {\n            return \"YES\".to_string();\n\
    \        }\n    }\n    \"NO\".to_string()", "    let start = std::cmp::max(interval1.0,\
    \ interval2.0);\n    let end = std::cmp::min(interval1.1, interval2.1);\n    if\
    \ start > end {\n        return \"NO\".to_string();\n    }\n    let diff = end\
    \ - start + 1;\n    match &*(2..(diff - 1)).filter(|x| diff % x == 0).collect::<Vec<_>>()\
    \ {\n        [] => \"YES\".to_string(),\n        _ => \"NO\".to_string(),\n  \
    \  }", "    let start = interval1.0.max(interval2.0);\n    let end = interval1.1.min(interval2.1);\n\
    \    if start <= end {\n        if end == start || end == start + 1 {\n      \
    \      \"NO\".to_string()\n        } else {\n            if is_prime(end - start\
    \ + 1) {\n                \"YES\".to_string()\n            } else {\n        \
    \        \"NO\".to_string()\n            }\n        }\n    } else {\n        \"\
    NO\".to_string()\n    }", "    let start1 = interval1.0;\n    let end1 = interval1.1;\n\
    \    let start2 = interval2.0;\n    let end2 = interval2.1;\n    if start1 > end2\
    \ || start2 > end1 {\n        return \"NO\".to_string();\n    }\n    let start_intersection\
    \ = start1.max(start2);\n    let end_intersection = end1.min(end2);\n    let mut\
    \ is_prime = true;\n    for i in 2..(end_intersection - start_intersection + 1)\
    \ {\n        if (end_intersection - start_intersection + 1) % i == 0 {\n     \
    \       is_prime = false;\n            break;\n        }\n    }\n    if is_prime\
    \ {\n        return \"YES\".to_string();\n    }\n    \"NO\".to_string()", "  \
    \  if interval1.0 > interval2.1 || interval2.0 > interval1.1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let length =\n        if interval1.0 > interval2.0\
    \ {\n            interval1.0 - interval2.1\n        } else {\n            interval2.0\
    \ - interval1.1\n        };\n    if is_prime(length) {\n        \"YES\".to_string()\n\
    \    } else {\n        \"NO\".to_string()\n    }", "    let intersection = (interval1.0.max(interval2.0),\
    \ interval1.1.min(interval2.1));\n    let result =\n        if intersection.0\
    \ <= intersection.1 {\n            is_prime(intersection.1 - intersection.0 +\
    \ 1)\n        } else {\n            false\n        };\n    if result {\n     \
    \   \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n    }", " \
    \   let interval = (\n        interval1.0.max(interval2.0),\n        interval1.1.min(interval2.1),\n\
    \    );\n    if interval.0 >= interval.1 {\n        return \"NO\".to_string();\n\
    \    }\n    let range = (interval.0 + 1..interval.1).collect::<Vec<isize>>();\n\
    \    if range.len() < 2 {\n        return \"YES\".to_string();\n    }\n    if\
    \ range.iter().all(|&x| x % 2 != 0) {\n        return \"YES\".to_string();\n \
    \   }\n    if range.iter().any(|&x| x == 3) {\n        return \"YES\".to_string();\n\
    \    }\n    for i in (3..=range.len() / 2).step_by(2) {\n        if range.iter().all(|&x|\
    \ x % i != 0) {\n            return \"YES\".to_string();\n        }\n    }\n \
    \   \"NO\".to_string()", "    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    if start1 <= start2 && start2 <= end1 {\n        if\
    \ start1 <= end2 && end2 <= end1 {\n            if end2 - start2 == 1 {\n    \
    \            return \"YES\".to_string();\n            }\n            if is_prime(end2\
    \ - start2) {\n                return \"YES\".to_string();\n            }\n  \
    \      } else {\n            if end1 - start2 == 1 {\n                return \"\
    YES\".to_string();\n            }\n            if is_prime(end1 - start2) {\n\
    \                return \"YES\".to_string();\n            }\n        }\n    }\
    \ else if start2 <= start1 && start1 <= end2 {\n        if start2 <= end1 && end1\
    \ <= end2 {\n            if end1 - start1 == 1 {\n                return \"YES\"\
    .to_string();\n            }\n            if is_prime(end1 - start1) {\n     \
    \           return \"YES\".to_string();\n            }\n        } else {\n   \
    \         if end2 - start1 == 1 {\n                return \"YES\".to_string();\n\
    \            }\n            if is_prime(end2 - start1) {\n                return\
    \ \"YES\".to_string();\n            }\n        }\n    }\n    \"NO\".to_string()",
  "    if interval1.0 > interval2.1 || interval2.0 > interval1.1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let start = std::cmp::max(interval1.0, interval2.0);\n\
    \    let end = std::cmp::min(interval1.1, interval2.1);\n    if start > end {\n\
    \        return \"NO\".to_string();\n    }\n    if is_prime(end - start + 1) {\n\
    \        return \"YES\".to_string();\n    }\n    return \"NO\".to_string();",
  "    if interval1.0 > interval2.1 || interval2.0 > interval1.1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let mut v = vec![];\n    if interval1.0 < interval2.0\
    \ {\n        v.push(interval2.0);\n    } else {\n        v.push(interval1.0);\n\
    \    }\n    if interval1.1 < interval2.1 {\n        v.push(interval1.1);\n   \
    \ } else {\n        v.push(interval2.1);\n    }\n    let length = v[1] - v[0]\
    \ + 1;\n    if length == 1 {\n        return \"NO\".to_string();\n    }\n    if\
    \ length == 2 {\n        return \"YES\".to_string();\n    }\n    for i in 2..length\
    \ / 2 + 1 {\n        if length % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()", "    // This function takes two intervals\
    \ and returns the intersection,\n    // if it exists, of these two intervals\n\
    \    let (x1, y1) = interval1;\n    let (x2, y2) = interval2;\n    // if (x1,\
    \ y1) and (x2, y2) are disjoint, return false\n    if x1 > y2 || x2 > y1 {\n \
    \       return \"NO\".to_string();\n    }\n    // (a, b) is the intersection of\
    \ (x1, y1) and (x2, y2)\n    let (a, b) = (cmp::max(x1, x2), cmp::min(y1, y2));\n\
    \    // if (a, b) is a prime, return \"YES\"\n    if is_prime(b - a + 1) {\n \
    \       return \"YES\".to_string();\n    }\n    // if (a, b) is not a prime, return\
    \ \"NO\"\n    return \"NO\".to_string();", "    let (start1, end1) = interval1;\n\
    \    let (start2, end2) = interval2;\n    let max_start = std::cmp::max(start1,\
    \ start2);\n    let min_end = std::cmp::min(end1, end2);\n    if max_start > min_end\
    \ {\n        return \"NO\".to_string();\n    }\n    let length = min_end - max_start\
    \ + 1;\n    if length == 1 {\n        return \"NO\".to_string();\n    }\n    let\
    \ mut result = false;\n    let mut counter = 3;\n    while counter * counter <=\
    \ length {\n        if length % counter == 0 {\n            result = true;\n \
    \           break;\n        }\n        counter += 2;\n    }\n    if result {\n\
    \        \"NO\".to_string()\n    } else {\n        \"YES\".to_string()\n    }",
  "    let mut result = \"NO\";\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let mut x: isize = 0;\n    let mut y: isize = 0;\n    if c <= b && a <= d\
    \ {\n        x = c;\n        y = b;\n        if a > c {\n            x = a;\n\
    \        }\n        if b < d {\n            y = b;\n        }\n        if y -\
    \ x >= 0 {\n            if is_prime(y - x) {\n                result = \"YES\"\
    ;\n            }\n        }\n    }\n    result.to_string()", "    let (x1, y1)\
    \ = interval1;\n    let (x2, y2) = interval2;\n    if (x1 > y2) || (x2 > y1) {\n\
    \        return \"NO\".to_string();\n    }\n    let range = if x1 > x2 { x1..y2\
    \ } else { x2..y1 };\n    let range_len = range.len() as isize;\n    if range_len\
    \ == 0 {\n        return \"NO\".to_string();\n    }\n    let mut is_prime = true;\n\
    \    for i in 2..range_len {\n        if range_len % i == 0 {\n            is_prime\
    \ = false;\n            break;\n        }\n    }\n    if is_prime {\n        return\
    \ \"YES\".to_string();\n    }\n    \"NO\".to_string()", "    let start = interval1.0.max(interval2.0);\n\
    \    let end = interval1.1.min(interval2.1);\n    if start > end {\n        \"\
    NO\".to_string()\n    } else {\n        let length = end - start + 1;\n      \
    \  if length == 2 {\n            \"YES\".to_string()\n        } else {\n     \
    \       let mut is_prime = true;\n            for i in 3..length {\n         \
    \       if length % i == 0 {\n                    is_prime = false;\n        \
    \            break;\n                }\n            }\n            if is_prime\
    \ {\n                \"YES\".to_string()\n            } else {\n             \
    \   \"NO\".to_string()\n            }\n        }\n    }", "    let (mut start,\
    \ mut end) = (interval1.0, interval1.1);\n    if start > end {\n        start\
    \ = interval1.1;\n        end = interval1.0;\n    }\n    let (mut i1_start, mut\
    \ i1_end) = (interval2.0, interval2.1);\n    if i1_start > i1_end {\n        i1_start\
    \ = interval2.1;\n        i1_end = interval2.0;\n    }\n    if end < i1_start\
    \ || start > i1_end {\n        return \"NO\".to_string();\n    }\n    let s =\
    \ std::cmp::max(start, i1_start);\n    let e = std::cmp::min(end, i1_end);\n \
    \   if s >= e {\n        return \"NO\".to_string();\n    }\n    let s = s as usize;\n\
    \    let e = e as usize;\n    let diff = e - s;\n    let result =\n        if\
    \ diff == 1 || diff == 2 || diff == 3 || diff == 5 || diff == 7 || diff == 11\
    \ {\n            \"YES\"\n        } else {\n            \"NO\"\n        };\n \
    \   result.to_string()", "    let (interval1_left, interval1_right) = interval1;\n\
    \    let (interval2_left, interval2_right) = interval2;\n    let mut left = interval1_left;\n\
    \    let mut right = interval1_right;\n    if interval2_left > interval1_left\
    \ {\n        left = interval2_left;\n    }\n    if interval2_right < interval1_right\
    \ {\n        right = interval2_right;\n    }\n    if left > right {\n        return\
    \ \"NO\".to_string();\n    }\n    if left == right {\n        return \"YES\".to_string();\n\
    \    }\n    let s = right - left + 1;\n    if s == 2 {\n        return \"YES\"\
    .to_string();\n    }\n    for i in 2..(s as f64).sqrt() as isize + 1 {\n     \
    \   if s % i == 0 {\n            return \"NO\".to_string();\n        }\n    }\n\
    \    \"YES\".to_string()", "    if interval1.0 <= interval2.1 && interval2.0 <=\
    \ interval1.1 {\n        let low = std::cmp::max(interval1.0, interval2.0);\n\
    \        let high = std::cmp::min(interval1.1, interval2.1);\n        if is_prime(high\
    \ - low + 1) {\n            return \"YES\".to_string();\n        }\n    }\n  \
    \  \"NO\".to_string()", "    let x = interval1.0.max(interval2.0);\n    let y\
    \ = interval1.1.min(interval2.1);\n    let interval = x..=y;\n    if interval.len()\
    \ > 0 {\n        if interval.len() == 1 {\n            \"YES\".to_string()\n \
    \       } else {\n            match interval.len() {\n                2 | 3 |\
    \ 5 | 7 | 11 | 13 | 17 | 19 | 23 | 29 | 31 | 37 | 41 | 43 | 47 | 53 | 59 | 61\
    \ | 67 | 71 | 73 | 79 | 83 | 89 | 97 => \"YES\".to_string(),\n               \
    \ _ => \"NO\".to_string()\n            }\n        }\n    } else {\n        \"\
    NO\".to_string()\n    }", "    // (1,1) (1,1)\n    // (1,2) (2,4)\n    // (2,4)\
    \ (1,2)\n    // (3,3) (3,3)\n    // (1,3) (2,4)\n    // (2,4) (1,3)\n    // (5,5)\
    \ (5,5)\n    // (1,10) (5,5)\n    // (5,5) (1,10)\n    // (1,10) (2,4)\n    //\
    \ (2,4) (1,10)\n    // (1,1) (1,10)\n    // (1,10) (1,1)\n    // (1,10) (1,20)\n\
    \    // (1,20) (1,10)\n    // (9,9) (9,9)\n    // (5,5) (10,10)\n    // (10,10)\
    \ (5,5)\n    // (5,5) (11,11)\n    // (11,11) (5,5)\n    // (2,2) (2,2)\n    //\
    \ (1,20) (5,15)\n    // (5,15) (1,20)\n    // (10,100) (20,50)\n    // (20,50)\
    \ (10,100)\n    // (1,100) (50,100)\n    // (50,100) (1,100)\n    // (10,100)\
    \ (50,100)\n    // (50,100) (10,100)\n    // (15,15) (15,15)\n    // (10,15) (20,25)\n\
    \    // (20,25) (10,15)\n    // (1,1) (3,3)\n    // (3,3) (1,1)\n    // (1,1)\
    \ (5,5)\n    // (5,5) (1,1)\n    // (1,2) (1,2)\n    // (1,3) (3,3)\n    // (3,3)\
    \ (1,3)\n    // (1", "    let interval1 = interval1.0..interval1.1;\n    let interval2\
    \ = interval2.0..interval2.1;\n    if let Some(intersection) = interval1.intersection(&interval2)\
    \ {\n        // let intersection = intersection.0..intersection.1;\n        if\
    \ intersection.end - intersection.start < 2 {\n            \"NO\".to_string()\n\
    \        } else {\n            for i in 2..(intersection.end - intersection.start)\
    \ {\n                if (intersection.end - intersection.start) % i == 0 {\n \
    \                   return \"NO\".to_string();\n                }\n          \
    \  }\n            \"YES\".to_string()\n        }\n    } else {\n        \"NO\"\
    .to_string()\n    }", "    let (l1, r1) = interval1;\n    let (l2, r2) = interval2;\n\
    \    if l1 > r2 || l2 > r1 {\n        return \"NO\".to_string();\n    }\n    let\
    \ (l, r) = (l1.max(l2), r1.min(r2));\n    if (l..r).count() == 1 {\n        return\
    \ \"YES\".to_string();\n    }\n    return \"NO\".to_string();", "    let (a, b)\
    \ = interval1;\n    let (c, d) = interval2;\n    if (c >= a && c <= b) || (d >=\
    \ a && d <= b) {\n        let max = isize::max(isize::max(a, b), isize::max(c,\
    \ d));\n        let min = isize::min(isize::min(a, b), isize::min(c, d));\n  \
    \      let range = (min..max).collect::<Vec<isize>>();\n        if range.len()\
    \ > 1 {\n            if range.len() == 2 {\n                return \"YES\".to_string();\n\
    \            }\n            if range.iter().all(|&n| n % 2 != 0) {\n         \
    \       return \"YES\".to_string();\n            }\n        }\n    }\n    \"NO\"\
    .to_string()", "    let _interval1 = interval1;\n    let _interval2 = interval2;\n\
    \    unimplemented!()", "    let isize_max = std::isize::MAX;\n    let isize_min\
    \ = std::isize::MIN;\n    let (mut start, mut end) = (isize_max, isize_min);\n\
    \    let (mut start1, mut end1) = interval1;\n    let (mut start2, mut end2) =\
    \ interval2;\n    // start and end of intersection\n    if start1 < start2 {\n\
    \        start = start2;\n    } else {\n        start = start1;\n    }\n    if\
    \ end1 > end2 {\n        end = end2;\n    } else {\n        end = end1;\n    }\n\
    \    if start > end {\n        return \"NO\".to_string();\n    }\n    if is_prime(end\
    \ - start + 1) {\n        return \"YES\".to_string();\n    }\n    \"NO\".to_string()",
  "    if interval1.0 > interval2.1 || interval2.0 > interval1.1 {\n        \"NO\"\
    .to_string()\n    } else {\n        let (start, end) = \n            if interval1.0\
    \ > interval2.0 { (interval1.0, interval2.1) }\n            else { (interval2.0,\
    \ interval1.1) };\n        match (start..end).len() {\n            1 => \"YES\"\
    .to_string(),\n            2 => \"YES\".to_string(),\n            3 => \"YES\"\
    .to_string(),\n            5 => \"YES\".to_string(),\n            7 => \"YES\"\
    .to_string(),\n            _ => \"NO\".to_string(),\n        }\n    }", "    let\
    \ max_start = interval1.0.max(interval2.0);\n    let min_end = interval1.1.min(interval2.1);\n\
    \    let res = min_end - max_start;\n    if res < 0 {\n        \"NO\".to_string()\n\
    \    } else if res == 0 {\n        \"YES\".to_string()\n    } else {\n       \
    \ match primes::is_prime(res as u64) {\n            true => \"YES\".to_string(),\n\
    \            false => \"NO\".to_string(),\n        }\n    }", "    let (i1s, i1e)\
    \ = interval1;\n    let (i2s, i2e) = interval2;\n    let i1 = (i1s..=i1e).collect::<Vec<isize>>();\n\
    \    let i2 = (i2s..=i2e).collect::<Vec<isize>>();\n    let inter: Vec<_> = i1.iter().filter(|x|\
    \ i2.contains(x)).collect();\n    match inter.len() {\n        0 => \"NO\".to_string(),\n\
    \        1 => \"YES\".to_string(),\n        _ => inter.iter().any(|&x| prime(x))\
    \ ? \"YES\".to_string() : \"NO\".to_string(),\n    }", "    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let (mut start, mut end)\
    \ = (0, 0);\n    if start1 >= start2 && start1 <= end2 {\n        start = start1;\n\
    \    } else if start2 >= start1 && start2 <= end1 {\n        start = start2;\n\
    \    }\n    if end1 >= start2 && end1 <= end2 {\n        end = end1;\n    } else\
    \ if end2 >= start1 && end2 <= end1 {\n        end = end2;\n    }\n    if start\
    \ > end {\n        return \"NO\".to_string();\n    }\n    let len = end - start\
    \ + 1;\n    for i in 2..(len as f64).sqrt() as isize + 1 {\n        if len % i\
    \ == 0 {\n            return \"NO\".to_string();\n        }\n    }\n    \"YES\"\
    .to_string()", "    let (s1, e1) = interval1;\n    let (s2, e2) = interval2;\n\
    \    if (s1 > e2) || (s2 > e1) {\n        return \"NO\".to_string();\n    }\n\
    \    let (start, end) = if s1 > s2 {\n        (s1, e2)\n    } else {\n       \
    \ (s2, e1)\n    };\n    let mut count = end - start;\n    if count == 1 {\n  \
    \      return \"NO\".to_string();\n    }\n    while count > 1 {\n        if (end\
    \ - start + 1) % count == 0 {\n            return \"NO\".to_string();\n      \
    \  }\n        count -= 1;\n    }\n    \"YES\".to_string()", "    let mut start\
    \ = interval1.0;\n    let mut end = interval1.1;\n    if interval2.0 > start {\n\
    \        start = interval2.0;\n    }\n    if interval2.1 < end {\n        end\
    \ = interval2.1;\n    }\n    if start > end {\n        return \"NO\".to_string();\n\
    \    }\n    let mut length = end - start + 1;\n    while length > 1 {\n      \
    \  if start % length == 0 && end % length == 0 {\n            return \"NO\".to_string();\n\
    \        }\n        length -= 1;\n    }\n    \"YES\".to_string()", "    use num::Signed;\n\
    \    let min = |a: isize, b: isize| -> isize { if a < b { a } else { b } };\n\
    \    let max = |a: isize, b: isize| -> isize { if a > b { a } else { b } };\n\
    \    let (start1, end1) = interval1;\n    let (start2, end2) = interval2;\n  \
    \  let start = max(start1, start2);\n    let end = min(end1, end2);\n    if start\
    \ > end {\n        return \"NO\".to_string();\n    }\n    let len = end - start\
    \ + 1;\n    let is_prime = primes::is_prime(len as u64);\n    if is_prime {\n\
    \        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n    }",
  "    if interval1.0 > interval2.1 || interval2.0 > interval1.1 {\n        \"NO\"\
    .to_string()\n    } else {\n        let start = interval1.0.max(interval2.0);\n\
    \        let end = interval1.1.min(interval2.1);\n        let len = end - start\
    \ + 1;\n        if len < 2 {\n            \"NO\".to_string()\n        } else {\n\
    \            let mut is_prime = true;\n            for i in 2..len {\n       \
    \         if len % i == 0 {\n                    is_prime = false;\n         \
    \           break;\n                }\n            }\n            if is_prime\
    \ {\n                \"YES\".to_string()\n            } else {\n             \
    \   \"NO\".to_string()\n            }\n        }\n    }", "    match get_intersection(interval1,\
    \ interval2) {\n        None => \"NO\".to_string(),\n        Some((_, _)) => {\n\
    \            let (start, end) = get_intersection(interval1, interval2).unwrap();\n\
    \            match is_prime((end - start + 1) as usize) {\n                true\
    \ => \"YES\".to_string(),\n                false => \"NO\".to_string(),\n    \
    \        }\n        }\n    }", "    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    if start1 > end2 || start2 > end1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let start = start1.max(start2);\n    let end\
    \ = end1.min(end2);\n    if start <= end {\n        if (start..end).count() ==\
    \ 2 {\n            return \"YES\".to_string();\n        }\n    }\n    \"NO\".to_string()",
  "    let (a, b) = interval1;\n    let (c, d) = interval2;\n    if a <= c && c <=\
    \ b && b <= d {\n        if is_prime(b - c + 1) { \"YES\".to_string() } else {\
    \ \"NO\".to_string() }\n    } else if a <= c && c <= d && d <= b {\n        if\
    \ is_prime(d - c + 1) { \"YES\".to_string() } else { \"NO\".to_string() }\n  \
    \  } else if c <= a && a <= d && d <= b {\n        if is_prime(d - a + 1) { \"\
    YES\".to_string() } else { \"NO\".to_string() }\n    } else if c <= a && a <=\
    \ b && b <= d {\n        if is_prime(b - a + 1) { \"YES\".to_string() } else {\
    \ \"NO\".to_string() }\n    } else {\n        \"NO\".to_string()\n    }", "  \
    \  let x_start = interval1.0;\n    let x_end = interval1.1;\n    let y_start =\
    \ interval2.0;\n    let y_end = interval2.1;\n    let (start, end) = if x_start\
    \ <= y_start {\n        if x_end >= y_start {\n            (y_start, if x_end\
    \ <= y_end { x_end } else { y_end })\n        } else {\n            return \"\
    NO\".to_string();\n        }\n    } else {\n        if y_end >= x_start {\n  \
    \          (x_start, if y_end <= x_end { y_end } else { x_end })\n        } else\
    \ {\n            return \"NO\".to_string();\n        }\n    };\n    let len =\
    \ end - start + 1;\n    if len == 1 {\n        return \"NO\".to_string();\n  \
    \  }\n    match len {\n        2 | 3 | 5 | 7 => \"YES\".to_string(),\n       \
    \ _ => \"NO\".to_string(),\n    }", "    let (i, j) = (interval1.0, interval1.1);\n\
    \    let (a, b) = (interval2.0, interval2.1);\n    let mut flag = true;\n    let\
    \ mut count = 0;\n    let mut result = \"NO\";\n    while flag {\n        if i\
    \ > j {\n            break;\n        }\n        if (i >= a && i <= b) || (j >=\
    \ a && j <= b) {\n            count += 1;\n        }\n        if count == 0 {\n\
    \            break;\n        }\n        if count != 2 {\n            i += 1;\n\
    \            j -= 1;\n        } else {\n            if (i == a && j == b) || (i\
    \ == b && j == a) {\n                flag = false;\n                result = \"\
    YES\";\n            } else {\n                flag = false;\n            }\n \
    \       }\n    }\n    result.to_string()", "    let (a, b) = interval1;\n    let\
    \ (c, d) = interval2;\n    let mut e = 0;\n    let mut f = 0;\n    if c < a {\n\
    \        e = c;\n        f = a;\n    } else {\n        e = a;\n        f = c;\n\
    \    }\n    if b < d {\n        if b < f || e > d {\n            return \"NO\"\
    .to_string();\n        }\n    } else {\n        if d < f || e > b {\n        \
    \    return \"NO\".to_string();\n        }\n    }\n    let mut length = b - a;\n\
    \    if length < 0 {\n        length = length * -1;\n    }\n    let mut i = 2;\n\
    \    while i < length {\n        if length % i == 0 {\n            return \"NO\"\
    .to_string();\n        }\n        i += 1;\n    }\n    \"YES\".to_string()", " \
    \   let start = interval1.0.max(interval2.0);\n    let end = interval1.1.min(interval2.1);\n\
    \    if start > end {\n        return \"NO\".to_string();\n    }\n    let length\
    \ = end - start + 1;\n    match length {\n        0 => \"NO\".to_string(),\n \
    \       1 => \"YES\".to_string(),\n        2 => \"YES\".to_string(),\n       \
    \ 4 => \"NO\".to_string(),\n        _ => {\n            for x in 2..(length /\
    \ 2 + 1) {\n                if length % x == 0 {\n                    return \"\
    NO\".to_string();\n                }\n            }\n            \"YES\".to_string()\n\
    \        }\n    }", "    let mut i1_start = interval1.0;\n    let mut i1_end =\
    \ interval1.1;\n    let mut i2_start = interval2.0;\n    let mut i2_end = interval2.1;\n\
    \    if i1_start > i1_end {\n        std::mem::swap(&mut i1_start, &mut i1_end);\n\
    \    }\n    if i2_start > i2_end {\n        std::mem::swap(&mut i2_start, &mut\
    \ i2_end);\n    }\n    if i1_end < i2_start || i2_end < i1_start {\n        return\
    \ \"NO\".to_string();\n    }\n    let len = match (i1_start <= i2_start, i1_end\
    \ <= i2_end) {\n        (true, true) => i1_end - i2_start,\n        (true, false)\
    \ => i2_end - i2_start,\n        (false, true) => i1_end - i1_start,\n       \
    \ (false, false) => i1_start - i2_start,\n    };\n    if is_prime(len) {\n   \
    \     \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n    }", " \
    \   let (mut start, mut end) = {\n        let (start1, end1) = interval1;\n  \
    \      let (start2, end2) = interval2;\n        let new_start = start1.max(start2);\n\
    \        let new_end = end1.min(end2);\n        if new_start > new_end {\n   \
    \         return \"NO\".to_string();\n        }\n        (new_start, new_end)\n\
    \    };\n    start -= 1;\n    if start == 0 {\n        return \"NO\".to_string();\n\
    \    }\n    for i in 2..(end as f64).sqrt() as isize + 1 {\n        if start %\
    \ i == 0 || end % i == 0 {\n            return \"NO\".to_string();\n        }\n\
    \    }\n    \"YES\".to_string()", "  let mut new_interval = (0, 0);\n  if interval1.0\
    \ <= interval2.0 && interval2.0 <= interval1.1 {\n    new_interval.0 = interval2.0;\n\
    \  } else if interval2.0 <= interval1.0 && interval1.0 <= interval2.1 {\n    new_interval.0\
    \ = interval1.0;\n  }\n  if interval1.0 <= interval2.1 && interval2.1 <= interval1.1\
    \ {\n    new_interval.1 = interval2.1;\n  } else if interval2.0 <= interval1.1\
    \ && interval1.1 <= interval2.1 {\n    new_interval.1 = interval1.1;\n  }\n  if\
    \ new_interval.0 == 0 || new_interval.1 == 0 {\n    \"NO\".to_string()\n  } else\
    \ {\n    let len = new_interval.1 - new_interval.0 + 1;\n    for i in 2..len {\n\
    \      if len % i == 0 {\n        return \"NO\".to_string();\n      }\n    }\n\
    \    \"YES\".to_string()\n  }", "    let intersection = match (interval1, interval2)\
    \ {\n        ((a, b), (c, d)) if c <= b && a <= d => (std::cmp::max(a, c), std::cmp::min(b,\
    \ d)),\n        _ => return \"NO\".to_string(),\n    };\n    if intersection.0\
    \ == intersection.1 {\n        \"NO\".to_string()\n    } else {\n        let length\
    \ = intersection.1 - intersection.0 - 1;\n        if is_prime(length) {\n    \
    \        \"YES\".to_string()\n        } else {\n            \"NO\".to_string()\n\
    \        }\n    }", "    // Check if intervals intersect\n    if interval1.0 >\
    \ interval2.1 || interval2.0 > interval1.1 {\n        return \"NO\".to_string();\n\
    \    }\n    // Find the intersection of the intervals\n    let start = if interval1.0\
    \ < interval2.0 {\n        interval2.0\n    } else {\n        interval1.0\n  \
    \  };\n    let end = if interval1.1 < interval2.1 {\n        interval1.1\n   \
    \ } else {\n        interval2.1\n    };\n    let len = end - start + 1;\n    //\
    \ Check if the length of the intersection is a prime number\n    if !primes::is_prime(len)\
    \ {\n        return \"NO\".to_string();\n    }\n    return \"YES\".to_string();",
  "    let mut interval = (0, 0);\n    let mut min1 = interval1.0;\n    let mut max1\
    \ = interval1.1;\n    let mut min2 = interval2.0;\n    let mut max2 = interval2.1;\n\
    \    if min1 > max1 {\n        let temp = min1;\n        min1 = max1;\n      \
    \  max1 = temp;\n    }\n    if min2 > max2 {\n        let temp = min2;\n     \
    \   min2 = max2;\n        max2 = temp;\n    }\n    if max1 < min2 || max2 < min1\
    \ {\n        return \"NO\".to_string();\n    }\n    if min1 <= min2 && max1 <=\
    \ max2 {\n        interval = (min2, max1);\n    } else if min1 <= min2 && max1\
    \ >= max2 {\n        interval = (min2, max2);\n    } else if min1 >= min2 && max1\
    \ <= max2 {\n        interval = (min1, max1);\n    } else if min1 >= min2 && max1\
    \ >= max2 {\n        interval = (min1, max2);\n    }\n    let mut prime_number\
    \ = true;\n    for i in 2..(interval.1 - interval.0 + 1) {\n        if interval.1\
    \ - interval.0 + 1 != i && (interval.1 - interval.0 + 1) % i == 0 {\n        \
    \    prime_number = false;\n            break;\n        }\n    }\n    if prime_number\
    \ {\n        return \"YES\".to_string();\n    } else {\n        return \"NO\"\
    .to_string();\n    }", "    let mut list = Vec::new();\n    for i in interval1.0..=interval1.1\
    \ {\n        if i >= interval2.0 && i <= interval2.1 {\n            list.push(i);\n\
    \        }\n    }\n    let size = list.len();\n    if size < 2 {\n        return\
    \ \"NO\".to_string();\n    }\n    let res = is_prime(&size);\n    if res {\n \
    \       return \"YES\".to_string();\n    }\n    \"NO\".to_string()", "    let\
    \ (start1, end1) = interval1;\n    let (start2, end2) = interval2;\n    if start1\
    \ >= end2 || start2 >= end1 {\n        \"NO\".to_string()\n    } else {\n    \
    \    let intersection = if start1 < start2 {\n            (start2, if end1 < end2\
    \ { end1 } else { end2 })\n        } else {\n            (start1, if end1 < end2\
    \ { end1 } else { end2 })\n        };\n        let length = (intersection.1 -\
    \ intersection.0) + 1;\n        if (length == 2) || (length % 2 != 0 && !(2..length).any(|v|\
    \ length % v == 0)) {\n            \"YES\".to_string()\n        } else {\n   \
    \         \"NO\".to_string()\n        }\n    }", "    let start = std::cmp::max(interval1.0,\
    \ interval2.0);\n    let end = std::cmp::min(interval1.1, interval2.1);\n    if\
    \ start > end {\n        \"NO\".to_string()\n    } else {\n        let l = end\
    \ - start + 1;\n        if (l == 2) || (l == 3) || (l == 5) || (l == 7) {\n  \
    \          \"YES\".to_string()\n        } else {\n            \"NO\".to_string()\n\
    \        }\n    }", "    // let inter = intersection(interval1, interval2);\n\
    \    // println!(\"{:?}\", inter);\n    if interval1.0 > interval2.1 || interval2.0\
    \ > interval1.1 {\n        return \"NO\".to_string();\n    }\n    let mut inter:\
    \ (isize, isize) = (0, 0);\n    if interval1.0 > interval2.0 {\n        inter.0\
    \ = interval1.0;\n    } else {\n        inter.0 = interval2.0;\n    }\n    if\
    \ interval1.1 < interval2.1 {\n        inter.1 = interval1.1;\n    } else {\n\
    \        inter.1 = interval2.1;\n    }\n    let l = inter.1 - inter.0;\n    for\
    \ i in 2..l + 1 {\n        if l % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()", "    let (low, high) = (interval1.0.max(interval2.0),\
    \ interval1.1.min(interval2.1));\n    if low > high {\n        return \"NO\".to_string();\n\
    \    }\n    let len = high - low + 1;\n    if is_prime(len) {\n        return\
    \ \"YES\".to_string();\n    }\n    \"NO\".to_string()", "    // code here\n  \
    \  let (a, b) = interval1;\n    let (c, d) = interval2;\n    if a > d || b < c\
    \ { return \"NO\".to_string(); }\n    let (e, f) = if a < c { (c, d) } else {\
    \ (a, b) };\n    let primes = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    primes.contains(&(f\
    \ - e + 1))", "    let interval_intersection = (\n        std::cmp::max(interval1.0,\
    \ interval2.0),\n        std::cmp::min(interval1.1, interval2.1),\n    );\n  \
    \  if interval_intersection.0 >= interval_intersection.1 {\n        \"NO\".to_string()\n\
    \    } else {\n        let interval_length = interval_intersection.1 - interval_intersection.0;\n\
    \        if interval_length <= 1 {\n            \"NO\".to_string()\n        }\
    \ else {\n            let mut prime = true;\n            for i in 2..interval_length\
    \ {\n                if interval_length % i == 0 {\n                    prime\
    \ = false;\n                    break;\n                }\n            }\n   \
    \         if prime {\n                \"YES\".to_string()\n            } else\
    \ {\n                \"NO\".to_string()\n            }\n        }\n    }", " \
    \   let length = std::cmp::max(interval1.0, interval2.0) - std::cmp::min(interval1.1,\
    \ interval2.1);\n    if length <= 0 { return \"NO\".to_string(); }\n    if primes::is_prime(length\
    \ as usize) { \"YES\".to_string() } else { \"NO\".to_string() }", "    let intv1\
    \ = ((interval1.0).min(interval1.1), (interval1.0).max(interval1.1));\n    let\
    \ intv2 = ((interval2.0).min(interval2.1), (interval2.0).max(interval2.1));\n\
    \    if intv1.1 < intv2.0 || intv2.1 < intv1.0 {\n        \"NO\".to_string()\n\
    \    } else {\n        let length = ((intv1.0).max(intv2.0) - (intv1.1).min(intv2.1)).abs()\
    \ + 1;\n        if length == 1 {\n            \"NO\".to_string()\n        } else\
    \ {\n            let result = (2..length/2 + 1).filter(|&x| length % x == 0).collect::<Vec<_>>();\n\
    \            if result.len() == 0 {\n                \"YES\".to_string()\n   \
    \         } else {\n                \"NO\".to_string()\n            }\n      \
    \  }\n    }", "    let a = interval1.0.max(interval2.0);\n    let b = interval1.1.min(interval2.1);\n\
    \    if a <= b {\n        if is_prime(b - a + 1) {\n            return \"YES\"\
    .to_string();\n        }\n    }\n    \"NO\".to_string()", "    if interval1.0\
    \ <= interval2.1 && interval2.0 <= interval1.1 {\n        let intersection = (interval1.0.max(interval2.0),\
    \ interval1.1.min(interval2.1));\n        if intersection.1 - intersection.0 ==\
    \ 1 { return \"NO\".to_string(); }\n        for i in 2..(intersection.1 - intersection.0)\
    \ {\n            if (intersection.1 - intersection.0) % i == 0 { return \"NO\"\
    .to_string(); }\n        }\n        \"YES\".to_string()\n    } else {\n      \
    \  \"NO\".to_string()\n    }", "    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let (lower, upper) = if start1 > start2 {\n        (start1,\
    \ end2)\n    } else {\n        (start2, end1)\n    };\n    let length = if lower\
    \ > upper {\n        0\n    } else {\n        upper - lower + 1\n    };\n    if\
    \ length == 0 {\n        \"NO\".to_string()\n    } else {\n        match length\
    \ {\n            1 | 2 | 3 | 5 | 7 | 11 | 13 | 17 | 19 | 23 | 29 | 31 | 37 | 41\
    \ | 43 | 47 | 53 | 59 | 61 | 67 | 71 | 73 | 79 | 83 | 89 | 97 => \"YES\".to_string(),\n\
    \            _ => \"NO\".to_string(),\n        }\n    }", "    let mut intersection\
    \ = (0, 0);\n    let left = if interval1.0 < interval2.0 { interval1.0 } else\
    \ { interval2.0 };\n    let right = if interval1.1 < interval2.1 { interval1.1\
    \ } else { interval2.1 };\n    if right > left {\n        intersection = (left,\
    \ right);\n    }\n    if is_prime(intersection.1 - intersection.0) {\n       \
    \ return \"YES\".to_string();\n    }\n    \"NO\".to_string()", "    let (a, b)\
    \ = interval1;\n    let (c, d) = interval2;\n    let (left, right) = (max(a, c),\
    \ min(b, d));\n    if left >= right {\n        return \"NO\".to_string();\n  \
    \  }\n    let length = right - left + 1;\n    if length == 2 {\n        return\
    \ \"YES\".to_string();\n    }\n    for i in 2..length {\n        if length % i\
    \ == 0 {\n            return \"NO\".to_string();\n        }\n    }\n    \"YES\"\
    .to_string()", "    // Write your code here\n    let (begin1, end1) = interval1;\n\
    \    let (begin2, end2) = interval2;\n    let begin = std::cmp::max(begin1, begin2);\n\
    \    let end = std::cmp::min(end1, end2);\n    if begin > end {\n        return\
    \ \"NO\".to_string();\n    }\n    for i in 2..begin {\n        if end % i == 0\
    \ {\n            return \"NO\".to_string();\n        }\n    }\n    return \"YES\"\
    .to_string();", "    //let (min, max) = if interval1.0 < interval2.0 {\n    //\
    \    (interval1.0, interval2.1)\n    //} else {\n    //    (interval2.0, interval1.1)\n\
    \    //};\n    let min = interval1.0.max(interval2.0);\n    let max = interval1.1.min(interval2.1);\n\
    \    let v = if min <= max { max - min + 1 } else { 0 };\n    if v < 2 {\n   \
    \     return \"NO\".to_string();\n    }\n    if is_prime(v) {\n        \"YES\"\
    .to_string()\n    } else {\n        \"NO\".to_string()\n    }", "  let (start1,\
    \ end1) = interval1;\n  let (start2, end2) = interval2;\n  if start1 > end2 ||\
    \ start2 > end1 {\n    return \"NO\".to_string();\n  }\n  let mut max_start =\
    \ start1;\n  let mut min_end = end1;\n  if start2 > max_start {\n    max_start\
    \ = start2;\n  }\n  if end2 < min_end {\n    min_end = end2;\n  }\n  if max_start\
    \ > min_end {\n    return \"NO\".to_string();\n  }\n  let length = min_end - max_start\
    \ + 1;\n  if length <= 1 {\n    return \"NO\".to_string();\n  }\n  for i in 2..length\
    \ {\n    if length % i == 0 {\n      return \"NO\".to_string();\n    }\n  }\n\
    \  \"YES\".to_string()", "    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    if start1 >= end2 || start2 >= end1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1, start2);\n\
    \    let end = std::cmp::min(end1, end2);\n    if is_prime(end - start) {\n  \
    \      \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n    }"]
stop_tokens:
- "\n}"
