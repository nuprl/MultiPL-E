name: HumanEval_57_monotonic
language: rs
prompt: "/// Return True is list elements are monotonically increasing or decreasing.\n\
  fn monotonic(l: Vec<isize>) -> bool {\n"
tests: "}\n\nfn main() {\n    let candidate = monotonic;\n    assert_eq!(candidate(vec![1,\
  \ 2, 4, 10]), true);\n    assert_eq!(candidate(vec![1, 2, 4, 20]), true);\n    assert_eq!(candidate(vec![1,\
  \ 20, 4, 10]), false);\n    assert_eq!(candidate(vec![4, 1, 0, -10]), true);\n \
  \   assert_eq!(candidate(vec![4, 1, 1, 0]), true);\n    assert_eq!(candidate(vec![1,\
  \ 2, 3, 2, 5, 60]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 60]),\
  \ true);\n    assert_eq!(candidate(vec![9, 9, 9, 9]), true);\n}\n"
completions: ['    l.windows(2).all(|w| w[0] <= w[1]) || l.windows(2).all(|w| w[0]
    >= w[1])', "    let mut prev = l[0];\n    let mut inc = true;\n    let mut dec\
    \ = true;\n    for i in l.iter() {\n        if i > &prev {\n            dec =\
    \ false;\n        } else if i < &prev {\n            inc = false;\n        }\n\
    \        prev = *i;\n    }\n    inc || dec", '    l.windows(2).all(|w| w[0] <
    w[1]) || l.windows(2).all(|w| w[0] > w[1])', '    l.windows(2).all(|w| w[0] <=
    w[1]) || l.windows(2).all(|w| w[0] >= w[1])', "    let mut monotonic = true;\n\
    \    let mut previous = l[0];\n    for e in l {\n        monotonic = monotonic\
    \ && (e == previous || e == previous + 1 || e == previous - 1);\n        previous\
    \ = e;\n    }\n    monotonic", "    let mut i = 0;\n    let mut n = 0;\n    for\
    \ x in l {\n        if i == 0 {\n            n = x;\n        } else if x < n {\n\
    \            return false;\n        }\n        i += 1;\n    }\n    true", "  \
    \  let mut last = l[0];\n    let mut order = 0;\n    for v in l.iter().skip(1)\
    \ {\n        if order == 0 {\n            if *v < last {\n                order\
    \ = -1;\n            } else if *v > last {\n                order = 1;\n     \
    \       }\n        } else if *v < last && order == 1 {\n            return false;\n\
    \        } else if *v > last && order == -1 {\n            return false;\n   \
    \     }\n        last = *v;\n    }\n    true", "    let mut inc = false;\n   \
    \ let mut dec = false;\n    let mut ret = true;\n    for i in 1..l.len() {\n \
    \       if l[i] > l[i - 1] {\n            if dec {\n                ret = false;\n\
    \                break;\n            }\n            inc = true;\n        } else\
    \ if l[i] < l[i - 1] {\n            if inc {\n                ret = false;\n \
    \               break;\n            }\n            dec = true;\n        }\n  \
    \  }\n    ret", "    let mut prev: isize = l[0];\n    let mut ascending = None;\n\
    \    for e in l.iter().skip(1) {\n        if ascending == None {\n           \
    \ ascending = Some(e > &prev);\n        }\n        if ascending.unwrap() && e\
    \ < &prev {\n            return false;\n        }\n        if !ascending.unwrap()\
    \ && e > &prev {\n            return false;\n        }\n        prev = *e;\n \
    \   }\n    true", "    let mut increasing = true;\n    let mut decreasing = true;\n\
    \    let mut last = 0;\n    for i in l {\n        if i < last {\n            increasing\
    \ = false;\n        }\n        if i > last {\n            decreasing = false;\n\
    \        }\n        last = i;\n    }\n    increasing || decreasing", "    let\
    \ mut list = l.clone();\n    list.sort();\n    let mut list_rev = l.clone();\n\
    \    list_rev.sort_by(|a, b| b.cmp(a));\n    for i in 0..l.len() {\n        if\
    \ l[i] != list[i] && l[i] != list_rev[i] {\n            return false;\n      \
    \  }\n    }\n    true", "    match l.len() {\n        0 => panic!(\"empty list\"\
    ),\n        1 => true,\n        2 => l[0] < l[1],\n        _ => monotonic_inner(l,\
    \ 0, l.len() - 1)\n    }", "    let mut asc = true;\n    let mut desc = true;\n\
    \    for i in 1..l.len() {\n        if l[i] > l[i - 1] {\n            desc = false;\n\
    \        } else if l[i] < l[i - 1] {\n            asc = false;\n        }\n  \
    \  }\n    asc || desc", "    let mut increasing = true;\n    let mut decreasing\
    \ = true;\n    for i in 1..l.len() {\n        increasing = increasing && l[i]\
    \ >= l[i - 1];\n        decreasing = decreasing && l[i] <= l[i - 1];\n    }\n\
    \    increasing || decreasing", "    if l.len() < 2 {\n        return true;\n\
    \    }\n    let delta = l[1] - l[0];\n    for i in 1..l.len() - 1 {\n        if\
    \ l[i + 1] - l[i] != delta {\n            return false;\n        }\n    }\n  \
    \  true", "    let mut prev = l[0];\n    let mut increasing = None;\n    for i\
    \ in l {\n        if increasing == None {\n            if i > prev {\n       \
    \         increasing = Some(true);\n            } else if i < prev {\n       \
    \         increasing = Some(false);\n            }\n        } else if i > prev\
    \ && !increasing.unwrap() {\n            return false;\n        } else if i <\
    \ prev && increasing.unwrap() {\n            return false;\n        }\n      \
    \  prev = i;\n    }\n    true", '    l.windows(2).all(|w| w[0] <= w[1]) || l.windows(2).all(|w|
    w[0] >= w[1])', "    let mut increasing = true;\n    let mut decreasing = true;\n\
    \    let mut prev = l[0];\n    for &curr in l.iter().skip(1) {\n        if curr\
    \ < prev {\n            increasing = false;\n        }\n        if curr > prev\
    \ {\n            decreasing = false;\n        }\n        prev = curr;\n    }\n\
    \    increasing || decreasing", "  match l.iter().zip(l.iter().skip(1)).collect::<Vec<_>>().iter().find(|(a,\
    \ b)| {\n    a > b || a < b\n  }) {\n    Some(_) => false,\n    None => true\n\
    \  }", "    let mut increasing = true;\n    let mut decreasing = true;\n    for\
    \ i in 1..l.len() {\n        increasing = increasing && l[i - 1] <= l[i];\n  \
    \      decreasing = decreasing && l[i - 1] >= l[i];\n    }\n    increasing ||\
    \ decreasing", "    let m = l.iter().fold((None, false), |acc, &i| {\n       \
    \ let (previous, increasing) = acc;\n        let new_increasing = match previous\
    \ {\n            None => true,\n            Some(p) => (i - p) * (increasing as\
    \ isize) > 0,\n        };\n        (Some(i), new_increasing)\n    });\n    let\
    \ (_, increasing) = m;\n    increasing", "    let mut inc = true;\n    let mut\
    \ dec = true;\n    for i in 1..l.len() {\n        inc &= l[i] >= l[i - 1];\n \
    \       dec &= l[i] <= l[i - 1];\n    }\n    inc || dec", "    let mut increasing\
    \ = true;\n    let mut decreasing = true;\n    let l = l.iter();\n    let mut\
    \ pre = l.clone().next().unwrap();\n    for i in l {\n        if i < pre {\n \
    \           increasing = false;\n        }\n        if i > pre {\n           \
    \ decreasing = false;\n        }\n        pre = i;\n    }\n    increasing || decreasing",
  "    if l.len() == 0 {\n        return true;\n    }\n    let (mut min, mut max)\
    \ = (l[0], l[0]);\n    for i in 1..l.len() {\n        if l[i] < min {\n      \
    \      min = l[i];\n        }\n        if l[i] > max {\n            max = l[i];\n\
    \        }\n    }\n    return max - min == l.len() as isize - 1;", "    let mut\
    \ increasing = l[0] < l[1];\n    for i in 1..l.len() - 1 {\n        if increasing\
    \ {\n            if l[i] > l[i + 1] {\n                return false;\n       \
    \     }\n        } else {\n            if l[i] < l[i + 1] {\n                return\
    \ false;\n            }\n        }\n    }\n    true", "    let mut d: isize =\
    \ 0;\n    for i in 0..l.len() - 1 {\n        if l[i] < l[i + 1] {\n          \
    \  if d == -1 {\n                return false;\n            }\n            d =\
    \ 1;\n        } else if l[i] > l[i + 1] {\n            if d == 1 {\n         \
    \       return false;\n            }\n            d = -1;\n        }\n    }\n\
    \    true", "    let mut b = true;\n    for i in 1..l.len() {\n        let diff\
    \ = l[i - 1] - l[i];\n        if diff != 0 && diff != 1 && diff != -1 {\n    \
    \        b = false;\n            break;\n        }\n    }\n    b", '    l.windows(2).all(|w|
    w[0] < w[1]) || l.windows(2).all(|w| w[0] > w[1])', '    l.windows(2).all(|w|
    w[0] <= w[1]) || l.windows(2).all(|w| w[0] >= w[1])', '  l.windows(2).all(|w|
    w[0] <= w[1]) || l.windows(2).all(|w| w[0] >= w[1])', "    let mut prev = l[0];\n\
    \    let mut increasing = true;\n    for i in 1..l.len() {\n        if l[i] <\
    \ prev {\n            increasing = false;\n            break;\n        }\n   \
    \     prev = l[i];\n    }\n    if increasing {\n        return true;\n    }\n\
    \    let mut prev = l[0];\n    for i in 1..l.len() {\n        if l[i] > prev {\n\
    \            return false;\n        }\n        prev = l[i];\n    }\n    true",
  "    let mut i = 0;\n    let mut inc = true;\n    while i < l.len() - 1 {\n    \
    \    if l[i] > l[i + 1] {\n            inc = false;\n            break;\n    \
    \    }\n        i += 1;\n    }\n    let mut i = 0;\n    let mut dec = true;\n\
    \    while i < l.len() - 1 {\n        if l[i] < l[i + 1] {\n            dec =\
    \ false;\n            break;\n        }\n        i += 1;\n    }\n    inc || dec",
  "    if l.len() < 2 {\n        return true;\n    }\n    let mut prev = l[0];\n \
    \   let mut all_equal = true;\n    for v in l.iter().skip(1) {\n        if prev\
    \ != *v {\n            all_equal = false;\n        }\n        if *v < prev {\n\
    \            if all_equal {\n                all_equal = false;\n            }\
    \ else {\n                return false;\n            }\n        }\n        prev\
    \ = *v;\n    }\n    true", "    let mut is_increasing = l[0] < l[1];\n    for\
    \ idx in 1..l.len() - 1 {\n        if (l[idx] < l[idx + 1]) != is_increasing {\n\
    \            return false;\n        }\n    }\n    true", "    let mut strictly_increasing\
    \ = true;\n    let mut strictly_decreasing = true;\n    for (prev, next) in l.iter().zip(l.iter().skip(1))\
    \ {\n        if prev > next {\n            strictly_increasing = false;\n    \
    \    }\n        if prev < next {\n            strictly_decreasing = false;\n \
    \       }\n    }\n    strictly_increasing || strictly_decreasing", "    let first\
    \ = l[0];\n    let mut prev = first;\n    let mut increasing = true;\n    for\
    \ v in l.iter().skip(1) {\n        if prev != *v {\n            if increasing\
    \ {\n                if prev > *v {\n                    increasing = false;\n\
    \                }\n            } else {\n                if prev < *v {\n   \
    \                 return false;\n                }\n            }\n        }\n\
    \        prev = *v;\n    }\n    true", "  for i in 1..l.len() {\n    if l[i] >\
    \ l[i-1] {\n      for i in i..l.len() {\n        if l[i] < l[i-1] {\n        \
    \  return false;\n        }\n      }\n    } else if l[i] < l[i-1] {\n      for\
    \ i in i..l.len() {\n        if l[i] > l[i-1] {\n          return false;\n   \
    \     }\n      }\n    }\n  }\n  true", "    let mut cur = 0;\n    for el in l\
    \ {\n        if el == cur {\n            return false;\n        }\n        cur\
    \ = el;\n    }\n    true", "    return match l[0] {\n        x if x > l[1] =>\
    \ decreasing(l),\n        x if x < l[1] => increasing(l),\n        _ => true,\n\
    \    };", "    let (mut inc, mut dec) = (true, true);\n    for (a, b) in l.iter().zip(l.iter().skip(1))\
    \ {\n        if a > b {\n            inc = false;\n        }\n        if a < b\
    \ {\n            dec = false;\n        }\n    }\n    inc || dec", "    let mut\
    \ last = l[0];\n    let sign = if l[1] > last {1} else {-1};\n    for x in l.iter().skip(1)\
    \ {\n        if *x * sign < last * sign {\n            return false;\n       \
    \ }\n        last = *x;\n    }\n    true", "    // Use the first two elements\
    \ to determine if the list is increasing\n    // or decreasing\n    let len =\
    \ l.len();\n    if len <= 1 {\n        return true;\n    }\n    let mut is_increasing\
    \ = l[0] < l[1];\n    for i in 1..len - 1 {\n        if is_increasing {\n    \
    \        if l[i] > l[i + 1] {\n                return false;\n            }\n\
    \        } else {\n            if l[i] < l[i + 1] {\n                return false;\n\
    \            }\n        }\n    }\n    true", "    let mut m = true;\n    let mut\
    \ i = 0;\n    while i < l.len() - 1 {\n        if (l[i] - l[i + 1]).abs() > 1\
    \ {\n            m = false;\n            break;\n        }\n        i += 1;\n\
    \    }\n    m", "    let mut l_i = l.iter();\n    if let Some(initial) = l_i.next()\
    \ {\n        let mut last = *initial;\n        for el in l_i {\n            if\
    \ *el < last {\n                return false;\n            }\n            last\
    \ = *el;\n        }\n    }\n    true", "    let len = l.len();\n    if len < 2\
    \ {\n        return true;\n    }\n    let mut delta = l[1] - l[0];\n    for i\
    \ in 1..len - 1 {\n        if (l[i + 1] - l[i]) * delta < 0 {\n            return\
    \ false;\n        }\n    }\n    true", "    let mut prev = l[0];\n    let mut\
    \ inc = l[0] < l[1];\n    for i in l {\n        if inc {\n            if i < prev\
    \ {\n                return false;\n            }\n        } else {\n        \
    \    if i > prev {\n                return false;\n            }\n        }\n\
    \        prev = i;\n    }\n    true", "    let mut increasing = true;\n    let\
    \ mut decreasing = true;\n    let mut previous = 0;\n    for elem in l {\n   \
    \     if elem < previous {\n            increasing = false;\n        }\n     \
    \   if elem > previous {\n            decreasing = false;\n        }\n       \
    \ previous = elem;\n    }\n    increasing || decreasing", "    for w in l.windows(2)\
    \ {\n        let diff = w[1] - w[0];\n        if diff > 0 {\n            if monotonic_increasing.is_none()\
    \ {\n                monotonic_increasing = Some(true);\n            } else if\
    \ monotonic_increasing != Some(true) {\n                return false;\n      \
    \      }\n        } else if diff < 0 {\n            if monotonic_increasing.is_none()\
    \ {\n                monotonic_increasing = Some(false);\n            } else if\
    \ monotonic_increasing != Some(false) {\n                return false;\n     \
    \       }\n        }\n    }\n    true", "    let increasing = l.iter().fold((isize::min_value(),\
    \ false), |(last, increasing), &cur| {\n        if cur < last {\n            (cur,\
    \ false)\n        } else {\n            (cur, increasing)\n        }\n    }).1;\n\
    \    let decreasing = l.iter().fold((isize::max_value(), false), |(last, decreasing),\
    \ &cur| {\n        if cur > last {\n            (cur, false)\n        } else {\n\
    \            (cur, decreasing)\n        }\n    }).1;\n    increasing || decreasing",
  "    let s = l.iter().fold((0, isize::max_value()), |(state, prev), next| {\n  \
    \      match state {\n            0 => {\n                if prev > *next {\n\
    \                    (1, *next)\n                } else if prev < *next {\n  \
    \                  (2, *next)\n                } else {\n                    (0,\
    \ *next)\n                }\n            }\n            1 => {\n             \
    \   if prev < *next {\n                    (0, *next)\n                } else\
    \ {\n                    (1, *next)\n                }\n            }\n      \
    \      2 => {\n                if prev > *next {\n                    (0, *next)\n\
    \                } else {\n                    (2, *next)\n                }\n\
    \            }\n            _ => panic!(\"Illegal state\"),\n        }\n    });\n\
    \    s.0 != 0", "    let mut d: Vec<isize> = vec![];\n    for i in 1..l.len()\
    \ {\n        d.push(l[i] - l[i - 1]);\n    }\n    match d.iter().all(|n| *n ==\
    \ d[0]) {\n        true => {\n            if d[0] < 0 {\n                false\n\
    \            } else {\n                true\n            }\n        }\n      \
    \  false => false,\n    }", "    match l.len() {\n        0 => true,\n       \
    \ 1 => true,\n        2 => l[0] <= l[1],\n        _ => {\n            let mut\
    \ a = l[0];\n            let mut b = l[1];\n            if b < a {\n         \
    \       std::mem::swap(&mut a, &mut b);\n            }\n            (1..l.len()).all(|i|\
    \ {\n                let c = l[i];\n                if c >= b {\n            \
    \        a = b;\n                    b = c;\n                    true\n      \
    \          } else if c <= a {\n                    a = c;\n                  \
    \  true\n                } else {\n                    false\n               \
    \ }\n            })\n        }\n    }", "    for (i, j) in l.iter().zip(l.iter().skip(1))\
    \ {\n        if *i < *j {\n            return false;\n        }\n    }\n    true",
  "    if l.len() <= 1 {\n        return true;\n    }\n    let mut direction = l[1]\
    \ - l[0];\n    for i in 2..l.len() {\n        if direction == 0 {\n          \
    \  direction = l[i] - l[i - 1];\n        } else if direction > 0 && l[i] < l[i\
    \ - 1] {\n            return false;\n        } else if direction < 0 && l[i] >\
    \ l[i - 1] {\n            return false;\n        }\n    }\n    true", "    //\
    \ this vector will store the differences between adjacent list elements\n    let\
    \ mut diff = Vec::new();\n    // iterate over a pair of adjacent list elements\n\
    \    for i in l.iter().zip(l.iter().skip(1)) {\n        // determine the difference\
    \ between adjacent elements\n        diff.push(i.1 - i.0);\n    }\n    // check\
    \ if all differences are positive or negative\n    diff.iter().all(|&x| x >= 0)\
    \ || diff.iter().all(|&x| x <= 0)", "    let mut incr = true;\n    let mut decr\
    \ = true;\n    for (a, b) in l.iter().zip(l.iter().skip(1)) {\n        if a >\
    \ b {\n            incr = false;\n        }\n        if a < b {\n            decr\
    \ = false;\n        }\n    }\n    incr || decr", "    if l.len() <= 1 {\n    \
    \    return true;\n    }\n    let mut increasing = l[0] < l[1];\n    for i in\
    \ 1..l.len() - 1 {\n        if increasing && l[i] > l[i + 1] {\n            return\
    \ false;\n        }\n        if !increasing && l[i] < l[i + 1] {\n           \
    \ return false;\n        }\n    }\n    true", "    let mut monotonic = true;\n\
    \    let mut i = 0;\n    while monotonic && i < l.len() - 1 {\n        monotonic\
    \ = l[i] == l[i + 1] || l[i] < l[i + 1];\n        i += 1;\n    }\n    monotonic",
  "    let mut sign = 0;\n    for e in l {\n        let s = if e > 0 { 1 } else if\
    \ e < 0 { -1 } else { 0 };\n        if sign == 0 {\n            sign = s;\n  \
    \      } else if sign == 1 && s == -1 {\n            return false;\n        }\
    \ else if sign == -1 && s == 1 {\n            return false;\n        }\n    }\n\
    \    true", "    match l.iter().fold((None, None), |(prev, sign), val| {\n   \
    \     if let Some(s) = sign {\n            if *val == prev.unwrap() {\n      \
    \          return (Some(*val), Some(s));\n            }\n            let diff\
    \ = val - prev.unwrap();\n            if diff.abs() == 1 {\n                if\
    \ diff.signum() == s {\n                    return (Some(*val), Some(s));\n  \
    \              }\n            }\n            return (Some(*val), None);\n    \
    \    }\n        (Some(*val), Some(val.signum()))\n    }) {\n        (_, Some(_))\
    \ => true,\n        _ => false,\n    }", "    let mut t = 0;\n    for i in 1..l.len()\
    \ {\n        let d = l[i] - l[i - 1];\n        if d == 0 {\n            return\
    \ false;\n        }\n        if t != 0 && d * t < 0 {\n            return false;\n\
    \        }\n        t = d;\n    }\n    true", "    let mut prev = l[0];\n    let\
    \ inc = l[1] > prev;\n    let dec = l[1] < prev;\n    for n in l {\n        if\
    \ inc && n < prev {\n            return false;\n        }\n        if dec && n\
    \ > prev {\n            return false;\n        }\n        prev = n;\n    }\n \
    \   true", "    let n = l.len();\n    if n < 2 {\n        return true;\n    }\n\
    \    let mut i = 1;\n    let mut increasing = l[1] > l[0];\n    loop {\n     \
    \   if i == n {\n            return true;\n        }\n        if l[i] < l[i -\
    \ 1] && increasing {\n            return false;\n        }\n        if l[i] >\
    \ l[i - 1] && !increasing {\n            return false;\n        }\n        i +=\
    \ 1;\n    }", "    let mut up = false;\n    let mut down = false;\n    for i in\
    \ 1..l.len() {\n        if l[i] > l[i - 1] {\n            up = true;\n       \
    \ } else if l[i] < l[i - 1] {\n            down = true;\n        }\n        if\
    \ up && down {\n            return false;\n        }\n    }\n    true", "    let\
    \ mut prev = l[0];\n    let mut dir = 0;\n    for &e in l.iter().skip(1) {\n \
    \       if dir == 0 {\n            if e > prev {\n                dir = 1;\n \
    \           } else if e < prev {\n                dir = -1;\n            }\n \
    \       } else if (e - prev) * dir < 0 {\n            return false;\n        }\n\
    \        prev = e;\n    }\n    true", "    let first = l[0];\n    let mut increasing\
    \ = true;\n    let mut decreasing = true;\n    for &x in l.iter().skip(1) {\n\
    \        if x < first {\n            increasing = false;\n        }\n        if\
    \ x > first {\n            decreasing = false;\n        }\n    }\n    increasing\
    \ || decreasing", "    let mut inc = true;\n    let mut dec = true;\n    for i\
    \ in 1..l.len() {\n        if l[i] < l[i - 1] {\n            inc = false;\n  \
    \      }\n        if l[i] > l[i - 1] {\n            dec = false;\n        }\n\
    \    }\n    inc || dec", "    let mut i = 0;\n    while i < l.len() - 1 {\n  \
    \      if l[i] > l[i + 1] {\n            return true;\n        }\n        i +=\
    \ 1;\n    }\n    false", "  let mut diffs = l.windows(2).map(|w| w[1] - w[0]);\n\
    \  let mut d = diffs.next().unwrap();\n  for d_ in diffs {\n    if d * d_ < 0\
    \ {\n      return false;\n    }\n    d = d_;\n  }\n  true", "    let mut incr\
    \ = true;\n    let mut decr = true;\n    for i in 1..l.len() {\n        if l[i]\
    \ < l[i - 1] {\n            incr = false;\n        }\n        if l[i] > l[i -\
    \ 1] {\n            decr = false;\n        }\n    }\n    incr || decr", "    let\
    \ mut arr = l.clone();\n    arr.sort();\n    arr == l || arr == l.iter().rev().collect()",
  "    if l.len() <= 1 {\n        return true;\n    }\n    let last = l[0];\n    let\
    \ inc = l[1] > last;\n    l.iter().skip(1).all(|&x| {\n        let res = inc ==\
    \ (x > last);\n        last = x;\n        res\n    })", "    fn check(x: isize,\
    \ y: isize) -> bool {\n        x <= y\n    }\n    let mut it = l.iter();\n   \
    \ let mut previous = it.next().unwrap();\n    for el in it {\n        if !check(*previous,\
    \ *el) {\n            return false;\n        }\n        previous = el;\n    }\n\
    \    true", "    match l.windows(2).all(|w| w[0] < w[1]) {\n        true => true,\n\
    \        false => l.windows(2).all(|w| w[0] > w[1]),\n    }", "    let mut m =\
    \ 1;\n    for i in 1..l.len() {\n        let diff = l[i] - l[i - 1];\n       \
    \ if diff != 0 {\n            if m != 0 && m != diff.signum() {\n            \
    \    return false;\n            }\n            m = diff.signum();\n        }\n\
    \    }\n    true", "    fn monotonic_increasing(l: Vec<isize>) -> bool {\n   \
    \     // ...\n\n        true\n    }\n\n    fn monotonic_decreasing(l: Vec<isize>)\
    \ -> bool {\n        // ...\n\n        true\n    }\n\n    if l.len() < 2 {\n \
    \       return true;\n    }\n\n    // ...\n\n    true", "    let mut curr = 0;\n\
    \    for e in l {\n        if e > curr {\n            curr = e;\n        } else\
    \ if e < curr {\n            return false;\n        }\n    }\n    true", "   \
    \ let mut increasing = true;\n    let mut decreasing = true;\n    for i in 1..l.len()\
    \ {\n        if l[i] < l[i - 1] {\n            increasing = false;\n        }\n\
    \        if l[i] > l[i - 1] {\n            decreasing = false;\n        }\n  \
    \  }\n    increasing || decreasing", "    // A: whether values have been seen\
    \ monotonically increasing so far,\n    // or monotonically decreasing so far.\n\
    \    // B: whether values have been seen at all.\n    let (mut a, mut b) = (true,\
    \ false);\n    for (c, d) in l.iter().enumerate() {\n        if c == 0 {\n   \
    \         continue;\n        }\n        let e = l[c - 1];\n        if e < *d {\n\
    \            if !b {\n                b = true;\n            } else if !a {\n\
    \                return false;\n            }\n        } else if e > *d {\n  \
    \          if !b {\n                b = true;\n            } else if a {\n   \
    \             a = false;\n            } else {\n                return false;\n\
    \            }\n        }\n    }\n    true", "    let mut status = 0;\n    for\
    \ i in 1..l.len() {\n        let diff = l[i] - l[i - 1];\n        if diff == 0\
    \ {\n            continue;\n        }\n        if status == 0 {\n            status\
    \ = diff;\n        } else if status * diff < 0 {\n            return false;\n\
    \        }\n    }\n    true", "    let mut prev = 0;\n    let mut increasing =\
    \ true;\n    for i in l {\n        if prev == 0 {\n            prev = i;\n   \
    \         continue;\n        }\n        if prev > i {\n            increasing\
    \ = false;\n        }\n        if (prev > i && increasing) || (prev < i && !increasing)\
    \ {\n            return false;\n        }\n        prev = i;\n    }\n    true",
  "    let mut res = true;\n    let mut i = 0;\n    let mut check = true;\n    let\
    \ mut delta = 0;\n    while i < l.len()-1 && res {\n        if delta == 0 {\n\
    \            delta = l[i+1] - l[i];\n        }\n        if (l[i+1] - l[i]) * delta\
    \ < 0 {\n            check = false;\n        }\n        res = check;\n       \
    \ i += 1;\n    }\n    res", "    match l.len() {\n        0 => true,\n       \
    \ 1 => true,\n        2 => true,\n        _ => {\n            let d = l[1] - l[0];\n\
    \            for i in 2..l.len() {\n                if (l[i] - l[i - 1]) * d <\
    \ 0 {\n                    return false;\n                }\n            }\n \
    \           true\n        }\n    }", "    let mut last = l[0];\n    let mut increasing\
    \ = false;\n    let mut decreasing = false;\n    for i in l {\n        if i >\
    \ last {\n            increasing = true;\n        } else if i < last {\n     \
    \       decreasing = true;\n        }\n        last = i;\n    }\n    increasing\
    \ && !decreasing || !increasing && decreasing", "    let n = l.len();\n    let\
    \ mut up = true;\n    let mut down = true;\n    for i in 1..n {\n        if l[i]\
    \ < l[i - 1] {\n            up = false;\n        }\n        if l[i] > l[i - 1]\
    \ {\n            down = false;\n        }\n    }\n    up || down", "    // verify\
    \ for empty lists\n    if l.len() == 0 {\n        return true;\n    }\n\n    //\
    \ get first element\n    let mut last = l[0];\n\n    // iterate to the end\n \
    \   for i in 1..l.len() {\n        // if element is greater than previous return\
    \ False\n        if l[i] > last {\n            return false;\n        }\n    \
    \    // update the current with last\n        last = l[i];\n    }\n\n    // if\
    \ we reach to end of list, return True\n    true", '    l.windows(2).all(|w| w[0]
    == w[1] || w[0] < w[1] || w[0] > w[1])', "    let mut dec = true;\n    let mut\
    \ inc = true;\n    for (i, e) in l.iter().enumerate() {\n        match i {\n \
    \           0 => continue,\n            _ => {\n                dec = dec && (e\
    \ < &l[i - 1]);\n                inc = inc && (e > &l[i - 1]);\n            }\n\
    \        }\n    }\n    dec || inc", "    let mut direction = 0;\n    for a in\
    \ 1..l.len() {\n        let slope = (l[a] - l[a - 1]) / (a as isize - (a - 1)\
    \ as isize);\n        if slope == 0 {\n            continue;\n        }\n    \
    \    if direction == 0 {\n            direction = slope / slope.abs();\n     \
    \   } else if direction != slope / slope.abs() {\n            return false;\n\
    \        }\n    }\n    true", "    if l.len() < 2 {\n        return true;\n  \
    \  }\n    let dir = l[1] - l[0];\n    if dir == 0 {\n        return true;\n  \
    \  }\n    let mut prev = l[0];\n    for i in 1..l.len() {\n        if (l[i] -\
    \ prev) * dir < 0 {\n            return false;\n        }\n        prev = l[i];\n\
    \    }\n    true", "    let mut decreasing = true;\n    let mut increasing = true;\n\
    \    for i in 1..l.len() {\n        decreasing &= l[i] < l[i - 1];\n        increasing\
    \ &= l[i] > l[i - 1];\n    }\n    decreasing || increasing", "    let mut prev\
    \ = None;\n    for e in l {\n        match prev {\n            None => prev =\
    \ Some(e),\n            Some(p) => if (p < e) != l[0] < l[1] {\n             \
    \   return false;\n            }\n        }\n    }\n    true", '    l.windows(2).all(|w|
    w[0] <= w[1]) || l.windows(2).all(|w| w[0] >= w[1])', "    match l[0] <= l[1]\
    \ {\n        true => l.windows(2).all(|w| w[0] <= w[1]),\n        false => l.windows(2).all(|w|\
    \ w[0] >= w[1]),\n    }", "    let mut increasing = true;\n    let mut decreasing\
    \ = true;\n    for i in 1..l.len() {\n        if l[i] < l[i - 1] {\n         \
    \   increasing = false;\n        }\n        if l[i] > l[i - 1] {\n           \
    \ decreasing = false;\n        }\n    }\n    increasing || decreasing", "    let\
    \ mut i = 0;\n    while i < l.len() - 1 {\n        if l[i] != l[i + 1] {\n   \
    \         break;\n        }\n        i += 1;\n    }\n    if i == l.len() - 1 {\n\
    \        return true;\n    }\n    let inc = l[i] < l[i + 1];\n    while i < l.len()\
    \ - 1 {\n        if l[i] == l[i + 1] {\n            return false;\n        }\n\
    \        if inc != (l[i] < l[i + 1]) {\n            return false;\n        }\n\
    \        i += 1;\n    }\n    true", "    let mut dir = 0;\n    for i in 1..l.len()\
    \ {\n        let d = l[i] - l[i - 1];\n        if d != 0 {\n            if dir\
    \ != 0 && dir != d {\n                return false;\n            }\n         \
    \   dir = d;\n        }\n    }\n    true", "    let mut increasing = true;\n \
    \   let mut decreasing = true;\n    let mut last = l[0];\n    for i in l.iter()\
    \ {\n        if *i > last {\n            decreasing = false;\n        } else if\
    \ *i < last {\n            increasing = false;\n        }\n        last = *i;\n\
    \    }\n    return increasing || decreasing;", "    let mut inc = true;\n    let\
    \ mut dec = true;\n    for i in 1..l.len() {\n        inc &= l[i] >= l[i - 1];\n\
    \        dec &= l[i] <= l[i - 1];\n    }\n    inc || dec", "    let mut is_increasing\
    \ = true;\n    let mut is_decreasing = true;\n    for i in 1..l.len() {\n    \
    \    if l[i - 1] < l[i] {\n            is_decreasing = false;\n        }\n   \
    \     if l[i - 1] > l[i] {\n            is_increasing = false;\n        }\n  \
    \  }\n    is_increasing || is_decreasing", "    if l.len() < 2 {\n        return\
    \ true;\n    }\n    let first = l[0];\n    let step = l[1] - first;\n    for i\
    \ in 1..l.len() {\n        if l[i] - l[i - 1] != step {\n            return false;\n\
    \        }\n    }\n    true", "    let mut increasing = true;\n    let mut decreasing\
    \ = true;\n    for i in 1..l.len() {\n        increasing = increasing && l[i]\
    \ >= l[i - 1];\n        decreasing = decreasing && l[i] <= l[i - 1];\n    }\n\
    \    increasing || decreasing", "    // Using isize type because of \"-\" operation\n\
    \    let mut y = l[0];\n    let mut z = y;\n    let mut increasing = true;\n \
    \   let mut decreasing = true;\n    for x in l.iter() {\n        increasing =\
    \ increasing && y <= *x;\n        decreasing = decreasing && y >= *x;\n      \
    \  z = y;\n        y = *x;\n    }\n    increasing || decreasing", "    l.iter().enumerate().any(|(i,\
    \ _)| {\n        (i + 1 < l.len()) &&\n        (l[i] <= l[i + 1])\n    })", " \
    \   for w in l.windows(2) {\n        if w[0] > w[1] {\n            return false;\n\
    \        }\n    }\n    true", "    let mut same = true;\n    let mut ascending\
    \ = false;\n    for i in 1..l.len() {\n        if l[i] > l[i - 1] {\n        \
    \    if !ascending && !same {\n                return false;\n            }\n\
    \            ascending = true;\n            same = false;\n        } else if l[i]\
    \ < l[i - 1] {\n            if ascending && !same {\n                return false;\n\
    \            }\n            ascending = false;\n            same = false;\n  \
    \      }\n    }\n    true", "    let mut m = l[0];\n    let mut increasing = m\
    \ < l[1];\n    for n in l.iter().skip(1) {\n        if increasing && m > *n {\n\
    \            return false;\n        }\n        if !increasing && m < *n {\n  \
    \          return false;\n        }\n        m = *n;\n    }\n    true", "    let\
    \ mut m = true;\n    for i in 1..l.len() {\n        if l[i] < l[i - 1] {\n   \
    \         m = false;\n            break;\n        }\n    }\n    if m {\n     \
    \   return true;\n    }\n    let mut m = true;\n    for i in 1..l.len() {\n  \
    \      if l[i] > l[i - 1] {\n            m = false;\n            break;\n    \
    \    }\n    }\n    if m {\n        return true;\n    }\n    false", "    let up\
    \ = l.windows(2).all(|x| x[0] <= x[1]);\n    let down = l.windows(2).all(|x| x[0]\
    \ >= x[1]);\n    up || down", '    l.windows(2).map(|win| win[1] - win[0]).all(|x|
    x == 1 || x == -1)', "    let mut up = true;\n    let mut down = true;\n    for\
    \ i in 1..l.len() {\n        if l[i] < l[i - 1] {\n            up = false;\n \
    \       }\n        if l[i] > l[i - 1] {\n            down = false;\n        }\n\
    \    }\n    return up || down;", "    let mut i = 1;\n    let mut increasing =\
    \ true;\n    let mut decreasing = true;\n    while i < l.len() {\n        if l[i]\
    \ < l[i - 1] {\n            increasing = false;\n        }\n        if l[i] >\
    \ l[i - 1] {\n            decreasing = false;\n        }\n        i += 1;\n  \
    \  }\n    return increasing || decreasing;", "    let first = l[0];\n    let mut\
    \ direction = 0;\n\n    for i in 1..l.len() {\n        if first < l[i] {\n   \
    \         if direction == -1 {\n                return false;\n            }\n\
    \            direction = 1;\n        } else if first > l[i] {\n            if\
    \ direction == 1 {\n                return false;\n            }\n           \
    \ direction = -1;\n        }\n    }\n\n    true", "    let direction = l[1] -\
    \ l[0];\n    l.windows(2).all(|pair| {\n        let diff = pair[1] - pair[0];\n\
    \        diff == direction || diff == 0\n    })", "    let mut is_dec = false;\n\
    \    let mut is_inc = false;\n    let mut d = isize::max_value();\n    for n in\
    \ l {\n        if n < d {\n            is_dec = true;\n        } else if n > d\
    \ {\n            is_inc = true;\n        }\n        d = n;\n    }\n    is_dec\
    \ && is_inc", "    // Return True if the list is empty or has one element\n  \
    \  if l.len() <= 1 {\n        return true;\n    }\n\n    let mut diffs = Vec::new();\n\
    \    for i in 0..l.len() - 1 {\n        diffs.push(l[i + 1] - l[i]);\n    }\n\n\
    \    for i in 1..diffs.len() {\n        if diffs[i] * diffs[i - 1] < 0 {\n   \
    \         return false;\n        }\n    }\n\n    true", "    let mut inc = true;\n\
    \    let mut dec = true;\n    let mut last = l[0];\n    for cur in l.iter().skip(1)\
    \ {\n        if *cur < last {\n            inc = false;\n        }\n        if\
    \ *cur > last {\n            dec = false;\n        }\n        last = *cur;\n \
    \   }\n    inc || dec", "    if l.len() == 0 {\n        return true;\n    }\n\
    \    let mut m = l[0];\n    let mut inc = l[0] < l[1];\n    for e in l.iter().skip(1)\
    \ {\n        if inc && *e < m {\n            return false;\n        }\n      \
    \  if !inc && *e > m {\n            return false;\n        }\n        m = *e;\n\
    \    }\n    true", "    let (mut inc, mut dec) = (true, true);\n    for i in 1..l.len()\
    \ {\n        if l[i] < l[i - 1] {\n            inc = false;\n        }\n     \
    \   if l[i] > l[i - 1] {\n            dec = false;\n        }\n    }\n    inc\
    \ || dec", "    let mut monotonic = true;\n    let mut prev = l[0];\n    for v\
    \ in l {\n        if v < prev {\n            monotonic = false;\n            break;\n\
    \        }\n        prev = v;\n    }\n    monotonic", "    match l.len() {\n \
    \       0 => true,\n        1 => true,\n        2 => l[0] != l[1],\n        _\
    \ => {\n            let fst = l[0];\n            let snd = l[1];\n           \
    \ let (increasing, decreasing) = (fst < snd, fst > snd);\n            l.iter().skip(2).fold((increasing,\
    \ decreasing), |(inc, dec), &x| {\n                let inc_val = inc && x >= fst;\n\
    \                let dec_val = dec && x <= fst;\n                (inc_val, dec_val)\n\
    \            })\n        }\n    }", "    let size = l.len();\n    let mut dir\
    \ = 0;\n    for i in 1..size {\n        if l[i] > l[i - 1] {\n            if dir\
    \ > 0 {\n                return false;\n            }\n            dir = 1;\n\
    \        } else if l[i] < l[i - 1] {\n            if dir < 0 {\n             \
    \   return false;\n            }\n            dir = -1;\n        }\n    }\n  \
    \  true", "    let mut last = 0;\n    let mut monotonic = true;\n    for n in\
    \ l {\n        if last == 0 {\n            last = n;\n        } else if last >\
    \ n {\n            monotonic = false;\n            break;\n        }\n       \
    \ last = n;\n    }\n    monotonic", "    let first = l[0];\n    let mut increasing\
    \ = true;\n    let mut decreasing = true;\n    for i in l {\n        if i < first\
    \ {\n            increasing = false;\n        }\n        if i > first {\n    \
    \        decreasing = false;\n        }\n    }\n    increasing || decreasing",
  "    let mut inc = false;\n    let mut dec = false;\n    for w in l.windows(2) {\n\
    \        inc = inc || w[0] < w[1];\n        dec = dec || w[0] > w[1];\n    }\n\
    \    inc && !dec || dec && !inc", "    if l.len() <= 1 {\n        return true;\n\
    \    }\n    let first = l[0];\n    let mut asc = true;\n    let mut desc = true;\n\
    \    for &e in l.iter().skip(1) {\n        if e > first {\n            desc =\
    \ false;\n        } else if e < first {\n            asc = false;\n        }\n\
    \    }\n    asc || desc", "    let mut it = l.iter();\n    let mut previous =\
    \ *it.next().unwrap();\n    let mut increasing = true;\n    for current in it\
    \ {\n        if previous > current {\n            increasing = false;\n      \
    \  }\n        if previous < current {\n            if !increasing {\n        \
    \        return false;\n            }\n        }\n        previous = *current;\n\
    \    }\n    true", '  l.windows(2).all(|w| w[0] <= w[1]) || l.windows(2).all(|w|
    w[0] >= w[1])', "    if l.len() < 2 {\n        false\n    } else {\n        let\
    \ dir = l[1] - l[0];\n        if dir == 0 {\n            return false;\n     \
    \   }\n        for i in 2..l.len() {\n            if dir * (l[i] - l[i - 1]) <\
    \ 0 {\n                return false;\n            }\n        }\n        true\n\
    \    }", "    let m = l.len() as isize;\n    for i in 1..m {\n        if l[i as\
    \ usize] > l[(i - 1) as usize] {\n            return false;\n        }\n    }\n\
    \    true", "    let mut p = l[0];\n    let mut inc = false;\n    let mut dec\
    \ = false;\n    for n in l {\n        if n > p {\n            inc = true;\n  \
    \      } else if n < p {\n            dec = true;\n        }\n        if inc &&\
    \ dec {\n            return false;\n        }\n        p = n;\n    }\n    true",
  "    if l.len() <= 1 {\n        return true;\n    }\n    let mut d = l[1] - l[0];\n\
    \    for i in 2..l.len() {\n        if (l[i] - l[i - 1]) * d < 0 {\n         \
    \   return false;\n        }\n    }\n    true", "    let mut b: bool = false;\n\
    \    let mut i: usize = 0;\n    while i < l.len() - 1 {\n        if b {\n    \
    \        if l[i] > l[i + 1] {\n                return false;\n            }\n\
    \        } else {\n            if l[i] < l[i + 1] {\n                return false;\n\
    \            }\n        }\n        i += 1;\n        b = !b;\n    }\n    true",
  "    // TODO: find the base case and the inductive step\n    unimplemented!()",
  "    if l.len() == 0 {\n        return true;\n    }\n    let first = l[0];\n   \
    \ let direction = if first < 0 {\n        -1\n    } else {\n        1\n    };\n\
    \    for i in 0..l.len() - 1 {\n        if l[i] * direction < l[i + 1] * direction\
    \ {\n            return false;\n        }\n    }\n    true", "    let mut previous\
    \ = None;\n    for el in l {\n        if let Some(prev) = previous {\n       \
    \     if prev > el {\n                return false;\n            }\n        }\n\
    \        previous = Some(el);\n    }\n    true", "    let mut i = 1;\n    while\
    \ i < l.len() {\n        if l[i] == l[i - 1] {\n            i += 1;\n        \
    \    continue;\n        }\n        let diff = l[i] - l[i - 1];\n        let step\
    \ = diff / diff.abs();\n        while i < l.len() && (l[i] - l[i - 1]) == step\
    \ {\n            i += 1;\n        }\n        if i < l.len() {\n            return\
    \ false;\n        }\n    }\n    true", '    l.windows(2).all(|x| x[0] <= x[1])
    || l.windows(2).all(|x| x[0] >= x[1])', "    assert!(l.len() > 0);\n    match\
    \ l[0] < l[l.len() - 1] {\n        true => {\n            l.windows(2).all(|w|\
    \ w[0] <= w[1])\n        },\n        false => {\n            l.windows(2).all(|w|\
    \ w[0] >= w[1])\n        }\n    }", "    let mut incr = true;\n    let mut decr\
    \ = true;\n    let mut prev = l[0];\n    for &x in l.iter().skip(1) {\n      \
    \  incr &= x >= prev;\n        decr &= x <= prev;\n        prev = x;\n    }\n\
    \    incr || decr", "    let mut n = 0;\n    for i in 0..l.len() - 1 {\n     \
    \   let x = l[i];\n        let y = l[i + 1];\n        if x < y {\n           \
    \ n += 1;\n        } else if x > y {\n            n -= 1;\n        }\n    }\n\
    \    n.abs() == l.len() - 1", "  let mut m = 0;\n  let mut n = 0;\n  for x in\
    \ l.iter() {\n    if x > &m {\n      m = *x;\n      n += 1;\n    } else if x <\
    \ &m {\n      m = *x;\n      n -= 1;\n    }\n  }\n  n == l.len() as isize || n\
    \ == -(l.len() as isize)", "    for (i, &x) in l.iter().enumerate() {\n      \
    \  if i > 0 {\n            if !(l[i - 1] < x || l[i - 1] > x) {\n            \
    \    return false;\n            }\n        }\n    }\n    true", "    let mut m\
    \ = l[0];\n    let mut d = None;\n    for &e in l.iter().skip(1) {\n        let\
    \ cur = if e > m { Some(1) } else if e < m { Some(-1) } else { None };\n     \
    \   if d.is_none() {\n            d = cur;\n        } else if let Some(c) = cur\
    \ {\n            if d != Some(c) {\n                return false;\n          \
    \  }\n        }\n        m = e;\n    }\n    true", "    let mut forward = true;\n\
    \    let mut reverse = true;\n    let mut last = l[0];\n    for e in l.iter().skip(1)\
    \ {\n        forward = forward && e >= &last;\n        reverse = reverse && e\
    \ <= &last;\n        last = *e;\n    }\n    forward || reverse", "    let mut\
    \ increasing = true;\n    let mut decreasing = true;\n    for i in 1..l.len()\
    \ {\n        if l[i] < l[i - 1] {\n            increasing = false;\n        }\n\
    \        if l[i] > l[i - 1] {\n            decreasing = false;\n        }\n  \
    \  }\n    increasing || decreasing", "    let mut t = true;\n    let mut r = true;\n\
    \    let mut l_iter = l.iter();\n    match l_iter.next() {\n        Some(x) =>\
    \ {\n            for y in l_iter {\n                t = t && (*x <= *y);\n   \
    \             r = r && (*x >= *y);\n                if !t && !r {\n          \
    \          return false;\n                }\n                x = y;\n        \
    \    }\n        }\n        None => {\n            return false;\n        }\n \
    \   }\n    true", "    let mut t = 0;\n    for i in 1..l.len() {\n        if l[i\
    \ - 1] < l[i] {\n            if t == -1 {\n                return false;\n   \
    \         }\n            t = 1;\n        } else if l[i - 1] > l[i] {\n       \
    \     if t == 1 {\n                return false;\n            }\n            t\
    \ = -1;\n        }\n    }\n    true", "    let mut last = None;\n    for el in\
    \ l {\n        if let Some(prev) = last {\n            if el < prev {\n      \
    \          return false;\n            }\n        }\n        last = Some(el);\n\
    \    }\n    true", "    let mut i = 0;\n    let mut result = true;\n    while\
    \ result && i < l.len() - 1 {\n        result = l[i] < l[i + 1] || l[i] > l[i\
    \ + 1];\n        i += 1;\n    }\n    result", "    let mut slope = 0;\n    let\
    \ mut last = *l.get(0).unwrap();\n    for e in l.iter().skip(1) {\n        if\
    \ slope == 0 {\n            if *e > last {\n                slope = 1;\n     \
    \       } else if *e < last {\n                slope = -1;\n            }\n  \
    \      } else if *e > last && slope == -1 {\n            return false;\n     \
    \   } else if *e < last && slope == 1 {\n            return false;\n        }\n\
    \        last = *e;\n    }\n    true", "    let mut decreasing = false;\n    let\
    \ mut increasing = false;\n    for i in 1..l.len() {\n        if l[i] < l[i -\
    \ 1] {\n            decreasing = true;\n        } else if l[i] > l[i - 1] {\n\
    \            increasing = true;\n        }\n        if decreasing && increasing\
    \ {\n            return false;\n        }\n    }\n    true", "    if l.len() ==\
    \ 0 {\n        return true;\n    }\n    let mut b = l[0];\n    let mut d = 0;\n\
    \    for i in 1..l.len() {\n        if b < l[i] {\n            if d == -1 {\n\
    \                return false;\n            }\n            d = 1;\n        } else\
    \ if b > l[i] {\n            if d == 1 {\n                return false;\n    \
    \        }\n            d = -1;\n        }\n        b = l[i];\n    }\n    true",
  "    let mut dir = 0;\n    for (i, e) in l.iter().enumerate() {\n        if i >\
    \ 0 {\n            let ndir = (e - &l[i - 1]).signum();\n            if dir ==\
    \ 0 {\n                dir = ndir;\n            } else if dir != ndir {\n    \
    \            return false;\n            }\n        }\n    }\n    true", "    let\
    \ mut up = true;\n    let mut down = true;\n    let mut last = None;\n    for\
    \ v in l {\n        if let Some(last) = last {\n            if last < v {\n  \
    \              down = false;\n            } else if last > v {\n             \
    \   up = false;\n            }\n        }\n        last = Some(v);\n    }\n  \
    \  up || down", "    let mut last = None;\n    for x in l {\n        match last\
    \ {\n            None => last = Some(x),\n            Some(x2) => {\n        \
    \        if x > x2 && !l.iter().all(|a| *a > x2) {\n                    return\
    \ false;\n                }\n                if x < x2 && !l.iter().all(|a| *a\
    \ < x2) {\n                    return false;\n                }\n            \
    \    last = Some(x);\n            }\n        }\n    }\n    true", "    let mut\
    \ l = l;\n    let mut dir = 0;\n    let mut prev = l.remove(0);\n    for x in\
    \ l {\n        let cmp = x.cmp(&prev);\n        if cmp != dir && dir != 0 {\n\
    \            return false;\n        }\n        dir = cmp;\n        prev = x;\n\
    \    }\n    true", "    let mut rise = None;\n    for i in 1..l.len() {\n    \
    \    let inc = l[i] - l[i - 1];\n        if rise.is_none() {\n            rise\
    \ = Some(inc);\n        } else if rise.unwrap() * inc < 0 {\n            return\
    \ false;\n        }\n    }\n    true", "    let mut i = 0;\n    while i < l.len()\
    \ - 1 {\n        if l[i] < l[i + 1] {\n            i += 1;\n        } else {\n\
    \            break;\n        }\n    }\n    let mut j = i;\n    while j < l.len()\
    \ - 1 {\n        if l[j] > l[j + 1] {\n            j += 1;\n        } else {\n\
    \            break;\n        }\n    }\n    j == l.len() - 1", '    l.windows(2).all(|w|
    w[0] < w[1]) || l.windows(2).all(|w| w[0] > w[1])', "    let (s, e) = if l[0]\
    \ < l[1] {\n        (l[0], l[1])\n    } else {\n        (l[1], l[0])\n    };\n\
    \    l.iter().skip(2).all(|v| if s < e { *v >= e } else { *v <= e })", "    let\
    \ mut increasing = true;\n    let mut decreasing = true;\n    for (i, j) in l.iter().zip(l.iter().skip(1))\
    \ {\n        if j < i {\n            increasing = false;\n        }\n        if\
    \ j > i {\n            decreasing = false;\n        }\n    }\n    increasing ||\
    \ decreasing", "    let mut prev = None;\n    for item in l {\n        if let\
    \ Some(prev_item) = prev {\n            if item < prev_item {\n              \
    \  return false;\n            }\n        }\n        prev = Some(item);\n    }\n\
    \    true", "    let mut first = true;\n    let mut inc = None;\n    for i in\
    \ l {\n        if first {\n            first = false;\n        } else {\n    \
    \        let delta = i - prev;\n            if delta != 0 {\n                if\
    \ inc.is_none() {\n                    inc = Some(delta > 0);\n              \
    \  } else if (delta > 0) != inc.unwrap() {\n                    return false;\n\
    \                }\n            }\n        }\n        prev = i;\n    }\n    true",
  "    let mut inc = true;\n    let mut dec = true;\n    for i in 1..l.len() {\n \
    \       inc &= l[i] >= l[i - 1];\n        dec &= l[i] <= l[i - 1];\n    }\n  \
    \  inc || dec", "    match l.windows(2).find(|x| x[0] == x[1]) {\n        Some(_)\
    \ => false,\n        None => true,\n    }", "    let monotonic = match l.windows(2).position(|w|\
    \ w[0] != w[1]) {\n        Some(i) => (l[i] < l[i + 1]) == (i == 0),\n       \
    \ None => true,\n    };\n    if monotonic {\n        true\n    } else {\n    \
    \    false\n    }", "    let mut increasing = true;\n    let mut decreasing =\
    \ true;\n    for i in 1..l.len() {\n        if l[i] < l[i - 1] {\n           \
    \ increasing = false;\n        }\n        if l[i] > l[i - 1] {\n            decreasing\
    \ = false;\n        }\n    }\n    increasing || decreasing", "    let mut ascending\
    \ = true;\n    let mut descending = true;\n    for i in 1..l.len() {\n       \
    \ if l[i] < l[i - 1] {\n            ascending = false;\n        }\n        if\
    \ l[i] > l[i - 1] {\n            descending = false;\n        }\n    }\n    ascending\
    \ || descending", "    let mut isincreasing = true;\n    let mut isdecreasing\
    \ = true;\n    for i in 1..l.len() {\n        if l[i - 1] > l[i] {\n         \
    \   isincreasing = false;\n        }\n        if l[i - 1] < l[i] {\n         \
    \   isdecreasing = false;\n        }\n    }\n    isincreasing || isdecreasing",
  "    let mut i = 0;\n    let mut dir = 0;\n\n    while i < l.len() - 1 {\n     \
    \   if l[i] < l[i + 1] {\n            if dir == -1 {\n                return false;\n\
    \            }\n            dir = 1;\n        } else if l[i] > l[i + 1] {\n  \
    \          if dir == 1 {\n                return false;\n            }\n     \
    \       dir = -1;\n        }\n        i += 1;\n    }\n    true", "    let mut\
    \ m = l[0];\n    let mut d = 0;\n    for i in l {\n        if i > m {\n      \
    \      m = i;\n            d = 1;\n        } else if i < m {\n            m =\
    \ i;\n            d = -1;\n        }\n    }\n    d != 0", "    let mut inc = true;\n\
    \    let mut dec = true;\n    let mut last = l[0];\n    for i in 1..l.len() {\n\
    \        if l[i] > last {\n            dec = false;\n        } else if l[i] <\
    \ last {\n            inc = false;\n        }\n        last = l[i];\n    }\n \
    \   inc || dec", "    let n = l.len();\n    // Check if values increase or decrease\n\
    \    let inc = l[0] < l[n - 1];\n    // Check if all values increase or decrease\n\
    \    for i in 1..n {\n        if (inc && l[i - 1] > l[i]) || (!inc && l[i - 1]\
    \ < l[i]) {\n            return false;\n        }\n    }\n    true", "  let mut\
    \ d = l[1] - l[0];\n  for i in 1..l.len() - 1 {\n    if (l[i + 1] - l[i]) * d\
    \ < 0 {\n      return false;\n    }\n  }\n  true", "    let mut decreasing = true;\n\
    \    let mut increasing = true;\n    for i in 1..l.len() {\n        decreasing\
    \ &= l[i] < l[i - 1];\n        increasing &= l[i] > l[i - 1];\n    }\n    decreasing\
    \ || increasing", "    let mut is_increasing = true;\n    let mut is_decreasing\
    \ = true;\n    for i in 1..l.len() {\n        if l[i] < l[i - 1] {\n         \
    \   is_increasing = false;\n        }\n        if l[i] > l[i - 1] {\n        \
    \    is_decreasing = false;\n        }\n    }\n    is_increasing || is_decreasing",
  "    let mut dec = true;\n    let mut inc = true;\n    for window in l.windows(2)\
    \ {\n        if window[0] > window[1] {\n            inc = false;\n        }\n\
    \        if window[0] < window[1] {\n            dec = false;\n        }\n   \
    \ }\n    dec || inc", "    let mut sorted = l.clone();\n    sorted.sort();\n \
    \   sorted == l || sorted.iter().rev().collect::<Vec<_>>() == l", "    match l[..]\
    \ {\n        [a, b, ..] if a < b => monotonic_increasing(l),\n        [a, b, ..]\
    \ if a > b => monotonic_decreasing(l),\n        _ => true,\n    }", "    // Check\
    \ if all elements are the same, if so return true\n    let mut all_the_same =\
    \ true;\n    for i in 1..l.len() {\n        if l[i] != l[i - 1] {\n          \
    \  all_the_same = false;\n            break;\n        }\n    }\n    if all_the_same\
    \ {\n        return true;\n    }\n\n    // Check if all elements are monotonically\
    \ increasing or decreasing\n    let mut increasing = true;\n    let mut decreasing\
    \ = true;\n    for i in 1..l.len() {\n        if l[i] < l[i - 1] {\n         \
    \   increasing = false;\n        }\n        if l[i] > l[i - 1] {\n           \
    \ decreasing = false;\n        }\n    }\n    return increasing || decreasing;",
  "    let n = l.len();\n    for i in 0..n-1 {\n        if (l[i] < l[i+1]) && (l[i+1]\
    \ - l[i] != 1) {\n            return false;\n        }\n        if (l[i] > l[i+1])\
    \ && (l[i] - l[i+1] != 1) {\n            return false;\n        }\n    }\n   \
    \ true", "    let mut up = false;\n    let mut down = false;\n    let mut res\
    \ = true;\n    for i in 1..l.len() {\n        if l[i] > l[i - 1] {\n         \
    \   up = true;\n        } else if l[i] < l[i - 1] {\n            down = true;\n\
    \        }\n        if up && down {\n            res = false;\n            break;\n\
    \        }\n    }\n    res", "    let mut prev = l[0];\n    let mut order = None;\n\
    \    for elem in l.iter().skip(1) {\n        let o = if prev > *elem { -1 } else\
    \ if prev < *elem { 1 } else { 0 };\n        if order == None {\n            order\
    \ = Some(o);\n        } else if order != Some(o) {\n            return false;\n\
    \        }\n        prev = *elem;\n    }\n    true", "    if l.len() <= 1 {\n\
    \        return true;\n    }\n    let mut inc = false;\n    for i in 1..l.len()\
    \ {\n        let cur = l[i];\n        let prev = l[i - 1];\n        if cur ==\
    \ prev {\n            continue;\n        }\n        if inc {\n            if cur\
    \ < prev {\n                return false;\n            }\n        } else {\n \
    \           if cur > prev {\n                return false;\n            }\n  \
    \          inc = true;\n        }\n    }\n    true", "  let length = l.len();\n\
    \  if length < 2 {\n    return true;\n  }\n  let fst = l[0];\n  for i in 1..length\
    \ {\n    if fst < l[i] {\n      return increasing(l);\n    } else if fst > l[i]\
    \ {\n      return decreasing(l);\n    }\n  }\n  true", "    let mut increasing\
    \ = true;\n    let mut decreasing = true;\n    let mut prev = l[0];\n    for i\
    \ in l {\n        if i > prev {\n            decreasing = false;\n        } else\
    \ if i < prev {\n            increasing = false;\n        }\n        prev = i;\n\
    \    }\n    increasing || decreasing", "    let mut l = l;\n    l.sort();\n  \
    \  l.windows(2).all(|w| w[0] <= w[1]) || l.windows(2).all(|w| w[0] >= w[1])",
  "    let mut incr = true;\n    let mut decr = true;\n    for i in 1..l.len() {\n\
    \        incr = incr && l[i] >= l[i - 1];\n        decr = decr && l[i] <= l[i\
    \ - 1];\n    }\n    incr || decr", "    assert!(l.len() > 0);\n    if l.len()\
    \ == 1 {\n        return true;\n    }\n    let mut i = 1;\n    let mut increasing\
    \ = false;\n    let mut decreasing = false;\n    while i < l.len() {\n       \
    \ if l[i] > l[i - 1] {\n            increasing = true;\n        } else if l[i]\
    \ < l[i - 1] {\n            decreasing = true;\n        }\n        if increasing\
    \ && decreasing {\n            return false;\n        }\n        i += 1;\n   \
    \ }\n    true", "    let mut i = 0;\n    let mut inc = false;\n    let mut dec\
    \ = false;\n    let mut last = l[0];\n    for x in l {\n        if i == 0 {\n\
    \            i += 1;\n            continue;\n        }\n        if last < x {\n\
    \            inc = true;\n        } else if last > x {\n            dec = true;\n\
    \        }\n        if inc && dec {\n            return false;\n        }\n  \
    \      last = x;\n        i += 1;\n    }\n    true", "    let first = l[0];\n\
    \    let inc = l.iter().map(|&x| x >= first).all(|x| x);\n    let dec = l.iter().map(|&x|\
    \ x <= first).all(|x| x);\n    inc || dec", "    let mut last = l[0];\n    let\
    \ increasing = l[1] > last;\n    for x in l {\n        if (x > last) != increasing\
    \ {\n            return false;\n        }\n        last = x;\n    }\n    true",
  "  let mut i = 0;\n  let mut is_increasing = None;\n  while i < l.len() - 1 {\n\
    \    if l[i] < l[i + 1] {\n      if is_increasing.is_some() && is_increasing.unwrap()\
    \ == false {\n        return false;\n      }\n      is_increasing = Some(true);\n\
    \    } else if l[i] > l[i + 1] {\n      if is_increasing.is_some() && is_increasing.unwrap()\
    \ == true {\n        return false;\n      }\n      is_increasing = Some(false);\n\
    \    }\n    i += 1;\n  }\n  true", "    for i in 1..l.len() {\n        if l[i\
    \ - 1] != l[i] - 1 && l[i - 1] != l[i] + 1 {\n            return false;\n    \
    \    }\n    }\n    true", "    if l.len() < 2 {\n        true\n    } else {\n\
    \        let mut up = l[0] < l[1];\n        let mut prev = l[0];\n        for\
    \ v in l.iter().skip(1) {\n            if (up && prev > *v) || (!up && prev <\
    \ *v) {\n                return false;\n            }\n            up = !up;\n\
    \            prev = *v;\n        }\n        true\n    }", "    let n = l.len();\n\
    \    let mut v = 0;\n    for i in 1..n {\n        if l[i] > l[i - 1] {\n     \
    \       if v == -1 {\n                return false;\n            }\n         \
    \   v = 1;\n        } else if l[i] < l[i - 1] {\n            if v == 1 {\n   \
    \             return false;\n            }\n            v = -1;\n        }\n \
    \   }\n    true", "    //implement solution here\n    unimplemented!()", "   \
    \ let mut n = 0;\n    for (i, el) in l.iter().enumerate() {\n        if i > 0\
    \ {\n            if n * (el - l[i - 1]) <= 0 {\n                return false;\n\
    \            }\n            n = el - l[i - 1];\n        }\n    }\n    true", " \
    \   // monotonic(l) := \u2200i. 0 <= i < len(l) - 1 \u21D2 l[i] \u2264 l[i + 1]\
    \ \u2228 l[i] \u2265 l[i + 1]\n    l.windows(2).all(|w| w[0] <= w[1] || w[0] >=\
    \ w[1])"]
stop_tokens:
- "\n}"
