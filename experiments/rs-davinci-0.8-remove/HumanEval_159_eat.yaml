name: HumanEval_159_eat
language: rs
prompt: "/// You're a hungry rabbit, and you already have eaten a certain number of\
  \ carrots,\n/// but now you need to eat more carrots to complete the day's meals.\n\
  /// you should return an array of [ total number of eaten carrots after your meals,\n\
  /// the number of carrots left after your meals ]\n/// if there are not enough remaining\
  \ carrots, you will eat all remaining carrots, but will still be hungry.\n/// Example:\n\
  /// Variables:\n/// @number : integer\n/// the number of carrots that you have eaten.\n\
  /// @need : integer\n/// the number of carrots that you need to eat.\n/// @remaining\
  \ : integer\n/// the number of remaining carrots thet exist in stock\n/// Constrain:\n\
  /// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n\
  /// Have fun :)\nfn eat(number: isize, need: isize, remaining: isize) -> Vec<isize>\
  \ {\n"
tests: "}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6,\
  \ 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
  \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n   \
  \ assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1),\
  \ vec![5, 0]);\n}\n"
completions: ["    let remaining = if remaining < need {\n        0\n    } else {\n\
    \        remaining - need\n    };\n    vec![number + need, remaining]", "    let\
    \ mut total = number + remaining;\n    let mut eaten = number;\n    if total <\
    \ need {\n        eaten = total;\n        total = 0;\n    } else {\n        total\
    \ -= need;\n        eaten += need;\n    }\n    vec![eaten, total]", "    let remain\
    \ = remaining - number;\n    if remain >= need {\n        vec![number + need,\
    \ remain - need]\n    } else {\n        vec![number + remain, 0]\n    }", "  \
    \  if number + remaining < need {\n        vec![number + remaining, 0]\n    }\
    \ else {\n        vec![need, number + remaining - need]\n    }", "    let eaten\
    \ = number + if remaining >= need { need } else { remaining };\n    vec![eaten,\
    \ remaining - (eaten - number)]", "    let mut eaten = 0;\n    let carrots = remaining\
    \ + number;\n    if need >= carrots {\n        eaten = carrots;\n    } else {\n\
    \        eaten = number + need;\n    }\n    vec![eaten, carrots - eaten]", " \
    \   if number < 0 || need < 0 || remaining < 0 {\n        vec![-1, -1]\n    }\
    \ else if need <= remaining {\n        vec![number + need, remaining - need]\n\
    \    } else {\n        vec![number + remaining, 0]\n    }", "    if number + remaining\
    \ < need {\n        vec![number + remaining, 0]\n    } else {\n        vec![need,\
    \ number + remaining - need]\n    }", "    let carrots_left: isize = if remaining\
    \ < need {\n        0\n    } else {\n        remaining - need\n    };\n    vec![number\
    \ + need, carrots_left]", "    let left = remaining - need;\n    if left < 0 {\n\
    \        vec![number + remaining, 0]\n    } else {\n        vec![number + need,\
    \ left]\n    }", '    vec![need - std::cmp::min(need, remaining) + number, remaining
    - std::cmp::min(need, remaining)]', "    let sum = number + remaining;\n    if\
    \ need <= sum {\n        return vec![need, sum - need];\n    }\n    vec![sum,\
    \ 0]", "    let carrots = number + remaining;\n    let eaten = if carrots > need\
    \ { need } else { carrots };\n    vec![eaten, carrots - eaten]", "    let mut\
    \ number = number;\n    let mut need = need;\n    let mut result = vec![];\n \
    \   if remaining > 0 {\n        need = need - remaining;\n        if need <= 0\
    \ {\n            result.push(number + remaining);\n            result.push(0);\n\
    \        } else {\n            result.push(number + remaining);\n            result.push(need);\n\
    \        }\n    } else {\n        result.push(number);\n        result.push(need);\n\
    \    }\n    result", "    let value = (number + remaining).min(need);\n    let\
    \ remaining = remaining - value + number;\n    vec![value, remaining]", "    let\
    \ mut num: isize = number;\n    let mut rem: isize = remaining;\n    let mut need_eat:\
    \ isize = need;\n    let mut eaten: isize = 0;\n    let mut result: Vec<isize>\
    \ = Vec::new();\n\n    if num > 0 && num <= 1000 && need > 0 && need <= 1000 &&\
    \ remaining > 0 && remaining <= 1000 {\n        while num < need_eat {\n     \
    \       num += 1;\n            rem -= 1;\n            eaten += 1;\n          \
    \  if rem == 0 {\n                break;\n            }\n        }\n        if\
    \ rem == 0 {\n            result.push(num);\n            result.push(rem);\n \
    \       } else {\n            result.push(need_eat);\n            result.push(rem);\n\
    \        }\n    } else {\n        result.push(0);\n        result.push(0);\n \
    \   }\n    result", "    let mut eaten = number;\n    let mut required = need;\n\
    \    let mut left = remaining;\n    if eaten + left < required {\n        eaten\
    \ += left;\n        left = 0;\n    } else {\n        left = eaten + left - required;\n\
    \        eaten = required;\n    }\n    vec![eaten, left]", "    let mut total_carrots_eaten\
    \ = number;\n    let mut remaining_carrots = remaining;\n    if need > remaining\
    \ {\n        total_carrots_eaten += remaining;\n        remaining_carrots = 0;\n\
    \    } else {\n        total_carrots_eaten += need;\n        remaining_carrots\
    \ -= need;\n    }\n    vec![total_carrots_eaten, remaining_carrots]", "    let\
    \ mut answer = vec![number];\n    if remaining > need - number {\n        answer.push(remaining\
    \ - (need - number));\n    } else {\n        answer.push(0);\n    }\n    answer",
  "    let eaten = if number + remaining >= need {\n        need\n    } else {\n \
    \       number + remaining\n    };\n    let remaining = if number + remaining\
    \ >= need {\n        0\n    } else {\n        need - (number + remaining)\n  \
    \  };\n    vec![eaten, remaining]", "    let mut remaining = remaining;\n    let\
    \ mut number = number;\n    for _ in 0..need {\n        if remaining > 0 {\n \
    \           remaining -= 1;\n            number += 1;\n        }\n    }\n    vec![number,\
    \ remaining]", "    let mut eaten = number;\n    let mut remains = remaining;\n\
    \    let eaten_now = if need >= remains {\n        remains\n    } else {\n   \
    \     need\n    };\n    eaten += eaten_now;\n    remains -= eaten_now;\n    vec![eaten,\
    \ remains]", "    let mut total = number + remaining;\n    if total >= need {\n\
    \        total = need;\n    }\n    let remaining = remaining - (need - number);\n\
    \    vec![total, remaining]", "    let mut result = Vec::new();\n    let mut temp\
    \ = number + remaining;\n    if need >= temp {\n        result.push(temp);\n \
    \       result.push(0);\n    } else {\n        result.push(need);\n        result.push(temp\
    \ - need);\n    }\n    result", "    let mut result = vec![number, need];\n  \
    \  let mut missing = 0;\n    if result[0] < result[1] {\n        missing = result[1]\
    \ - result[0];\n        if missing <= remaining {\n            result[0] += missing;\n\
    \            result[1] -= missing;\n        } else {\n            result[0] +=\
    \ remaining;\n            result[1] -= remaining;\n        }\n    }\n    result",
  "    // your code here\n    if remaining >= number + need {\n        vec![number\
    \ + need, remaining - number - need]\n    } else {\n        vec![remaining, 0]\n\
    \    }", "    if number >= need {\n        return vec![number, 0];\n    }\n  \
    \  if number + remaining >= need {\n        return vec![need, number + remaining\
    \ - need];\n    }\n    vec![number + remaining, 0]", "    let number_after_eat\
    \ = number + need;\n    let remaining_after_eat = if number_after_eat >= remaining\
    \ {\n        0\n    } else {\n        remaining - number_after_eat\n    };\n \
    \   vec![number_after_eat, remaining_after_eat]", "    if need == 0 {\n      \
    \  return vec![number, remaining];\n    }\n\n    let remaining_after_eating =\
    \ remaining - need;\n    if remaining_after_eating < 0 {\n        return vec![number\
    \ + remaining, 0];\n    }\n\n    vec![number + need, remaining_after_eating]",
  "    if number + remaining >= need {\n        return vec![need, number + remaining\
    \ - need];\n    }\n    vec![number + remaining, 0]", "    let carrots_eaten =\
    \ std::cmp::min(remaining, need);\n    let total_eaten = carrots_eaten + number;\n\
    \    let carrots_left = remaining - carrots_eaten;\n    vec![total_eaten, carrots_left]",
  "    let eaten = if need >= remaining { remaining } else { number + remaining -\
    \ need };\n    vec![eaten, remaining - eaten]", "    let eaten = if need < remaining\
    \ {\n        number + need\n    } else {\n        number + remaining\n    };\n\
    \    let carrots_left = if need < remaining {\n        remaining - need\n    }\
    \ else {\n        0\n    };\n    vec![eaten, carrots_left]", "    let mut eaten\
    \ = number;\n    let mut remaining = remaining;\n    while eaten < need && remaining\
    \ > 0 {\n        eaten += 1;\n        remaining -= 1;\n    }\n    vec![eaten,\
    \ remaining]", "    let mut total = number + remaining;\n    if total >= need\
    \ {\n        total = need;\n    }\n    vec![total, total - need]", "    let mut\
    \ a = number + remaining;\n    if a >= need {\n        a = need;\n    }\n    vec![a,\
    \ need - a]", "    if need > remaining {\n        return vec![number + remaining,\
    \ 0];\n    } else {\n        return vec![number + need, remaining - need];\n \
    \   }", "    let (mut result, mut left) = (number, remaining);\n    if need >\
    \ remaining {\n        result += remaining;\n        left = 0;\n    } else {\n\
    \        result += need;\n        left -= need;\n    }\n    vec![result, left]",
  "    if number + remaining >= need {\n        vec![need, number + remaining - need]\n\
    \    } else {\n        vec![number + remaining, 0]\n    }", "    let eaten = if\
    \ need > remaining { remaining } else { need };\n    vec![number + eaten, remaining\
    \ - eaten]", "    let total_need = number + need;\n    if total_need <= remaining\
    \ {\n        vec![total_need, remaining - total_need]\n    } else {\n        vec![remaining,\
    \ 0]\n    }", "    if need > remaining {\n        vec![\n            number +\
    \ remaining,\n            0,\n        ]\n    } else {\n        vec![\n       \
    \     number + need,\n            remaining - need,\n        ]\n    }", "    let\
    \ mut rem = remaining - need;\n    let mut num = number + need;\n    if rem <\
    \ 0 {\n        rem = 0;\n        num = number + remaining;\n    }\n    vec![num,\
    \ rem]", "    let mut eaten = number;\n    if remaining <= eaten {\n        eaten\
    \ += remaining;\n    } else {\n        eaten += need;\n    }\n    vec![eaten,\
    \ remaining - need]", "    vec![\n        cmp::min(number + remaining, need),\n\
    \        cmp::max(remaining - (need - number), 0),\n    ]", "    // your code\
    \ here\n    let mut eaten = number;\n    let mut rem = remaining;\n    let mut\
    \ need = need;\n    while rem > 0 && need > 0 {\n        eaten += 1;\n       \
    \ rem -= 1;\n        need -= 1;\n    }\n    vec![eaten, rem]", "    if number\
    \ + remaining >= need {\n        vec![need, number + remaining - need]\n    }\
    \ else {\n        vec![number + remaining, 0]\n    }", "    let mut result = Vec::new();\n\
    \    let mut total = number + remaining;\n    let mut left = need - total;\n \
    \   if total >= need {\n        result.push(need);\n        left = remaining -\
    \ left;\n    } else {\n        result.push(total);\n    }\n    result.push(left);\n\
    \    result", "    let eaten = cmp::min(number + remaining, need);\n    let left\
    \ = cmp::max(remaining - (need - number), 0);\n    vec![eaten, left]", "    if\
    \ need <= number {\n        return vec![number, 0];\n    }\n    if remaining <=\
    \ 0 {\n        return vec![number, need - number];\n    }\n    let eaten = number\
    \ + remaining;\n    if eaten >= need {\n        return vec![eaten, eaten - need];\n\
    \    }\n    vec![eaten, 0]", "    let mut n = number;\n    let mut r = remaining;\n\
    \    let mut vec = Vec::new();\n    if number >= need {\n        vec.push(number);\n\
    \        vec.push(remaining);\n    } else {\n        if remaining >= need {\n\
    \            n += need;\n            r -= need;\n            vec.push(n);\n  \
    \          vec.push(r);\n        } else {\n            n += remaining;\n     \
    \       r -= remaining;\n            vec.push(n);\n            vec.push(r);\n\
    \        }\n    }\n    vec", "    let carrots_needed = number + need;\n    if\
    \ carrots_needed <= remaining {\n        return vec![carrots_needed, remaining\
    \ - carrots_needed];\n    }\n    vec![remaining, 0]", "    if need > remaining\
    \ {\n        vec![remaining + number, 0]\n    } else {\n        vec![need + number,\
    \ remaining - need]\n    }", "    let mut eaten = number;\n    let new_remaining\
    \ = if remaining < need {\n        eaten += remaining;\n        0\n    } else\
    \ {\n        eaten += need;\n        remaining - need\n    };\n    vec![eaten,\
    \ new_remaining]", "    if remaining + number >= need {\n        vec![need, remaining\
    \ + number - need]\n    } else {\n        vec![remaining + number, 0]\n    }",
  "    let eaten = if number + remaining < need {\n        number + remaining\n  \
    \  } else {\n        need\n    };\n    vec![eaten, remaining - (eaten - number)]",
  "    let eaten = if remaining < need {\n        remaining\n    } else {\n      \
    \  need\n    };\n    let mut left = remaining - eaten;\n    if left < 0 {\n  \
    \      left = 0;\n    }\n    return vec![number + eaten, left];", "    if number\
    \ + remaining >= need {\n        vec![need, (number + remaining) - need]\n   \
    \ } else {\n        vec![number + remaining, 0]\n    }", "    let total = remaining\
    \ + number;\n    if total > need {\n        vec![need, total - need]\n    } else\
    \ {\n        vec![total, 0]\n    }", "    let mut eat = number;\n    if eat >=\
    \ remaining {\n        return vec![eat, 0];\n    }\n    if eat + need >= remaining\
    \ {\n        eat += remaining;\n        return vec![eat, 0];\n    }\n    eat +=\
    \ need;\n    return vec![eat, remaining - eat];", "    let mut remain = remaining\
    \ - number;\n    let mut eaten = 0;\n    if remain >= need {\n        eaten =\
    \ need;\n        remain -= need;\n    } else {\n        eaten = remain;\n    \
    \    remain = 0;\n    }\n    vec![eaten, remain]", "    let left = remaining -\
    \ need;\n    if left >= 0 {\n        return vec![number + need, left];\n    }\
    \ else {\n        return vec![number + remaining, 0];\n    }", '    vec![number+remaining.min(need),
    (remaining-need).max(0)]', "    let mut result = vec![];\n    let carrots = if\
    \ need > remaining {\n        result.push(remaining + number);\n        result.push(0);\n\
    \        0\n    } else {\n        need\n    };\n    result.push(carrots + number);\n\
    \    result.push(remaining - carrots);\n    result", "    let n = number + remaining;\n\
    \    if n >= need {\n        vec![n - need, 0]\n    } else {\n        vec![n,\
    \ 0]\n    }", "    let eaten = if remaining >= need {\n        number + need\n\
    \    } else {\n        number + remaining\n    };\n    vec![eaten, std::cmp::max(0,\
    \ remaining - need)]", "    let mut num = number + remaining;\n    let mut need\
    \ = need - remaining;\n    if num < need {\n        need = num;\n    }\n    vec![need,\
    \ num - need]", "    let x = number + need;\n    if x < remaining {\n        vec![x,\
    \ remaining - x]\n    } else {\n        vec![remaining, 0]\n    }", "    // complete\
    \ the function\n    let mut result: Vec<isize> = Vec::new();\n    if remaining\
    \ < need {\n        result.push(number + remaining);\n        result.push(0);\n\
    \    } else {\n        result.push(number + need);\n        result.push(remaining\
    \ - need);\n    }\n    result", "    let mut result = vec![number, 0];\n    if\
    \ remaining >= need {\n        result[0] += need;\n        result[1] = remaining\
    \ - need;\n    } else {\n        result[0] += remaining;\n        result[1] =\
    \ 0;\n    }\n    result", "    if number + remaining >= need {\n        return\
    \ vec![need, remaining - (need - number)];\n    } else {\n        return vec![number\
    \ + remaining, 0];\n    }", "    let mut result = Vec::new();\n    if remaining\
    \ < need - number {\n        result.push(number + remaining);\n        result.push(0);\n\
    \    } else {\n        result.push(number + need);\n        result.push(remaining\
    \ - need);\n    }\n    result", "    let mut total = number + remaining;\n   \
    \ let mut left = 0;\n    if total >= need {\n        total = need;\n        left\
    \ = total - need;\n    } else {\n        left = 0;\n    }\n    vec![total, left]",
  "    if number > remaining {\n        vec![remaining, 0]\n    } else if number +\
    \ need > remaining {\n        vec![remaining, 0]\n    } else {\n        vec![number\
    \ + need, remaining - number - need]\n    }", '    vec![number + (need.min(remaining)),
    remaining - (need.min(remaining))]', "    let mut result = vec![number];\n   \
    \ if need <= remaining {\n        result.push(remaining - need);\n    } else {\n\
    \        result.push(0);\n    }\n    result", "    let (mut number, mut need,\
    \ mut remaining) = (number, need, remaining);\n    let mut result = vec![];\n\
    \    if remaining <= need {\n        result.push(number + remaining);\n      \
    \  result.push(0);\n    } else {\n        result.push(number + need);\n      \
    \  result.push(remaining - need);\n    }\n    result", "    vec![\n        number\
    \ + std::cmp::min(need, remaining),\n        remaining - std::cmp::min(need, remaining),\n\
    \    ]", "    let mut res = Vec::new();\n    let mut num = 0;\n    let mut rem\
    \ = 0;\n    let mut eat_num = 0;\n    if remaining > number {\n        num = number;\n\
    \        eat_num = need - number;\n        rem = remaining - eat_num;\n    } else\
    \ {\n        num = remaining;\n        eat_num = remaining - number;\n       \
    \ rem = 0;\n    }\n    res.push(num);\n    res.push(rem);\n    res", "    let\
    \ eaten = if number + remaining >= need {\n        need\n    } else {\n      \
    \  number + remaining\n    };\n    vec![eaten, remaining - (eaten - number)]",
  "    let x = remaining - need;\n    if x < 0 {\n        return vec![number + remaining,\
    \ 0];\n    } else {\n        return vec![number + need, x];\n    }", "    if number\
    \ + remaining >= need {\n        return vec![need, remaining - (need - number)];\n\
    \    }\n    vec![number + remaining, 0]", "    // your code\n    let mut total\
    \ = number + remaining;\n    let mut result = vec![];\n    if total >= need {\n\
    \        result.push(need);\n        result.push(total - need);\n    } else {\n\
    \        result.push(total);\n        result.push(0);\n    }\n    result", " \
    \   if number + remaining < need {\n        vec![number + remaining, 0]\n    }\
    \ else {\n        vec![need, number + remaining - need]\n    }", "    if remaining\
    \ >= need {\n        vec![number + need, remaining - need]\n    } else {\n   \
    \     vec![number + remaining, 0]\n    }", "    if need <= remaining {\n     \
    \   vec![number + need, remaining - need]\n    } else {\n        vec![number +\
    \ remaining, 0]\n    }", "    let mut i = 0;\n    let mut r = remaining;\n   \
    \ while i < need {\n        if r <= 0 {\n            return vec![number + i, r];\n\
    \        }\n        r -= 1;\n        i += 1;\n    }\n    vec![number + i, r]",
  "    let eaten = std::cmp::min(number + remaining, need);\n    vec![eaten, std::cmp::max(remaining\
    \ - (need - number), 0)]", "    let mut number = number;\n    let mut need = need;\n\
    \    let mut remaining = remaining;\n    if number >= need {\n        return vec![number,\
    \ remaining];\n    }\n    if remaining < need {\n        let tmp = remaining;\n\
    \        remaining = 0;\n        number += tmp;\n        need -= tmp;\n    } else\
    \ {\n        let tmp = need;\n        remaining -= tmp;\n        number += tmp;\n\
    \        need = 0;\n    }\n    return vec![number, remaining];", "    let mut\
    \ remaining = remaining;\n    let mut number = number;\n    for _ in 0..need {\n\
    \        if remaining > 0 {\n            number += 1;\n            remaining -=\
    \ 1;\n        }\n    }\n    vec![number, remaining]", "    //get the min between\
    \ remaining carrots and need\n    let min = isize::min(remaining, need);\n   \
    \ //get the max between min and 0\n    let min = isize::max(min, 0);\n    //return\
    \ the tuple (number + min, remaining - min)\n    vec![number + min, remaining\
    \ - min]", "    let mut eaten = number;\n    let mut leftover = 0;\n    if eaten\
    \ + remaining >= need {\n        eaten += need;\n        leftover = remaining\
    \ - need;\n    } else {\n        eaten += remaining;\n        leftover = 0;\n\
    \    }\n    vec![eaten, leftover]", "    if number + remaining >= need {\n   \
    \     vec![need, number + remaining - need]\n    } else {\n        vec![number\
    \ + remaining, 0]\n    }", "    let eaten = if remaining > number + need {\n \
    \       number + need\n    } else {\n        remaining\n    };\n    let left =\
    \ if remaining > number + need {\n        remaining - (number + need)\n    } else\
    \ {\n        0\n    };\n    vec![eaten, left]", "    let mut n = number;\n   \
    \ let mut remain = remaining;\n    let mut eaten = 0;\n    while n < need && remain\
    \ > 0 {\n        eaten += 1;\n        n += 1;\n        remain -= 1;\n    }\n \
    \   vec![n, remain]", "    let mut ate = Vec::new();\n    if number < 0 || need\
    \ < 0 || remaining < 0 {\n        ate.push(0);\n        ate.push(remaining);\n\
    \        return ate;\n    }\n    let left = remaining - need;\n    let mut res\
    \ = 0;\n    if left < 0 {\n        res = remaining;\n    } else {\n        res\
    \ = need;\n    }\n    ate.push(number + res);\n    ate.push(remaining - res);\n\
    \    ate", "    let mut total = number + remaining;\n    let left = if total >=\
    \ need {\n        total - need\n    } else {\n        total = need;\n        0\n\
    \    };\n    vec![total, left]", "    if need <= remaining {\n        vec![number\
    \ + need, remaining - need]\n    } else {\n        vec![number + remaining, 0]\n\
    \    }", "    let eaten = if remaining < need { remaining } else { need };\n \
    \   let left = if remaining < need { 0 } else { remaining - need };\n    vec![number\
    \ + eaten, left]", "    let mut result = vec![number, remaining];\n    if number\
    \ + remaining < need {\n        result[0] += remaining;\n        result[1] = 0;\n\
    \    } else {\n        result[0] += need;\n        result[1] -= need;\n    }\n\
    \    result", "    let left = (number + remaining).saturating_sub(need);\n   \
    \ let eaten = (number + remaining).saturating_sub(left);\n    vec![eaten, left]",
  "    let mut vec = Vec::new();\n    if number > 0 && need > 0 && remaining > 0 {\n\
    \        if number + remaining >= need {\n            vec.push(need);\n      \
    \      vec.push(remaining - (need - number));\n        } else {\n            vec.push(number\
    \ + remaining);\n            vec.push(0);\n        }\n    }\n    vec", "    let\
    \ mut eaten = number;\n    let mut result = vec![0, 0];\n    if remaining >= (number\
    \ + need) {\n        eaten += need;\n        result[0] = eaten;\n        result[1]\
    \ = remaining - eaten;\n    } else {\n        eaten += remaining;\n        result[0]\
    \ = eaten;\n        result[1] = 0;\n    }\n    result", "    let mut eaten: isize\
    \ = number;\n    let mut left: isize = remaining;\n    if need + number <= remaining\
    \ {\n        eaten += need;\n        left -= need;\n    } else {\n        eaten\
    \ += remaining;\n        left = 0;\n    }\n    return vec![eaten, left];", " \
    \   let result = number + remaining;\n    if result >= need {\n        vec![need,\
    \ result - need]\n    } else {\n        vec![result, 0]\n    }", "    let mut\
    \ result = Vec::new();\n    if number + remaining > need {\n        result.push(need);\n\
    \        result.push(number + remaining - need);\n    } else {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    }\n    result", "    let eaten =\
    \ if number + remaining >= need {\n        need\n    } else {\n        number\
    \ + remaining\n    };\n    vec![eaten, remaining - (eaten - number)]", "    if\
    \ number >= need {\n        return vec![number, 0];\n    }\n    if need - number\
    \ > remaining {\n        return vec![number + remaining, 0];\n    }\n    vec![number\
    \ + need, remaining - need]", "    // TODO: find a more performant solution\n\
    \    let mut actual_need = need;\n    if need <= remaining {\n        actual_need\
    \ = need;\n    } else {\n        actual_need = remaining;\n    }\n    let amount_eaten\
    \ = number + actual_need;\n    let amount_left = remaining - actual_need;\n  \
    \  vec![amount_eaten, amount_left]", "    let mut result = vec![number];\n   \
    \ result.push(remaining - need);\n    if remaining > need {\n        result[0]\
    \ += need;\n    } else {\n        result[0] += remaining;\n        result[1] =\
    \ 0;\n    }\n    result", "    let eaten = if need > remaining { remaining } else\
    \ { need };\n    vec![number + eaten, remaining - eaten]", "    let total = number\
    \ + std::cmp::min(need, remaining);\n    let left = std::cmp::max(0, (remaining\
    \ - need));\n    vec![total, left]", "    let mut eaten = number;\n    let mut\
    \ left = remaining;\n    for _ in 0..need {\n        if left > 0 {\n         \
    \   eaten += 1;\n            left -= 1;\n        }\n    }\n    vec![eaten, left]",
  "    if remaining > need {\n        return vec![number + need, remaining - need];\n\
    \    } else {\n        return vec![number + remaining, 0];\n    }", "    let eaten\
    \ = if number + remaining >= need {\n        need\n    } else {\n        number\
    \ + remaining\n    };\n    vec![eaten, remaining - (eaten - number)]", "    if\
    \ need == 0 {\n        return vec![number, remaining];\n    }\n    let mut new_number\
    \ = number;\n    let mut new_remaining = remaining;\n    if new_remaining > 0\
    \ {\n        new_number += 1;\n        new_remaining -= 1;\n    }\n    eat(new_number,\
    \ need - 1, new_remaining)", "    let total = number + remaining;\n    let remaining\
    \ = std::cmp::max(total - need, 0);\n    vec![total - remaining, remaining]",
  "    let mut x = 0;\n    let mut y = 0;\n    if need <= remaining {\n        x =\
    \ number + need;\n        y = remaining - need;\n    } else {\n        x = number\
    \ + remaining;\n        y = 0;\n    }\n    vec![x, y]", "    let mut eaten = number;\n\
    \    let mut need = need;\n    let mut remaining = remaining;\n    while need\
    \ > 0 && remaining > 0 {\n        eaten += 1;\n        need -= 1;\n        remaining\
    \ -= 1;\n    }\n    vec![eaten, remaining]", "    let total = number + need;\n\
    \    let remaining = if total > remaining {\n        remaining\n    } else {\n\
    \        remaining - total\n    };\n    vec![total, remaining]", "    let mut\
    \ total = number + need;\n    if total > remaining {\n        total = remaining;\n\
    \    }\n    vec![total, remaining - total]", "    let mut eaten = 0;\n    let\
    \ mut remaining = remaining;\n    while eaten < need && remaining > 0 {\n    \
    \    eaten += 1;\n        remaining -= 1;\n    }\n    if eaten < need {\n    \
    \    vec![eaten, 0]\n    } else {\n        vec![eaten, remaining]\n    }", " \
    \   let mut result = vec![number];\n    if need >= remaining {\n        result.push(remaining);\n\
    \        result.push(need - remaining);\n    } else {\n        result.push(need);\n\
    \        result.push(0);\n    }\n    result", "    if need >= remaining {\n  \
    \      return vec![number + remaining, 0];\n    }\n    vec![number + need, remaining\
    \ - need]", "    let mut eaten = number;\n    if remaining <= 0 {\n        return\
    \ vec![eaten, 0];\n    }\n    if need <= 0 {\n        return vec![eaten, remaining];\n\
    \    }\n    if remaining < need {\n        eaten += remaining;\n        return\
    \ vec![eaten, 0];\n    }\n    eaten += need;\n    return vec![eaten, remaining\
    \ - need];", "    let eaten = number + remaining;\n    let left = if eaten < need\
    \ { 0 } else { eaten - need };\n    vec![eaten, left]", "    let mut carrots_eaten\
    \ = number;\n    let mut carrots_remaining = remaining;\n    while carrots_eaten\
    \ < need && carrots_remaining > 0 {\n        carrots_eaten += 1;\n        carrots_remaining\
    \ -= 1;\n    }\n    vec![carrots_eaten, carrots_remaining]", "    let mut result\
    \ = Vec::new();\n    let mut eaten = number;\n    let mut stock = remaining;\n\
    \    while eaten < need && stock > 0 {\n        eaten += 1;\n        stock -=\
    \ 1;\n    }\n    result.push(eaten);\n    result.push(stock);\n    result", " \
    \   let mut left = remaining - need;\n    let mut new_number = number + need;\n\
    \    if left < 0 {\n        new_number += left;\n        left = 0;\n    }\n  \
    \  vec![new_number, left]", "    let mut number = number + remaining;\n    let\
    \ mut remaining = 0;\n    if number >= need {\n        number -= need;\n     \
    \   remaining = number;\n    }\n    vec![need, remaining]", "    let result: Vec<isize>\
    \ = if number + remaining >= need {\n        vec![need, number + remaining - need]\n\
    \    } else {\n        vec![number + remaining, 0]\n    };\n    result", "   \
    \ let total = number + remaining;\n    if total > need {\n        vec![need, total\
    \ - need]\n    } else {\n        vec![total, 0]\n    }", "    let mut number =\
    \ number;\n    let mut need = need;\n    let mut remaining = remaining;\n    if\
    \ number + remaining < need {\n        let temp = number + remaining;\n      \
    \  number = temp;\n        need = need - temp;\n        remaining = 0;\n    }\
    \ else {\n        number = number + need;\n        remaining = remaining - need;\n\
    \        need = 0;\n    }\n    vec![number, need, remaining]", "    let mut answer\
    \ = vec![];\n    if remaining >= need {\n        answer.push(number + need);\n\
    \        answer.push(remaining - need);\n    } else {\n        answer.push(number\
    \ + remaining);\n        answer.push(0);\n    }\n    answer", "    if number +\
    \ remaining >= need {\n        vec![need, remaining - (need - number)]\n    }\
    \ else {\n        vec![number + remaining, 0]\n    }", "    let mut result = vec![number,\
    \ remaining];\n    result[0] += std::cmp::min(need, remaining);\n    result[1]\
    \ -= std::cmp::min(need, remaining);\n    result", "    let (x, y) = (number +\
    \ remaining, need - remaining);\n    if y <= 0 {\n        vec![number + remaining,\
    \ 0]\n    } else {\n        vec![x, y]\n    }", "    let mut eaten = 0;\n    let\
    \ mut carrots = remaining;\n    if number >= need {\n        return vec![number,\
    \ remaining];\n    } else {\n        eaten = need - number;\n        if eaten\
    \ > carrots {\n            eaten = carrots;\n            carrots = 0;\n      \
    \  } else {\n            carrots -= eaten;\n        }\n    }\n    vec![number\
    \ + eaten, carrots]", "    if remaining + number >= need {\n        vec![number\
    \ + need, remaining + number - need]\n    } else {\n        vec![remaining + number,\
    \ 0]\n    }", "    if remaining < (need - number) {\n        vec![number + remaining,\
    \ 0]\n    } else {\n        vec![number + need, remaining - need]\n    }", " \
    \   let total_carrots = number + remaining;\n    if need >= total_carrots {\n\
    \        vec![total_carrots, 0]\n    } else {\n        vec![need, total_carrots\
    \ - need]\n    }", "    vec![\n        number + (remaining > need).max(need),\n\
    \        (remaining - need).max(0),\n    ]", "    let eaten = std::cmp::min(number\
    \ + remaining, need);\n    let left = remaining - (eaten - number);\n    vec![eaten,\
    \ left]", "    if number >= need {\n        vec![number, remaining]\n    } else\
    \ if remaining >= need - number {\n        vec![need, remaining - (need - number)]\n\
    \    } else {\n        vec![remaining + number, 0]\n    }", "    let eaten = if\
    \ remaining < number + need {\n        remaining\n    } else {\n        number\
    \ + need\n    };\n    let left = if remaining < number + need {\n        0\n \
    \   } else {\n        remaining - eaten\n    };\n    vec![eaten, left]", "   \
    \ let mut num = number;\n    let need = need;\n    let mut remaining = remaining;\n\
    \    let mut eat: Vec<isize> = Vec::new();\n    if need > remaining {\n      \
    \  eat.push(num + remaining);\n        eat.push(0);\n    } else {\n        eat.push(num\
    \ + need);\n        eat.push(remaining - need);\n    }\n    eat", "    let mut\
    \ eaten: Vec<isize> = Vec::new();\n    if remaining < need {\n        eaten.push(number\
    \ + remaining);\n        eaten.push(0);\n    } else {\n        eaten.push(number\
    \ + need);\n        eaten.push(remaining - need);\n    }\n    eaten", "    let\
    \ mut all_carrots = number + remaining;\n    let mut all_need = need;\n    if\
    \ all_carrots > all_need {\n        all_carrots -= all_need;\n        all_need\
    \ = 0;\n    } else {\n        all_need -= all_carrots;\n        all_carrots =\
    \ 0;\n    }\n    vec![all_need, all_carrots]", "    let mut remaining = remaining;\n\
    \    let number = number + std::cmp::min(need, remaining);\n    remaining -= std::cmp::min(need,\
    \ remaining);\n    vec![number, remaining]", "    let mut result = vec![];\n \
    \   let mut total = number + remaining;\n    if total >= need {\n        result.push(need);\n\
    \        result.push(total - need);\n    } else {\n        result.push(total);\n\
    \        result.push(0);\n    }\n    result", "    let mut ans: Vec<isize> = Vec::new();\n\
    \    let mut rem: isize = remaining - number;\n    if need > rem {\n        ans.push(remaining);\n\
    \        ans.push(0);\n    } else {\n        ans.push(number + need);\n      \
    \  ans.push(rem);\n    }\n    ans", "    if remaining + number >= need {\n   \
    \     vec![need, remaining + number - need]\n    } else {\n        vec![remaining\
    \ + number, 0]\n    }", "    if need >= remaining + number {\n        vec![remaining\
    \ + number, 0]\n    } else {\n        vec![number + need, remaining - need]\n\
    \    }", "    if need >= remaining {\n        return vec![number + remaining,\
    \ 0];\n    }\n    vec![number + need, remaining - need]", "    let eaten_carrots\
    \ = if remaining >= number + need {\n        number + need\n    } else {\n   \
    \     remaining\n    };\n    let left_carrots = remaining - eaten_carrots;\n \
    \   vec![eaten_carrots, left_carrots]", "    let mut eaten = 0;\n    if number\
    \ < need {\n        if remaining > 0 {\n            if remaining >= need - number\
    \ {\n                eaten = need - number;\n            } else {\n          \
    \      eaten = remaining;\n            }\n        }\n    }\n    vec![number +\
    \ eaten, remaining - eaten]", "    if number + remaining >= need {\n        vec![need,\
    \ number + remaining - need]\n    } else {\n        vec![number + remaining, 0]\n\
    \    }", "    let total = number + remaining;\n    if total >= need {\n      \
    \  vec![need, total - need]\n    } else {\n        vec![total, 0]\n    }", " \
    \   let mut total_num = 0;\n    let mut remainder = 0;\n    if need < remaining\
    \ {\n        total_num = number + need;\n        remainder = remaining - need;\n\
    \    } else {\n        total_num = number + remaining;\n        remainder = 0;\n\
    \    }\n    vec![total_num, remainder]", "    let mut need = need;\n    if remaining\
    \ <= 0 {\n        return vec![number, -1];\n    }\n    if need > remaining {\n\
    \        need = remaining;\n    }\n    return vec![number + need, remaining -\
    \ need];", "    if number + remaining >= need {\n        vec![need, (number +\
    \ remaining) - need]\n    } else {\n        vec![number + remaining, 0]\n    }",
  "    let mut total = number + remaining;\n    let mut rest = 0;\n    if total <\
    \ need {\n        total = total;\n        rest = 0;\n    } else {\n        total\
    \ = need;\n        rest = total - need;\n    }\n    vec![total, rest]", "    let\
    \ total = number + remaining;\n    if total >= need {\n        vec![need, total\
    \ - need]\n    } else {\n        vec![total, 0]\n    }", "    if remaining + number\
    \ < need {\n        return vec![remaining + number, 0];\n    }\n    vec![need,\
    \ remaining + number - need]", "    if need >= remaining {\n        vec![number\
    \ + remaining, 0]\n    } else {\n        vec![number + need, remaining - need]\n\
    \    }", "    let mut result = vec![];\n    let sum = number + remaining;\n  \
    \  if sum < need {\n        result.push(sum);\n        result.push(0);\n    }\
    \ else {\n        result.push(need);\n        result.push(sum - need);\n    }\n\
    \    result", "    vec![\n        std::cmp::min(number + remaining, need),\n \
    \       std::cmp::max(0, need - number - remaining),\n    ]", "    let mut number:\
    \ isize = number + (remaining - number - need).max(0);\n    vec![number, remaining\
    \ - number]", "    let mut first_arr = Vec::new();\n    let mut second_arr = Vec::new();\n\
    \    if need > number && need < remaining {\n        first_arr.push(number + need);\n\
    \        first_arr.push(remaining - need);\n    } else if need > number && need\
    \ > remaining {\n        second_arr.push(number + remaining);\n        second_arr.push(0);\n\
    \    } else {\n        first_arr.push(number);\n        first_arr.push(remaining);\n\
    \    }\n    first_arr", "    let mut result = Vec::new();\n    if need <= remaining\
    \ {\n        result.push(number + need);\n        result.push(remaining - need);\n\
    \    } else {\n        result.push(number + remaining);\n        result.push(0);\n\
    \    }\n    result", "    let mut number = number;\n    let mut need = need;\n\
    \    let mut remaining = remaining;\n    if number + remaining < need {\n    \
    \    let result = vec![number + remaining, 0];\n        return result;\n    }\
    \ else {\n        number += need;\n        remaining -= need;\n        let result\
    \ = vec![number, remaining];\n        return result;\n    }", "    let total =\
    \ number + remaining;\n    let eaten = if need <= total { need } else { total\
    \ };\n    vec![eaten, total - eaten]", "    let total_needed = number + need;\n\
    \    let carrots_eaten = if total_needed < remaining {\n        total_needed\n\
    \    } else {\n        remaining\n    };\n    vec![carrots_eaten, remaining -\
    \ carrots_eaten]", "    let carrots_consumed = if need <= remaining {\n      \
    \  number + need\n    } else {\n        number + remaining\n    };\n    let carrots_left\
    \ = remaining - need;\n    vec![carrots_consumed, carrots_left]", "    let mut\
    \ total = number + remaining;\n    if total < need {\n        total = remaining;\n\
    \    } else {\n        total -= need;\n    }\n    vec![number + remaining - total,\
    \ total]", '    vec![number + std::cmp::min(need, remaining), std::cmp::max(0,
    remaining - need)]', "    let mut result = Vec::new();\n    let mut eaten = number;\n\
    \    if remaining <= need {\n        eaten += remaining;\n        result.push(eaten);\n\
    \        result.push(0);\n    } else {\n        eaten += need;\n        result.push(eaten);\n\
    \        result.push(remaining - need);\n    }\n    result", "    let eaten =\
    \ remaining.min(number + need);\n    vec![eaten, remaining - eaten]", "    let\
    \ eaten = if need > remaining {\n        remaining\n    } else {\n        remaining\
    \ - need\n    };\n    vec![number + eaten, need - eaten]", "    let eaten = number\
    \ + remaining.min(need);\n    vec![eaten, remaining - need.min(remaining)]", " \
    \   let (mut eaten, mut left) = (number, remaining);\n    if left < need {\n \
    \       eaten += left;\n        left = 0;\n    } else {\n        eaten += need;\n\
    \        left -= need;\n    }\n    vec![eaten, left]", "    let eaten_carrots\
    \ = match number + remaining >= need {\n        true => need,\n        false =>\
    \ number + remaining,\n    };\n    let left_carrots = match number + remaining\
    \ >= need {\n        true => remaining - (need - number),\n        false => 0,\n\
    \    };\n    vec![eaten_carrots, left_carrots]", "    let mut s = number;\n  \
    \  let mut d = remaining;\n    for _ in 0..need {\n        if d > 0 {\n      \
    \      s += 1;\n            d -= 1;\n        }\n    }\n    vec![s, d]", "    if\
    \ remaining + number >= need {\n        vec![number + need, remaining + number\
    \ - need]\n    } else {\n        vec![remaining + number, 0]\n    }", "    let\
    \ mut number = number;\n    let mut remaining = remaining;\n    while number <\
    \ need && remaining > 0 {\n        number += 1;\n        remaining -= 1;\n   \
    \ }\n    vec![number, remaining]", "    let (mut eaten, mut left) = (number, remaining);\n\
    \    if need > 0 {\n        if left > 0 {\n            if need <= left {\n   \
    \             eaten += need;\n                left -= need;\n            } else\
    \ {\n                eaten += left;\n                left = 0;\n            }\n\
    \        }\n    }\n\n    vec![eaten, left]", "    let mut eaten = number;\n  \
    \  let mut left = remaining;\n    let mut hungry = false;\n    while eaten < need\
    \ {\n        if left > 0 {\n            eaten += 1;\n            left -= 1;\n\
    \        } else {\n            hungry = true;\n            break;\n        }\n\
    \    }\n    vec![eaten, left, hungry as isize]", "    if remaining >= need {\n\
    \        vec![number + need, remaining - need]\n    } else {\n        vec![number\
    \ + remaining, 0]\n    }", "    let mut eaten = number;\n    let mut left = remaining;\n\
    \    if left <= need {\n        eaten += left;\n        left = 0;\n    } else\
    \ {\n        eaten += need;\n        left -= need;\n    }\n    vec![eaten, left]",
  "    let x = std::cmp::min(remaining, need - number);\n    let y = std::cmp::max(0,\
    \ remaining - (need - number));\n    vec![number + x, y]", "    let total = number\
    \ + remaining;\n    if need > total {\n        vec![total, 0]\n    } else {\n\
    \        vec![need, total - need]\n    }", "    let m = number + need;\n    let\
    \ n = m - remaining;\n    if n > 0 {\n        return vec![m, 0];\n    } else {\n\
    \        return vec![m, n.abs()];\n    }", "    let total = number + remaining;\n\
    \    if total >= need {\n        return vec![need, total - need];\n    } else\
    \ {\n        return vec![total, 0];\n    }", "    let mut number = number;\n \
    \   let mut remaining = remaining;\n    let mut need = need;\n    let mut eaten\
    \ = Vec::new();\n    while need > 0 {\n        if remaining > 0 {\n          \
    \  number += 1;\n            remaining -= 1;\n            need -= 1;\n       \
    \ } else {\n            need -= 1;\n        }\n    }\n    eaten.push(number);\n\
    \    eaten.push(remaining);\n    eaten", "    let mut eaten = number;\n    let\
    \ mut not_eaten = remaining;\n    let mut hungry = false;\n    if eaten + remaining\
    \ < need {\n        eaten += remaining;\n        not_eaten = 0;\n        hungry\
    \ = true;\n    } else {\n        eaten += need;\n        not_eaten -= need;\n\
    \    }\n    vec![eaten, not_eaten, hungry as isize]", "    let mut n = number;\n\
    \    let mut r = remaining;\n    if number + remaining < need {\n        n +=\
    \ r;\n        r = 0;\n    } else {\n        n += need;\n        r -= need;\n \
    \   }\n    vec![n, r]", "    if number < 0 || need < 0 || remaining < 0 {\n  \
    \      vec![0, 0]\n    } else {\n        let mut total = number + remaining;\n\
    \        let mut eat = total - need;\n        if eat < 0 {\n            eat =\
    \ 0;\n        }\n        total -= eat;\n        vec![eat, total]\n    }", "  \
    \  let mut res = Vec::with_capacity(2);\n    if need < remaining {\n        res.push(number\
    \ + need);\n        res.push(remaining - need);\n    } else {\n        res.push(number\
    \ + remaining);\n        res.push(0);\n    }\n    res", '    return vec![number
    + std::cmp::min(need, remaining), std::cmp::max(0, remaining - need)];', "   \
    \ let sum = number + remaining;\n    if sum >= need {\n        vec![need, sum\
    \ - need]\n    } else {\n        vec![sum, 0]\n    }"]
stop_tokens:
- "\n}"
