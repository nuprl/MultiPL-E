language: rs
name: HumanEval_79_decimal_to_binary
results:
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    format!(\"db{}db\", format!(\"{:b}\", decimal))\n}\n\nfn main() {\n    let\
    \ candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823182
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary: String = \"db\".to_string();\n    let mut res: isize = decimal;\n\
    \    let mut remainder: isize;\n    let zero: char = '0';\n    let one: char =\
    \ '1';\n\n    while res > 0 {\n        remainder = res % 2;\n        if remainder\
    \ == 0 {\n            binary.push(zero);\n        } else {\n            binary.push(one);\n\
    \        }\n        res = res / 2;\n    }\n    let mut res: String = \"db\".to_string();\n\
    \    for n in binary.chars().rev() {\n        res.push(n);\n    }\n    res\n}\n\
    \nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbbd\"`,\n right: `\"db0db\"`', /tmp/tmp1jde3usy.rs:32:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823182
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut result = String::from(\"db\");\n    let mut dividend = decimal;\n\
    \    let mut remainder;\n    while dividend > 0 {\n        remainder = dividend\
    \ % 2;\n        dividend = dividend / 2;\n        result.push_str(&remainder.to_string());\n\
    \    }\n    result.push_str(\"db\");\n    result.chars().rev().collect()\n}\n\n\
    fn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpr3q_7m9d.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823182
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut s = String::new();\n    let mut d = decimal;\n    while d > 0 {\n\
    \        s.push_str(if d % 2 == 0 { \"0\" } else { \"1\" });\n        d /= 2;\n\
    \    }\n    s.push_str(\"db\");\n    s.chars().rev().collect()\n}\n\nfn main()\
    \ {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bd\"`,\n right: `\"db0db\"`', /tmp/tmptj0_tox2.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823182
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut bin = format!(\"{:b}\", decimal);\n    bin.insert_str(0, \"db\");\n\
    \    bin.push_str(\"db\");\n    bin\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823182
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut db = String::from(\"db\");\n    let mut v = decimal;\n    while v\
    \ > 0 {\n        db.push_str(&format!(\"{}\", v % 2));\n        v /= 2;\n    }\n\
    \    db.push_str(\"db\");\n    db.chars().rev().collect()\n}\n\nfn main() {\n\
    \    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpxtsidc3y.rs:20:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823182
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut res = String::from(\"db\");\n    let mut dec = decimal;\n    while\
    \ dec > 0 {\n        res.push_str(&(dec % 2).to_string());\n        dec /= 2;\n\
    \    }\n    res.push_str(\"db\");\n    res.chars().rev().collect()\n}\n\nfn main()\
    \ {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpl2hf27ia.rs:20:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823182
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    format!(\"db{}db\", decimal.to_string().chars().rev().map(|digit| {\n   \
    \     match digit {\n            '0' => \"0000\",\n            '1' => \"0001\"\
    ,\n            '2' => \"0010\",\n            '3' => \"0011\",\n            '4'\
    \ => \"0100\",\n            '5' => \"0101\",\n            '6' => \"0110\",\n \
    \           '7' => \"0111\",\n            '8' => \"1000\",\n            '9' =>\
    \ \"1001\",\n            _ => \"\",\n        }\n    }).collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"db0000db\"`,\n right: `\"db0db\"`', /tmp/tmpc0xzgglx.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823182
- exit_code: 1
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    format!(\"db{}db\", decimal.to_string_radix(2))\n}\n\nfn main() {\n    let\
    \ candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_string_radix` found for type `isize`\
    \ in the current scope\n --> /tmp/tmpy1cwj997.rs:8:31\n  |\n8 |     format!(\"\
    db{}db\", decimal.to_string_radix(2))\n  |                               ^^^^^^^^^^^^^^^\
    \ method not found in `isize`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659823182
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    decimal.to_string()\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"0\"`,\n right: `\"db0db\"`', /tmp/tmpu024o3o_.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823182
- exit_code: 1
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    format!(\"db{}db\", decimal.to_string(2))\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmp0zrmhftv.rs:8:31\n     |\n8    |     format!(\"db{}db\", decimal.to_string(2))\n\
    \     |                               ^^^^^^^^^ - supplied 1 argument\n     |\
    \                               |\n     |                               expected\
    \ 0 arguments\n     |\nnote: associated function defined here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1659823181
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    // format!(\"db{:?}db\", format!(\"{:b}\", decimal))\n    format!(\"db{:b}db\"\
    , decimal)\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823182
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary = String::new();\n    let mut dec = decimal;\n    while dec\
    \ > 0 {\n        binary.push_str(&(dec % 2).to_string());\n        dec /= 2;\n\
    \    }\n    format!(\"db{}db\", binary.chars().rev().collect::<String>())\n}\n\
    \nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmp7e2_sahl.rs:19:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823182
- exit_code: 1
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    format!(\"db{}db\", decimal.to_string(2))\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmp0zrmhftv.rs:8:31\n     |\n8    |     format!(\"db{}db\", decimal.to_string(2))\n\
    \     |                               ^^^^^^^^^ - supplied 1 argument\n     |\
    \                               |\n     |                               expected\
    \ 0 arguments\n     |\nnote: associated function defined here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1659823181
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = decimal;\n    while num\
    \ > 0 {\n        result.push(if num % 2 == 0 { '0' } else { '1' });\n        num\
    \ /= 2;\n    }\n    if decimal != 0 {\n        result.chars().rev().collect::<String>()\n\
    \    } else {\n        result.push('0');\n        result\n    }\n}\n\nfn main()\
    \ {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"0\"`,\n right: `\"db0db\"`', /tmp/tmp6n13aeuj.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823182
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut a = decimal;\n    while a !=\
    \ 0 {\n        result.push_str(&(a % 2).to_string());\n        a /= 2;\n    }\n\
    \    result.chars().rev().collect::<String>()\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"db0db\"`', /tmp/tmprp166pi7.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823182
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary = String::new();\n    let mut dec = decimal;\n    while dec\
    \ > 0 {\n        let remain = dec % 2;\n        let char = remain.to_string();\n\
    \        binary.push_str(&char);\n        dec = dec / 2;\n    }\n    let mut b\
    \ = String::from(\"db\");\n    b.push_str(&binary);\n    b.push_str(\"b\");\n\
    \    b.chars().rev().collect()\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bbd\"`,\n right: `\"db0db\"`', /tmp/tmp43oes1f1.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823182
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    // TODO:\n    let binary = format!(\"{:b}\", decimal);\n    format!(\"db{}db\"\
    , binary)\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823182
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let base = 2;\n    let mut decimal = decimal;\n    let mut binary = String::new();\n\
    \    let mut remainder;\n\n    while decimal > 0 {\n        remainder = decimal\
    \ % base;\n        decimal = decimal / base;\n        binary = format!(\"{}{}\"\
    , remainder, binary);\n    }\n\n    format!(\"db{}db\", binary)\n}\n\nfn main()\
    \ {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmpig9tj4b4.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823182
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    //in a string of 8 bits, first 2 bits are for the sign, next 3 are for the\
    \ exponent and last 3 are for the mantissa\n    //the mantissa is converted from\
    \ binary to decimal using base 2 and the exponent is added to it\n    let mut\
    \ binary_repr = format!(\"{:b}\", decimal);\n    let sign = if decimal >= 0 {\
    \ \"+\" } else { \"-\" };\n    let exp = if binary_repr.len() < 3 {\n        3\
    \ - binary_repr.len()\n    } else {\n        binary_repr.len() - 3\n    };\n \
    \   let mut exponent = format!(\"{:b}\", exp);\n    while exponent.len() < 3 {\n\
    \        exponent.insert(0, '0');\n    }\n    while binary_repr.len() < 3 {\n\
    \        binary_repr.insert(0, '0');\n    }\n    format!(\"db{}{}{}db\", sign,\
    \ exponent, binary_repr)\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"db+010000db\"`,\n right: `\"db0db\"`', /tmp/tmp5bp59skp.rs:29:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823182
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary: String = \"db\".to_string();\n    let mut dec = decimal;\n\
    \    while dec > 0 {\n        binary.push_str(&(dec % 2).to_string());\n     \
    \   dec /= 2;\n    }\n    binary.push_str(\"db\");\n    binary.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpi0vr6ui1.rs:20:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823182
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut tmp = decimal;\n    while tmp\
    \ != 0 {\n        result.push(match tmp % 2 {\n            0 => '0',\n       \
    \     1 => '1',\n            _ => ' ',\n        });\n        tmp /= 2;\n    }\n\
    \    result.chars().rev().collect::<String>()\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"db0db\"`', /tmp/tmpv5jgx0ji.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823182
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary = String::new();\n    let mut dec = decimal;\n    while dec\
    \ != 0 {\n        binary.push_str(&(dec % 2).to_string());\n        dec /= 2;\n\
    \    }\n    binary.chars().rev().collect::<String>()\n}\n\nfn main() {\n    let\
    \ candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"db0db\"`', /tmp/tmpvxnpkgwm.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823182
- exit_code: 1
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    format!(\"db{}db\", decimal.to_string().parse::<i32>().unwrap().to_string(2))\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmpqjaoecsi.rs:8:67\n     |\n8    |     format!(\"db{}db\", decimal.to_string().parse::<i32>().unwrap().to_string(2))\n\
    \     |                                                                   ^^^^^^^^^\
    \ - supplied 1 argument\n     |                                              \
    \                     |\n     |                                              \
    \                     expected 0 arguments\n     |\nnote: associated function\
    \ defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659823181
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    format!(\"db{}db\", decimal.to_string().chars().map(|c| match c {\n     \
    \   '0' => '0',\n        '1' => '1',\n        '2' => '1',\n        '3' => '1',\n\
    \        '4' => '1',\n        '5' => '1',\n        '6' => '1',\n        '7' =>\
    \ '1',\n        '8' => '1',\n        '9' => '1',\n        _ => panic!(\"Invalid\
    \ character {}.\", c),\n    }).collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"db11db\"`,\n right: `\"db100000db\"`', /tmp/tmpueuokjyu.rs:26:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823182
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdrgg1dte.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823182
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    format!(\"db{}db\", format!(\"{:b}\", decimal).chars().map(|c| if c == '0'\
    \ { ' ' } else { c }).collect::<String>())\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"db db\"`,\n right: `\"db0db\"`', /tmp/tmps6nop8fw.rs:13:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823182
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary = String::from(\"db\");\n    let mut remaining = decimal;\n\
    \    while remaining > 0 {\n        binary.push(if remaining % 2 == 0 { '0' }\
    \ else { '1' });\n        remaining /= 2;\n    }\n    binary.push_str(\"db\");\n\
    \    binary.chars().rev().collect()\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpgb3qygv8.rs:20:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823182
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    format!(\"db{}db\", format!(\"{:b}\", decimal))\n}\n\nfn main() {\n    let\
    \ candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823182
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut cnt = 0;\n    let mut rem =\
    \ 0;\n    let mut n = decimal;\n    while n != 0 {\n        rem = n % 2;\n   \
    \     n = n / 2;\n        result.push(std::char::from_digit(rem as u32, 10).unwrap());\n\
    \        cnt += 1;\n    }\n    let mut str = result.chars().rev().collect::<String>();\n\
    \    str.insert_str(0, \"db\");\n    str.push_str(\"db\");\n    str\n}\n\nfn main()\
    \ {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmp1nnt1bdh.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823182
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut result = \"db\".to_string();\n    let mut decimal = decimal;\n  \
    \  while decimal > 0 {\n        result.push(if decimal % 2 == 0 { '0' } else {\
    \ '1' });\n        decimal /= 2;\n    }\n    result.push('b');\n    result.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bbd\"`,\n right: `\"db0db\"`', /tmp/tmp4awd5hb6.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823182
- exit_code: 1
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    format!(\"db{}db\", dec_to_bin_s(decimal))\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `dec_to_bin_s` in this scope\n --> /tmp/tmpum4en_v9.rs:8:23\n\
    \  |\n8 |     format!(\"db{}db\", dec_to_bin_s(decimal))\n  |                \
    \       ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823182
- exit_code: 1
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    format!(\"db{}db\", decimal.to_string_radix(2))\n}\n\nfn main() {\n    let\
    \ candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_string_radix` found for type `isize`\
    \ in the current scope\n --> /tmp/tmpy1cwj997.rs:8:31\n  |\n8 |     format!(\"\
    db{}db\", decimal.to_string_radix(2))\n  |                               ^^^^^^^^^^^^^^^\
    \ method not found in `isize`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659823182
- exit_code: 1
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    format!(\"db{}db\", decimal.to_string(2))\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmp0zrmhftv.rs:8:31\n     |\n8    |     format!(\"db{}db\", decimal.to_string(2))\n\
    \     |                               ^^^^^^^^^ - supplied 1 argument\n     |\
    \                               |\n     |                               expected\
    \ 0 arguments\n     |\nnote: associated function defined here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1659823181
- exit_code: 1
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    format!(\"db{}db\", decimal.to_string(2))\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmp0zrmhftv.rs:8:31\n     |\n8    |     format!(\"db{}db\", decimal.to_string(2))\n\
    \     |                               ^^^^^^^^^ - supplied 1 argument\n     |\
    \                               |\n     |                               expected\
    \ 0 arguments\n     |\nnote: associated function defined here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1659823181
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut res = String::new();\n    let mut num = decimal;\n    res.push_str(\"\
    db\");\n    while num > 0 {\n        res.push_str(&if num % 2 == 0 { \"0\" } else\
    \ { \"1\" });\n        num /= 2;\n    }\n    res.push_str(\"db\");\n    res\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmpesd4r90c.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823182
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut decimal = decimal;\n    let mut binary = String::new();\n    while\
    \ decimal > 0 {\n        binary.push_str(&format!(\"{}\", decimal % 2));\n   \
    \     decimal /= 2;\n    }\n    binary\n}\n\nfn main() {\n    let candidate =\
    \ decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"db0db\"`', /tmp/tmpnljdxzxo.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823182
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let db = String::from(\"db\");\n    let mut bin = String::new();\n    let\
    \ mut n = decimal;\n    while n != 0 {\n        bin.push(std::char::from_digit((n\
    \ % 2) as u32, 10).unwrap());\n        n /= 2;\n    }\n    let mut ret = String::new();\n\
    \    ret.push_str(db.as_str());\n    ret.push_str(bin.as_str());\n    ret.push_str(db.as_str());\n\
    \    ret.chars().rev().collect()\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpbgudm3u7.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823182
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    unimplemented!(\"Convert number {} to binary\", decimal);\n}\n\nfn main()\
    \ {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: Convert number 0 to binary'',
    /tmp/tmpqw6smu07.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823182
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let binary = format!(\"{:b}\", decimal);\n    format!(\"db{}db\", binary)\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823182
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary = String::new();\n    binary.push_str(\"db\");\n    let mut\
    \ numerator = decimal;\n    while numerator > 0 {\n        binary.push_str(&(numerator\
    \ % 2).to_string());\n        numerator /= 2;\n    }\n    binary.push_str(\"b\"\
    );\n    binary.chars().rev().collect()\n}\n\nfn main() {\n    let candidate =\
    \ decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bbd\"`,\n right: `\"db0db\"`', /tmp/tmptxoet_sn.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823182
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let binary = format!(\"{:b}\", decimal);\n    let db_string = format!(\"\
    db{}db\", binary);\n    db_string\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823182
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    format!(\"db{}db\", decimal.to_string().chars().fold(String::new(), |acc,\
    \ ch| {\n        if ch == '0' || ch == '1' {\n            acc + &ch.to_string()\n\
    \        } else {\n            format!(\"{}{:b}\", acc, ch as u8)\n        }\n\
    \    }))\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"db110011110010db\"`,\n right: `\"db100000db\"`', /tmp/tmp_k1gei0n.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823182
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut decimal = decimal;\n    let mut number: String = String::new();\n\
    \    while decimal > 0 {\n        number.push_str(&(decimal % 2).to_string());\n\
    \        decimal /= 2;\n    }\n    \"db\".to_string() + &number.chars().rev().collect::<String>()\
    \ + \"db\"\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmpx_3b_9xg.rs:19:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823182
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary = String::from(\"db\");\n    let mut dec = decimal;\n    let\
    \ mut exp = 0;\n    while dec != 0 {\n        exp += 1;\n        dec /= 2;\n \
    \   }\n    while exp != 0 {\n        binary.push(if decimal & (1 << (exp - 1))\
    \ != 0 { '1' } else { '0' });\n        exp -= 1;\n    }\n    binary.push('b');\n\
    \    binary\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbb\"`,\n right: `\"db0db\"`', /tmp/tmp78yyb6hl.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823182
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary = String::from(\"db\");\n    let mut dec = decimal;\n    while\
    \ dec != 0 {\n        if dec % 2 == 0 {\n            binary.push('0');\n     \
    \   } else {\n            binary.push('1');\n        }\n        dec /= 2;\n  \
    \  }\n    binary.push_str(\"db\");\n    binary.chars().rev().collect()\n}\n\n\
    fn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmp22xnmcry.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823182
- exit_code: 1
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    format!(\"db{}db\", decimal.to_string(2))\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmp0zrmhftv.rs:8:31\n     |\n8    |     format!(\"db{}db\", decimal.to_string(2))\n\
    \     |                               ^^^^^^^^^ - supplied 1 argument\n     |\
    \                               |\n     |                               expected\
    \ 0 arguments\n     |\nnote: associated function defined here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1659823181
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary = String::new();\n    let mut n = decimal;\n    let mut bin\
    \ = 0;\n    while n > 0 {\n        bin = n % 2;\n        n = n / 2;\n        binary.push_str(&bin.to_string());\n\
    \    }\n    binary.chars().rev().collect::<String>()\n}\n\nfn main() {\n    let\
    \ candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"db0db\"`', /tmp/tmpmk5a71ek.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823182
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary = String::new();\n    binary.push_str(\"db\");\n    let mut\
    \ dec = decimal;\n    while dec > 0 {\n        if dec % 2 == 0 {\n           \
    \ binary.push('0');\n        } else {\n            binary.push('1');\n       \
    \ }\n        dec /= 2;\n    }\n    binary.push_str(\"db\");\n    binary.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmp6ei4scup.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823182
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut num = decimal;\n    while num\
    \ > 0 {\n        result.push(if num % 2 == 0 { '0' } else { '1' });\n        num\
    \ /= 2;\n    }\n    result.chars().rev().collect::<String>()\n}\n\nfn main() {\n\
    \    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"db0db\"`', /tmp/tmpfi_k3s1i.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823182
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    format!(\"db{}db\",\n            format!(\"{:b}\", decimal)\n           \
    \     .replace(\"0\", \"d0\")\n                .replace(\"1\", \"d1\"))\n}\n\n\
    fn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbd0db\"`,\n right: `\"db0db\"`', /tmp/tmpm7wz9d_b.rs:16:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823182
- exit_code: 1
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    format!(\"db{}db\", decimal.to_string_radix(2))\n}\n\nfn main() {\n    let\
    \ candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_string_radix` found for type `isize`\
    \ in the current scope\n --> /tmp/tmpy1cwj997.rs:8:31\n  |\n8 |     format!(\"\
    db{}db\", decimal.to_string_radix(2))\n  |                               ^^^^^^^^^^^^^^^\
    \ method not found in `isize`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659823182
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary: Vec<char> = Vec::new();\n    let mut n = decimal;\n    while\
    \ n > 0 {\n        let mut bit = n % 2;\n        n = n / 2;\n        binary.push(bit.to_string().chars().next().unwrap());\n\
    \    }\n    binary.reverse();\n    let mut d = String::from(\"db\");\n    for\
    \ b in binary {\n        d.push(b);\n    }\n    d.push_str(\"db\");\n    d\n}\n\
    \nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmpwgfprq3g.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823182
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary: String = String::new();\n    binary.push_str(\"db\");\n \
    \   let mut dec: isize = decimal;\n    while dec > 0 {\n        binary.push_str(&((dec\
    \ % 2).to_string()));\n        dec /= 2;\n    }\n    binary.push_str(\"b\");\n\
    \    binary.chars().rev().collect()\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bbd\"`,\n right: `\"db0db\"`', /tmp/tmpnyy5wyov.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823182
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut bin = vec!['d', 'b'];\n    let mut dec = decimal;\n    while dec\
    \ != 0 {\n        bin.push(match dec % 2 {\n            0 => '0',\n          \
    \  1 => '1',\n            _ => panic!(\"wtf?\"),\n        });\n        dec /=\
    \ 2;\n    }\n    bin.push('b');\n    bin.push('d');\n    bin.reverse();\n    bin.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbbd\"`,\n right: `\"db0db\"`', /tmp/tmpdzmqisoq.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823182
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut x = decimal;\n    let mut res = String::from(\"db\");\n    while\
    \ x != 0 {\n        res.push_str(&(x % 2).to_string());\n        x /= 2;\n   \
    \ }\n    res.push_str(\"db\");\n    res.chars().rev().collect()\n}\n\nfn main()\
    \ {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpqqgmu9ja.rs:20:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823182
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary = String::new();\n    let mut t = decimal;\n    if t < 0 {\n\
    \        t = t - 1;\n    }\n    while t != 0 {\n        binary.push_str(&(if t\
    \ % 2 == 0 { \"0\" } else { \"1\" }));\n        t = t / 2;\n    }\n    if decimal\
    \ < 0 {\n        for i in binary.chars() {\n            if i == '0' {\n      \
    \          println!(\"1\");\n            } else {\n                println!(\"\
    0\");\n            }\n        }\n    }\n    format!(\"db{}db\", binary)\n}\n\n\
    fn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmpko5ipzii.rs:31:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823182
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    format!(\"db{}db\", format!(\"{:b}\", decimal))\n}\n\nfn main() {\n    let\
    \ candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823182
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    format!(\"db{}db\", decimal.to_string())\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"db32db\"`,\n right: `\"db100000db\"`', /tmp/tmp82wz_mqb.rs:14:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823183
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary = String::from(\"db\");\n    let mut x = decimal;\n    let\
    \ mut digit = 0;\n    while x != 0 {\n        digit = x % 2;\n        binary.push(digit.to_string().chars().next().unwrap());\n\
    \        x = x / 2;\n    }\n    binary.push_str(\"db\");\n    binary.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpri7nfz5s.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823183
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    //unimplemented!(\"convert {} to binary\", decimal)\n    let mut result:\
    \ String = \"db\".to_string();\n    let mut n = decimal;\n    while n > 0 {\n\
    \        result.push_str(&((n%2).to_string()));\n        n = n/2;\n    }\n   \
    \ result.push_str(\"db\");\n    result.chars().rev().collect::<String>()\n}\n\n\
    fn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmplvmgmq7e.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823183
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    if decimal == 0 {\n        return \"dbdb\".to_string();\n    }\n    let mut\
    \ binary = String::new();\n    let mut temp = decimal;\n    while temp > 0 {\n\
    \        let rem = temp % 2;\n        temp = temp / 2;\n        binary.push_str(&rem.to_string());\n\
    \    }\n    binary = binary.chars().rev().collect();\n    format!(\"db{}db\",\
    \ binary)\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmphv2y6xet.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823183
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary = String::new();\n    let mut t = decimal;\n    while t >\
    \ 0 {\n        binary.push_str(&format!(\"{}\", t % 2));\n        t /= 2;\n  \
    \  }\n    format!(\"db{}db\", binary.chars().rev().collect::<String>())\n}\n\n\
    fn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmplnb1asvy.rs:19:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823183
- exit_code: 1
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    format!(\"db{}db\", decimal.to_string().chars().rev().map(|x| x.to_digit(10).unwrap()\
    \ as usize % 2).collect::<String>().chars().rev().collect::<String>())\n}\n\n\
    fn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `String` cannot be built from an iterator\
    \ over elements of type `usize`\n --> /tmp/tmpvqxvduvb.rs:8:103\n  |\n8 | ....unwrap()\
    \ as usize % 2).collect::<String>().chars().rev().collect::<String>())\n  |  \
    \                          ^^^^^^^ value of type `String` cannot be built from\
    \ `std::iter::Iterator<Item=usize>`\n  |\n  = help: the trait `FromIterator<usize>`\
    \ is not implemented for `String`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823183
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    // Your code here\n    let mut decimal = decimal;\n    let mut binary = String::from(\"\
    db\");\n    while decimal != 0 {\n        binary.push_str(&format!(\"{}\", decimal\
    \ % 2));\n        decimal /= 2;\n    }\n    binary.push_str(\"b\");\n    binary.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bbd\"`,\n right: `\"db0db\"`', /tmp/tmpjz7z7zxq.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823183
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary = String::new();\n    let mut decimal = decimal;\n    let\
    \ mut count = 0;\n    let mut binary_2 = String::new();\n    while decimal > 0\
    \ {\n        if decimal % 2 == 0 {\n            binary.push('0');\n        } else\
    \ {\n            binary.push('1');\n        }\n        decimal /= 2;\n       \
    \ count += 1;\n    }\n    for i in 0..binary.len() {\n        binary_2.push(binary.chars().nth(binary.len()\
    \ - i - 1).unwrap());\n    }\n    let binary_str = format!(\"{:0>6}\", binary_2);\n\
    \    format!(\"db{}d\", binary_str)\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"db000000d\"`,\n right: `\"db0db\"`', /tmp/tmpnepba_zh.rs:30:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823183
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    format!(\"db{}db\", format!(\"{:b}\", decimal))\n}\n\nfn main() {\n    let\
    \ candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823182
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut bin = String::new();\n    bin.push_str(\"db\");\n    let mut number\
    \ = decimal;\n    while number > 0 {\n        bin.push_str(&(number % 2).to_string());\n\
    \        number /= 2;\n    }\n    bin.push_str(\"db\");\n    bin.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmp2gffx2ph.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823183
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary = String::from(\"db\");\n    let mut n = decimal;\n    while\
    \ n > 0 {\n        if n % 2 == 0 {\n            binary.push('0');\n        } else\
    \ {\n            binary.push('1');\n        }\n        n /= 2;\n    }\n    binary.push_str(\"\
    db\");\n    binary.chars().rev().collect()\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpobgqrc9y.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823183
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary = String::new();\n    let mut temp = decimal;\n    let mut\
    \ count = 0;\n    while temp != 0 {\n        binary.push_str(&format!(\"{}\",\
    \ temp % 2));\n        temp /= 2;\n        count += 1;\n    }\n    for _ in 0..8\
    \ - count {\n        binary.push_str(\"0\");\n    }\n    let mut bin = \"db\"\
    .to_string();\n    for i in binary.chars().rev() {\n        bin.push(i);\n   \
    \ }\n    bin.push_str(\"db\");\n    bin\n}\n\nfn main() {\n    let candidate =\
    \ decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"db00000000db\"`,\n right: `\"db0db\"`', /tmp/tmpjgnk0e9k.rs:29:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823183
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut number = decimal;\n    while\
    \ number != 0 {\n        let value = number % 2;\n        number = number / 2;\n\
    \        result.push_str(&value.to_string());\n    }\n    let mut result_reversed\
    \ = String::new();\n    result_reversed.push_str(\"db\");\n    for i in result.chars().rev()\
    \ {\n        result_reversed.push(i);\n    }\n    result_reversed.push_str(\"\
    db\");\n    result_reversed\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmpmz9uici7.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823183
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary = String::new();\n    let mut dec = decimal;\n    while dec\
    \ != 0 {\n        binary.push_str(&(dec % 2).to_string());\n        dec /= 2;\n\
    \    }\n    format!(\"db{}db\", binary.chars().rev().collect::<String>())\n}\n\
    \nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmp1vja3p98.rs:19:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823183
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    String::from(format!(\"db{:b}db\", decimal))\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823183
- exit_code: 1
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    format!(\"db{}db\", decimal.to_string(2))\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmp0zrmhftv.rs:8:31\n     |\n8    |     format!(\"db{}db\", decimal.to_string(2))\n\
    \     |                               ^^^^^^^^^ - supplied 1 argument\n     |\
    \                               |\n     |                               expected\
    \ 0 arguments\n     |\nnote: associated function defined here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1659823181
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary = String::new();\n    binary.push_str(\"db\");\n    let mut\
    \ is_zero = false;\n    let mut remainder = decimal;\n    let mut divisor = 2;\n\
    \    while !is_zero {\n        let result = remainder / divisor;\n        let\
    \ remainder_of_div = remainder % divisor;\n        if result == 0 && remainder_of_div\
    \ == 0 {\n            is_zero = true;\n        } else {\n            remainder\
    \ = result;\n            if remainder_of_div == 0 {\n                binary.push_str(\"\
    0\");\n            } else {\n                binary.push_str(\"1\");\n       \
    \     }\n        }\n    }\n    binary.push_str(\"db\");\n    return binary;\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmp2cm79a53.rs:33:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823183
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary = String::new();\n    let mut val = decimal;\n    while val\
    \ > 0 {\n        binary.push_str(&(val % 2).to_string());\n        val /= 2;\n\
    \    }\n    binary.chars().rev().collect::<String>()\n}\n\nfn main() {\n    let\
    \ candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"db0db\"`', /tmp/tmp8cy4akfo.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823183
- exit_code: 1
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut result = String::from(\"db\");\n    if decimal == 0 {\n        result.push('0');\n\
    \    } else {\n        while decimal > 0 {\n            result.push_str(&format!(\"\
    {}\", decimal % 2));\n            decimal /= 2;\n        }\n    }\n    result.push_str(\"\
    db\");\n    result.chars().rev().collect()\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `decimal`\n  --> /tmp/tmpfvm9dmpw.rs:14:13\n\
    \   |\n7  | fn decimal_to_binary(decimal: isize) -> String {\n   |           \
    \           ------- help: consider making this binding mutable: `mut decimal`\n\
    ...\n14 |             decimal /= 2;\n   |             ^^^^^^^^^^^^ cannot assign\
    \ to immutable argument\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659823183
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut value = decimal;\n    let mut binary = \"db\".to_string();\n    while\
    \ value > 0 {\n        binary = binary + &(value % 2).to_string();\n        value\
    \ = value / 2;\n    }\n    binary + \"db\"\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmpab47obv9.rs:19:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823183
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    if decimal == 0 {\n        return String::from(\"db0db\");\n    }\n    let\
    \ mut result = String::new();\n    let mut remainder = decimal;\n    while remainder\
    \ > 0 {\n        let modulus = remainder % 2;\n        result.push_str(&modulus.to_string());\n\
    \        remainder = remainder / 2;\n    }\n    format!(\"db{}db\", result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823183
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    // 1. Convert to binary string\n    let mut binary = format!(\"{:b}\", decimal);\n\
    \n    // 2. Match an even or odd number of characters\n    let binary_db = match\
    \ binary.len() % 2 {\n        0 => format!(\"db{}db\", binary),\n        _ =>\
    \ format!(\"d{}db\", binary),\n    };\n\n    binary_db\n}\n\nfn main() {\n   \
    \ let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"d0db\"`,\n right: `\"db0db\"`', /tmp/tmph1z6afa1.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823183
- exit_code: 1
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    format!(\"db{}db\", decimal.to_string(2))\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmp0zrmhftv.rs:8:31\n     |\n8    |     format!(\"db{}db\", decimal.to_string(2))\n\
    \     |                               ^^^^^^^^^ - supplied 1 argument\n     |\
    \                               |\n     |                               expected\
    \ 0 arguments\n     |\nnote: associated function defined here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1659823181
- exit_code: 1
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    format!(\"db{}db\", isize::to_string(decimal, 2))\n}\n\nfn main() {\n   \
    \ let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpkj_y_56c.rs:8:23\n     |\n8    |     format!(\"db{}db\", isize::to_string(decimal,\
    \ 2))\n     |                       ^^^^^^^^^^^^^^^^ -------  - supplied 2 arguments\n\
    \     |                       |\n     |                       expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659823183
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut result = format!(\"db{}db\", decimal.to_string());\n    let mut binary\
    \ = \"\".to_string();\n    let mut current = 0;\n    let mut number = decimal;\n\
    \    let mut reverse = false;\n    let mut power = 1;\n    while current < number\
    \ {\n        current = 2i32.pow(power) as isize;\n        power += 1;\n    }\n\
    \    current = 2i32.pow(power - 2) as isize;\n    power -= 2;\n    for _ in 0..power\
    \ {\n        if number >= current {\n            binary.push_str(\"1\");\n   \
    \         number -= current;\n        } else {\n            binary.push_str(\"\
    0\");\n        }\n        if current == 1 {\n            reverse = true;\n   \
    \     }\n        if reverse {\n            current -= 1;\n        } else {\n \
    \           current /= 2;\n        }\n    }\n    result.insert_str(2, &binary);\n\
    \    result\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmprcv4i1b6.rs:18:24

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823183
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut bin = Vec::new();\n    let mut n = decimal;\n    while n != 0 {\n\
    \        let m = n % 2;\n        n = n / 2;\n        bin.push(m);\n    }\n   \
    \ format!(\"db{}db\", bin.iter().rev().map(|&x| x.to_string()).collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmph7lqie8h.rs:20:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823183
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary = String::from(\"db\");\n    let mut left = decimal;\n   \
    \ while left > 0 {\n        let c = left % 2;\n        left = left / 2;\n    \
    \    binary.push(std::char::from_digit(c as u32, 10).unwrap());\n    }\n    binary.push_str(\"\
    db\");\n    binary.chars().rev().collect()\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpgt6b9q79.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823183
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut remainder: isize;\n    let mut binary = String::new();\n    let mut\
    \ temp = decimal;\n\n    while temp > 0 {\n        remainder = temp % 2;\n   \
    \     temp /= 2;\n        binary.push_str(&remainder.to_string());\n    }\n\n\
    \    //reverse the number\n    binary.chars().rev().collect::<String>()\n}\n\n\
    fn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"db0db\"`', /tmp/tmpr5kvdtf_.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823183
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    format!(\"db{}db\", format!(\"{:b}\", decimal).to_string())\n}\n\nfn main()\
    \ {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823183
- exit_code: 1
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary = String::new();\n    binary.push_str(\"db\");\n    while\
    \ decimal != 0 {\n        binary.push_str(&decimal % 2.to_string());\n       \
    \ decimal /= 2;\n    }\n    binary.push_str(\"b\");\n    return binary.chars().rev().collect();\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot mod `&isize` by `String`\n  --> /tmp/tmpkaoge3rl.rs:11:34\n\
    \   |\n11 |         binary.push_str(&decimal % 2.to_string());\n   |         \
    \                         ^ no implementation for `&isize % String`\n   |\n  \
    \ = help: the trait `Rem<String>` is not implemented for `&isize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659823183
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    \"db\".to_string() + &format!(\"{:b}\", decimal) + \"db\"\n}\n\nfn main()\
    \ {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823183
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut results = vec![];\n    let mut number = decimal;\n    while number\
    \ > 0 {\n        results.push(if number % 2 == 0 { '0' } else { '1' });\n    \
    \    number /= 2;\n    }\n    results.reverse();\n    format!(\"db{}db\", results.into_iter().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmpn_23fzmv.rs:20:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823183
- exit_code: 1
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    format!(\"db{}db\", dec_to_binary(decimal))\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `dec_to_binary` in this scope\n -->\
    \ /tmp/tmp13x910ir.rs:8:23\n  |\n8 |     format!(\"db{}db\", dec_to_binary(decimal))\n\
    \  |                       ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659823183
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary = String::from(\"db\");\n    let mut num = decimal;\n    while\
    \ num != 0 {\n        binary.push_str(&((num % 2).to_string()));\n        num\
    \ /= 2;\n    }\n    binary.push_str(\"db\");\n    binary.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpho1duf4h.rs:20:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823183
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    format!(\"db{}db\", decimal.to_string())\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"db32db\"`,\n right: `\"db100000db\"`', /tmp/tmp82wz_mqb.rs:14:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823183
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut decimal = decimal;\n    let mut binary = String::from(\"db\");\n\
    \    while decimal > 0 {\n        let remainder = decimal % 2;\n        binary.push_str(&remainder.to_string());\n\
    \        decimal /= 2;\n    }\n    binary.push_str(\"db\");\n    binary.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpq6wgiejw.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823183
- exit_code: 1
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    format!(\"db{}db\", decimal.to_string(2))\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmp0zrmhftv.rs:8:31\n     |\n8    |     format!(\"db{}db\", decimal.to_string(2))\n\
    \     |                               ^^^^^^^^^ - supplied 1 argument\n     |\
    \                               |\n     |                               expected\
    \ 0 arguments\n     |\nnote: associated function defined here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1659823181
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut decimal = decimal;\n    while\
    \ decimal != 0 {\n        result.push_str(&(decimal % 2).to_string());\n     \
    \   decimal /= 2;\n    }\n    format!(\"db{}db\", result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmp22aotz04.rs:19:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823183
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    format!(\"db{}db\", decimal.to_string().chars().map(|c| format!(\"{:04b}\"\
    , c.to_digit(10).unwrap())).collect::<String>())\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"db0000db\"`,\n right: `\"db0db\"`', /tmp/tmpbtd73f46.rs:13:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823183
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    format!(\"db{}db\", decimal.to_string())\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"db32db\"`,\n right: `\"db100000db\"`', /tmp/tmp82wz_mqb.rs:14:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823183
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut bin = String::new();\n    let mut num = decimal;\n    bin.push_str(\"\
    db\");\n    while num > 0 {\n        bin.push_str(&(num%2).to_string());\n   \
    \     num = num/2;\n    }\n    bin.push_str(\"b\");\n    let mut fin = String::new();\n\
    \    for i in (0..bin.len()).rev() {\n        fin.push(bin.chars().nth(i).unwrap());\n\
    \    }\n    fin\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n  \
    \  assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bbd\"`,\n right: `\"db0db\"`', /tmp/tmpvkjupbp6.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823183
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    String::from(format!(\"{:#b}\", decimal))\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"0b0\"`,\n right: `\"db0db\"`', /tmp/tmpdi2bvrh_.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823183
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut result = String::new();\n    let mut current_number = decimal;\n\
    \    while current_number > 0 {\n        result.push(if current_number % 2 ==\
    \ 0 { '0' } else { '1' });\n        current_number /= 2;\n    }\n    let mut final_result\
    \ = String::from(\"db\");\n    for c in result.chars().rev() {\n        final_result.push(c);\n\
    \    }\n    final_result.push('b');\n    final_result\n}\n\nfn main() {\n    let\
    \ candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbb\"`,\n right: `\"db0db\"`', /tmp/tmp86lwvsxp.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823183
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut dec = decimal;\n    let mut binary: String = String::new();\n   \
    \ while dec > 0 {\n        binary.push_str(&format!(\"{}\", dec % 2));\n     \
    \   dec /= 2;\n    }\n    binary.chars().rev().collect::<String>()\n}\n\nfn main()\
    \ {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"db0db\"`', /tmp/tmp46eiu5n2.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823183
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary = String::from(\"db\");\n    let mut dec = decimal;\n    while\
    \ dec > 0 {\n        let bin_num = match dec % 2 {\n            0 => \"0\",\n\
    \            1 => \"1\",\n            _ => \"\",\n        };\n        binary.push_str(bin_num);\n\
    \        dec /= 2;\n    }\n    binary.push_str(\"db\");\n    binary\n}\n\nfn main()\
    \ {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmpv_zu31fc.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823183
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    if decimal < 0 {\n        let mut res = String::new();\n        res.push_str(\"\
    db\");\n        let mut a = decimal.abs();\n        while a > 0 {\n          \
    \  res.push_str(&(a % 2).to_string());\n            a /= 2;\n        }\n     \
    \   res.push_str(\"b\");\n        res.chars().rev().collect()\n    } else {\n\
    \        let mut res = String::new();\n        res.push_str(\"db\");\n       \
    \ let mut a = decimal;\n        while a > 0 {\n            res.push_str(&(a %\
    \ 2).to_string());\n            a /= 2;\n        }\n        res.push_str(\"b\"\
    );\n        res.chars().rev().collect()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bbd\"`,\n right: `\"db0db\"`', /tmp/tmpzqsuvz4w.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823183
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    if decimal < 0 {\n        panic!(\"Only positive number allowed\")\n    }\n\
    \n    if decimal == 0 {\n        return \"dbdb\".to_string();\n    }\n\n    let\
    \ mut decimal = decimal;\n    let mut binary = String::new();\n\n    loop {\n\
    \        if decimal == 0 {\n            break;\n        }\n\n        binary.push_str(&(decimal\
    \ % 2).to_string());\n        decimal /= 2;\n    }\n\n    binary = binary.chars().rev().collect();\n\
    \    let mut result = String::new();\n    result.push_str(\"db\");\n    result.push_str(&binary);\n\
    \    result.push_str(\"db\");\n\n    result\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmpfn93hz1z.rs:39:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823183
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let preamble = \"db\";\n    let postamble = \"db\";\n    let mut binary_string\
    \ = String::new();\n    let mut curr_decimal = decimal;\n    let mut has_remainder\
    \ = false;\n    let mut has_started = false;\n    loop {\n        if curr_decimal\
    \ < 2 {\n            binary_string = binary_string + &(curr_decimal.to_string());\n\
    \            break;\n        }\n        let remainder = curr_decimal % 2;\n  \
    \      if remainder > 0 {\n            has_remainder = true;\n        }\n    \
    \    if has_remainder || has_started {\n            binary_string = binary_string\
    \ + &(remainder.to_string());\n            has_started = true;\n        }\n  \
    \      curr_decimal = curr_decimal / 2;\n    }\n    binary_string = preamble.to_string()\
    \ + &binary_string.chars().rev().collect::<String>() + &postamble;\n    binary_string\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"db1db\"`,\n right: `\"db100000db\"`', /tmp/tmp5t266n0d.rs:36:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823183
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    return format!(\"db{}db\", decimal.to_string());\n}\n\nfn main() {\n    let\
    \ candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"db32db\"`,\n right: `\"db100000db\"`', /tmp/tmp3vkm2e23.rs:14:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823183
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut final_str = String::from(\"db\");\n    if decimal == 0 {\n      \
    \  final_str.push('0');\n    }\n    let mut tmp = decimal;\n    while tmp > 0\
    \ {\n        final_str.push_str(&format!(\"{}\", tmp % 2));\n        tmp /= 2;\n\
    \    }\n    final_str.push_str(\"db\");\n    final_str.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bd0bd\"`,\n right: `\"db0db\"`', /tmp/tmpf7xqnilx.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823183
- exit_code: 1
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    format!(\"db{}db\", decimal.to_string(2))\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmp0zrmhftv.rs:8:31\n     |\n8    |     format!(\"db{}db\", decimal.to_string(2))\n\
    \     |                               ^^^^^^^^^ - supplied 1 argument\n     |\
    \                               |\n     |                               expected\
    \ 0 arguments\n     |\nnote: associated function defined here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1659823181
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary: String = \"db\".to_string();\n    let mut target = decimal;\n\
    \    while target > 0 {\n        binary.push_str(\n            if target % 2 ==\
    \ 0 {\n                \"0\"\n            } else {\n                \"1\"\n  \
    \          }\n        );\n        target /= 2;\n    }\n    binary.push_str(\"\
    db\");\n    binary.chars().rev().collect()\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpny2xgy7w.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823183
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary = String::new();\n    binary.push_str(\"db\");\n    let mut\
    \ decimal = decimal;\n    loop {\n        if decimal <= 0 {\n            break;\n\
    \        }\n        let last_digit = decimal % 2;\n        binary.push_str(&last_digit.to_string());\n\
    \        decimal = decimal / 2;\n    }\n    binary.push_str(\"db\");\n    binary.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpd7e4n46d.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823183
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut res = String::from(\"db\");\n    let mut decimal = decimal;\n   \
    \ loop {\n        let remainder = decimal % 2;\n        res.push_str(&remainder.to_string());\n\
    \        decimal /= 2;\n        if decimal == 0 {\n            break;\n      \
    \  }\n    }\n    res.push_str(\"db\");\n    res.chars().rev().collect()\n}\n\n\
    fn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bd0bd\"`,\n right: `\"db0db\"`', /tmp/tmp8wxnx0nl.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823183
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary: String = String::new();\n    let mut decimal = decimal;\n\
    \    while decimal > 0 {\n        let rem = decimal % 2;\n        decimal = decimal\
    \ / 2;\n        binary.push_str(&rem.to_string());\n    }\n    binary\n}\n\nfn\
    \ main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"db0db\"`', /tmp/tmpsljy30ki.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823183
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut hex = String::from(\"db\");\n    let mut b = decimal;\n    loop {\n\
    \        hex = format!(\"{}{}\", b % 2, hex);\n        b /= 2;\n        if b ==\
    \ 0 {\n            break;\n        }\n    }\n    format!(\"{}db\", hex)\n}\n\n\
    fn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"0dbdb\"`,\n right: `\"db0db\"`', /tmp/tmpteg85f40.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823183
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary = String::new();\n    let mut num = decimal;\n    while num\
    \ > 0 {\n        let a = (num % 2) as u8;\n        num = num / 2;\n        binary.push(std::char::from_digit(a\
    \ as u32, 10).unwrap());\n    }\n    let mut new_str = String::from(\"db\");\n\
    \    for c in binary.chars().rev() {\n        new_str.push(c);\n    }\n    new_str.push('b');\n\
    \    new_str\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbb\"`,\n right: `\"db0db\"`', /tmp/tmpbitoe4d6.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823183
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut string = String::new();\n    let mut decimal = decimal;\n    let\
    \ mut db = \"db\".to_string();\n    if decimal < 0 {\n        db = \"b\".to_string();\n\
    \        decimal = decimal + 1;\n    }\n    while decimal > 0 {\n        string.push_str(&((decimal\
    \ % 2).to_string()));\n        decimal = decimal / 2;\n    }\n    db.push_str(&string);\n\
    \    db.push_str(\"b\");\n    db.chars().rev().collect()\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bbd\"`,\n right: `\"db0db\"`', /tmp/tmp5xm7u7bg.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823184
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    \"db\".to_string() + &format!(\"{:b}\", decimal) + \"db\"\n}\n\nfn main()\
    \ {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823183
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary = String::from(\"db\");\n    let mut quotient = decimal;\n\
    \    let mut remainder = 0;\n    loop {\n        remainder = quotient % 2;\n \
    \       quotient = quotient / 2;\n        binary.push_str(&remainder.to_string());\n\
    \        if quotient == 0 {\n            break;\n        }\n    }\n    binary.push_str(\"\
    db\");\n    binary.chars().rev().collect()\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bd0bd\"`,\n right: `\"db0db\"`', /tmp/tmp4r6dh0zp.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823184
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary = String::new();\n    let mut x = decimal;\n    while x >\
    \ 0 {\n        binary.push_str(&((x % 2).to_string()));\n        x /= 2;\n   \
    \ }\n    return format!(\"db{}b\", binary.chars().rev().collect::<String>());\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbb\"`,\n right: `\"db0db\"`', /tmp/tmprrgsz9rj.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823184
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    format!(\"db{}db\", format!(\"{:b}\", decimal))\n}\n\nfn main() {\n    let\
    \ candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823182
- exit_code: 1
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    format!(\"db{}db\", decimal.to_string_radix(2))\n}\n\nfn main() {\n    let\
    \ candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_string_radix` found for type `isize`\
    \ in the current scope\n --> /tmp/tmpy1cwj997.rs:8:31\n  |\n8 |     format!(\"\
    db{}db\", decimal.to_string_radix(2))\n  |                               ^^^^^^^^^^^^^^^\
    \ method not found in `isize`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659823182
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary = String::new();\n    let mut decimal = decimal;\n    while\
    \ decimal > 0 {\n        binary.push(std::char::from_digit((decimal % 2) as u32,\
    \ 10).unwrap());\n        decimal /= 2;\n    }\n    binary.chars().rev().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"db0db\"`', /tmp/tmpmhfp16e7.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823184
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary = vec![];\n    let mut decimal = decimal;\n    while decimal\
    \ > 0 {\n        binary.push(decimal % 2);\n        decimal /= 2;\n    }\n   \
    \ binary.reverse();\n    format!(\"db{}db\", binary.iter().fold(String::new(),\
    \ |s, d| s + &d.to_string()))\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmpvwnou4ix.rs:20:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823184
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut res = format!(\"db{}db\", decimal.to_string());\n    res.push_str(\"\
    1\");\n    res\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n   \
    \ assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"db0db1\"`,\n right: `\"db0db\"`', /tmp/tmpx22mtrfd.rs:15:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823184
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary: String = String::new();\n    let mut value = decimal;\n \
    \   while value > 0 {\n        binary.push_str(&(value % 2).to_string());\n  \
    \      value /= 2;\n    }\n    binary.chars().rev().collect::<String>()\n}\n\n\
    fn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"db0db\"`', /tmp/tmpninzyx54.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823184
- exit_code: 1
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    format!(\"db{}db\", decimal.to_string(2))\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmp0zrmhftv.rs:8:31\n     |\n8    |     format!(\"db{}db\", decimal.to_string(2))\n\
    \     |                               ^^^^^^^^^ - supplied 1 argument\n     |\
    \                               |\n     |                               expected\
    \ 0 arguments\n     |\nnote: associated function defined here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1659823181
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    format!(\"db{}db\", format!(\"{:b}\", decimal))\n}\n\nfn main() {\n    let\
    \ candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823182
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let db = \"db\";\n    let mut binary: String = db.to_string();\n    let mut\
    \ mutable_decimal = decimal;\n    if mutable_decimal == 0 {\n        return format!(\"\
    {}{}\", db, mutable_decimal);\n    }\n    while mutable_decimal > 0 {\n      \
    \  binary.push_str(&(mutable_decimal % 2).to_string());\n        mutable_decimal\
    \ /= 2;\n    }\n    binary.push_str(db);\n    return binary.chars().rev().collect::<String>();\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"db0\"`,\n right: `\"db0db\"`', /tmp/tmpbblcqwar.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823184
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    format!(\"db{}db\", decimal.to_string())\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"db32db\"`,\n right: `\"db100000db\"`', /tmp/tmp82wz_mqb.rs:14:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823183
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary: String = String::new();\n    let mut temp: isize = decimal;\n\
    \    while temp > 0 {\n        binary.push_str(match temp % 2 {\n            0\
    \ => \"0\",\n            1 => \"1\",\n            _ => \"\",\n        });\n  \
    \      temp /= 2;\n    }\n    binary.push_str(\"b0\");\n    binary.chars().rev().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"0b\"`,\n right: `\"db0db\"`', /tmp/tmp_84995lo.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823184
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary = format!(\"db{:b}db\", decimal);\n    let mut bin_len = binary.len();\n\
    \    let mut i = bin_len - 1;\n    while i > 0 {\n        binary.insert(i, 'b');\n\
    \        i -= 4;\n    }\n    binary\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"db0dbb\"`,\n right: `\"db0db\"`', /tmp/tmpaaae6dom.rs:20:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823184
- exit_code: 1
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    format!(\"db{}db\", decimal.to_string(2))\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmp0zrmhftv.rs:8:31\n     |\n8    |     format!(\"db{}db\", decimal.to_string(2))\n\
    \     |                               ^^^^^^^^^ - supplied 1 argument\n     |\
    \                               |\n     |                               expected\
    \ 0 arguments\n     |\nnote: associated function defined here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1659823181
- exit_code: 1
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary = String::new();\n    if decimal == 0 {\n        binary.push_str(\"\
    0\");\n    } else {\n        while decimal > 0 {\n            binary.push_str(&(decimal\
    \ % 2).to_string());\n            decimal /= 2;\n        }\n    }\n    binary\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `decimal`\n  --> /tmp/tmphgh5ysz1.rs:14:13\n\
    \   |\n7  | fn decimal_to_binary(decimal: isize) -> String {\n   |           \
    \           ------- help: consider making this binding mutable: `mut decimal`\n\
    ...\n14 |             decimal /= 2;\n   |             ^^^^^^^^^^^^ cannot assign\
    \ to immutable argument\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659823184
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary = String::new();\n    let mut num = decimal;\n    let mut\
    \ count = 0;\n    loop {\n        if num == 0 {\n            if count == 0 {\n\
    \                binary.push('0');\n            }\n            break;\n      \
    \  }\n        let x = num % 2;\n        binary.push_str(&x.to_string());\n   \
    \     num = num / 2;\n        count += 1;\n    }\n    binary.chars().rev().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"0\"`,\n right: `\"db0db\"`', /tmp/tmpjq3nim8z.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823184
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    // TODO\n    \"db00db\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"db00db\"`,\n right: `\"db0db\"`', /tmp/tmputpgfva_.rs:14:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823184
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary = vec![];\n    let mut decimal = decimal;\n    while decimal\
    \ > 0 {\n        binary.push(if decimal % 2 == 0 { '0' } else { '1' });\n    \
    \    decimal /= 2;\n    }\n    binary.reverse();\n    format!(\"db{}db\", binary.into_iter().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmp_448d96c.rs:20:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823184
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut bin = String::new();\n    let mut num = decimal;\n    let (mut remainder,\
    \ mut quotient);\n    while num > 0 {\n        remainder = num % 2;\n        quotient\
    \ = num / 2;\n        num = quotient;\n        bin.push_str(&remainder.to_string());\n\
    \    }\n    String::from(\"db\") + &bin.chars().rev().collect::<String>() + \"\
    db\"\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmptbmq5ge5.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823184
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let db = \"db\";\n    format!(\"{}\", db)\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"db\"`,\n right: `\"db0db\"`', /tmp/tmpc1041j25.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823184
- exit_code: 1
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    format!(\"db{}db\", isize::to_str_radix(decimal, 2))\n}\n\nfn main() {\n\
    \    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no function or associated item named `to_str_radix` found\
    \ for type `isize` in the current scope\n --> /tmp/tmp0ekdb90o.rs:8:30\n  |\n\
    8 |     format!(\"db{}db\", isize::to_str_radix(decimal, 2))\n  |            \
    \                  ^^^^^^^^^^^^\n  |                              |\n  |     \
    \                         function or associated item not found in `isize`\n \
    \ |                              help: there is an associated function with a\
    \ similar name: `from_str_radix`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659823184
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    // db01db\n    let mut result = String::from(\"db\");\n    let mut decimal\
    \ = decimal;\n    while decimal > 0 {\n        result.push_str(&((decimal % 2).to_string()));\n\
    \        decimal /= 2;\n    }\n    result.push_str(\"db\");\n    result.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpwlsvissp.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823184
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut res = String::new();\n    let mut n = decimal;\n    res.push_str(\"\
    db\");\n    loop {\n        if n == 0 {\n            break;\n        }\n     \
    \   let r = n % 2;\n        res.push_str(&r.to_string());\n        n = n / 2;\n\
    \    }\n    res.push_str(\"b\");\n    res.chars().rev().collect()\n}\n\nfn main()\
    \ {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bbd\"`,\n right: `\"db0db\"`', /tmp/tmpewxms_b5.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823184
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut result = String::from(\"db\");\n    let mut value = decimal;\n  \
    \  while value > 0 {\n        let rem = value % 2;\n        result.push_str(&format!(\"\
    {}\", rem));\n        value /= 2;\n    }\n    result.push_str(\"db\");\n    result.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpg3uq7z7n.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823184
- exit_code: 1
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    format!(\"db{}db\", binary_format(&decimal.to_string()))\n}\n\nfn main()\
    \ {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `binary_format` in this scope\n -->\
    \ /tmp/tmplto240yd.rs:8:23\n  |\n8 |     format!(\"db{}db\", binary_format(&decimal.to_string()))\n\
    \  |                       ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659823184
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut result = String::from(\"db\");\n    let mut decimal = decimal;\n\
    \    while decimal != 0 {\n        result.push(if decimal % 2 == 0 { '0' } else\
    \ { '1' });\n        decimal /= 2;\n    }\n    result.push('b');\n    result.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bbd\"`,\n right: `\"db0db\"`', /tmp/tmpd75h93as.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823184
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary = String::new();\n    let mut decimal = decimal;\n    while\
    \ decimal != 0 {\n        binary.push_str(&((decimal % 2).to_string()));\n   \
    \     decimal /= 2;\n    }\n    let mut new_binary = String::new();\n    for c\
    \ in binary.chars().rev() {\n        new_binary.push(c);\n    }\n    format!(\"\
    db{}db\", new_binary)\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmpxj6xg12i.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823184
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    format!(\"db{}db\", decimal.to_string())\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"db32db\"`,\n right: `\"db100000db\"`', /tmp/tmp82wz_mqb.rs:14:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823183
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    format!(\"db{}db\", format!(\"{:b}\", decimal))\n}\n\nfn main() {\n    let\
    \ candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823182
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut string: String = \"db\".to_string();\n    let mut n = decimal;\n\
    \    loop {\n        if n > 0 {\n            string.push(match n % 2 {\n     \
    \           0 => '0',\n                _ => '1',\n            });\n          \
    \  n /= 2;\n        } else {\n            break;\n        }\n    }\n    string.push_str(\"\
    db\");\n    string.chars().rev().collect()\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpg185f12k.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823184
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    format!(\"db{}db\", format!(\"{:b}\", decimal))\n}\n\nfn main() {\n    let\
    \ candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823182
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut result = String::from(\"db\");\n    let mut value = decimal;\n  \
    \  while value != 0 {\n        if value % 2 == 0 {\n            result.push('0');\n\
    \        } else {\n            result.push('1');\n        }\n        value /=\
    \ 2;\n    }\n    result.push_str(\"db\");\n    result.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpsn1mcb19.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823184
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut ret = \"db\".to_string();\n    let mut n = decimal;\n    while n\
    \ > 0 {\n        let b = n % 2;\n        n = n / 2;\n        ret.push_str(&b.to_string());\n\
    \    }\n    ret.push_str(\"db\");\n    ret.chars().rev().collect()\n}\n\nfn main()\
    \ {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmps210wqps.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823184
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary = String::from(\"db\");\n    let mut rem = decimal;\n    while\
    \ rem > 0 {\n        binary.push_str(&(rem % 2).to_string());\n        rem /=\
    \ 2;\n    }\n    binary.push_str(\"db\");\n    binary.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpxb6nggqr.rs:20:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823184
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary = \"db\".to_string();\n    let mut dec = decimal;\n    while\
    \ dec > 0 {\n        binary.push_str(&((dec % 2).to_string()));\n        dec /=\
    \ 2;\n    }\n    binary.push_str(\"db\");\n    binary.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpf25227my.rs:20:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823184
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    format!(\"db{}db\", format!(\"{:b}\", decimal))\n}\n\nfn main() {\n    let\
    \ candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823182
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    format!(\"db{}db\", format!(\"{:b}\", decimal))\n}\n\nfn main() {\n    let\
    \ candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823182
- exit_code: 1
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    format!(\"db{}db\", isize::to_str_radix(decimal, 2))\n}\n\nfn main() {\n\
    \    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no function or associated item named `to_str_radix` found\
    \ for type `isize` in the current scope\n --> /tmp/tmp0ekdb90o.rs:8:30\n  |\n\
    8 |     format!(\"db{}db\", isize::to_str_radix(decimal, 2))\n  |            \
    \                  ^^^^^^^^^^^^\n  |                              |\n  |     \
    \                         function or associated item not found in `isize`\n \
    \ |                              help: there is an associated function with a\
    \ similar name: `from_str_radix`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659823184
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    // Decimal can be converted to binary using the to_string() function, but\n\
    \    // the result will be in base 2, so we need to remove the '0b' part.\n  \
    \  format!(\"db{}db\", decimal.to_string().replace(\"0b\", \"\"))\n}\n\nfn main()\
    \ {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"db32db\"`,\n right: `\"db100000db\"`', /tmp/tmp5xdql34d.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823184
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary = String::new();\n    let mut num = decimal;\n    let mut\
    \ count = 0;\n    while num > 0 {\n        binary.push_str(&(num % 2).to_string());\n\
    \        num /= 2;\n        count += 1;\n    }\n    binary.chars().rev().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"db0db\"`', /tmp/tmpift5c4pw.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823184
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut string = \"db\".to_string();\n    let mut decimal = decimal;\n  \
    \  while decimal > 0 {\n        let rem = decimal % 2;\n        string = format!(\"\
    {}{}\", rem, string);\n        decimal = decimal / 2;\n    }\n    string = format!(\"\
    {}db\", string);\n    string\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmpspu7kknv.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823184
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    format!(\"db{}db\", format!(\"{:b}\", decimal))\n}\n\nfn main() {\n    let\
    \ candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823182
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary = String::from(\"db\");\n    let mut number = decimal;\n \
    \   while number > 0 {\n        let rem = number % 2;\n        binary.push_str(&rem.to_string());\n\
    \        number /= 2;\n    }\n    binary.push_str(\"db\");\n    binary.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpq043n5pk.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823184
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    //\n    //    binary_to_decimal(\"db11011011010110110111110111db\")\n   \
    \ //    // should return 123456789\n    //    binary_to_decimal(\"db10011101101101db\"\
    )\n    //    // should return 2015\n    format!(\"db{:b}db\", decimal)\n}\n\n\
    fn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823184
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary = String::from(\"db\");\n    let mut n = decimal;\n    while\
    \ n > 0 {\n        binary.push_str(&((n % 2).to_string()));\n        n /= 2;\n\
    \    }\n    binary.push_str(\"db\");\n    binary.chars().rev().collect()\n}\n\n\
    fn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpsffqikkn.rs:20:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823184
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    // db010101db\n    // db0101db\n    // db1db\n    let mut binary = \"db\"\
    .to_string();\n    let mut n = decimal;\n    while n > 0 {\n        binary.push_str(&(n%2).to_string());\n\
    \        n = n/2;\n    }\n    binary.push_str(\"db\");\n    binary.chars().rev().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpdhomw_ue.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823184
- exit_code: 1
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary = String::from(\"db\");\n    if decimal == 0 {\n        binary.push('0');\n\
    \    } else {\n        while decimal > 0 {\n            let rem = decimal % 2;\n\
    \            decimal /= 2;\n            let binary_character = match rem {\n \
    \               0 => '0',\n                1 => '1',\n                _ => ' ',\n\
    \            };\n            binary.push(binary_character);\n        }\n    }\n\
    \    binary.push('b');\n    binary.chars().rev().collect()\n}\n\nfn main() {\n\
    \    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `decimal`\n  --> /tmp/tmpgqkdmi8i.rs:14:13\n\
    \   |\n7  | fn decimal_to_binary(decimal: isize) -> String {\n   |           \
    \           ------- help: consider making this binding mutable: `mut decimal`\n\
    ...\n14 |             decimal /= 2;\n   |             ^^^^^^^^^^^^ cannot assign\
    \ to immutable argument\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659823184
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut decimal = decimal;\n    let mut binary = String::from(\"db\");\n\
    \    while decimal > 0 {\n        binary.push_str(&(decimal % 2).to_string());\n\
    \        decimal /= 2;\n    }\n    binary.push_str(\"db\");\n    return binary.chars().rev().collect();\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpnt7zzw6_.rs:20:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823184
- exit_code: 1
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    format!(\"db{}db\", &decimal.to_string().chars().map(|x| {\n        match\
    \ x {\n            '0' => '00',\n            '1' => '01',\n            '2' =>\
    \ '10',\n            '3' => '11',\n            '4' => '100',\n            '5'\
    \ => '101',\n            '6' => '110',\n            '7' => '111',\n          \
    \  '8' => '1000',\n            '9' => '1001',\n            _ => panic!(\"Illegal\
    \ input\")\n        }\n    }).collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmp5yvdqeqw.rs:10:20\n\
    \   |\n10 |             '0' => '00',\n   |                    ^^^^\n   |\nhelp:\
    \ if you meant to write a `str` literal, use double quotes\n   |\n10 |       \
    \      '0' => \"00\",\n   |                    ~~~~\n\nerror: character literal\
    \ may only contain one codepoint\n  --> /tmp/tmp5yvdqeqw.rs:11:20\n   |\n11 |\
    \             '1' => '01',\n   |                    ^^^^\n   |\nhelp: if you meant\
    \ to write a `str` literal, use double quotes\n   |\n11 |             '1' => \"\
    01\",\n   |                    ~~~~\n\nerror: character literal may only contain\
    \ one codepoint\n  --> /tmp/tmp5yvdqeqw.rs:12:20\n   |\n12 |             '2' =>\
    \ '10',\n   |                    ^^^^\n   |\nhelp: if you meant to write a `str`\
    \ literal, use double quotes\n   |\n12 |             '2' => \"10\",\n   |    \
    \                ~~~~\n\nerror: character literal may only contain one codepoint\n\
    \  --> /tmp/tmp5yvdqeqw.rs:13:20\n   |\n13 |             '3' => '11',\n   |  \
    \                  ^^^^\n   |\nhelp: if you meant to write a `str` literal, use\
    \ double quotes\n   |\n13 |             '3' => \"11\",\n   |                 \
    \   ~~~~\n\nerror: character literal may only contain one codepoint\n  --> /tmp/tmp5yvdqeqw.rs:14:20\n\
    \   |\n14 |             '4' => '100',\n   |                    ^^^^^\n   |\nhelp:\
    \ if you meant to write a `str` literal, use double quotes\n   |\n14 |       \
    \      '4' => \"100\",\n   |                    ~~~~~\n\nerror: character literal\
    \ may only contain one codepoint\n  --> /tmp/tmp5yvdqeqw.rs:15:20\n   |\n15 |\
    \             '5' => '101',\n   |                    ^^^^^\n   |\nhelp: if you\
    \ meant to write a `str` literal, use double quotes\n   |\n15 |             '5'\
    \ => \"101\",\n   |                    ~~~~~\n\nerror: character literal may only\
    \ contain one codepoint\n  --> /tmp/tmp5yvdqeqw.rs:16:20\n   |\n16 |         \
    \    '6' => '110',\n   |                    ^^^^^\n   |\nhelp: if you meant to\
    \ write a `str` literal, use double quotes\n   |\n16 |             '6' => \"110\"\
    ,\n   |                    ~~~~~\n\nerror: character literal may only contain"
  stdout: ''
  timestamp: 1659823184
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    decimal.to_string()\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"0\"`,\n right: `\"db0db\"`', /tmp/tmpu024o3o_.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823182
- exit_code: 1
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    format!(\"db{}db\", binary_str(decimal))\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `binary_str` in this scope\n --> /tmp/tmpa293gg8y.rs:8:23\n\
    \  |\n8 |     format!(\"db{}db\", binary_str(decimal))\n  |                  \
    \     ^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823184
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary: String = String::new();\n    let mut x = decimal;\n    binary.push_str(\"\
    db\");\n    if x == 0 {\n        binary.push('0');\n    }\n    while x > 0 {\n\
    \        if x % 2 == 0 {\n            binary.push('0');\n        } else {\n  \
    \          binary.push('1');\n        }\n        x /= 2;\n    }\n    binary.push_str(\"\
    db\");\n    binary.chars().rev().collect()\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bd0bd\"`,\n right: `\"db0db\"`', /tmp/tmp3hsp6o0o.rs:28:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823184
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary = String::from(\"db\");\n    let mut decimal = decimal;\n\
    \    while decimal != 0 {\n        let remainder = decimal % 2;\n        decimal\
    \ = decimal / 2;\n        binary.push_str(&remainder.to_string());\n    }\n  \
    \  binary.push_str(\"db\");\n    binary.chars().rev().collect()\n}\n\nfn main()\
    \ {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmphe3iw3st.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823184
- exit_code: 1
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    // The format of the string will be 'dbxxxxxxdb', where the 'xxxxxx' are\
    \ the binary numbers.\n    let mut result = String::new();\n    let mut remainder\
    \ = decimal;\n    let mut number = 0;\n    let mut power = 0;\n    let mut number_string\
    \ = String::new();\n    // Example, the number 25 is 11001 in binary. The 'xxxxxx'\
    \ will represent the number 11001,\n    // but there will be other characters,\
    \ 'db' at the beginning and end.\n    result.push_str(\"db\");\n    if decimal\
    \ == 0 {\n        result.push_str(\"0\");\n    }\n    while remainder > 0 {\n\
    \        remainder /= 2;\n        power += 1;\n    }\n    while power > 0 {\n\
    \        power -= 1;\n        number = decimal / 2_isize.pow(power);\n       \
    \ if number == 1 {\n            number_string.push_str(\"1\");\n            result.push_str(\"\
    1\");\n            remainder = decimal - 2_isize.pow(power);\n            decimal\
    \ = remainder;\n        } else {\n            number_string.push_str(\"0\");\n\
    \            result.push_str(\"0\");\n        }\n    }\n    result.push_str(\"\
    db\");\n    result\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: SyntaxError
  stderr: "warning: value assigned to `number` is never read\n  --> /tmp/tmpn98e_0xg.rs:11:13\n\
    \   |\n11 |     let mut number = 0;\n   |             ^^^^^^\n   |\n   = note:\
    \ `#[warn(unused_assignments)]` on by default\n   = help: maybe it is overwritten\
    \ before being read?\n\nerror[E0384]: cannot assign to immutable argument `decimal`\n\
    \  --> /tmp/tmpn98e_0xg.rs:31:13\n   |\n7  | fn decimal_to_binary(decimal: isize)\
    \ -> String {\n   |                      ------- help: consider making this binding\
    \ mutable: `mut decimal`\n...\n31 |             decimal = remainder;\n   |   \
    \          ^^^^^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659823184
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    format!(\"db{}db\", decimal.to_string())\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"db32db\"`,\n right: `\"db100000db\"`', /tmp/tmp82wz_mqb.rs:14:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823183
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let prefix = \"db\";\n    let suffix = \"db\";\n    let binary = format!(\"\
    {:b}\", decimal);\n    format!(\"{}{}{}\", prefix, binary, suffix)\n}\n\nfn main()\
    \ {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823184
- exit_code: 1
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut int = 0;\n    let mut binary = Vec::new();\n    while decimal > 0\
    \ {\n        let rem = decimal % 2;\n        int = int * 10 + rem;\n        decimal\
    \ /= 2;\n    }\n    let mut int = int.to_string();\n    for c in int.chars() {\n\
    \        binary.push(c);\n    }\n    binary.reverse();\n    let mut b = String::new();\n\
    \    b.push_str(\"db\");\n    for c in binary {\n        b.push(c);\n    }\n \
    \   b.push_str(\"db\");\n    b\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpfca_b5by.rs:15:9\n\
    \   |\n15 |     let mut int = int.to_string();\n   |         ----^^^\n   |   \
    \      |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0384]: cannot assign to immutable argument `decimal`\n\
    \  --> /tmp/tmpfca_b5by.rs:13:9\n   |\n7  | fn decimal_to_binary(decimal: isize)\
    \ -> String {\n   |                      ------- help: consider making this binding\
    \ mutable: `mut decimal`\n...\n13 |         decimal /= 2;\n   |         ^^^^^^^^^^^^\
    \ cannot assign to immutable argument\n\nerror: aborting due to previous error;\
    \ 1 warning emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659823184
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    // Basically I'm inverting a binary string in this solution\n    let mut\
    \ binary_str = format!(\"{:b}\", decimal);\n    let mut binary_output = \"db\"\
    .to_string();\n    let mut itr = binary_str.len();\n    while itr > 0 {\n    \
    \    binary_output.push(binary_str.chars().nth(itr - 1).unwrap());\n        itr\
    \ -= 1;\n    }\n    binary_output.push_str(\"db\");\n    binary_output\n}\n\n\
    fn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"db000001db\"`,\n right: `\"db100000db\"`', /tmp/tmpqvwwl5i7.rs:23:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823184
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    // TODO\n    \"db11111111db\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"db11111111db\"`,\n right: `\"db0db\"`', /tmp/tmphtkww4gp.rs:14:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823184
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let bin_str = if decimal == 0 {\n        \"0\".to_string()\n    } else {\n\
    \        let mut n = decimal;\n        let mut remainders = Vec::new();\n    \
    \    while n > 0 {\n            remainders.push(n % 2);\n            n /= 2;\n\
    \        }\n        remainders.iter().rev().map(|r| r.to_string()).collect()\n\
    \    };\n    format!(\"db{}db\", bin_str)\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823185
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut res = String::new();\n    let mut remaining = decimal;\n    while\
    \ remaining > 0 {\n        res.push_str(&(remaining % 2).to_string());\n     \
    \   remaining /= 2;\n    }\n    res.chars().rev().collect::<String>()\n}\n\nfn\
    \ main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"db0db\"`', /tmp/tmpvswrf4z3.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823184
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut decimal = decimal;\n    let mut binary = String::from(\"db\");\n\
    \    while decimal > 0 {\n        binary.push_str(&((decimal % 2).to_string()));\n\
    \        decimal /= 2;\n    }\n    binary.push_str(\"db\");\n    binary.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpnj09a4xw.rs:20:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823185
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    format!(\"db{}db\", format!(\"{:b}\", decimal))\n}\n\nfn main() {\n    let\
    \ candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823182
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    format!(\"db{}db\", format!(\"{:b}\", decimal))\n}\n\nfn main() {\n    let\
    \ candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823182
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary = vec![];\n    let mut i = decimal;\n    while i > 0 {\n \
    \       binary.push(if i % 2 == 0 { '0' } else { '1' });\n        i /= 2;\n  \
    \  }\n    format!(\"db{}db\", binary.iter().rev().collect::<String>())\n}\n\n\
    fn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmp8et86j39.rs:19:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823184
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    \"d\".to_string() + &decimal.to_string() + \"b\"\n}\n\nfn main() {\n    let\
    \ candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"d0b\"`,\n right: `\"db0db\"`', /tmp/tmp1no7fqv7.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823185
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary: String = String::new();\n    let mut num = decimal;\n   \
    \ if num == 0 {\n        return String::from(\"db0db\");\n    }\n    while num\
    \ > 0 {\n        binary.push(std::char::from_digit((num % 2) as u32, 10).unwrap());\n\
    \        num /= 2;\n    }\n    binary.push_str(\"db\");\n    binary.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bd100000\"`,\n right: `\"db100000db\"`', /tmp/tmpm0n7vw_d.rs:24:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823185
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    if decimal == 0 {\n        \"db0db\".to_string()\n    } else {\n        format!(\"\
    db{}db\", decimal.to_string().chars().map(|d| (d as isize - 48).to_string()).collect::<String>())\n\
    \    }\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"db32db\"`,\n right: `\"db100000db\"`', /tmp/tmpopud0d_2.rs:18:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823185
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    return format!(\"db{}db\", decimal.to_string());\n}\n\nfn main() {\n    let\
    \ candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"db32db\"`,\n right: `\"db100000db\"`', /tmp/tmp3vkm2e23.rs:14:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823183
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let binary = format!(\"{:b}\", decimal);\n    format!(\"db{}db\", binary)\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823182
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut bin = format!(\"{:b}\", decimal);\n    bin.insert_str(0, \"db\");\n\
    \    bin.push_str(\"db\");\n    bin\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823182
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary = String::new();\n    let mut dec = decimal;\n    while dec\
    \ != 0 {\n        binary.push_str(&(dec % 2).to_string());\n        dec /= 2;\n\
    \    }\n    binary.chars().rev().collect::<String>()\n}\n\nfn main() {\n    let\
    \ candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"db0db\"`', /tmp/tmpvxnpkgwm.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823182
- exit_code: 1
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    format!(\"db{}db\", dec_to_bin(decimal).collect::<String>())\n}\n\nfn main()\
    \ {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `dec_to_bin` in this scope\n --> /tmp/tmpkyovr7ky.rs:8:23\n\
    \  |\n8 |     format!(\"db{}db\", dec_to_bin(decimal).collect::<String>())\n \
    \ |                       ^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659823184
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    // TODO: wite your code here\n    // &0b1010_1010_u8\n    let mut bin_str\
    \ = format!(\"{:b}\", decimal);\n    let mut ret_str = \"db\".to_string();\n \
    \   ret_str.push_str(&bin_str);\n    ret_str.push_str(\"db\");\n    ret_str\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823185
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary = String::new();\n    let mut decimal = decimal;\n    while\
    \ decimal != 0 {\n        binary.push_str(&(decimal % 2).to_string());\n     \
    \   decimal /= 2;\n    }\n    format!(\"db{}db\", binary.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmpah1pwjuh.rs:19:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823185
- exit_code: 1
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    format!(\"db{}db\", decimal.to_string(2))\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmp0zrmhftv.rs:8:31\n     |\n8    |     format!(\"db{}db\", decimal.to_string(2))\n\
    \     |                               ^^^^^^^^^ - supplied 1 argument\n     |\
    \                               |\n     |                               expected\
    \ 0 arguments\n     |\nnote: associated function defined here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1659823181
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary = format!(\"db{:b}db\", decimal);\n    let mut zeros_to_add\
    \ = 8 - binary.len() % 8;\n    if zeros_to_add == 8 {\n        zeros_to_add =\
    \ 0;\n    }\n    for _ in 0..zeros_to_add {\n        binary.insert(2, '0');\n\
    \    }\n    binary\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"db0000db\"`,\n right: `\"db0db\"`', /tmp/tmpzj75outt.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823185
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut binary = String::new();\n    let mut dec = decimal;\n    while dec\
    \ > 0 {\n        binary.push_str(&(dec % 2).to_string());\n        dec /= 2;\n\
    \    }\n    binary.push_str(\"db\");\n    binary.chars().rev().collect()\n}\n\n\
    fn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bd\"`,\n right: `\"db0db\"`', /tmp/tmpigoxrkr_.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823185
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut n = decimal;\n    let mut result = String::new();\n    while n !=\
    \ 0 {\n        let remain = n % 2;\n        n = n / 2;\n        result.push_str(&remain.to_string());\n\
    \    }\n    format!(\"db{}db\", &result.chars().rev().collect::<String>())\n}\n\
    \nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmpr1aknd3k.rs:20:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823185
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    // if(decimal % 2 == 0) {\n    //     return decimal_to_binary(decimal /\
    \ 2) + \"0\".to_string();\n    // } else {\n    //     return decimal_to_binary(decimal\
    \ / 2) + \"1\".to_string();\n    // }\n    format!(\"db{}db\", format!(\"{:b}\"\
    , decimal))\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823185
- exit_code: 101
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    let mut result = \"db\".to_string();\n    let mut n = decimal;\n    while\
    \ n > 0 {\n        result.push_str(&(n % 2).to_string());\n        n /= 2;\n \
    \   }\n    result.push_str(\"db\");\n    result.chars().rev().collect()\n}\n\n\
    fn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpdkn24tzr.rs:20:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823185
- exit_code: 0
  program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\nfn decimal_to_binary(decimal: isize) -> String {\n\
    \    // .unwrap() could panic, but not here\n    (format!(\"db{:b}db\", decimal)).to_string()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823185
