name: HumanEval_69_search
language: rs
prompt: "/// You are given a non-empty list of positive integers. Return the greatest\
  \ integer that is greater than \n/// zero, and has a frequency greater than or equal\
  \ to the value of the integer itself. \n/// The frequency of an integer is the number\
  \ of times it appears in the list.\n/// If no such a value exist, return -1.\nfn\
  \ search(lst: Vec<isize>) -> isize {\n"
tests: "}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![5,\
  \ 5, 5, 5, 1]), 1);\n    assert_eq!(candidate(vec![4, 1, 4, 1, 4, 4]), 4);\n   \
  \ assert_eq!(candidate(vec![3, 3]), -1);\n    assert_eq!(candidate(vec![8, 8, 8,\
  \ 8, 8, 8, 8, 8]), 8);\n    assert_eq!(candidate(vec![2, 3, 3, 2, 2]), 2);\n   \
  \ assert_eq!(candidate(vec![2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1,\
  \ 7, 4, 10, 8, 1]), 1);\n    assert_eq!(candidate(vec![3, 2, 8, 2]), 2);\n    assert_eq!(candidate(vec![6,\
  \ 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]), 1);\n    assert_eq!(candidate(vec![8, 8, 3,\
  \ 6, 5, 6, 4]), -1);\n    assert_eq!(candidate(vec![6, 9, 6, 7, 1, 4, 7, 1, 8, 8,\
  \ 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]), 1);\n    assert_eq!(candidate(vec![1,\
  \ 9, 10, 1, 3]), 1);\n    assert_eq!(candidate(vec![6, 9, 7, 5, 8, 7, 5, 3, 7, 5,\
  \ 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]), 5);\n    assert_eq!(candidate(vec![1]),\
  \ 1);\n    assert_eq!(candidate(vec![8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6,\
  \ 10, 4, 2, 1, 10, 2, 1, 1, 5]), 4);\n    assert_eq!(candidate(vec![2, 10, 4, 8,\
  \ 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]), 2);\n    assert_eq!(candidate(vec![1,\
  \ 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]), 1);\n    assert_eq!(candidate(vec![9, 2,\
  \ 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8,\
  \ 10, 9, 4]), 4);\n    assert_eq!(candidate(vec![2, 6, 4, 2, 8, 7, 5, 6, 4, 10,\
  \ 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]), 4);\n    assert_eq!(candidate(vec![9,\
  \ 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]), 2);\n    assert_eq!(candidate(vec![5,\
  \ 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]), -1);\n    assert_eq!(candidate(vec![10]),\
  \ -1);\n    assert_eq!(candidate(vec![9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]),\
  \ 2);\n    assert_eq!(candidate(vec![5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]), 1);\n\
  \    assert_eq!(candidate(vec![7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5,\
  \ 6, 7, 6, 7, 7, 6]), 1);\n    assert_eq!(candidate(vec![3, 10, 10, 9, 2]), -1);\n\
  }\n"
completions: ["    let mut counter = HashMap::new();\n    for element in lst {\n \
    \       *counter.entry(element).or_insert(0) += 1;\n    }\n    let mut result\
    \ = -1;\n    for (number, count) in counter {\n        if count >= number {\n\
    \            result = number;\n        }\n    }\n    result", "    let mut max_freq\
    \ = 0;\n    let mut count = HashMap::new();\n    for n in lst {\n        let count\
    \ = count.entry(n).or_insert(0);\n        *count += 1;\n        if *count > max_freq\
    \ {\n            max_freq = *count;\n        }\n    }\n    for (key, value) in\
    \ count {\n        if key <= value && key > max_freq {\n            max_freq =\
    \ key;\n        }\n    }\n    if max_freq == 0 {\n        -1\n    } else {\n \
    \       max_freq\n    }", "    let mut arr = vec![0; 1001];\n    let mut max =\
    \ -1;\n    for el in lst {\n        arr[el as usize] += 1;\n        if arr[el\
    \ as usize] >= el && el > max {\n            max = el;\n        }\n    }\n   \
    \ max", "    let mut min = -1;\n    let mut freq = HashMap::new();\n    for i\
    \ in lst {\n        *freq.entry(i).or_insert(0) += 1;\n    }\n    for i in lst\
    \ {\n        if freq[&i] >= i && i > min {\n            min = i;\n        }\n\
    \    }\n    min", "    let mut freq = std::collections::HashMap::new();\n    for\
    \ i in lst {\n        *freq.entry(i).or_insert(0) += 1;\n    }\n    for i in (1..100).rev()\
    \ {\n        match freq.get(&i) {\n            Some(num) => {\n              \
    \  if num >= &i {\n                    return i;\n                }\n        \
    \    }\n            None => (),\n        }\n    }\n    -1", "    let mut num_counts\
    \ = HashMap::new();\n    for i in lst {\n        let count = num_counts.entry(i).or_insert(0);\n\
    \        *count += 1;\n    }\n    let mut max_freq = 0;\n    for (num, freq) in\
    \ num_counts {\n        if num <= freq && freq > max_freq {\n            max_freq\
    \ = freq;\n        }\n    }\n    return max_freq;", "    let mut count = HashMap::new();\n\
    \    for &x in &lst {\n        let entry = count.entry(x).or_insert(0);\n    \
    \    *entry += 1;\n    }\n    for &x in &lst {\n        if let Some(n) = count.get(&x)\
    \ {\n            if *n >= x {\n                return x;\n            }\n    \
    \    }\n    }\n    -1", "    let mut res = -1;\n    for i in 1..lst.len() + 1\
    \ {\n        let c = lst.iter().filter(|&e| *e == i as isize).count();\n     \
    \   if c >= i {\n            res = i as isize;\n        }\n    }\n    res", " \
    \   let mut map = HashMap::new();\n    let mut result = -1;\n    for &elem in\
    \ lst.iter() {\n        let count = map.entry(elem).or_insert(0);\n        *count\
    \ += 1;\n        if *count >= elem && elem > result {\n            result = elem;\n\
    \        }\n    }\n    result", "    let mut freq = HashMap::new();\n    for x\
    \ in lst {\n        let counter = freq.entry(x).or_insert(0);\n        *counter\
    \ += 1;\n    }\n    for (key, val) in freq.iter() {\n        if *key > &0 && *key\
    \ <= val {\n            return *key;\n        }\n    }\n    -1", "    let mut\
    \ cnt: Vec<(isize, usize)> = vec![];\n    let mut max = -1;\n    for i in lst\
    \ {\n        let mut found = false;\n        for j in &mut cnt {\n           \
    \ if j.0 == i {\n                j.1 += 1;\n                found = true;\n  \
    \              break;\n            }\n        }\n        if !found {\n       \
    \     cnt.push((i, 1));\n        }\n    }\n    for i in &cnt {\n        if i.1\
    \ >= i.0 as usize && i.0 > max {\n            max = i.0;\n        }\n    }\n \
    \   max", "    let mut dct: HashMap<isize, isize> = HashMap::new();\n    for x\
    \ in lst {\n        let val = dct.entry(x).or_insert(0);\n        *val += 1;\n\
    \    }\n    for x in lst {\n        if dct.contains_key(&x) && dct[&x] >= x {\n\
    \            return x;\n        }\n    }\n    -1", "    let mut frequencies =\
    \ HashMap::new();\n    for i in lst {\n        *frequencies.entry(i).or_insert(0)\
    \ += 1;\n    }\n    lst.iter().rev().find(|i| {\n        let freq = frequencies.get(i).unwrap();\n\
    \        *i <= *freq\n    }).unwrap_or(&-1).clone()", "    let mut m: HashMap<isize,\
    \ isize> = HashMap::new();\n    let mut max = 0;\n    for i in lst {\n       \
    \ m.insert(i, 1 + m.get(&i).unwrap_or(&0));\n        max = max.max(i);\n    }\n\
    \    for i in (0..max + 1).rev() {\n        if let Some(c) = m.get(&i) {\n   \
    \         if *c >= i {\n                return i;\n            }\n        }\n\
    \    }\n    -1", "    let mut counts = lst.iter().fold(HashMap::new(), |mut map,\
    \ num| {\n        *map.entry(num).or_insert(0) += 1;\n        map\n    });\n \
    \   let mut sorted = Vec::from_iter(counts.into_iter());\n    sorted.sort_by(|a,\
    \ b| b.1.cmp(&a.1));\n    let highest = sorted.first().unwrap().1;\n    let result\
    \ = sorted.iter().find(|v| {\n        v.0 > &0 && v.1 >= v.0 && v.1 == highest\n\
    \    });\n    match result {\n        Some(r) => *r.0,\n        None => -1\n \
    \   }", "    let mut max = -1;\n    let mut count = 0;\n    let mut counts = vec![];\n\
    \    for i in lst {\n        if i > max {\n            max = i;\n        }\n \
    \       if i > count {\n            counts.push(count);\n            count = 0;\n\
    \        }\n        count += 1;\n    }\n    counts.push(count);\n    for (i, &x)\
    \ in counts.iter().enumerate() {\n        if x >= i as isize {\n            return\
    \ i as isize;\n        }\n    }\n    -1", "    if lst.is_empty() {\n        -1\n\
    \    } else {\n        let mut freq = Vec::new();\n        for v in &lst {\n \
    \           if *v > 0 {\n                if freq.len() < v {\n               \
    \     freq.resize(*v as usize, 0);\n                }\n                freq[(v\
    \ - 1) as usize] += 1;\n            }\n        }\n        let mut i = freq.len();\n\
    \        while i > 0 {\n            if freq[i - 1] >= i as isize {\n         \
    \       return i as isize;\n            }\n            i -= 1;\n        }\n  \
    \      -1\n    }", "    let mut freq = HashMap::new();\n    for i in lst {\n \
    \       *freq.entry(i).or_insert(0) += 1;\n    }\n    for f in freq.keys() {\n\
    \        if *f <= freq[f] {\n            return *f;\n        }\n    }\n    -1",
  '    lst.iter().fold(0, |acc, val| if acc < *val { *val } else { acc })', "    //\
    \ Pass 1 - calculate the frequency of each positive integer in the given list\n\
    \    let mut frequency: HashMap<isize, usize> = HashMap::new();\n    for num in\
    \ lst {\n        *frequency.entry(num).or_insert(0) += 1;\n    }\n\n    // Pass\
    \ 2 - find the greatest integer that has a frequency at least as large as its\
    \ value\n    let mut max = -1;\n    for (&num, &freq) in &frequency {\n      \
    \  if num > 0 && freq >= num as usize && num > max {\n            max = num;\n\
    \        }\n    }\n\n    return max;", "    let mut count: HashMap<isize, isize>\
    \ = HashMap::new();\n    for i in lst {\n        let c = count.entry(i).or_insert(0);\n\
    \        *c += 1;\n    }\n    let mut m: isize = 0;\n    for (k, v) in count.iter()\
    \ {\n        if v >= k && k > &m {\n            m = *k;\n        }\n    }\n  \
    \  if m > 0 {\n        m\n    } else {\n        -1\n    }", "    // Calculate\
    \ frequency of each integer and sort.\n    let mut sorted = lst.into_iter().collect::<HashMap<_,\
    \ _>>()\n        .into_iter().collect::<Vec<(_, _)>>();\n    sorted.sort_by(|&(_,\
    \ c1), &(_, c2)| c2.cmp(&c1));\n\n    // Check if any value is greater than its\
    \ frequency.\n    let mut i = 0;\n    loop {\n        if i >= sorted.len() {\n\
    \            return -1;\n        }\n        if sorted[i].0 > sorted[i].1 {\n \
    \           return sorted[i].0;\n        }\n        i += 1;\n    }", "    let\
    \ mut counts = vec![0; 101];\n\n    for &x in &lst {\n        if x > 0 {\n   \
    \         counts[x as usize] += 1;\n        }\n    }\n\n    counts.iter().enumerate().rev().find(|(i,\
    \ &c)| c >= *i as isize).map(|(i, _)| i as isize).unwrap_or(-1)", "    let mut\
    \ m = std::collections::HashMap::new();\n    for x in lst {\n        let c = m.entry(x).or_insert(0);\n\
    \        *c += 1;\n    }\n    m.iter().filter(|&(k, v)| k <= v).max_by_key(|&(k,\
    \ _)| *k).map(|(&k, _)| k).unwrap_or(-1)", "    let mut counts = HashMap::new();\n\
    \    for &i in &lst {\n        let count = counts.entry(i).or_insert(0);\n   \
    \     *count += 1;\n    }\n    for i in (1..=lst.len() as isize).rev() {\n   \
    \     match counts.get(&i) {\n            Some(count) if count >= &i => return\
    \ i,\n            _ => (),\n        }\n    }\n    -1", "    let mut counts = HashMap::new();\n\
    \    for elem in lst {\n        *counts.entry(elem).or_insert(0) += 1;\n    }\n\
    \    let mut sorted = counts.iter().collect::<Vec<_>>();\n    sorted.sort_by(|a,\
    \ b| b.1.cmp(a.1));\n    for (key, val) in sorted {\n        if *key > 0 && *val\
    \ >= *key {\n            return *key;\n        }\n    }\n    -1", "    let mut\
    \ n = lst.iter().max().unwrap();\n    while *n > 0 {\n        if lst.iter().filter(|&x|\
    \ x == n).count() >= *n as usize {\n            return *n;\n        }\n      \
    \  n -= 1;\n    }\n    -1", "    // Get the frequencies\n    let mut freqs = std::collections::HashMap::new();\n\
    \    for elem in lst {\n        let counter = freqs.entry(elem).or_insert(0);\n\
    \        *counter += 1;\n    }\n\n    let mut max = -1;\n    for (key, val) in\
    \ freqs {\n        if key > val {\n            continue;\n        }\n        if\
    \ key > max {\n            max = key;\n        }\n    }\n    max", "    let mut\
    \ m: HashMap<isize, usize> = HashMap::new();\n    for i in lst {\n        *m.entry(i).or_insert(0)\
    \ += 1;\n    }\n    let mut v: Vec<_> = m.iter().collect();\n    v.sort_by(|&(_,\
    \ cnt), &(_, cnt2)| cnt.cmp(cnt2));\n    let mut result = -1;\n    for i in v.iter().rev()\
    \ {\n        if i.0 > &i.1 {\n            result = *i.0;\n            break;\n\
    \        }\n    }\n    result", "    let mut dct = HashMap::new();\n    for i\
    \ in lst {\n        *dct.entry(i).or_insert(0) += 1;\n    }\n    let mut m = -1;\n\
    \    for (k, v) in dct {\n        if k <= v && k > m {\n            m = k;\n \
    \       }\n    }\n    m", "    use std::collections::HashMap;\n    let mut d =\
    \ HashMap::new();\n    for i in lst {\n        if d.contains_key(&i) {\n     \
    \       let c = d.get_mut(&i).unwrap();\n            *c += 1;\n        } else\
    \ {\n            d.insert(i, 1);\n        }\n    }\n    let mut r = -1;\n    for\
    \ (i, c) in d {\n        if i == c && r < i {\n            r = i;\n        }\n\
    \    }\n    r", "    let mut dict = std::collections::HashMap::new();\n    for\
    \ item in lst {\n        let val = dict.entry(item).or_insert(0);\n        *val\
    \ += 1;\n    }\n    let mut best = -1;\n    for (key, val) in dict {\n       \
    \ if key <= val && key > best {\n            best = key;\n        }\n    }\n \
    \   best", "    let mut frequencies = [0; 100_000];\n    let mut max_val = 0;\n\
    \    for &num in &lst {\n        frequencies[num as usize] += 1;\n        max_val\
    \ = num;\n    }\n    for &num in &lst {\n        if num as usize <= max_val as\
    \ usize {\n            let frequency = frequencies[num as usize];\n          \
    \  if frequency >= num {\n                return num;\n            }\n       \
    \ }\n    }\n    -1", "    // Calculate frequency of each of the elements\n   \
    \ let freq = count_frequency(lst);\n    println!(\"{:?}\", freq);\n    // Find\
    \ max frequency\n    let max_freq = *freq.values().max().unwrap();\n    // Return\
    \ the first maximum frequency element with which frequency equals to max_freq\n\
    \    freq.iter().filter(|(&key, &value)| key == value && value == max_freq).map(|(&k,\
    \ _)| k).next().unwrap_or(-1)", "    let mut mp: HashMap<isize, isize> = HashMap::new();\n\
    \    for i in lst {\n        *mp.entry(i).or_insert(0) += 1;\n    }\n    let mut\
    \ res = -1;\n    for (&key, &value) in &mp {\n        if key <= value && key >\
    \ res {\n            res = key;\n        }\n    }\n    res", "    let mut arr:\
    \ [isize; 100] = [0; 100];\n    for i in lst {\n        arr[i as usize] += 1;\n\
    \    }\n    for i in 1..arr.len() {\n        if arr[i] >= i as isize {\n     \
    \       return i as isize;\n        }\n    }\n    -1", "    let mut value_counts\
    \ = HashMap::new();\n    for &v in &lst {\n        let val = value_counts.entry(v).or_insert(0);\n\
    \        *val += 1;\n    }\n    // println!(\"{:?}\", value_counts);\n    let\
    \ mut max = -1;\n    for (v, count) in value_counts {\n        if count >= v &&\
    \ v > max {\n            max = v;\n        }\n    }\n    max", "    let mut freq\
    \ = HashMap::new();\n    for x in lst {\n        *freq.entry(x).or_insert(0) +=\
    \ 1;\n    }\n    let mut found = false;\n    let mut ans = -1;\n    for (&val,\
    \ &freq) in &freq {\n        if val > 0 && freq >= val {\n            if !found\
    \ || val > ans {\n                found = true;\n                ans = val;\n\
    \            }\n        }\n    }\n    ans", "    let mut lst = lst;\n    lst.sort();\n\
    \    let mut i = 1;\n    let mut count = 0;\n    while i < lst.len() {\n     \
    \   if lst[i] == lst[i - 1] {\n            count += 1;\n        } else {\n   \
    \         if count >= lst[i - 1] as usize {\n                return lst[i - 1];\n\
    \            }\n            count = 0;\n        }\n        i += 1;\n    }\n  \
    \  -1", "    let mut m: HashMap<isize, isize> = HashMap::new();\n    for i in\
    \ lst {\n        let count = m.entry(i).or_insert(0);\n        *count += 1;\n\
    \    }\n    let mut v: Vec<isize> = Vec::new();\n    for (k, v) in m {\n     \
    \   if v >= k {\n            v.push(k);\n        }\n    }\n    if v.len() == 0\
    \ {\n        return -1;\n    }\n    v.sort();\n    return v[v.len() - 1];", " \
    \   let mut temp: Vec<(isize, isize)> = Vec::new();\n    let mut ans: isize =\
    \ -1;\n    for i in lst {\n        let mut f = 0;\n        for j in &temp {\n\
    \            if j.0 == i {\n                f = j.1;\n                break;\n\
    \            }\n        }\n        temp.push((i, f + 1));\n    }\n    temp.sort_by(|a,\
    \ b| b.1.cmp(&a.1));\n    for k in &temp {\n        if k.0 <= k.1 {\n        \
    \    ans = k.0;\n            break;\n        }\n    }\n    ans", "    let mut\
    \ freq: HashMap<isize, isize> = HashMap::new();\n    let mut max = 0;\n    for\
    \ elem in lst {\n        freq.entry(elem).and_modify(|n| { *n += 1 }).or_insert(1);\n\
    \        if elem > max {\n            max = elem;\n        }\n    }\n    for num\
    \ in (1..=max).rev() {\n        if freq.get(&num).unwrap_or(&0) >= &num {\n  \
    \          return num;\n        }\n    }\n    -1", "    let mut result = -1;\n\
    \    let mut counts = vec![0; (lst.len() + 1) as usize];\n    for i in lst {\n\
    \        counts[i as usize] += 1;\n    }\n    for i in lst {\n        if counts[i\
    \ as usize] >= i && i > result {\n            result = i;\n        }\n    }\n\
    \    result", "    let mut counts = [0; 10];\n    for num in lst {\n        if\
    \ num > 0 && num < 10 {\n            counts[num as usize] += 1;\n        }\n \
    \   }\n    let mut max_val = -1;\n    for i in 0..10 {\n        if counts[i] >=\
    \ i {\n            max_val = i as isize;\n        }\n    }\n    max_val", "  let\
    \ mut count = vec![0;lst.len()];\n  for i in lst {\n    count[i as usize] += 1;\n\
    \  }\n  println!(\"{:?}\", count);\n  println!(\"{:?}\", lst);\n  for i in lst\
    \ {\n    let mut j = i as usize;\n    if count[j] >= j {\n      return j as isize;\n\
    \    }\n  }\n  -1", "    let mut freq = HashMap::new();\n    for e in lst {\n\
    \        *freq.entry(e).or_insert(0) += 1;\n    }\n    let mut max = -1;\n   \
    \ for (x, k) in freq.iter() {\n        if x <= k && *x > max {\n            max\
    \ = *x;\n        }\n    }\n    max", "    let mut max = 0;\n    let mut count\
    \ = 1;\n    let mut max_count = 0;\n    let mut first = true;\n    for i in lst\
    \ {\n        if first {\n            max = i;\n            first = false;\n  \
    \      } else if i > max {\n            max = i;\n            count = 1;\n   \
    \     } else if i == max {\n            count += 1;\n        }\n        if count\
    \ >= max {\n            max_count = max;\n        }\n    }\n    if max_count !=\
    \ 0 { max_count } else { -1 }", "    let mut frequencies = HashMap::new();\n \
    \   for num in lst {\n        let count = frequencies.entry(num).or_insert(0);\n\
    \        *count += 1;\n    }\n    let mut lst = frequencies.keys().cloned().collect::<Vec<isize>>();\n\
    \    lst.sort();\n    lst.reverse();\n    for num in lst {\n        if num <=\
    \ frequencies[&num] {\n            return num;\n        }\n    }\n    -1", " \
    \   let mut freq = lst.iter().fold(HashMap::new(), |mut acc, &i| {\n        *acc.entry(i).or_insert(0)\
    \ += 1;\n        acc\n    });\n    freq.retain(|&k, &v| k == v);\n    *freq.keys().max().unwrap_or(&-1)",
  "    let mut lst = lst;\n    lst.sort();\n    let mut i = 0;\n    let lst_len =\
    \ lst.len();\n    let mut max_freq = 0;\n    let mut max_freq_num = -1;\n    while\
    \ i < lst_len {\n        let num = lst[i];\n        if num > max_freq {\n    \
    \        let mut cnt = 1;\n            i += 1;\n            while i < lst_len\
    \ && lst[i] == num {\n                cnt += 1;\n                i += 1;\n   \
    \         }\n            if cnt >= num as usize {\n                max_freq =\
    \ cnt;\n                max_freq_num = num;\n            }\n        } else {\n\
    \            i += 1;\n        }\n    }\n    max_freq_num", "    let mut map =\
    \ HashMap::new();\n    for item in lst {\n        *map.entry(item).or_insert(0)\
    \ += 1;\n    }\n    let mut values: Vec<_> = map.values().map(|v| *v).collect();\n\
    \    values.sort();\n    for item in values.iter().rev() {\n        if item >=\
    \ &values.len() {\n            return *item as isize;\n        }\n    }\n    -1",
  "    if lst.is_empty() {\n        -1\n    } else {\n        let mut occ: HashMap<isize,\
    \ usize> = HashMap::new();\n        for el in lst {\n            *occ.entry(el).or_insert(0)\
    \ += 1;\n        }\n        let mut res = -1;\n        for (&k, &v) in &occ {\n\
    \            if v >= k as usize && k > res {\n                res = k;\n     \
    \       }\n        }\n        res\n    }", "    let mut m = HashMap::new();\n\
    \    for &x in &lst {\n        let count = m.entry(x).or_insert(0);\n        *count\
    \ += 1;\n    }\n    let mut current = -1;\n    for (k, v) in m {\n        if k\
    \ <= v && k > current {\n            current = k;\n        }\n    }\n    current",
  "    if lst.is_empty() {\n        return -1;\n    }\n    let mut next = 1;\n   \
    \ let mut count = 0;\n    let mut freq = lst.iter().fold(HashMap::new(), |mut\
    \ map, &x| {\n        let c = map.entry(x).or_insert(0);\n        *c += 1;\n \
    \       map\n    });\n    while next <= freq.len() as isize {\n        if let\
    \ Some(c) = freq.get(&next) {\n            if *c >= next {\n                return\
    \ next;\n            }\n        }\n        next += 1;\n    }\n    -1", "    let\
    \ mut sorted_lst = lst.clone();\n    sorted_lst.sort();\n    sorted_lst.dedup();\n\
    \    let mut dict = HashMap::new();\n    for i in lst {\n        let count = dict.entry(i).or_insert(0);\n\
    \        *count += 1;\n    }\n    for i in sorted_lst {\n        let count = dict.get(&i).unwrap();\n\
    \        if i <= *count {\n            return i;\n        }\n    }\n    -1", " \
    \ let mut ans = 0;\n  let mut hash = HashMap::new();\n  for i in 0..lst.len()\
    \ {\n    if hash.contains_key(&lst[i]) {\n      *hash.get_mut(&lst[i]).unwrap()\
    \ += 1;\n    } else {\n      hash.insert(lst[i], 1);\n    }\n  }\n  for i in 0..lst.len()\
    \ {\n    let frequency = hash.get(&lst[i]).unwrap();\n    if frequency >= &lst[i]\
    \ && lst[i] > ans {\n      ans = lst[i];\n    }\n  }\n  if ans == 0 {\n    -1\n\
    \  } else {\n    ans\n  }", "    let mut map = HashMap::new();\n    let mut max_freq\
    \ = 0;\n    let mut res = -1;\n    for i in lst {\n        let count = map.entry(i).or_insert(0);\n\
    \        *count += 1;\n        if *count >= i {\n            res = i;\n      \
    \  }\n        max_freq = std::cmp::max(max_freq, *count);\n    }\n    res", " \
    \   let counter = frequencies(lst);\n    for (key, value) in counter {\n     \
    \   if key <= value {\n            return key;\n        }\n    }\n    -1", " \
    \   let mut frequencies = HashMap::new();\n    for &el in &lst {\n        let\
    \ count = frequencies.entry(el).or_insert(0);\n        *count += 1;\n    }\n \
    \   let mut res = -1;\n    for (key, value) in frequencies {\n        if key <=\
    \ value && key > res {\n            res = key;\n        }\n    }\n    res", " \
    \   let mut map = HashMap::new();\n    for i in lst {\n        let counter = map.entry(i).or_insert(0);\n\
    \        *counter += 1;\n    }\n    let mut v: Vec<(isize, usize)> = map.into_iter().collect();\n\
    \    v.sort_by(|a, b| b.0.cmp(&a.0));\n    if v[0].0 == 1 {\n        -1\n    }\
    \ else {\n        v.iter().find(|&x| x.0 == x.1 as isize).unwrap().0\n    }",
  "    if lst.is_empty() {\n        -1\n    } else {\n        lst.iter().fold(0, |mut\
    \ result, i| {\n            if lst.iter().filter(|x| **x == *i).count() >= *i\
    \ as usize {\n                result = *i;\n            }\n            result\n\
    \        })\n    }", "    // create a frequency list for the numbers in the list\n\
    \    let mut freq: Vec<(isize, usize)> = Vec::new();\n    for &x in lst.iter()\
    \ {\n        let (value, count) = freq.pop().unwrap_or((x, 0));\n        if value\
    \ == x {\n            freq.push((value, count + 1));\n        } else {\n     \
    \       freq.push((value, count));\n            freq.push((x, 1));\n        }\n\
    \    }\n    // find the max value\n    let (mut max, mut cnt) = freq.pop().unwrap();\n\
    \    while let Some((x, c)) = freq.pop() {\n        if c > cnt {\n           \
    \ max = x;\n            cnt = c;\n        }\n    }\n    if max <= cnt {\n    \
    \    max\n    } else {\n        -1\n    }", "    // We want to do a counting sort,\
    \ with the indices being the numbers\n    // and the values being the frequency\
    \ of them\n    let mut freq: Vec<isize> = vec![0; lst.len()];\n    for num in\
    \ lst {\n        if num <= 0 {\n            continue;\n        }\n        freq[num\
    \ as usize] += 1;\n    }\n    // Now we want to iterate through the freq list,\
    \ starting at the end\n    for (i, freq) in freq.iter().enumerate().rev() {\n\
    \        if i == 0 {\n            break;\n        }\n        if i <= *freq {\n\
    \            return i as isize;\n        }\n    }\n    -1", "    // create a counter\
    \ for each element\n    let mut counter = BTreeMap::new();\n    for val in lst\
    \ {\n        let e = counter.entry(val).or_insert(0);\n        *e += 1;\n    }\n\
    \n    // grab the maximum integer in the tree\n    let mut maximum = counter.iter().next_back().unwrap().0;\n\
    \n    // if there is no value in the list greater than the maximum value, return\
    \ -1\n    if counter.get(&maximum).unwrap() > &maximum {\n        return -1;\n\
    \    }\n\n    // find the value greater than maximum that has a greater frequency\n\
    \    let mut found = false;\n    for (key, value) in counter.iter() {\n      \
    \  if *key > maximum && *value >= key {\n            maximum = *key;\n       \
    \     found = true;\n        }\n    }\n\n    // if there is no value greater than\
    \ the maximum integer that has a greater frequency, return -1\n    if !found {\n\
    \        return -1;\n    }\n\n    // return the maximum value\n    maximum", " \
    \   let mut frequency: Vec<isize> = vec![0; lst.len()];\n    for elem in lst {\n\
    \        frequency[elem as usize] += 1;\n    }\n    for i in 0..lst.len() {\n\
    \        if frequency[i] >= i as isize {\n            return i as isize;\n   \
    \     }\n    }\n    -1", "    let mut counts = HashMap::new();\n    for &i in\
    \ &lst {\n        let count = counts.entry(i).or_insert(0);\n        *count +=\
    \ 1;\n    }\n    for (i, &count) in counts.iter().rev() {\n        if *i > 0 &&\
    \ count >= *i {\n            return *i;\n        }\n    }\n    -1", "    let max\
    \ = lst.iter().max().unwrap_or(&0);\n    for i in 1..=*max {\n        if lst.iter().filter(|&&x|\
    \ x == i).count() >= i as usize {\n            return i;\n        }\n    }\n \
    \   -1", "    let mut freq = [0; 101];\n    for n in lst {\n        if n > 0 {\n\
    \            freq[n as usize] += 1;\n        }\n    }\n    for n in (1..100).rev()\
    \ {\n        if freq[n] >= n {\n            return n as isize;\n        }\n  \
    \  }\n    -1", "    let mut m = std::collections::HashMap::new();\n    for n in\
    \ lst {\n        *m.entry(n).or_insert(0) += 1;\n    }\n    let mut result = -1;\n\
    \    for (k, v) in m {\n        if k > v {\n            continue;\n        }\n\
    \        if result < k {\n            result = k;\n        }\n    }\n    result",
  "    let mut count: Vec<isize> = vec![0;*lst.iter().max().unwrap() as usize + 1];\n\
    \    for num in lst {\n        count[num as usize] += 1;\n    }\n    for num in\
    \ lst {\n        if count[num as usize] >= num {\n            return num;\n  \
    \      }\n    }\n    -1", "    // Make hash table\n    let mut ht: HashMap<isize,\
    \ isize> = HashMap::new();\n    for i in lst {\n        let counter = ht.entry(i).or_insert(0);\n\
    \        *counter += 1;\n    }\n\n    let mut found = false;\n    for (&k, &v)\
    \ in &ht {\n        if k > 0 && k <= v {\n            found = true;\n        \
    \    break;\n        }\n    }\n\n    // Return the greatest key\n    if found\
    \ {\n        let mut sorted_keys: Vec<&isize> = ht.keys().collect();\n       \
    \ sorted_keys.sort();\n        return *sorted_keys.last().unwrap();\n    } else\
    \ {\n        return -1;\n    }", "    // count the frequency of each integer\n\
    \    let mut cnt: HashMap<isize, isize> = HashMap::new();\n    for item in lst\
    \ {\n        let c = cnt.entry(item).or_insert(0);\n        *c += 1;\n    }\n\
    \    // find the maximum\n    let mut max: Option<isize> = None;\n    for item\
    \ in lst {\n        match max {\n            None => max = Some(item),\n     \
    \       Some(n) => {\n                if item >= n && cnt[&item] >= item {\n \
    \                   max = Some(item);\n                }\n            }\n    \
    \    }\n    }\n    match max {\n        None => -1,\n        Some(m) => m,\n \
    \   }", "    let mut lst = lst;\n    lst.sort();\n    let mut prev = 0;\n    let\
    \ mut count = 0;\n    for (i, x) in lst.iter().enumerate() {\n        if i ==\
    \ 0 {\n            prev = *x;\n            count = 1;\n        } else if *x ==\
    \ prev {\n            count += 1;\n        } else {\n            if count >= prev\
    \ {\n                return prev;\n            }\n            prev = *x;\n   \
    \         count = 1;\n        }\n    }\n    if count >= prev {\n        return\
    \ prev;\n    }\n    -1", "    let mut frequency: HashMap<isize, isize> = HashMap::new();\n\
    \    for x in lst {\n        *frequency.entry(x).or_insert(0) += 1;\n    }\n \
    \   let mut keys: Vec<isize> = frequency.keys().cloned().collect();\n    keys.sort();\n\
    \    for key in keys {\n        if frequency[&key] >= key {\n            return\
    \ key;\n        }\n    }\n    -1", "    let mut freq:HashMap<isize, usize> = HashMap::new();\n\
    \    let mut max_key = 0;\n    let mut max_val = 0;\n    let mut max_val_count\
    \ = 0;\n    for val in lst {\n        let entry = freq.entry(val).or_insert(0);\n\
    \        *entry += 1;\n        if val > max_key {\n            max_key = val;\n\
    \        }\n        if *entry > max_val_count {\n            max_val = val;\n\
    \            max_val_count = *entry;\n        }\n    }\n    for i in 1..max_key+1\
    \ {\n        let count = match freq.get(&i) {\n            Some(c) => *c,\n  \
    \          None => 0,\n        };\n        if count >= i {\n            return\
    \ i;\n        }\n    }\n    return -1;", '    lst.iter().filter(|x| lst.iter().filter(|y|
    **y == **x).count() >= **x as usize).max().unwrap_or(&-1)', "    let mut max =\
    \ 0;\n    let mut count = 0;\n    for i in 0..lst.len() {\n        if lst[i] >\
    \ max {\n            max = lst[i];\n        }\n    }\n    for i in 0..lst.len()\
    \ {\n        if lst[i] == max {\n            count += 1;\n        }\n    }\n \
    \   if count < max {\n        return -1;\n    }\n    max", "    let mut counter\
    \ = vec![0; lst.len()];\n    for i in 0..lst.len() {\n        counter[lst[i] as\
    \ usize] += 1;\n    }\n    for i in 1..counter.len() {\n        if counter[i]\
    \ >= i {\n            return i as isize;\n        }\n    }\n    -1", "    let\
    \ mut idx: HashMap<isize, usize> = HashMap::new();\n    for i in lst {\n     \
    \   let count = idx.entry(i).or_insert(0);\n        *count += 1;\n    }\n    for\
    \ i in 1..=lst.len() as isize {\n        let count = idx.get(&i);\n        if\
    \ count.is_some() && count.unwrap() >= &i {\n            return i;\n        }\n\
    \    }\n    -1", "    let mut counts = HashMap::new();\n    let mut max = -1;\n\
    \    for el in lst {\n        let new_count = match counts.get(&el) {\n      \
    \      Some(count) => count + 1,\n            None => 1,\n        };\n       \
    \ if new_count >= el && el > max {\n            max = el;\n        }\n       \
    \ counts.insert(el, new_count);\n    }\n    max", "    let (m, _) = lst.iter().fold((0,\
    \ 0), |(m, c), &x| {\n        (cmp::max(m, x), if x == m { c + 1 } else { c })\n\
    \    });\n    if m <= lst.len() as isize { m } else { -1 }", "    let mut map\
    \ = HashMap::new();\n    let mut max = 0;\n    for n in lst {\n        *map.entry(n).or_insert(0)\
    \ += 1;\n        if n > max {\n            max = n;\n        }\n    }\n    for\
    \ i in (1..max+1).rev() {\n        match map.get(&i) {\n            Some(n) =>\
    \ {\n                if i <= *n {\n                    return i;\n           \
    \     }\n            },\n            None => {},\n        }\n    }\n    -1", " \
    \   let mut max_freq = 0;\n    let mut set: HashSet<isize> = HashSet::new();\n\
    \    for n in lst {\n        set.insert(n);\n        if n > max_freq {\n     \
    \       max_freq = n;\n        }\n    }\n    for n in 1..=max_freq {\n       \
    \ if !set.contains(&n) {\n            continue;\n        }\n        let mut count\
    \ = 0;\n        for &num in &lst {\n            if num == n {\n              \
    \  count += 1;\n            }\n        }\n        if count >= n {\n          \
    \  return n;\n        }\n    }\n    -1", "    let mut hm = HashMap::new();\n \
    \   for x in lst {\n        *hm.entry(x).or_insert(0) += 1;\n    }\n    let mut\
    \ ans = -1;\n    for (k, v) in hm {\n        if v >= k && k > ans {\n        \
    \    ans = k;\n        }\n    }\n    ans", "  let mut ans = -1;\n  let len = lst.len();\n\
    \  for i in 0..len {\n    let mut n = 0;\n    for j in 0..len {\n      if lst[j]\
    \ == lst[i] {\n        n += 1;\n      }\n    }\n    if lst[i] <= n && lst[i] >\
    \ ans {\n      ans = lst[i];\n    }\n  }\n  ans", "    let mut m = HashMap::new();\n\
    \    for item in lst {\n        let count = m.entry(item).or_insert(0);\n    \
    \    *count += 1;\n    }\n    let mut res = -1;\n    for (key, value) in m {\n\
    \        if value >= key && key > res {\n            res = key;\n        }\n \
    \   }\n    res", "    let mut results = HashMap::new();\n    for item in lst {\n\
    \        *results.entry(item).or_insert(0) += 1;\n    }\n    let mut max_value\
    \ = -1;\n    for (key, value) in results {\n        if value >= key {\n      \
    \      max_value = cmp::max(max_value, key);\n        }\n    }\n    max_value",
  "    let mut m: Vec<i32> = vec![0; 1001];\n    for x in lst {\n        m[x as usize]\
    \ += 1;\n    }\n    for i in (1..1001).rev() {\n        if m[i] >= i as i32 {\n\
    \            return i as isize;\n        }\n    }\n    -1", "  let mut hash_map\
    \ = HashMap::new();\n  for &item in lst.iter() {\n    let counter = hash_map.entry(item).or_insert(0);\n\
    \    *counter += 1;\n  }\n  for (&item, counter) in hash_map.iter() {\n    if\
    \ item <= *counter {\n      return item;\n    }\n  }\n  -1", "    use std::collections::HashMap;\n\
    \    let mut map = HashMap::new();\n    let mut max = 0;\n    for x in lst {\n\
    \        if x <= 0 { continue; }\n        max = std::cmp::max(max, x);\n     \
    \   let val = map.entry(x).or_insert(0);\n        *val += 1;\n    }\n    for i\
    \ in (1..max+1).rev() {\n        if let Some(val) = map.get(&i) {\n          \
    \  if *val >= i {\n                return i;\n            }\n        }\n    }\n\
    \    -1", "    let mut counts = HashMap::new();\n    for n in lst {\n        let\
    \ entry = counts.entry(n).or_insert(0);\n        *entry += 1;\n    }\n    let\
    \ mut max = -1;\n    for (n,c) in counts {\n        if n > max && n <= c {\n \
    \           max = n;\n        }\n    }\n    max", "    let mut m = std::collections::HashMap::new();\n\
    \    for v in lst {\n        *m.entry(v).or_insert(0) += 1;\n    }\n    for i\
    \ in (1..lst.len() as isize + 1).rev() {\n        match m.get(&i) {\n        \
    \    Some(v) if *v >= i => return i,\n            _ => (),\n        }\n    }\n\
    \    -1", "    let mut cache = vec![0; lst.len()];\n    for i in lst {\n     \
    \   cache[i as usize] += 1;\n    }\n    let res = cache.iter().enumerate().filter(|(i,\
    \ c)| *c >= *i as isize + 1).max_by_key(|(i, _)| *i);\n    match res {\n     \
    \   Some((i, _)) => i as isize,\n        None => -1,\n    }", "    let mut count\
    \ = HashMap::new();\n    for x in lst {\n        let counter = count.entry(x).or_insert(0);\n\
    \        *counter += 1;\n    }\n    let mut values: Vec<isize> = count.iter().map(|(k,\
    \ _)| *k).collect();\n    values.sort();\n    values.dedup();\n    let mut max\
    \ = 0;\n    for val in values {\n        let freq = *count.get(&val).unwrap();\n\
    \        if freq >= val && val > max {\n            max = val;\n        }\n  \
    \  }\n    max", "    let len = lst.len();\n    let mut counts = Vec::with_capacity(len);\n\
    \    for n in lst {\n        let mut need_new = true;\n        for c in &mut counts\
    \ {\n            if c.val == n {\n                c.count += 1;\n            \
    \    need_new = false;\n                break;\n            }\n        }\n   \
    \     if need_new {\n            counts.push(Count { val: n, count: 1 });\n  \
    \      }\n    }\n    let mut res = -1;\n    for c in &counts {\n        if c.val\
    \ <= c.count && c.val > res {\n            res = c.val;\n        }\n    }\n  \
    \  res", "    // create histogram\n    let mut histogram = HashMap::new();\n \
    \   for i in lst {\n        let count = histogram.entry(i).or_insert(0);\n   \
    \     *count += 1;\n    }\n\n    // search\n    for i in (1..=lst.len() as isize).rev()\
    \ {\n        if histogram.get(&i).is_some() && *histogram.get(&i).unwrap() >=\
    \ i {\n            return i;\n        }\n    }\n\n    return -1;", "    let mut\
    \ counter = HashMap::new();\n    for &x in &lst {\n        *counter.entry(x).or_insert(0)\
    \ += 1;\n    }\n    let mut result = None;\n    for (x, freq) in counter {\n \
    \       if x > 0 && freq >= x {\n            if let Some(r) = result {\n     \
    \           if x > r {\n                    result = Some(x);\n              \
    \  }\n            } else {\n                result = Some(x);\n            }\n\
    \        }\n    }\n    result.unwrap_or(-1)", "    let mut count = vec![0; lst.len()];\n\
    \    for num in lst {\n        if num >= 0 && num < lst.len() as isize {\n   \
    \         count[num as usize] += 1;\n        }\n    }\n    for num in lst {\n\
    \        if num >= 0 && num < lst.len() as isize && count[num as usize] >= num\
    \ {\n            return num;\n        }\n    }\n    -1", "    let mut frequency\
    \ = vec![0; lst.len()];\n    let mut max = -1;\n    for i in 0..lst.len() {\n\
    \        frequency[lst[i] as usize] += 1;\n        if lst[i] > max && lst[i] <=\
    \ frequency[lst[i] as usize] {\n            max = lst[i];\n        }\n    }\n\
    \    max", "    let mut m = vec![0; 101];\n    for n in lst {\n        m[n as\
    \ usize] += 1;\n    }\n    for i in (1..=100).rev() {\n        if m[i] >= i {\n\
    \            return i as isize;\n        }\n    }\n    -1", "    use std::collections::HashMap;\n\
    \    let mut h = HashMap::new();\n    for i in lst {\n        if i > 0 {\n   \
    \         let c = h.entry(i).or_insert(0);\n            *c += 1;\n        }\n\
    \    }\n    let mut last = 0;\n    for (key, val) in h.iter() {\n        if key\
    \ <= val {\n            last = cmp::max(*key, last);\n        }\n    }\n    if\
    \ last == 0 { -1 } else { last }", "    let mut map = HashMap::new();\n    for\
    \ e in lst {\n        *map.entry(e).or_insert(0) += 1;\n    }\n    let mut res\
    \ = -1;\n    for (k, v) in map {\n        if v >= k && k > res {\n           \
    \ res = k;\n        }\n    }\n    res", "    use std::collections::HashMap;\n\
    \    let mut result = -1;\n    let mut data = HashMap::new();\n    for value in\
    \ lst {\n        let counter = data.entry(value).or_insert(0);\n        *counter\
    \ += 1;\n    }\n    for (key, value) in data {\n        if key < *value && key\
    \ > result {\n            result = key;\n        }\n    }\n    result", "    let\
    \ mut ans = -1;\n    let mut dict = HashMap::new();\n    for elem in lst {\n \
    \       if dict.contains_key(&elem) {\n            *dict.get_mut(&elem).unwrap()\
    \ += 1;\n        } else {\n            dict.insert(elem, 1);\n        }\n    }\n\
    \    let mut keys: Vec<isize> = dict.keys().map(|x| *x).collect();\n    keys.sort();\n\
    \    keys.reverse();\n    for key in keys {\n        if dict.get(&key).unwrap()\
    \ >= &key {\n            ans = key;\n            break;\n        }\n    }\n  \
    \  ans", "    let mut counts = HashMap::new();\n    for num in lst {\n       \
    \ let counter = counts.entry(num).or_insert(0);\n        *counter += 1;\n    }\n\
    \    let mut items: Vec<isize> = counts.keys().cloned().collect();\n    items.sort();\n\
    \    for num in items.iter().rev() {\n        if *num <= counts[num] {\n     \
    \       return *num;\n        }\n    }\n    -1", "    let mut f = {\n        let\
    \ mut buf = Vec::new();\n        for &x in &lst {\n            buf.push(x);\n\
    \        }\n        buf.sort();\n        buf.dedup();\n        buf\n    };\n \
    \   f.sort_by_key(|&x| x);\n    let mut cnt = 0;\n    let mut ans = -1;\n    for\
    \ i in 0..f.len() {\n        if lst.iter().filter(|&&x| x == f[i]).count() >=\
    \ f[i] as usize {\n            cnt += 1;\n            ans = f[i];\n        }\n\
    \    }\n    if cnt == 1 {\n        ans\n    } else {\n        -1\n    }", "  \
    \  // Create frequency table\n    let mut freq: HashMap<isize, isize> = HashMap::new();\n\
    \    for n in lst {\n        let mut entry = freq.entry(n).or_insert(0);\n   \
    \     *entry += 1;\n    }\n\n    // Find the maximum value\n    let mut best_value\
    \ = -1;\n    for (value, count) in freq {\n        if value >= count && value\
    \ > best_value {\n            best_value = value;\n        }\n    }\n\n    best_value",
  "    let mut map = HashMap::new();\n    for i in lst {\n        *map.entry(i).or_insert(0)\
    \ += 1;\n    }\n    let freq_list = map.iter().map(|(&k, &v)| (k, v)).collect::<Vec<_>>();\n\
    \    for (i, j) in freq_list {\n        if j >= i {\n            return i;\n \
    \       }\n    }\n    -1", "    let mut count = HashMap::new();\n    for x in\
    \ lst {\n        *count.entry(x).or_insert(0) += 1;\n    }\n    let mut val =\
    \ -1;\n    for (k, v) in count {\n        if k == v as isize && k > val {\n  \
    \          val = k;\n        }\n    }\n    val", "    let mut buckets = vec![0;\
    \ lst.len() + 1];\n    for x in lst {\n        buckets[x as usize] += 1;\n   \
    \ }\n    for i in (0..buckets.len()).rev() {\n        if buckets[i] >= i as isize\
    \ {\n            return i as isize;\n        }\n    }\n    -1", "    let counts\
    \ = lst.iter().fold(HashMap::new(), |mut acc, &elem| {\n        *acc.entry(elem).or_insert(0)\
    \ += 1;\n        acc\n    });\n    for (n, f) in counts {\n        if n as usize\
    \ <= f && n > 0 {\n            return n;\n        }\n    }\n    -1", "    let\
    \ mut frequencies = HashMap::new();\n    for value in lst {\n        if value\
    \ > 0 {\n            *frequencies.entry(value).or_insert(0) += 1;\n        }\n\
    \    }\n    let mut max_found = -1;\n    for (key, value) in frequencies {\n \
    \       if key == value && value > max_found {\n            max_found = value;\n\
    \        }\n    }\n    max_found", "    let mut freq = vec![0; lst.len()];\n \
    \   for i in 0..lst.len() {\n        freq[lst[i] as usize] += 1;\n    }\n    for\
    \ i in lst.len() - 1..0 {\n        if freq[i] >= i as isize {\n            return\
    \ i as isize;\n        }\n    }\n    -1", "    use std::collections::HashMap;\n\
    \    let mut m = HashMap::new();\n    for i in lst {\n        *m.entry(i).or_insert(0)\
    \ += 1;\n    }\n    for i in 1..isize::max_value() {\n        if let Some(v) =\
    \ m.get(&i) {\n            if v >= &i {\n                return i;\n         \
    \   }\n        }\n    }\n    -1", "    let mut temp = lst.clone();\n    temp.sort();\n\
    \    let mut freq = vec![0; temp.len()];\n    let mut count = 0;\n    for i in\
    \ 0..temp.len() {\n        if i == 0 {\n            freq[i] = 1;\n        } else\
    \ if temp[i] == temp[i - 1] {\n            freq[i] = freq[i - 1] + 1;\n      \
    \  } else {\n            freq[i] = 1;\n        }\n        if freq[i] >= temp[i]\
    \ && temp[i] > 0 {\n            count += 1;\n        }\n    }\n    if count >\
    \ 0 {\n        for j in 0..temp.len() {\n            if freq[j] >= temp[j] &&\
    \ temp[j] > 0 {\n                return temp[j];\n            }\n        }\n \
    \   }\n    -1", "    let mut cnt = HashMap::new();\n    for el in lst {\n    \
    \    let v = cnt.entry(el).or_insert(0);\n        *v += 1;\n    }\n    for el\
    \ in cnt.keys() {\n        if *el > *cnt.get(el).unwrap() {\n            continue;\n\
    \        }\n        if *el == *cnt.get(el).unwrap() {\n            return *el;\n\
    \        }\n    }\n    -1", "    let mut cnt: HashMap<isize, usize> = HashMap::new();\n\
    \    for i in lst {\n        *cnt.entry(i).or_insert(0) += 1;\n    }\n    for\
    \ (k, v) in cnt.iter() {\n        if *k <= *v as isize {\n            return *k;\n\
    \        }\n    }\n    -1", "    // A value can't appear more than n times, so\
    \ at least n values must be in the list\n    let n = lst.len();\n    let max =\
    \ lst.iter().max().unwrap();\n    for x in 1..=*max {\n        if lst.iter().filter(|&y|\
    \ y == &x).count() >= x {\n            return x;\n        }\n    }\n    -1", " \
    \   if lst.len() < 1 {\n        return -1;\n    }\n    let counts = lst.iter().fold(HashMap::new(),\
    \ |mut acc, n| { \n        *acc.entry(n).or_insert(0) += 1;\n        acc\n   \
    \ });\n    for (n, c) in counts.iter() {\n        if *n <= &c {\n            return\
    \ *n;\n        }\n    }\n    -1", "    let mut freq: HashMap<isize, isize> = HashMap::new();\n\
    \    let mut max = -1;\n    for i in lst {\n        *freq.entry(i).or_insert(0)\
    \ += 1;\n        if *freq.get(&i).unwrap() >= i && i > max {\n            max\
    \ = i;\n        }\n    }\n    max", "    let mut out: isize = -1;\n    let mut\
    \ counts: HashMap<isize, isize> = HashMap::new();\n    for n in lst {\n      \
    \  *counts.entry(n).or_insert(0) += 1;\n    }\n    for (&n, &c) in &counts {\n\
    \        if n >= c && n > out {\n            out = n;\n        }\n    }\n    out",
  "    // TODO\n    -1", "    let mut count = vec![0; *lst.iter().max().unwrap() as\
    \ usize + 1];\n    for num in lst {\n        count[num as usize] += 1;\n    }\n\
    \    for (i, x) in count.iter().enumerate() {\n        if x >= &(i as isize) {\n\
    \            return i as isize;\n        }\n    }\n    -1", "    let mut m = std::collections::HashMap::new();\n\
    \    for i in lst {\n        let count = m.entry(i).or_insert(0);\n        *count\
    \ += 1;\n    }\n    for i in lst {\n        if let Some(f) = m.get(&i) {\n   \
    \         if i <= *f {\n                return i;\n            }\n        }\n\
    \    }\n    -1", "    let mut m: HashMap<isize, usize> = HashMap::new();\n   \
    \ for i in lst {\n        if m.contains_key(&i) {\n            *m.get_mut(&i).unwrap()\
    \ += 1;\n        } else {\n            m.insert(i, 1);\n        }\n    }\n   \
    \ let mut v: Vec<isize> = m.keys().map(|x| *x).collect();\n    v.sort();\n   \
    \ for i in v {\n        if i <= m[&i] as isize {\n            return i;\n    \
    \    }\n    }\n    -1", "    let mut freq: Vec<usize> = vec![0; lst.len()];\n\
    \    for v in lst {\n        if (v - 1) as usize < lst.len() {\n            freq[(v\
    \ - 1) as usize] += 1;\n        }\n    }\n    for (i, &v) in freq.iter().enumerate()\
    \ {\n        if i as isize >= v as isize {\n            return -1;\n        }\n\
    \    }\n    (lst.len() - 1) as isize", "    let mut count = std::collections::HashMap::new();\n\
    \    let mut max = -1;\n    for i in lst {\n        count.entry(i).and_modify(|e|\
    \ *e += 1).or_insert(1);\n        if i > max && count[&i] >= i {\n           \
    \ max = i;\n        }\n    }\n    max", "    let mut counts = HashMap::new();\n\
    \    for i in lst {\n        let count = counts.entry(i).or_insert(0);\n     \
    \   *count += 1;\n    }\n    for i in lst {\n        if i == counts[&i] {\n  \
    \          return i;\n        }\n    }\n    -1", "    let mut d: HashMap<isize,\
    \ isize> = HashMap::new();\n    for e in lst {\n        let v = d.entry(e).or_insert(0);\n\
    \        *v += 1;\n    }\n    let mut candidates: Vec<(isize, isize)> = d.iter().map(|(k,\
    \ v)| (*k, *v)).collect();\n    candidates.sort_by(|a, b| {\n        if a.1 ==\
    \ b.1 {\n            a.0.cmp(&b.0)\n        } else {\n            b.1.cmp(&a.1)\n\
    \        }\n    });\n    for (k, v) in candidates {\n        if k == v {\n   \
    \         return k;\n        }\n    }\n    -1", "    // your code here\n    let\
    \ mut freq = HashMap::new();\n    for i in lst {\n        *freq.entry(i).or_insert(0)\
    \ += 1;\n    }\n    freq.iter().filter(|&(_, &f)| f >= &2).map(|(&k, _)| k).max().unwrap_or(&-1)",
  "    let mut res = -1;\n    let mut value_map = HashMap::new();\n    for i in lst\
    \ {\n        *value_map.entry(i).or_insert(0) += 1;\n    }\n    for i in lst {\n\
    \        if *value_map.get(&i).unwrap() >= i && i > res {\n            res = i;\n\
    \        }\n    }\n    res", "    let mut g = 0;\n    let mut f = 0;\n    for\
    \ i in 1..lst.len() {\n        if lst[i] > g {\n            g = lst[i];\n    \
    \        f = 1;\n        } else if lst[i] == g {\n            f += 1;\n      \
    \  }\n    }\n    if f < g {\n        -1\n    } else {\n        g\n    }", "  \
    \  lst.iter().fold(0, |mut acc, &n| {\n        if lst.iter().filter(|&x| *x ==\
    \ n).count() >= n as usize {\n            acc = n;\n        }\n        acc\n \
    \   })", "    let mut cnt: HashMap<isize, usize> = HashMap::new();\n    for i\
    \ in lst {\n        let entry = cnt.entry(i).or_insert(0);\n        *entry +=\
    \ 1;\n    }\n    let mut max = -1;\n    for (k, v) in cnt {\n        if k >= v\
    \ && k > max {\n            max = k;\n        }\n    }\n    max", "    use std::collections::HashMap;\n\
    \    let mut dict = HashMap::new();\n    let mut max = isize::min_value();\n \
    \   let mut count = isize::min_value();\n    for i in lst {\n        let c = dict.entry(i).or_insert(0);\n\
    \        *c += 1;\n        if *c >= i && *c > count {\n            max = i;\n\
    \            count = *c;\n        }\n    }\n    if max == isize::min_value() {\n\
    \        return -1;\n    }\n    max", "    let mut unique = lst.into_iter().collect::<HashSet<_>>();\n\
    \    let mut freq = HashMap::new();\n    for x in unique.drain() {\n        freq.insert(x,\
    \ lst.iter().filter(|&n| n == &x).count());\n    }\n    freq.into_iter()\n   \
    \     .filter(|&(_, v)| v >= 2)\n        .map(|(k, v)| (k, v as isize))\n    \
    \    .filter(|&(k, v)| k <= v)\n        .max_by_key(|&(_, v)| v)\n        .map(|(k,\
    \ _)| k)\n        .unwrap_or(-1)", "    let freq = lst.iter().fold(HashMap::new(),\
    \ |mut m, &x| {\n        *m.entry(x).or_insert(0) += 1;\n        m\n    });\n\
    \    let m = lst.iter().filter(|&&x| freq[&x] >= x).max().unwrap_or(&-1);\n  \
    \  *m", "    let mut m: HashMap<isize, isize> = HashMap::new();\n    for i in\
    \ lst {\n        if m.contains_key(&i) {\n            let c = m.get(&i).unwrap();\n\
    \            m.insert(i, c + 1);\n        } else {\n            m.insert(i, 1);\n\
    \        }\n    }\n    for (k, v) in m.iter() {\n        if k <= v {\n       \
    \     return *k;\n        }\n    }\n    -1", "    let mut counter = HashMap::new();\n\
    \    for i in lst {\n        let cnt = counter.entry(i).or_insert(0);\n      \
    \  *cnt += 1;\n    }\n    for i in 1..counter.len() + 1 {\n        if let Some(x)\
    \ = counter.get(&i) {\n            if x >= &i {\n                return i;\n \
    \           }\n        }\n    }\n    -1", "    let mut cnt: HashMap<isize, isize>\
    \ = HashMap::new();\n    for i in lst {\n        let entry = cnt.entry(i).or_insert(0);\n\
    \        *entry += 1;\n    }\n    for (k, v) in cnt.iter() {\n        if k <=\
    \ v {\n            return *k;\n        }\n    }\n    -1", "    // Iterate through\
    \ the list\n    for num in &lst {\n        // Only consider positive numbers\n\
    \        if *num > 0 {\n            // Number of occurrences\n            let\
    \ mut count = 0;\n            // Iterate through the list again to count the number\
    \ of occurrences\n            for num2 in &lst {\n                if *num == *num2\
    \ {\n                    count += 1;\n                }\n            }\n     \
    \       // Only consider the number if it is greater than 0 and\n            //\
    \ has more occurrences than its value\n            if count >= *num {\n      \
    \          return *num;\n            }\n        }\n    }\n    // Return -1 if\
    \ the condition is not satisfied by any number\n    -1", "    let mut times: Vec<usize>\
    \ = Vec::new();\n    times.resize(lst.len(), 0);\n    let mut i = 0;\n    for\
    \ num in lst {\n        times[num as usize] += 1;\n    }\n    for num in lst {\n\
    \        if num as usize < times.len() && times[num as usize] >= num as usize\
    \ {\n            return num;\n        }\n    }\n    -1", "    let mut freq = HashMap::new();\n\
    \    for i in lst {\n        let c = freq.entry(i).or_insert(0);\n        *c +=\
    \ 1;\n    }\n    let mut result = -1;\n    for (val, f) in freq {\n        if\
    \ val <= f && val > result {\n            result = val;\n        }\n    }\n  \
    \  result", "    let mut counts = HashMap::new();\n    for x in lst {\n      \
    \  *counts.entry(x).or_insert(0) += 1;\n    }\n    for (x, count) in counts {\n\
    \        if count < x {\n            continue;\n        }\n        if count ==\
    \ x {\n            return x;\n        }\n        return count;\n    }\n    -1",
  "    let mut freq: HashMap<isize, usize> = HashMap::new();\n    for el in lst {\n\
    \        let count = freq.entry(el).or_insert(0);\n        *count += 1;\n    }\n\
    \    let mut res = -1;\n    for el in freq.keys() {\n        if *el <= freq[el]\
    \ as isize && *el > res {\n            res = *el;\n        }\n    }\n    res",
  "    use std::collections::HashMap;\n    let mut hm = HashMap::new();\n    let mut\
    \ hmi = HashMap::new();\n    let mut max = 0;\n    for num in lst {\n        if\
    \ num < 1 {\n            continue;\n        }\n        *hm.entry(num).or_insert(0)\
    \ += 1;\n        if num > max {\n            max = num;\n        }\n    }\n  \
    \  for num in 1..=max {\n        let freq = hm.get(&num).unwrap_or(&0);\n    \
    \    hmi.insert(num, *freq);\n    }\n    let mut res = -1;\n    for (key, val)\
    \ in hmi {\n        if val >= key {\n            res = key;\n        }\n    }\n\
    \    res", "    let mut occurrences = lst.iter().fold(HashMap::new(), |mut occurrences,\
    \ i| {\n        let count = occurrences.entry(*i).or_insert(0);\n        *count\
    \ += 1;\n        occurrences\n    });\n    let max_occurrences = occurrences.values().max().unwrap();\n\
    \    let mut relevant_occurrences = HashMap::new();\n    for (num, occurrences)\
    \ in occurrences {\n        if occurrences >= num {\n            let count = relevant_occurrences.entry(occurrences).or_insert(0);\n\
    \            *count += 1;\n        }\n    }\n    let mut relevant_max = 0;\n \
    \   for (occurrences, count) in relevant_occurrences {\n        if occurrences\
    \ >= count && occurrences > relevant_max {\n            relevant_max = occurrences;\n\
    \        }\n    }\n    if relevant_max > *max_occurrences {\n        relevant_max\
    \ as isize\n    } else {\n        -1\n    }", "    // Let's first make a simple\
    \ implementation\n    let mut counts = HashMap::new();\n    for &x in &lst {\n\
    \        if x <= 0 {\n            panic!(\"list contains a non-positive value\"\
    );\n        }\n        let count = counts.entry(x).or_insert(0);\n        *count\
    \ += 1;\n    }\n    let mut result = -1;\n    for (&x, &count) in &counts {\n\
    \        if count >= x && x > result {\n            result = x;\n        }\n \
    \   }\n    result", "    let mut counts = vec![0; 101];\n\n    for el in lst {\n\
    \        counts[el as usize] += 1;\n    }\n\n    for i in 100..0 {\n        if\
    \ counts[i] >= i {\n            return i as isize;\n        }\n    }\n\n    -1",
  "    let mut lst = lst;\n    lst.sort();\n    let mut f = 1;\n    let mut n = 0;\n\
    \    let mut i = 0;\n    while i < lst.len() {\n        if lst[i] == n {\n   \
    \         f += 1;\n        } else {\n            if f >= n {\n               \
    \ return n;\n            }\n            n = lst[i];\n            f = 1;\n    \
    \    }\n        i += 1;\n    }\n    if f >= n {\n        return n;\n    }\n  \
    \  -1", "    let mut counts = vec![0; 100];\n    for i in lst {\n        counts[i\
    \ as usize] += 1;\n    }\n    for i in (1..100).rev() {\n        if counts[i]\
    \ >= i {\n            return i as isize;\n        }\n    }\n    -1", "    use\
    \ std::collections::HashMap;\n    let mut counts = HashMap::new();\n    for x\
    \ in lst {\n        let c = counts.entry(x).or_insert(0);\n        *c += 1;\n\
    \    }\n    let mut max_freq = -1;\n    for &x in &lst {\n        let c = *counts.get(&x).unwrap();\n\
    \        if c >= x && c > max_freq {\n            max_freq = c;\n        }\n \
    \   }\n    if max_freq == -1 {\n        return -1;\n    }\n    for (&x, &c) in\
    \ &counts {\n        if c == max_freq {\n            return x;\n        }\n  \
    \  }\n    return -1;", "    if lst.is_empty() {\n        return -1;\n    }\n \
    \   let mut occurrences = HashMap::new();\n    for item in lst {\n        let\
    \ new_val = *occurrences.get(&item).unwrap_or(&0) + 1;\n        occurrences.insert(item,\
    \ new_val);\n    }\n    let mut max = -1;\n    for (key, val) in occurrences {\n\
    \        if val >= key && key > max {\n            max = key;\n        }\n   \
    \ }\n    max", "    let mut num_count = HashMap::new();\n    for n in lst {\n\
    \        *num_count.entry(n).or_insert(0) += 1;\n    }\n    let mut ans = -1;\n\
    \    for (&num, &cnt) in num_count.iter() {\n        if num <= cnt && num > ans\
    \ {\n            ans = num;\n        }\n    }\n    ans", "    let mut counts =\
    \ [0; 10001];\n    for &i in &lst {\n        counts[i as usize] += 1;\n    }\n\
    \    for i in (1..10001).rev() {\n        if counts[i] >= i {\n            return\
    \ i as isize;\n        }\n    }\n    -1", "    let mut freq: HashMap<isize, isize>\
    \ = HashMap::new();\n    for i in lst {\n        if freq.contains_key(&i) {\n\
    \            *freq.get_mut(&i).unwrap() += 1;\n        } else {\n            freq.insert(i,\
    \ 1);\n        }\n    }\n    freq.iter().filter(|(&k, &v)| k <= &v).map(|(&k,\
    \ &v)| k).max().unwrap_or(-1)", "    use std::collections::HashMap;\n    let mut\
    \ freq = HashMap::new();\n    for elem in lst {\n        let freq_elem = freq.entry(elem).or_insert(0);\n\
    \        *freq_elem += 1;\n    }\n    let mut res = -1;\n    for (elem, freq_elem)\
    \ in freq {\n        if elem <= freq_elem && elem > res {\n            res = elem;\n\
    \        }\n    }\n    res", "    let mut hm = HashMap::new();\n    for num in\
    \ lst {\n        if hm.contains_key(&num) {\n            *hm.get_mut(&num).unwrap()\
    \ += 1;\n        } else {\n            hm.insert(num, 1);\n        }\n    }\n\
    \    let mut max = -1;\n    for num in lst {\n        if num > 0 && hm.get(&num).unwrap()\
    \ >= &num {\n            max = std::cmp::max(max, num);\n        }\n    }\n  \
    \  max", "    let mut m = HashMap::new();\n    for i in lst {\n        let counter\
    \ = m.entry(i).or_insert(0);\n        *counter += 1;\n    }\n    let mut max =\
    \ -1;\n    for (k, v) in m {\n        if k == v && k > max {\n            max\
    \ = k;\n        }\n    }\n    max", "    let mut freq = HashMap::new();\n    for\
    \ n in lst {\n        *freq.entry(n).or_insert(0) += 1;\n    }\n    (1..).take_while(|&n|\
    \ n <= lst.len() as isize).find(|&n| freq.get(&n).map_or(false, |&f| f >= n)).unwrap_or(-1)",
  "    let mut numbers: HashMap<isize, isize> = HashMap::new();\n    for num in lst\
    \ {\n        *numbers.entry(num).or_insert(0) += 1;\n    }\n    let mut keys:\
    \ Vec<isize> = numbers.keys().map(|&n| n).collect();\n    keys.sort();\n    let\
    \ mut best_num = -1;\n    for num in keys {\n        let count = numbers[&num];\n\
    \        if count >= num && num > best_num {\n            best_num = num;\n  \
    \      }\n    }\n    best_num", "    let mut freq = HashMap::new();\n    for i\
    \ in lst {\n        *freq.entry(i).or_insert(0) += 1;\n    }\n    for &(k, v)\
    \ in freq.iter() {\n        if k <= v {\n            return k;\n        }\n  \
    \  }\n    -1", "    let mut lst = lst;\n    lst.sort();\n    let len = lst.len();\n\
    \    for i in 1..len {\n        if lst[i] == lst[i - 1] {\n            lst.remove(i);\n\
    \        }\n    }\n    for i in 0..len {\n        let n = lst[i];\n        if\
    \ n == len - i {\n            return n;\n        }\n    }\n    -1", "    // count\
    \ the number of times each value appears in the list\n    let mut counts = [0;\
    \ 101];\n    for &x in &lst {\n        counts[x as usize] += 1;\n    }\n\n   \
    \ // search the list in reverse order\n    for i in (1..101).rev() {\n       \
    \ if counts[i] >= i {\n            return i as isize;\n        }\n    }\n\n  \
    \  -1", "    let mut count = HashMap::new();\n    for num in lst {\n        *count.entry(num).or_insert(0)\
    \ += 1;\n    }\n    let mut max = 0;\n    for (key, val) in count.iter() {\n \
    \       if *key > max && *key <= *val {\n            max = *key;\n        }\n\
    \    }\n    if max == 0 {\n        return -1;\n    }\n    max", "    lst.iter().fold(HashMap::new(),\
    \ |mut hm, &i| {\n        let freq = hm.entry(i).or_insert(0);\n        *freq\
    \ += 1;\n        hm\n    }).into_iter().filter(|(&i, &freq)| freq >= i).max_by_key(|&(i,\
    \ _)| i).map(|(i, _)| i).unwrap_or(-1)", "    // Find the most frequent integer\n\
    \    let mut mx = -1;\n    let mut cnt = 0;\n    for i in lst {\n        let mut\
    \ local_cnt = 0;\n        for j in lst {\n            if i == j {\n          \
    \      local_cnt += 1;\n            }\n        }\n        if local_cnt > cnt {\n\
    \            cnt = local_cnt;\n            mx = i;\n        }\n    }\n    // Find\
    \ the first integer with frequency greater than or equal to that integer\n   \
    \ if cnt > mx {\n        mx\n    } else {\n        -1\n    }", "    let mut counts\
    \ = HashMap::new();\n    for value in lst {\n        let count = counts.entry(value).or_insert(0);\n\
    \        *count += 1;\n    }\n    let mut max_freq = -1;\n    for (key, freq)\
    \ in counts {\n        if key >= freq && freq > max_freq {\n            max_freq\
    \ = freq;\n        }\n    }\n    max_freq", "  // count occurrences\n  let mut\
    \ freq:HashMap<isize, isize> = HashMap::new();\n  for &e in lst.iter() {\n   \
    \ *freq.entry(e).or_insert(0) += 1;\n  }\n  for &e in lst.iter() {\n    if freq.contains_key(&e)\
    \ && e <= *freq.get(&e).unwrap() {\n      return e;\n    }\n  }\n  -1", "    //\
    \ count frequencies\n    let mut counts = HashMap::new();\n    for n in lst {\n\
    \        *counts.entry(n).or_insert(0) += 1;\n    }\n\n    // find maximum key\
    \ with count at least as high\n    let mut max = -1;\n    for (&k, &c) in &counts\
    \ {\n        if k > max && c >= k {\n            max = k;\n        }\n    }\n\
    \    max", "    let mut counts = HashMap::new();\n    for i in lst {\n       \
    \ *counts.entry(i).or_insert(0) += 1;\n    }\n    let mut freqs = HashMap::new();\n\
    \    for (i, count) in counts {\n        *freqs.entry(count).or_insert(0) += 1;\n\
    \    }\n    for (count, freq) in freqs {\n        if count <= freq {\n       \
    \     return count;\n        }\n    }\n    -1", "    let mut frequency = [0; 100];\n\
    \    for n in lst {\n        frequency[n as usize] += 1;\n    }\n    for (i, n)\
    \ in frequency.iter().enumerate() {\n        if n >= &i && i > 0 {\n         \
    \   return i as isize;\n        }\n    }\n    -1", "  let mut m = HashMap::new();\n\
    \  for i in lst {\n    *m.entry(i).or_insert(0) += 1;\n  }\n  let mut r = -1;\n\
    \  for (k, v) in m {\n    if k > 0 && v >= k {\n      r = max(r, k);\n    }\n\
    \  }\n  r", "    let mut frequencies = HashMap::new();\n    for i in lst {\n \
    \       let count = frequencies.entry(i).or_insert(0);\n        *count += 1;\n\
    \    }\n    let mut max = -1;\n    for (num, freq) in frequencies {\n        if\
    \ num <= freq && num > max {\n            max = num;\n        }\n    }\n    max",
  "    let mut occurences = HashMap::new();\n    for elem in lst {\n        let count\
    \ = occurences.entry(elem).or_insert(0);\n        *count += 1;\n    }\n    let\
    \ mut result = -1;\n    for (k, v) in occurences {\n        if k >= v && k > result\
    \ {\n            result = k;\n        }\n    }\n    result", "    let mut num_freq\
    \ = HashMap::new();\n    let mut freq_num = HashMap::new();\n    let mut max_num\
    \ = -1;\n    let mut max_freq = -1;\n    for n in lst {\n        let freq = match\
    \ num_freq.get(&n) {\n            Some(freq) => freq + 1,\n            None =>\
    \ 1,\n        };\n        if freq > max_freq {\n            max_freq = freq;\n\
    \            max_num = n;\n        }\n        num_freq.insert(n, freq);\n    \
    \    freq_num.insert(freq, n);\n    }\n    if max_freq >= max_num {\n        return\
    \ max_num;\n    }\n    for i in (1..max_freq).rev() {\n        if let Some(n)\
    \ = freq_num.get(&i) {\n            if *n > i {\n                return *n;\n\
    \            }\n        }\n    }\n    -1", "    let mut counts = HashMap::new();\n\
    \    for i in lst {\n        *counts.entry(i).or_insert(0) += 1;\n    }\n    let\
    \ mut result = -1;\n    for (k, v) in counts {\n        if k <= v && k > result\
    \ {\n            result = k;\n        }\n    }\n    result", "    let mut freq\
    \ = vec![0; 101];\n    for v in lst {\n        freq[v as usize] += 1;\n    }\n\
    \    for (i, &v) in freq.iter().enumerate().rev() {\n        if v >= i as isize\
    \ {\n            return i as isize;\n        }\n    }\n    -1", "    let mut freq\
    \ = HashMap::new();\n    for v in lst {\n        if freq.contains_key(&v) {\n\
    \            let f = freq.get_mut(&v).unwrap();\n            *f += 1;\n      \
    \  } else {\n            freq.insert(v, 1);\n        }\n    }\n    let mut max\
    \ = -1;\n    for (v, f) in freq {\n        if v <= *f && v > max {\n         \
    \   max = v;\n        }\n    }\n    max", "    use std::collections::HashMap;\n\
    \    let mut mp: HashMap<isize, isize> = HashMap::new();\n    for i in lst {\n\
    \        let item = mp.entry(i).or_insert(0);\n        *item += 1;\n    }\n  \
    \  for (key, val) in mp.iter() {\n        if key == val {\n            return\
    \ *key;\n        }\n    }\n    -1", "    let mut map = std::collections::HashMap::new();\n\
    \    for i in lst {\n        *map.entry(i).or_insert(0) += 1;\n    }\n    let\
    \ mut ans = -1;\n    for (k, v) in map {\n        if k > 0 && v >= k {\n     \
    \       ans = std::cmp::max(ans, k);\n        }\n    }\n    ans", "    let mut\
    \ freq: HashMap<isize, isize> = HashMap::new();\n    for i in lst {\n        let\
    \ count = freq.entry(i).or_insert(0);\n        *count += 1;\n    }\n    let mut\
    \ max = -1;\n    for (key, value) in freq {\n        if value >= key && value\
    \ > max {\n            max = value;\n        }\n    }\n    max", "    let mut\
    \ freq = HashMap::new();\n    for num in lst {\n        *freq.entry(num).or_insert(0)\
    \ += 1;\n    }\n    let mut res = 0;\n    for (k, v) in freq {\n        if k >\
    \ v {\n            continue;\n        }\n        if k > res {\n            res\
    \ = k;\n        }\n    }\n    res", "    let mut freq = vec![0isize; 101];\n \
    \   for num in lst {\n        freq[num as usize] += 1;\n    }\n    for i in (1..101).rev()\
    \ {\n        if freq[i] >= i {\n            return i as isize;\n        }\n  \
    \  }\n    -1", "    let mut counts = vec![0; *lst.iter().max().unwrap() as usize\
    \ + 1];\n    let mut result = -1;\n    for item in lst {\n        counts[item\
    \ as usize] += 1;\n        if counts[item as usize] >= item && item > result {\n\
    \            result = item;\n        }\n    }\n    result", "    let mut lst =\
    \ lst;\n    lst.sort();\n    let mut last = -1;\n    let mut prev_num = -1;\n\
    \    let mut count = 0;\n    for i in lst {\n        if i == prev_num {\n    \
    \        count += 1;\n        } else {\n            if prev_num > 0 && count >=\
    \ prev_num {\n                return prev_num;\n            }\n            prev_num\
    \ = i;\n            count = 1;\n        }\n    }\n    if prev_num > 0 && count\
    \ >= prev_num {\n        return prev_num;\n    }\n    -1", "    let mut frequency:\
    \ HashMap<isize, isize> = HashMap::new();\n    for el in lst {\n        *frequency.entry(el).or_insert(0)\
    \ += 1;\n    }\n    for (key, value) in frequency.iter() {\n        if *key <=\
    \ *value {\n            return *key;\n        }\n    }\n    -1", "    let mut\
    \ result = -1;\n    let mut max = 0;\n    let mut freq = HashMap::new();\n   \
    \ for x in lst {\n        let cnt = match freq.get(&x) {\n            Some(f)\
    \ => *f,\n            None => 0,\n        };\n        freq.insert(x, cnt + 1);\n\
    \        if cnt + 1 >= x && x > max {\n            max = x;\n            result\
    \ = x;\n        }\n    }\n    result", "    let mut lst = lst;\n    lst.sort();\n\
    \    let mut count = 1;\n    let mut result = -1;\n    let mut previous = lst[0];\n\
    \    for x in lst.iter().skip(1) {\n        if *x == previous {\n            count\
    \ += 1;\n        } else {\n            if count >= previous {\n              \
    \  result = previous;\n            }\n            count = 1;\n            previous\
    \ = *x;\n        }\n    }\n    if count >= previous {\n        result = previous;\n\
    \    }\n    result", "    use std::collections::HashMap;\n    let mut table =\
    \ HashMap::new();\n    for i in lst {\n        let counter = table.entry(i).or_insert(0);\n\
    \        *counter += 1;\n    }\n    for (key, val) in table {\n        if key\
    \ <= val {\n            return key;\n        }\n    }\n    -1", "    let mut map\
    \ = HashMap::new();\n    for x in lst {\n        *map.entry(x).or_insert(0) +=\
    \ 1;\n    }\n    let mut keys: Vec<_> = map.keys().collect();\n    keys.sort();\n\
    \    let mut i = keys.len() - 1;\n    while i >= 0 {\n        if *map.get(&keys[i]).unwrap()\
    \ >= keys[i] {\n            return keys[i];\n        }\n        i -= 1;\n    }\n\
    \    -1", "    use std::collections::HashMap;\n    let mut map = HashMap::new();\n\
    \    for i in lst {\n        if map.contains_key(&i) {\n            *map.get_mut(&i).unwrap()\
    \ += 1;\n        } else {\n            map.insert(i, 1);\n        }\n    }\n \
    \   let mut max = -1;\n    for (key, val) in map {\n        if key >= val && key\
    \ > max {\n            max = key;\n        }\n    }\n    max", "    let mut cache\
    \ = HashMap::new();\n    for i in lst {\n        *cache.entry(i).or_insert(0)\
    \ += 1;\n    }\n    for (key, value) in cache {\n        if key == value {\n \
    \           return key;\n        }\n    }\n    -1", "    let mut d: HashMap<isize,\
    \ isize> = HashMap::new();\n    let mut m = 0;\n    for i in lst {\n        *d.entry(i).or_insert(0)\
    \ += 1;\n        if i > m {\n            m = i;\n        }\n    }\n    let mut\
    \ z = -1;\n    for j in 1..=m {\n        if d.contains_key(&j) && d[&j] >= j {\n\
    \            z = j;\n        }\n    }\n    z", "    let mut hsh = HashMap::new();\n\
    \    for item in lst {\n        let count = hsh.entry(item).or_insert(0);\n  \
    \      *count += 1;\n    }\n    for (&key, &val) in hsh.iter() {\n        if key\
    \ == val {\n            return key;\n        }\n    }\n    -1", "    let mut freq:\
    \ HashMap<isize, usize> = HashMap::new();\n    let mut max_key = -1;\n    let\
    \ mut max_value = 0;\n    let mut key = 0;\n    let mut value = 0;\n    for i\
    \ in lst {\n        key = i;\n        value = *freq.entry(key).or_insert(0);\n\
    \        freq.insert(key, value + 1);\n        if *freq.get(&key).unwrap() >=\
    \ key as usize && key > max_key {\n            max_key = key;\n            max_value\
    \ = *freq.get(&key).unwrap();\n        }\n    }\n    max_key", "    if lst.is_empty()\
    \ {\n        return -1;\n    }\n    let mut lst = lst;\n    lst.sort();\n    let\
    \ mut prev = 0;\n    let mut freq = 0;\n    for &item in lst.iter() {\n      \
    \  if item > 0 {\n            if item == prev {\n                freq += 1;\n\
    \            } else {\n                if item <= freq {\n                   \
    \ return item;\n                }\n                prev = item;\n            \
    \    freq = 1;\n            }\n        }\n    }\n    if prev <= freq {\n     \
    \   prev\n    } else {\n        -1\n    }", "    let mut fv = std::collections::HashMap::new();\n\
    \    let mut vf = std::collections::HashMap::new();\n    let mut nc = 0;\n   \
    \ for n in lst {\n        let f = *fv.entry(n).or_insert(0);\n        let v =\
    \ *vf.entry(f).or_insert(vec![]);\n        vf.insert(f, v);\n        fv.insert(n,\
    \ f + 1);\n        nc = std::cmp::max(nc, f + 1);\n    }\n    for f in (1..nc).rev()\
    \ {\n        if let Some(v) = vf.get(&f) {\n            for n in v {\n       \
    \         if *n >= f {\n                    return *n;\n                }\n  \
    \          }\n        }\n    }\n    -1", "    let mut cnt = std::collections::HashMap::new();\n\
    \    for i in lst {\n        *cnt.entry(i).or_insert(0) += 1;\n    }\n    for\
    \ i in cnt.keys() {\n        if *i <= cnt[i] {\n            return *i;\n     \
    \   }\n    }\n    -1", "    let mut cnt = [0; 1001];\n    for n in lst {\n   \
    \     cnt[n as usize] += 1;\n    }\n    for n in (1..cnt.len()).rev() {\n    \
    \    if cnt[n] >= n as isize {\n            return n as isize;\n        }\n  \
    \  }\n    -1"]
stop_tokens:
- "\n}"
