name: HumanEval_49_modp
language: rs
prompt: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p: isize)\
  \ -> isize {\n"
tests: "}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5),\
  \ 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101),\
  \ 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101),\
  \ 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
  }\n"
completions: ["    if n == 0 {\n        return 1;\n    }\n    if n % 2 == 0 {\n  \
    \      return modp(n / 2, p) * modp(n / 2, p) % p;\n    }\n    return 2 * modp(n\
    \ - 1, p) % p;", "    let mut res = 1;\n    let mut n = n;\n    let mut tmp =\
    \ 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * tmp)\
    \ % p;\n        }\n        tmp = (tmp * tmp) % p;\n        n /= 2;\n    }\n  \
    \  res", "    let mut res = 1;\n    let mut x = 2;\n    let mut p = p;\n    let\
    \ mut n = n;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = res\
    \ * x % p;\n        }\n        x = x * x % p;\n        n = n / 2;\n    }\n   \
    \ res", "    if n == 0 {\n        return 1;\n    }\n    let a = modp(n / 2, p);\n\
    \    let r = (a * a) % p;\n    if n % 2 == 0 {\n        return r;\n    }\n   \
    \ (r * 2) % p", "    let mut result = 1;\n    let mut power = n;\n    let mut\
    \ base = 2;\n    while power > 0 {\n        if power % 2 == 1 {\n            result\
    \ = (result * base) % p;\n        }\n        base = (base * base) % p;\n     \
    \   power /= 2;\n    }\n    result", "    if n == 0 {\n        return 1;\n   \
    \ }\n    let mut s = 1;\n    let mut t = 2;\n    while t <= n {\n        t *=\
    \ 2;\n        s = (s * t) % p;\n    }\n    s", "\tif n == 0 {\n\t\treturn 1;\n\
    \t}\n\tif n % 2 == 0 {\n\t\treturn (modp(n / 2, p) * modp(n / 2, p)) % p;\n\t\
    }\n\t(modp(n - 1, p) * modp(n - 1, p) * 2) % p;", "    let mut result = 1;\n \
    \   let mut k = n;\n    let mut two = 2;\n    while k > 0 {\n        if k % 2\
    \ == 1 {\n            result = (result * two) % p;\n        }\n        two = (two\
    \ * two) % p;\n        k = k / 2;\n    }\n    result", "    if n == 0 {\n    \
    \    return 1;\n    }\n    if n == 1 {\n        return 2;\n    }\n    if n % 2\
    \ == 0 {\n        let tmp = modp(n / 2, p);\n        return tmp * tmp % p;\n \
    \   }\n    return 2 * modp(n - 1, p) % p;", "    let mut res = 1;\n    let mut\
    \ n = n;\n    let mut k = 2;\n    while n > 0 {\n        if n % 2 == 1 {\n   \
    \         res = (res * k) % p;\n        }\n        k = (k * k) % p;\n        n\
    \ = n / 2;\n    }\n    res", "    let mut n = n;\n    let mut r = 1;\n    let\
    \ mut p = p;\n    while n > 0 {\n        if n % 2 == 1 {\n            r = (r *\
    \ 2) % p;\n        }\n        n /= 2;\n        p = (p * p) % MODULO;\n    }\n\
    \    r", "    let mut result = 1;\n    let mut n = n;\n    let mut p = p;\n  \
    \  while n > 0 {\n        if n % 2 == 1 {\n            result = (result * 2) %\
    \ p;\n        }\n        n /= 2;\n        p = (p * p) % p;\n    }\n    result",
  "    let mut r = 1;\n    let mut k = n;\n    let mut b = 2;\n    while k > 0 {\n\
    \        if k % 2 == 1 {\n            r = (r * b) % p;\n        }\n        k =\
    \ k / 2;\n        b = (b * b) % p;\n    }\n    r", "    let mut res = 1;\n   \
    \ let mut two = 2;\n    let mut exp = n;\n    while exp > 0 {\n        if exp\
    \ % 2 == 1 {\n            res = (res * two) % p;\n        }\n        two = (two\
    \ * two) % p;\n        exp /= 2;\n    }\n    res", "    if n == 0 {\n        return\
    \ 1;\n    }\n    let mut x = modp(n / 2, p);\n    if n % 2 == 0 {\n        x =\
    \ (x * x) % p;\n    } else {\n        x = (((x * x) % p) * 2) % p;\n    }\n  \
    \  if x < 0 {\n        x += p;\n    }\n    x", "    let mut res = 1;\n    let\
    \ mut i = n;\n    let mut x = 2;\n    while i > 0 {\n        if i % 2 == 1 {\n\
    \            res = (res * x) % p;\n        }\n        x = (x * x) % p;\n     \
    \   i = i / 2;\n    }\n    res", "\tlet mut result = 1;\n\tlet mut pow = n;\n\t\
    let mut mult = 2;\n\twhile pow > 0 {\n\t\tif pow % 2 == 1 {\n\t\t\tresult = (result\
    \ * mult) % p;\n\t\t}\n\t\tmult = (mult * mult) % p;\n\t\tpow /= 2;\n\t}\n\tresult",
  "    if n == 0 {\n        return 1;\n    }\n    if n % 2 == 0 {\n        let tmp\
    \ = modp(n / 2, p);\n        return tmp * tmp % p;\n    }\n    modp(n - 1, p)\
    \ * 2 % p", "    let mut r = 1;\n    let mut m = n;\n    let mut b = 2;\n    while\
    \ m > 0 {\n        if m % 2 == 1 {\n            r = (r * b) % p;\n        }\n\
    \        m = m / 2;\n        b = (b * b) % p;\n    }\n    r", "\tif n == 0 {\n\
    \t\treturn 1;\n\t}\n\tif n % 2 == 0 {\n\t\treturn modp(n / 2, p) * modp(n / 2,\
    \ p) % p;\n\t}\n\treturn 2 * modp(n - 1, p) % p;", "    if n == 0 {\n        return\
    \ 1;\n    }\n\n    let half = modp(n / 2, p);\n    half * half % p * (if n % 2\
    \ == 0 { 1 } else { 2 }) % p", "    if n == 0 {\n        return 1;\n    }\n  \
    \  let half = modp(n / 2, p);\n    let other_half = if n % 2 == 0 { half } else\
    \ { p - half };\n    (half * other_half) % p", "    let mut modp = 1;\n    for\
    \ _ in 0..n {\n        modp = (modp * 2) % p;\n    }\n    modp", "    match n\
    \ {\n        0 => 1,\n        _ => modp(n-1, p) * 2 % p,\n    }", "    if n ==\
    \ 0 {\n        return 1;\n    }\n    if n == 1 {\n        return 2;\n    }\n \
    \   let x = modp(n / 2, p);\n    if n % 2 == 0 {\n        return x * x % p;\n\
    \    } else {\n        return 2 * x * x % p;\n    }", "    let mut result = 1;\n\
    \    let mut x = 2;\n    let mut i = n;\n    while i > 0 {\n        if i % 2 ==\
    \ 1 {\n            result = (result * x) % p;\n        }\n        x = (x * x)\
    \ % p;\n        i = i / 2;\n    }\n    result", "    let mut result = 1;\n   \
    \ let mut n = n;\n    let mut base = 2;\n    while n > 0 {\n        if n % 2 ==\
    \ 1 {\n            result = (result * base) % p;\n        }\n        n /= 2;\n\
    \        base = (base * base) % p;\n    }\n    result", "    if n == 0 {\n   \
    \     return 1;\n    }\n    let mut b: isize = 1;\n    let mut r: isize = 2;\n\
    \    for _ in 0..n {\n        b = (b * r) % p;\n    }\n    b", "    let mut res\
    \ = 1;\n    let mut two = 2;\n    while n > 0 {\n        if n % 2 == 1 {\n   \
    \         res = (res * two) % p;\n        }\n        two = (two * two) % p;\n\
    \        n = n / 2;\n    }\n    res", "    let mut r = 1;\n    let mut i = n;\n\
    \    while i > 0 {\n        if i % 2 == 1 {\n            r = (r * 2) % p;\n  \
    \      }\n        i = i / 2;\n    }\n    r", "    if n == 0 {\n        return\
    \ 1;\n    }\n    if n == 1 {\n        return 2;\n    }\n    if n % 2 == 0 {\n\
    \        let m = modp(n / 2, p);\n        return (m * m) % p;\n    }\n    (2 *\
    \ modp(n - 1, p)) % p", "    let mut res = 1;\n    let mut exp = n;\n    let mut\
    \ base = 2;\n    while exp > 0 {\n        if exp % 2 == 1 {\n            res =\
    \ (res * base) % p;\n        }\n        exp = exp / 2;\n        base = (base *\
    \ base) % p;\n    }\n    res", "    assert!(n >= 0);\n    assert!(p > 0);\n  \
    \  if n == 0 {\n        return 1;\n    }\n    let mut x = modp(n / 2, p);\n  \
    \  x = x * x % p;\n    if n % 2 == 1 {\n        x = x * 2 % p;\n    }\n    x",
  "    let mut r = 1;\n    let mut k = n;\n    let mut m = 2;\n    while k > 0 {\n\
    \        if k % 2 == 1 {\n            r = (r * m) % p;\n        }\n        m =\
    \ (m * m) % p;\n        k = k / 2;\n    }\n    r", "    let mut r = 1;\n    let\
    \ mut k = n;\n    let mut y = 2;\n    while k > 0 {\n        if k % 2 == 1 {\n\
    \            r = (r * y) % p;\n        }\n        y = (y * y) % p;\n        k\
    \ = k / 2;\n    }\n    r", "    let mut n = n;\n    let mut result = 1;\n    let\
    \ mut b = 2;\n    let mp = p - 1;\n    while n > 0 {\n        if n & 1 == 1 {\n\
    \            result = (result * b) % p;\n        }\n        n >>= 1;\n       \
    \ b = (b * b) % p;\n    }\n    result", "    let mut res = 1;\n    let mut cur\
    \ = 2;\n    for bit in (0..32).rev() {\n        if (n & (1 << bit)) != 0 {\n \
    \           res = (res * cur) % p;\n        }\n        cur = (cur * cur) % p;\n\
    \    }\n    res", "    if n == 0 {\n        return 1;\n    }\n    if n & 1 ==\
    \ 0 {\n        return modp(n >> 1, p) * modp(n >> 1, p) % p;\n    }\n    return\
    \ modp(n >> 1, p) * modp(n >> 1, p) * 2 % p;", "    if n == 0 {\n        return\
    \ 1;\n    }\n    let mut ans = modp(n / 2, p);\n    ans = (ans * ans) % p;\n \
    \   if n % 2 == 1 {\n        ans = (ans * 2) % p;\n    }\n    ans", "    if n\
    \ == 0 {\n        return 1;\n    }\n    let mut n = n;\n    let mut res = 2;\n\
    \    let mut p = p;\n    while n > 1 {\n        if n % 2 == 1 {\n            res\
    \ = (res * res) % p;\n        }\n        n /= 2;\n        res = (res * res) %\
    \ p;\n    }\n    res", "    if n == 0 {\n        return 1;\n    }\n    let mut\
    \ n = n;\n    let mut res = modp(n / 2, p);\n    res = res * res % p;\n    if\
    \ n % 2 == 1 {\n        res = res * 2 % p;\n    }\n    res", "    let mut result\
    \ = 1;\n    let mut base = 2;\n    let mut exp = n;\n    while exp > 0 {\n   \
    \     if exp % 2 == 1 {\n            result = (result * base) % p;\n        }\n\
    \        exp = exp / 2;\n        base = (base * base) % p;\n    }\n    result",
  "    let mut x = 1;\n    let mut e = n;\n    while e > 0 {\n        if e % 2 ==\
    \ 1 {\n            x = x * 2 % p;\n        }\n        e = e / 2;\n        if e\
    \ > 0 {\n            x = x * x % p;\n        }\n    }\n    x", "\tif n == 0 {\n\
    \t\treturn 1;\n\t}\n\tif n % 2 == 0 {\n\t\tlet t = modp(n / 2, p);\n\t\treturn\
    \ (t * t) % p;\n\t}\n\treturn (2 * modp(n - 1, p)) % p;", "    let mut i = 1;\n\
    \    let mut j = 0;\n    let mut b = vec![0; n as usize];\n    while i < n {\n\
    \        let mut k = 0;\n        while k < n {\n            b[k as usize] = j\
    \ % 2;\n            j /= 2;\n            k += 1;\n        }\n        j = i;\n\
    \        k = n - 1;\n        while k >= 0 {\n            let d = 2 * b[k as usize]\
    \ + j % 2;\n            j = (j - d) / 2;\n            b[k as usize] = d;\n   \
    \         k -= 1;\n        }\n        i += 1;\n    }\n    let mut res = 0;\n \
    \   i = n - 1;\n    while i >= 0 {\n        res = (2 * res + b[i as usize]) %\
    \ p;\n        i -= 1;\n    }\n    res", "    if n == 0 {\n        return 1;\n\
    \    }\n    if n % 2 == 0 {\n        modp(n / 2, p) * modp(n / 2, p) % p\n   \
    \ } else {\n        2 * modp(n - 1, p) % p\n    }", "    let mut n = n % p;\n\
    \    let mut result = 1;\n    let mut x = 2;\n    while n > 0 {\n        if n\
    \ % 2 == 1 {\n            result = result * x % p;\n        }\n        x = x *\
    \ x % p;\n        n = n / 2;\n    }\n    result", "    // This is the actual algorithm;\
    \ unfortunately, it's a little slow.\n    // let m = (p - 1) >> 1;\n    // let\
    \ mut r = 1;\n    // for _ in 0..m {\n    //     r = (r * r) % p;\n    //    \
    \ if n & 1 != 0 {\n    //         r = (r * 2) % p;\n    //     }\n    //     n\
    \ >>= 1;\n    // }\n    // return r;\n\n    // Here's a fast way to do the same\
    \ thing. This fails if n >= p^2, but who cares.\n    let mut r = 1;\n    let mut\
    \ n = n % p;\n    while n > 0 {\n        if n & 1 != 0 {\n            r = (r *\
    \ 2) % p;\n        }\n        n >>= 1;\n        r = (r * r) % p;\n    }\n    return\
    \ r;", "    let mut res = 1;\n    let mut nn = n;\n    let mut p = p;\n    while\
    \ nn > 0 {\n        if nn % 2 == 1 {\n            res = (res * n) % p;\n     \
    \   }\n        nn = nn / 2;\n        n = (n * n) % p;\n    }\n    res", "    if\
    \ n == 0 {\n        return 1;\n    }\n    if n == 1 {\n        return 2;\n   \
    \ }\n    let a = modp(n/2, p);\n    let aa = (a * a) % p;\n    if n % 2 == 0 {\n\
    \        return aa;\n    }\n    (aa * 2) % p", "    let mut res = 1;\n    let\
    \ mut pow = n;\n    let mut a = 2;\n    while pow > 0 {\n        if pow % 2 ==\
    \ 1 {\n            res = (res * a) % p;\n        }\n        pow /= 2;\n      \
    \  a = (a * a) % p;\n    }\n    res", "    let mut n = n;\n    let mut res = 1;\n\
    \    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * 2) % p;\n\
    \        }\n        n /= 2;\n    }\n    res", "    let mut res = 1;\n    let mut\
    \ pow = n;\n    let mut x = 2;\n    while pow > 0 {\n        if pow % 2 == 1 {\n\
    \            res = (res * x) % p;\n        }\n        pow = pow / 2;\n       \
    \ x = (x * x) % p;\n    }\n    res", "    assert!(n >= 0);\n    assert!(p > 0);\n\
    \    let mut r = 1;\n    let mut rr = 2;\n    let mut nn = n;\n    while nn >\
    \ 0 {\n        if nn % 2 == 1 {\n            r = (r * rr) % p;\n        }\n  \
    \      rr = (rr * rr) % p;\n        nn /= 2;\n    }\n    r", "    match n {\n\
    \        0 => 1,\n        1 => 2,\n        _ => {\n            // (2^n)^2 = 2^(2n)\
    \ = (2^n)^2 mod p\n            let mut b = modp(n / 2, p);\n            b = (b\
    \ * b) % p;\n            if n % 2 == 1 {\n                b = (b * 2) % p;\n \
    \           }\n            b\n        }\n    }", "    let mut r = 1;\n    let\
    \ mut s = 2;\n    let mut m = n;\n    while m > 0 {\n        if m % 2 == 1 {\n\
    \            r = (r * s) % p;\n        }\n        s = (s * s) % p;\n        m\
    \ = m / 2;\n    }\n    r", "    if n == 0 {\n        return 1;\n    }\n    let\
    \ mut p0 = 2;\n    let mut p1 = 2;\n    for _ in 1..n {\n        p1 = (p0 * p1)\
    \ % p;\n        p0 = p1;\n    }\n    p1", "    let mut result = 1;\n    let mut\
    \ base = 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            result =\
    \ (result * base) % p;\n        }\n        base = (base * base) % p;\n       \
    \ n /= 2;\n    }\n    result", "    let mut m = 1;\n    let mut k = n;\n    let\
    \ mut b = 2;\n    while k > 0 {\n        if k % 2 == 1 {\n            m = (m *\
    \ b) % p;\n        }\n        k = k / 2;\n        b = (b * b) % p;\n    }\n  \
    \  m", "    let mut sum = 1;\n    let mut m = n;\n    let mut k = 1;\n    while\
    \ m > 0 {\n        if m % 2 == 1 {\n            sum = (sum * k) % p;\n       \
    \ }\n        k = (k * k) % p;\n        m = m / 2;\n    }\n    sum", "    let mut\
    \ result = 1;\n    let mut n = n;\n    let mut base = 2;\n    while n > 0 {\n\
    \        if n % 2 == 1 {\n            result = (result * base) % p;\n        }\n\
    \        n = n / 2;\n        base = (base * base) % p;\n    }\n    result", " \
    \   let mut n = n;\n    let mut r = 1;\n    while n > 0 {\n        if n % 2 ==\
    \ 1 {\n            r = (r * 2) % p;\n        }\n        n /= 2;\n    }\n    r",
  "\tif n == 0 {\n\t\treturn 1;\n\t}\n\tif n == 1 {\n\t\treturn 2;\n\t}\n\tif n %\
    \ 2 == 0 {\n\t\tlet m = modp(n / 2, p);\n\t\treturn (m * m) % p;\n\t}\n\telse\
    \ {\n\t\tlet m = modp(n - 1, p);\n\t\treturn (2 * m) % p;\n\t}", "    let mut\
    \ m = 1;\n    let mut x = 2;\n    while n > 0 {\n        if n % 2 == 1 {\n   \
    \         m = (m * x) % p;\n        }\n        x = (x * x) % p;\n        n /=\
    \ 2;\n    }\n    m", "\tif n == 0 {\n\t\treturn 1;\n\t}\n\tif n % 2 == 0 {\n\t\
    \tlet m = modp(n / 2, p);\n\t\treturn m * m % p;\n\t}\n\treturn modp(n - 1, p)\
    \ * 2 % p;", "    let mut r = 1;\n    let mut k = n;\n    let mut s = 2;\n   \
    \ while k > 0 {\n        if k % 2 == 1 {\n            r = (r * s) % p;\n     \
    \   }\n        s = (s * s) % p;\n        k = k / 2;\n    }\n    r", "    let mut\
    \ t = 1;\n    let mut x = n;\n    let mut m = p;\n    while x > 0 {\n        if\
    \ x % 2 == 1 {\n            t = (t * n) % p;\n        }\n        x = x / 2;\n\
    \        n = (n * n) % p;\n    }\n    t", "    let mut r = 1;\n    let mut b =\
    \ 2;\n    for i in 0..n {\n        if i > 0 && i % 64 == 0 {\n            r =\
    \ (r * b) % p;\n            b = 2;\n        } else {\n            b = (b * b)\
    \ % p;\n        }\n    }\n    r", "    let mut res = 1;\n    let mut exp = n;\n\
    \    let mut base = 2;\n    while exp > 0 {\n        if exp % 2 == 1 {\n     \
    \       res = (res * base) % p;\n        }\n        exp /= 2;\n        base =\
    \ (base * base) % p;\n    }\n    res", "    if n == 0 {\n        return 1;\n \
    \   }\n    let mut ans = modp(n / 2, p);\n    ans = (ans * ans) % p;\n    if n\
    \ % 2 == 1 {\n        ans = (ans * 2) % p;\n    }\n    ans", "    if n == 0 {\n\
    \        return 1;\n    }\n    if n % 2 == 0 {\n        let tmp = modp(n / 2,\
    \ p);\n        return (tmp * tmp) % p;\n    }\n    (modp(n - 1, p) * 2) % p",
  "    if n == 0 {\n        return 1;\n    }\n\n    let mut sum = 1;\n    let mut\
    \ add = 2;\n    let mut k = n;\n    while k > 0 {\n        if k % 2 == 1 {\n \
    \           sum = (sum * add) % p;\n        }\n        add = (add * add) % p;\n\
    \        k /= 2;\n    }\n    sum", "    let mut r = 1;\n    let mut k = n;\n \
    \   let mut m = p - 2;\n    while m > 0 {\n        if m % 2 == 1 {\n         \
    \   r = (r * k) % p;\n        }\n        k = (k * k) % p;\n        m /= 2;\n \
    \   }\n    r", "    match n {\n        0 => 1,\n        _ => modp(n - 1, p) *\
    \ 2 % p,\n    }", "    match n {\n        0 => 1,\n        n if n % 2 == 0 =>\
    \ {\n            let e = modp(n / 2, p);\n            modmul(e, e, p)\n      \
    \  }\n        _ => modmul(modp(n - 1, p), 2, p),\n    }", "    let mut r = 1;\n\
    \    let mut pw = n;\n    let mut n = p - 2;\n    while n > 0 {\n        if n\
    \ % 2 == 1 {\n            r = (r * pw) % p;\n        }\n        pw = (pw * pw)\
    \ % p;\n        n /= 2;\n    }\n    r", "    let (mut x, mut y) = (1, 2);\n  \
    \  for _ in 0..n {\n        x = (x * y) % p;\n    }\n    x", "\tlet mut r = 1;\n\
    \tlet mut m = n;\n\tlet mut i = p - 2;\n\twhile i > 0 {\n\t\tif i % 2 == 1 {\n\
    \t\t\tr = r * m % p;\n\t\t}\n\t\tm = m * m % p;\n\t\ti /= 2;\n\t}\n\tr", "   \
    \ let mut r = 1;\n    let mut d = 2;\n    let mut b = n;\n    while b > 0 {\n\
    \        if b % 2 == 1 {\n            r = (r * d) % p;\n        }\n        d =\
    \ (d * d) % p;\n        b = b / 2;\n    }\n    r", "    if n == 0 {\n        return\
    \ 1;\n    }\n    if n % 2 == 0 {\n        return modp(n / 2, p) * modp(n / 2,\
    \ p) % p;\n    }\n    return modp(n - 1, p) * modp(n - 1, p) * 2 % p;", "    let\
    \ mut n = n;\n    let mut result = 1;\n    let mut base = 2;\n    while n > 0\
    \ {\n        if n % 2 == 1 {\n            result = (result * base) % p;\n    \
    \    }\n        n /= 2;\n        base = (base * base) % p;\n    }\n    result",
  "    let mut result = 1;\n    let mut a = 2;\n    let mut e = n;\n    while e >\
    \ 0 {\n        if e % 2 == 1 {\n            result = (result * a) % p;\n     \
    \   }\n        a = (a * a) % p;\n        e /= 2;\n    }\n    result", "    let\
    \ mut res = 1;\n    let mut i = n;\n    let mut k = p - 2;\n    while k > 0 {\n\
    \        if k % 2 == 1 {\n            res = (res * i) % p;\n        }\n      \
    \  i = (i * i) % p;\n        k /= 2;\n    }\n    res", "    let mut k = 1;\n \
    \   let mut l = 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            k\
    \ = (k * l) % p;\n        }\n        l = (l * l) % p;\n        n /= 2;\n    }\n\
    \    k", "    if n == 0 {\n        return 1;\n    }\n    if n % 2 == 0 {\n   \
    \     let t = modp(n / 2, p);\n        return (t * t) % p;\n    }\n    (2 * modp(n\
    \ - 1, p)) % p", "    if n == 0 {\n        return 1;\n    }\n    let mut res =\
    \ 1;\n    let mut p = p;\n    let mut n = n;\n    while n > 0 {\n        if n\
    \ % 2 == 1 {\n            res = (res * p) % MOD;\n        }\n        p = (p *\
    \ p) % MOD;\n        n /= 2;\n    }\n    res", "    let mut n = n;\n    let mut\
    \ result = 1;\n    let mut b = 2;\n    while n > 0 {\n        if n % 2 == 1 {\n\
    \            result = (result * b) % p;\n        }\n        n = n / 2;\n     \
    \   b = (b * b) % p;\n    }\n    result", "    let mut result = 1;\n    let mut\
    \ n = n;\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * 2) % p;\n        }\n        n /= 2;\n    }\n    result", "    if n == 0 {\
    \ return 1; }\n    let t = modp(n / 2, p);\n    t * t % p * if n % 2 == 0 { 1\
    \ } else { 2 } % p", "    assert!(n >= 0);\n    let mut n = n;\n    let mut res\
    \ = 1;\n    let mut base = 2;\n    while n > 0 {\n        if n % 2 == 1 {\n  \
    \          res = (res * base) % p;\n        }\n        base = (base * base) %\
    \ p;\n        n /= 2;\n    }\n    res", "    let mut r = 1;\n    let mut n = n;\n\
    \    let mut m = n % (p - 1);\n    n = m;\n    while n > 0 {\n        if n % 2\
    \ == 1 {\n            r = (r * m) % p;\n        }\n        m = (m * m) % p;\n\
    \        n /= 2;\n    }\n    r", "    if n == 0 {\n        return 1;\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n / 2, p) * modp(n / 2, p) % p;\n  \
    \  }\n    return modp(n - 1, p) * 2 % p;", "    if n == 0 {\n        return 1;\n\
    \    }\n    let mut res = 1;\n    let mut k = 1;\n    while k <= n {\n       \
    \ res = (res * 2) % p;\n        k += 1;\n    }\n    res", "    let mut result\
    \ = 1;\n    let mut base = 2;\n    let mut exp = n;\n    while exp > 0 {\n   \
    \     if exp % 2 == 1 {\n            result = (result * base) % p;\n        }\n\
    \        exp /= 2;\n        base = (base * base) % p;\n    }\n    result", " \
    \   if n == 0 {\n        return 1;\n    }\n    if n % 2 == 0 {\n        let t\
    \ = modp(n / 2, p);\n        return t * t % p;\n    }\n    modp(n - 1, p) * 2\
    \ % p", "    let mut ret = 1;\n    let mut n = n;\n    let mut x = 2;\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            ret = (ret * x) % p;\n       \
    \ }\n        x = (x * x) % p;\n        n /= 2;\n    }\n    ret", "    let mut\
    \ result = 1;\n    let mut _n = n;\n    let mut base = 2;\n    while _n > 0 {\n\
    \        if _n % 2 == 1 {\n            result = (result * base) % p;\n       \
    \ }\n        _n /= 2;\n        base = (base * base) % p;\n    }\n    result",
  "    let mut i = 0;\n    let mut accum = 1;\n    while i < n {\n        accum =\
    \ (accum * 2) % p;\n        i += 1;\n    }\n    accum", "    let mut res = 1;\n\
    \    let mut base = 2;\n    let mut exp = n;\n    while exp > 0 {\n        if\
    \ exp % 2 == 1 {\n            res = (res * base) % p;\n        }\n        base\
    \ = (base * base) % p;\n        exp /= 2;\n    }\n    res", "    if n == 0 {\n\
    \        return 1;\n    }\n    let mut n = n;\n    let mut r = 1;\n    let mut\
    \ base = 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            r = (r *\
    \ base) % p;\n        }\n        base = (base * base) % p;\n        n /= 2;\n\
    \    }\n    r", "    let mut d = 1;\n    let mut k = 0;\n    let mut n = n;\n\
    \    while n > 0 {\n        if n % 2 == 1 {\n            d = (d * 2) % p;\n  \
    \      }\n        n /= 2;\n        k += 1;\n    }\n    if k >= p {\n        d\
    \ = (d * modp(2, p - 2)) % p;\n    }\n    d", "    if n == 0 {\n        return\
    \ 1;\n    }\n    // (2^n mod p) = ((2^(n/2) mod p)^2) mod p\n    let mut x = modp(n\
    \ / 2, p);\n    x = (x * x) % p;\n    if n % 2 == 1 {\n        x = (x * 2) % p;\n\
    \    }\n    x", "    let mut prod = 1;\n    let mut m = n;\n    while m > 0 {\n\
    \        if m % 2 == 1 {\n            prod = (prod * 2) % p;\n        }\n    \
    \    m = m / 2;\n    }\n    prod", "    if n == 0 {\n        return 1;\n    }\n\
    \    if n % 2 == 0 {\n        let res = modp(n / 2, p);\n        return (res *\
    \ res) % p;\n    }\n    (modp(n - 1, p) * 2) % p", "    let mut x = 1;\n    let\
    \ mut i = 0;\n    while i < n {\n        x = (x * 2) % p;\n        i += 1;\n \
    \   }\n    x", "    if n < 0 {\n        panic!(\"modp() is not defined for negative\
    \ values\");\n    }\n\n    let mut result = 1;\n    let mut bin = n;\n    let\
    \ mut x = 2;\n\n    while bin > 0 {\n        if bin % 2 == 1 {\n            result\
    \ = (result * x) % p;\n        }\n        bin /= 2;\n        x = (x * x) % p;\n\
    \    }\n\n    result", "    let mut res = 1;\n    let mut temp = n;\n    while\
    \ temp > 0 {\n        if temp % 2 == 1 {\n            res = res * 2 % p;\n   \
    \     }\n        temp = temp / 2;\n        println!(\"{}\", res);\n    }\n   \
    \ res", "    let mut re = 1;\n    let mut b = 2;\n    let mut i = n;\n    while\
    \ i > 0 {\n        if i % 2 == 1 {\n            re = (re * b) % p;\n        }\n\
    \        b = (b * b) % p;\n        i = i / 2;\n    }\n    re", "    let mut modulus\
    \ = 1;\n    let mut n_tmp = n;\n    while n_tmp != 0 {\n        if n_tmp % 2 ==\
    \ 1 {\n            modulus = (modulus * 2) % p;\n        }\n        n_tmp /= 2;\n\
    \    }\n    modulus", "    if n == 0 {\n        return 1;\n    }\n    if n ==\
    \ 1 {\n        return 2;\n    }\n    let mut res = modp(n / 2, p);\n    res =\
    \ res * res % p;\n    if n % 2 == 1 {\n        res = res * 2 % p;\n    }\n   \
    \ res", "    let mut ret = 1;\n    let mut base = 2;\n    let mut pn = n;\n  \
    \  while pn > 0 {\n        if pn % 2 == 1 {\n            ret = (ret * base) %\
    \ p;\n        }\n        base = (base * base) % p;\n        pn /= 2;\n    }\n\
    \    ret", "    let mut r = 1;\n    let mut k = n;\n    let mut m = p - 2;\n \
    \   while m > 0 {\n        if m % 2 == 1 {\n            r = (r * k) % p;\n   \
    \     }\n        k = (k * k) % p;\n        m /= 2;\n    }\n    r", "    if n ==\
    \ 0 {\n        return 1;\n    }\n    let mut res = modp(n / 2, p);\n    res =\
    \ (res * res) % p;\n    if n % 2 == 1 {\n        res = (res * 2) % p;\n    }\n\
    \    res", "    let mut result = 1;\n    let mut k = 1;\n    let mut m = n;\n\
    \    while m > 0 {\n        if m % 2 == 1 {\n            result = (result * k)\
    \ % p;\n        }\n        k = (k * k) % p;\n        m /= 2;\n    }\n    result",
  "    assert!(n >= 0);\n    let mut pow2: isize = 1;\n    let mut result: isize =\
    \ 1;\n    while pow2 <= n {\n        if (n & pow2) != 0 {\n            result\
    \ = result * 2 % p;\n        }\n        pow2 *= 2;\n    }\n    result", "    if\
    \ n == 0 {\n        return 1;\n    }\n    if n == 1 {\n        return 2;\n   \
    \ }\n    if n % 2 == 0 {\n        let half = modp(n / 2, p);\n        return (half\
    \ * half) % p;\n    }\n    let half = modp(n / 2, p);\n    return (half * half\
    \ * 2) % p;", "    if n == 0 {\n        return 1;\n    }\n    let mut res = modp(n\
    \ / 2, p);\n    res = res * res % p;\n    if n % 2 == 1 {\n        res = res *\
    \ 2 % p;\n    }\n    res", "    let mut res = 1;\n    let mut n = n;\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            res = res * 2 % p;\n        }\n\
    \        n /= 2;\n        if n > 0 {\n            res = res * res % p;\n     \
    \   }\n    }\n    res", "    let mut b: isize = 1;\n    let mut m: isize = n;\n\
    \    while m > 0 {\n        if m % 2 == 1 {\n            b = (b * n) % p;\n  \
    \      }\n        n = (n * n) % p;\n        m = m / 2;\n    }\n    b", "    let\
    \ mut res = 1;\n    let mut n = n;\n    while n > 0 {\n        res = (res * 2)\
    \ % p;\n        n -= 1;\n    }\n    res", "    let mut m = 1;\n    let mut p2\
    \ = 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            m = (m * p2) %\
    \ p;\n        }\n        p2 = (p2 * p2) % p;\n        n /= 2;\n    }\n    m",
  "    if n == 0 {\n        return 1;\n    }\n    if n % 2 == 0 {\n        let half\
    \ = modp(n / 2, p);\n        return (half * half) % p;\n    }\n    return (2 *\
    \ modp(n - 1, p)) % p;", "    if n % p == 0 {\n        return 0;\n    }\n    (1\
    \ << (n % (p - 1))) % p", "    let mut x = 1;\n    let mut y = 2;\n    for _ in\
    \ 0..n {\n        x = (x * y) % p;\n    }\n    x", "    let mut s = 1;\n    let\
    \ mut i = 0;\n    let mut t = n;\n    let mut k = 1;\n    let h = floor(ln(n as\
    \ f64) / ln(2.0));\n    while i <= h {\n        if (t / 2) * 2 == t {\n      \
    \      s = (s * k) % p;\n        }\n        k = (k * k) % p;\n        t = t /\
    \ 2;\n        i = i + 1;\n    }\n    s", "    let mut res = 1;\n    let mut fac\
    \ = 2;\n    let mut exp = n;\n    while exp > 0 {\n        if exp % 2 == 1 {\n\
    \            res = (res * fac) % p;\n        }\n        fac = (fac * fac) % p;\n\
    \        exp /= 2;\n    }\n    res", "    if n % p == 0 {\n        return 0;\n\
    \    }\n    let mut result = 1;\n    for _ in 0..n {\n        result = (result\
    \ * 2) % p;\n    }\n    result", "    let mut b = 1;\n    let mut e = n;\n   \
    \ let mut r = 1;\n    loop {\n        if e == 0 {\n            return r;\n   \
    \     }\n        if e % 2 == 1 {\n            r = (r * b) % p;\n        }\n  \
    \      e = e / 2;\n        b = (b * b) % p;\n    }", "    let mut r = 1;\n   \
    \ let mut b = n;\n    while b > 0 {\n        if b % 2 == 1 {\n            r =\
    \ (r * n) % p;\n        }\n        b = b / 2;\n        n = (n * n) % p;\n    }\n\
    \    r", "    assert!(n >= 0);\n    if n == 0 {\n        return 1;\n    }\n  \
    \  if n % 2 == 0 {\n        let t = modp(n / 2, p);\n        return (t * t) %\
    \ p;\n    }\n    return (2 * modp(n - 1, p)) % p;", "    let mut res = 1;\n  \
    \  let mut pow = n;\n    let mut m = p;\n    while pow > 0 {\n        if pow %\
    \ 2 == 1 {\n            res = (res * m) % p;\n        }\n        pow /= 2;\n \
    \       m = (m * m) % p;\n    }\n    res", "    let mut res = 1;\n    let mut\
    \ m = n;\n    let mut x = 2;\n    while m > 0 {\n        if m % 2 == 1 {\n   \
    \         res = (res * x) % p;\n        }\n        m /= 2;\n        x = (x * x)\
    \ % p;\n    }\n    res", "    let mut res = 1;\n    let mut n_tmp = n;\n    while\
    \ n_tmp > 0 {\n        if n_tmp % 2 == 1 {\n            res = (res * 2) % p;\n\
    \        }\n        n_tmp = n_tmp / 2;\n    }\n    res", "    if n == 0 {\n  \
    \      return 1;\n    }\n    if n % 2 == 0 {\n        let n = n / 2;\n       \
    \ return (modp(n, p) * modp(n, p)) % p;\n    }\n    return (2 * modp(n - 1, p))\
    \ % p;", "    if n < 0 {\n        panic!(\"n >= 0 required in modp, but got {}\"\
    , n);\n    }\n    let mut r = 1;\n    let mut p = p;\n    let mut two = 2;\n \
    \   let mut n = n;\n    while n > 0 {\n        if n % 2 == 1 {\n            r\
    \ = (r * two) % p;\n        }\n        two = (two * two) % p;\n        n = n /\
    \ 2;\n    }\n    r", "    let mut res = 1;\n    let mut k = n;\n    let mut m\
    \ = 2;\n    while k > 0 {\n        if k % 2 == 1 {\n            res = (res * m)\
    \ % p;\n        }\n        k /= 2;\n        m = (m * m) % p;\n    }\n    res",
  "    if n == 0 {\n        return 1;\n    }\n\n    if n == 1 {\n        return 2;\n\
    \    }\n\n    let mut m = n / 2;\n    let mut r = 1;\n    let mut x = 2;\n\n \
    \   if n % 2 == 1 {\n        r = 2;\n    }\n\n    while m > 0 {\n        x = (x\
    \ * x) % p;\n        if m % 2 == 1 {\n            r = (r * x) % p;\n        }\n\
    \        m = m / 2;\n    }\n\n    r", "    if n == 0 {\n        return 1;\n  \
    \  }\n    let mut s = modp(n / 2, p);\n    s = (s * s) % p;\n    if n % 2 == 1\
    \ {\n        s = (s * 2) % p;\n    }\n    return s;", "    let mut v = 1;\n  \
    \  let mut s = 1;\n    while s < n {\n        s = s << 1;\n        v = (v * v)\
    \ % p;\n    }\n    v", "    match n {\n        0 => 1,\n        _ => modp(n /\
    \ 2, p) * modp(n - n / 2, p) % p,\n    }", "    if n == 0 {\n        return 1;\n\
    \    }\n    let mut nn = n;\n    let mut r = 2;\n    while nn > 1 {\n        if\
    \ nn % 2 == 1 {\n            r = (r * 2) % p;\n        }\n        nn /= 2;\n \
    \   }\n    r", "    let mut r = 1;\n    let mut a = 2;\n    let mut m = n;\n \
    \   while m > 0 {\n        if m % 2 == 1 {\n            r = (r * a) % p;\n   \
    \     }\n        a = (a * a) % p;\n        m /= 2;\n    }\n    r", "    if n ==\
    \ 0 {\n        return 1;\n    }\n    if n == 1 {\n        return 2;\n    }\n \
    \   if n % 2 == 0 {\n        let t = modp(n / 2, p);\n        return (t * t) %\
    \ p;\n    }\n    return (2 * modp(n - 1, p)) % p;", "    if n == 0 {\n       \
    \ return 1;\n    }\n\n    let mut x = modp(n >> 1, p);\n    x = (x * x) % p;\n\
    \    if n & 1 == 1 {\n        x = (x * 2) % p;\n    }\n    x", "    let mut r\
    \ = 1;\n    let mut n = n;\n    while n > 0 {\n        if n % 2 == 1 {\n     \
    \       r = (r * 2) % p;\n        }\n        n /= 2;\n    }\n    r", "    let\
    \ mut n = n;\n    let mut b = 1;\n    while n > 0 {\n        b = (b * (n & 1)\
    \ + b) % p;\n        n >>= 1;\n        b = (b * 2) % p;\n    }\n    b", "    let\
    \ mut pwr = BigInt::from(1);\n    for _ in 0..n {\n        pwr = pwr * BigInt::from(2);\n\
    \    }\n    let pbi = BigInt::from(p);\n    pwr % pbi", "    let mut r = 1;\n\
    \    let mut k = 1;\n    let mut two = 2;\n    while k <= n {\n        if k &\
    \ n != 0 {\n            r = (r * two) % p;\n        }\n        two = (two * two)\
    \ % p;\n        k = k << 1;\n    }\n    r", "    let mut m = 1;\n    let mut x\
    \ = 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            m = (m * x) %\
    \ p;\n        }\n        x = (x * x) % p;\n        n /= 2;\n    }\n    m", " \
    \   let mut result = 1;\n    let mut n = n;\n    while n > 0 {\n        if n %\
    \ 2 == 1 {\n            result = (result * 2) % p;\n        }\n        n /= 2;\n\
    \    }\n    result", "    let mut ret = 1;\n    let mut two = 2;\n    while n\
    \ > 0 {\n        if n % 2 == 1 {\n            ret = (ret * two) % p;\n       \
    \ }\n        two = (two * two) % p;\n        n = n / 2;\n    }\n    ret", "  \
    \  let mut r = 1;\n    let mut a = 2;\n    while n > 0 {\n        if n % 2 ==\
    \ 1 {\n            r = (r * a) % p;\n        }\n        a = (a * a) % p;\n   \
    \     n /= 2;\n    }\n    r", "    let mut res = 1;\n    let mut k = n;\n    let\
    \ mut pow2 = 2;\n    while k > 0 {\n        if k % 2 == 1 {\n            res =\
    \ (res * pow2) % p;\n        }\n        pow2 = (pow2 * pow2) % p;\n        k /=\
    \ 2;\n    }\n    res", "    if n == 0 { return 1; }\n    let mut y = 1;\n    let\
    \ mut x = 2;\n    while n > 1 {\n        if n % 2 == 0 {\n            x = (x *\
    \ x) % p;\n            n /= 2;\n        } else {\n            y = (x * y) % p;\n\
    \            x = (x * x) % p;\n            n = (n - 1) / 2;\n        }\n    }\n\
    \    (x * y) % p", "    let mut res = 1;\n    let mut cur = 2;\n    let mut exp\
    \ = n;\n    while exp > 0 {\n        if exp % 2 == 1 {\n            res = (res\
    \ * cur) % p;\n        }\n        cur = (cur * cur) % p;\n        exp /= 2;\n\
    \    }\n    res", "    if n == 0 {\n        return 1;\n    }\n    let mut result\
    \ = modp(n / 2, p);\n    result = (result * result) % p;\n    if n % 2 == 1 {\n\
    \        result = (result * 2) % p;\n    }\n    result", '    modp_bits(n, 0,
    p)', "    let mut res = 1;\n    let mut i = n;\n    let mut j = p - 2;\n    while\
    \ i > 0 {\n        if i % 2 == 1 {\n            res = (res * j) % p;\n       \
    \ }\n        i /= 2;\n        j = (j * j) % p;\n    }\n    res", "    let mut\
    \ result = 1;\n    let mut base = 2;\n    let mut cur = n;\n    while cur > 0\
    \ {\n        if cur % 2 == 1 {\n            result = result * base % p;\n    \
    \    }\n        base = base * base % p;\n        cur = cur / 2;\n    }\n    result",
  "    let mut n = n;\n    let mut r = 1;\n    while n > 0 {\n        if n % 2 ==\
    \ 1 {\n            r = (r * 2) % p;\n        }\n        n = n / 2;\n    }\n  \
    \  r", "    let mut r = 1;\n    let mut d = 2;\n    let mut e = n;\n    while\
    \ e > 0 {\n        if e % 2 == 1 {\n            r = (r * d) % p;\n        }\n\
    \        d = (d * d) % p;\n        e = e / 2;\n    }\n    r", "    let mut x =\
    \ 1;\n    let mut k = n;\n    while k > 0 {\n        while k % 2 == 0 {\n    \
    \        k /= 2;\n            x = (x * x) % p;\n        }\n        k -= 1;\n \
    \       x = (x * 2) % p;\n    }\n    x", "    let mut n = n;\n    let mut result\
    \ = 1;\n    let mut base = 2;\n    while n > 0 {\n        if n % 2 == 1 {\n  \
    \          result = (result * base) % p;\n        }\n        n /= 2;\n       \
    \ base = (base * base) % p;\n    }\n    result", "    if n == 0 {\n        return\
    \ 1;\n    }\n    if n % 2 == 0 {\n        let t = modp(n / 2, p);\n        t *\
    \ t % p\n    } else {\n        2 * modp(n - 1, p) % p\n    }", "    let mut result\
    \ = 1;\n    let mut b = n;\n    let mut a = 2;\n    while b > 0 {\n        if\
    \ b % 2 == 1 {\n            result = (result * a) % p;\n        }\n        b =\
    \ b / 2;\n        a = (a * a) % p;\n    }\n    result", "    let mut d = 1;\n\
    \    let mut k = 0;\n    let mut q = p - 1;\n    while q % 2 == 0 {\n        k\
    \ += 1;\n        q /= 2;\n    }\n    let mut z = modpow(n, q, p);\n    while k\
    \ > 0 {\n        if z != 1 && z != p - 1 {\n            z = (z * z) % p;\n   \
    \     }\n        if z != p - 1 {\n            d = 0;\n        }\n        k -=\
    \ 1;\n    }\n    if d == 0 {\n        -1\n    } else {\n        z\n    }", " \
    \   let mut res = 1;\n    let mut n = n;\n    let mut p = p;\n    let mut exp\
    \ = 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * exp)\
    \ % p;\n        }\n        exp = (exp * exp) % p;\n        n /= 2;\n    }\n  \
    \  res", "    let mut r = 1;\n    let mut b = 2;\n    let mut e = n;\n    while\
    \ e > 0 {\n        if e % 2 == 1 {\n            r = (r * b) % p;\n        }\n\
    \        e = e / 2;\n        b = (b * b) % p;\n    }\n    r", "    let mut i =\
    \ 1;\n    let mut j = 1;\n    while i < n {\n        j = (2 * j) % p;\n      \
    \  i += 1;\n    }\n    j", "    let mut result = 1;\n    let mut base = 2;\n \
    \   let mut exp = n;\n    while exp > 0 {\n        if exp % 2 == 1 {\n       \
    \     result = (result * base) % p;\n        }\n        exp /= 2;\n        base\
    \ = (base * base) % p;\n    }\n    result", "    let mut result = 1;\n    let\
    \ mut base = 2;\n    let mut exponent = n;\n    while exponent > 0 {\n       \
    \ if exponent % 2 == 1 {\n            result = (result * base) % p;\n        }\n\
    \        exponent = exponent / 2;\n        base = (base * base) % p;\n    }\n\
    \    result", "    let mut res = 1;\n    let mut x = 2;\n    let mut pow = n;\n\
    \    while pow > 0 {\n        if pow % 2 == 1 {\n            res = (res * x) %\
    \ p;\n        }\n        x = (x * x) % p;\n        pow /= 2;\n    }\n    res",
  "    assert!(n >= 0);\n    assert!(p > 0);\n    let mut res = 1;\n    let mut base\
    \ = 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * base)\
    \ % p;\n        }\n        base = (base * base) % p;\n        n /= 2;\n    }\n\
    \    res", "    if n == 0 {\n        return 1;\n    }\n    let mut result = 1;\n\
    \    let mut x = 2;\n    let mut y = n;\n    while y > 0 {\n        if y % 2 ==\
    \ 1 {\n            result = (result * x) % p;\n        }\n        x = (x * x)\
    \ % p;\n        y = y / 2;\n    }\n    result", "    let mut n = n;\n    let mut\
    \ res = 1;\n    while n > 0 {\n        res = (res * 2) % p;\n        n -= 1;\n\
    \    }\n    res", "    let mut result = 1;\n    let mut y = 2;\n    let mut k\
    \ = n;\n    while k > 0 {\n        if k % 2 == 1 {\n            result = (result\
    \ * y) % p;\n        }\n        y = (y * y) % p;\n        k /= 2;\n    }\n   \
    \ result", "    let mut res = 1;\n    let mut pow = n;\n    let mut base = 2;\n\
    \    while pow > 0 {\n        if pow % 2 == 1 {\n            res = (res * base)\
    \ % p;\n        }\n        pow /= 2;\n        base = (base * base) % p;\n    }\n\
    \    res", "    let mut ret = 1;\n    let mut cur = 2;\n    let mut p = p;\n \
    \   let mut n = n;\n    while n > 0 {\n        if n % 2 == 1 {\n            ret\
    \ = (ret * cur) % p;\n        }\n        cur = (cur * cur) % p;\n        n /=\
    \ 2;\n    }\n    ret", "    let mut r = 1;\n    let mut n = n;\n    while n >\
    \ 0 {\n        if n % 2 == 1 {\n            r = (r * 2) % p;\n        }\n    \
    \    n /= 2;\n    }\n    r", "    if n <= 0 {\n        1\n    } else {\n     \
    \   let mut x = modp(n >> 1, p);\n        x = x * x % p;\n        if n & 1 ==\
    \ 1 {\n            x = x * 2 % p;\n        }\n        x\n    }", "    let mut\
    \ d = 1;\n    let mut k = n;\n    while k > 0 {\n        if k % 2 == 1 {\n   \
    \         d = (d * 2) % p;\n        }\n        k = k / 2;\n    }\n    d", "  \
    \  let mut res = 1;\n    let mut n = n;\n    while n > 0 {\n        if n % 2 ==\
    \ 1 {\n            res = (res * 2) % p;\n        }\n        n /= 2;\n    }\n \
    \   res", "    if n == 0 {\n        return 1;\n    }\n    if n % 2 == 0 {\n  \
    \      let mut m = modp(n / 2, p);\n        return m * m % p;\n    }\n    let\
    \ mut m = modp(n - 1, p);\n    return m * 2 % p;", "    let mut result = 1;\n\
    \    let mut base = 2;\n    let mut power = n;\n    while power > 0 {\n      \
    \  if power % 2 == 1 {\n            result = (result * base) % p;\n        }\n\
    \        base = (base * base) % p;\n        power /= 2;\n    }\n    result", " \
    \   let mut res = 1;\n    let mut a = 2;\n    let mut b = n;\n    while b > 0\
    \ {\n        if b % 2 == 1 {\n            res = res * a % p;\n        }\n    \
    \    a = a * a % p;\n        b /= 2;\n    }\n    res", "    let mut ret = 1;\n\
    \    let mut b = 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            ret\
    \ = (ret * b) % p;\n        }\n        b = (b * b) % p;\n        n = n / 2;\n\
    \    }\n    ret", "    let mut base = 2;\n    let mut exponent = n;\n    let mut\
    \ result = 1;\n    while exponent > 0 {\n        if exponent % 2 == 1 {\n    \
    \        result = (result * base) % p;\n        }\n        exponent /= 2;\n  \
    \      base = (base * base) % p;\n    }\n    result", "    if n < 1 {\n      \
    \  panic!(\"modp(n, p) for n < 1\");\n    }\n    let mut result = 1;\n    let\
    \ mut base = 2;\n    let mut d = n;\n    while d > 0 {\n        if d % 2 == 1\
    \ {\n            result = result * base % p;\n        }\n        base = base *\
    \ base % p;\n        d /= 2;\n    }\n    result", "    if n == 0 {\n        return\
    \ 1;\n    }\n\n    if n % 2 == 0 {\n        return modp(n / 2, p) * modp(n / 2,\
    \ p) % p;\n    }\n\n    return modp(n - 1, p) * modp(n, p) % p;", "    if n ==\
    \ 0 {\n        return 1;\n    }\n    if n == 1 {\n        return 2;\n    }\n \
    \   // p is prime.\n    let a = modp(n / 2, p);\n    let b = (a * a) % p;\n  \
    \  if n % 2 == 0 {\n        return b;\n    }\n    return (b * 2) % p;", "    let\
    \ mut k = n;\n    let mut r = 1;\n    while k > 0 {\n        if k % 2 == 1 {\n\
    \            r = r * 2 % p;\n        }\n        k = k / 2;\n        if k > 0 {\n\
    \            r = r * r % p;\n        }\n    }\n    r", "    let mut p = p;\n \
    \   let mut n = n;\n    let mut res = 1;\n    let mut b = 2;\n    while n > 0\
    \ {\n        if n % 2 == 1 {\n            res = (res * b) % p;\n        }\n  \
    \      n = n / 2;\n        b = (b * b) % p;\n    }\n    res", "    let mut r =\
    \ 1;\n    let mut b = n;\n    let mut a = 2;\n    while b > 0 {\n        if b\
    \ % 2 == 1 {\n            r = (r * a) % p;\n        }\n        b /= 2;\n     \
    \   a = (a * a) % p;\n    }\n    r", "\tassert!(n >= 0);\n\tassert!(p > 0);\n\t\
    let mut c = 1;\n\tfor _ in 0..n {\n\t\tc = (c * 2) % p;\n\t}\n\tc", "    let mut\
    \ res = 1;\n    let mut x = 2;\n    let mut n_bin = n;\n    while n_bin > 0 {\n\
    \        if n_bin % 2 == 1 {\n            res = (res * x) % p;\n        }\n  \
    \      x = (x * x) % p;\n        n_bin /= 2;\n    }\n    res", "    let mut k\
    \ = 1;\n    let mut p = p;\n    let mut result = 1;\n    while k <= n {\n    \
    \    if k & n != 0 {\n            result = result * p % MOD;\n        }\n    \
    \    k <<= 1;\n        p = p * p % MOD;\n    }\n    result", "    let mut r =\
    \ 1;\n    let mut nn = n;\n    let mut ppp = p;\n    while nn > 0 {\n        if\
    \ nn % 2 == 1 {\n            r = (r * nn) % ppp;\n        }\n        nn = nn /\
    \ 2;\n        ppp = (ppp * ppp) % p;\n    }\n    r", "    let mut res = 1;\n \
    \   let mut y = 2;\n    let mut m = n;\n    while m > 0 {\n        if m % 2 ==\
    \ 1 {\n            res = (res * y) % p;\n        }\n        y = (y * y) % p;\n\
    \        m /= 2;\n    }\n    res", "    let mut n = n;\n    let mut res = 1;\n\
    \    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * 2) % p;\n\
    \        }\n        n = n / 2;\n    }\n    res", "    let mut r = 1;\n    let\
    \ mut a = 2;\n    let mut b = n;\n    while b > 0 {\n        if b % 2 == 1 {\n\
    \            r = (r * a) % p;\n        }\n        a = (a * a) % p;\n        b\
    \ = b / 2;\n    }\n    r"]
stop_tokens:
- "\n}"
