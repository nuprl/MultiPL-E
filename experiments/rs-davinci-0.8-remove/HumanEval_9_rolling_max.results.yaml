language: rs
name: HumanEval_9_rolling_max
results:
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut rolling_max = Vec::new();\n    let\
    \ mut current_max = numbers[0];\n    rolling_max.push(current_max);\n\n    for\
    \ i in 1..numbers.len() {\n        current_max = std::cmp::max(current_max, numbers[i]);\n\
    \        rolling_max.push(current_max);\n    }\n\n    rolling_max\n}\n\nfn main()\
    \ {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpwb4j4x0h.rs:5:27

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823096
- exit_code: 1
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max_found = numbers[0];\n    let mut\
    \ result = Vec::new();\n    result.push(max_found);\n\n    for &number in numbers.iter().skip(1)\
    \ {\n        max_found = max(max_found, number);\n        result.push(max_found);\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n   \
    \ assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n --> /tmp/tmptompqrdb.rs:9:21\n\
    \  |\n9 |         max_found = max(max_found, number);\n  |                   \
    \  ^^^ not found in this scope\n  |\nhelp: consider importing this function\n\
    \  |\n1 | use std::cmp::max;\n  |\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823096
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    if numbers.is_empty() {\n        return Vec::new();\n\
    \    }\n\n    let mut result = Vec::with_capacity(numbers.len());\n    let mut\
    \ max = numbers[0];\n    result.push(max);\n\n    for i in 1..numbers.len() {\n\
    \        if numbers[i] > max {\n            max = numbers[i];\n        }\n   \
    \     result.push(max);\n    }\n\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823096
- exit_code: 1
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut maximums = Vec::with_capacity(numbers.len());\n\
    \    let mut max_element = numbers[0];\n    maximums.push(max_element);\n\n  \
    \  for i in 1..numbers.len() {\n        max_element = max(max_element, numbers[i]);\n\
    \        maximums.push(max_element);\n    }\n\n    maximums\n}\n\nfn main() {\n\
    \    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n --> /tmp/tmpy6c1fuy7.rs:9:23\n\
    \  |\n9 |         max_element = max(max_element, numbers[i]);\n  |           \
    \            ^^^ not found in this scope\n  |\nhelp: consider importing this function\n\
    \  |\n1 | use std::cmp::max;\n  |\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823096
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut current_max\
    \ = numbers[0];\n    result.push(current_max);\n    for i in 1..numbers.len()\
    \ {\n        current_max = if numbers[i] > current_max {\n            numbers[i]\n\
    \        } else {\n            current_max\n        };\n        result.push(current_max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpbvi4kl0f.rs:5:27

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823096
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut rolling_max: Vec<isize> = Vec::new();\n\
    \    let mut max_element = numbers[0];\n    rolling_max.push(max_element);\n\n\
    \    for element in numbers[1..].iter() {\n        max_element = std::cmp::max(max_element,\
    \ *element);\n        rolling_max.push(max_element);\n    }\n\n    rolling_max\n\
    }\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpjx8wpac2.rs:5:27

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823096
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    for window\
    \ in numbers.windows(3) {\n        result.push(*window.iter().max().unwrap());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 4]`,\n right: `[1, 2, 3, 4]`', /tmp/tmpq0w4ic2y.rs:14:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823096
- exit_code: 1
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    numbers\n        .iter()\n        .scan(None,\
    \ |state, &x| {\n            *state = match *state {\n                None =>\
    \ Some(x),\n                Some(state) => Some(std::cmp::max(state, x)),\n  \
    \          };\n            Some(*state)\n        })\n        .collect()\n}\n\n\
    fn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `Option<isize>`\n  --> /tmp/tmpa_s7cc7i.rs:13:10\n   |\n\
    13 |         .collect()\n   |          ^^^^^^^ value of type `Vec<isize>` cannot\
    \ be built from `std::iter::Iterator<Item=Option<isize>>`\n   |\n   = help: the\
    \ trait `FromIterator<Option<isize>>` is not implemented for `Vec<isize>`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823096
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    if numbers.is_empty() {\n        return vec![];\n\
    \    }\n\n    let mut result = vec![];\n    let mut current_max = numbers[0];\n\
    \    result.push(current_max);\n\n    for i in 1..numbers.len() {\n        current_max\
    \ = current_max.max(numbers[i]);\n        result.push(current_max);\n    }\n\n\
    \    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823096
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut output = Vec::new();\n    let mut current_max\
    \ = numbers[0];\n    output.push(current_max);\n\n    for &number in numbers.iter().skip(1)\
    \ {\n        current_max = std::cmp::max(current_max, number);\n        output.push(current_max);\n\
    \    }\n\n    output\n}\n\nfn main() {\n    let candidate = rolling_max;\n   \
    \ assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmp28_0p4i_.rs:5:27

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823096
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max\
    \ = 0;\n    for n in numbers {\n        max = n.max(max);\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823096
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max = 0;\n    let mut result = Vec::new();\n\
    \    for number in numbers {\n        if number > max {\n            max = number;\n\
    \        }\n        result.push(max);\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823096
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max = numbers[0];\n    let mut result\
    \ = Vec::new();\n    result.push(max);\n\n    for i in 1..numbers.len() {\n  \
    \      if numbers[i] > max {\n            max = numbers[i];\n        }\n     \
    \   result.push(max);\n    }\n\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpzbpx8t56.rs:4:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823096
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut stack = Vec::new();\n    let mut maxes\
    \ = Vec::new();\n\n    for &num in numbers.iter() {\n        while !stack.is_empty()\
    \ && stack.last().unwrap() < &num {\n            stack.pop();\n        }\n\n \
    \       stack.push(num);\n        maxes.push(stack.last().unwrap().clone());\n\
    \    }\n\n    maxes\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 3, 2, 1]`,\n right: `[4, 4, 4, 4]`', /tmp/tmph5qsk1da.rs:23:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823096
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max_so_far = numbers[0];\n    let mut\
    \ result = vec![];\n    for number in numbers {\n        if number > max_so_far\
    \ {\n            max_so_far = number;\n        }\n        result.push(max_so_far);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpky2embh6.rs:4:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823096
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max_numbers = vec![numbers[0]];\n \
    \   let mut max_value = numbers[0];\n\n    for n in numbers.iter().skip(1) {\n\
    \        max_value = max_value.max(*n);\n        max_numbers.push(max_value);\n\
    \    }\n\n    max_numbers\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpo3r1n0p1.rs:4:32

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823096
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut rolling_max = Vec::new();\n    let\
    \ mut current_max = numbers[0];\n    rolling_max.push(current_max);\n\n    for\
    \ n in numbers.iter().skip(1) {\n        if n > &current_max {\n            current_max\
    \ = *n;\n        }\n        rolling_max.push(current_max);\n    }\n\n    rolling_max\n\
    }\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpmtke5gd1.rs:5:27

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823096
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut rolling_max: Vec<isize> = Vec::new();\n\
    \    let mut maximum: isize = numbers[0];\n    rolling_max.push(maximum);\n\n\
    \    for number in numbers.iter().skip(1) {\n        maximum = if number > &maximum\
    \ {\n            *number\n        } else {\n            maximum\n        };\n\
    \        rolling_max.push(maximum);\n    }\n\n    rolling_max\n}\n\nfn main()\
    \ {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpilf4dw3g.rs:5:30

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823096
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max_numbers = Vec::with_capacity(numbers.len());\n\
    \    let mut max = isize::min_value();\n    for n in numbers {\n        max =\
    \ std::cmp::max(max, n);\n        max_numbers.push(max);\n    }\n    max_numbers\n\
    }\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823096
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut max = numbers[0];\n    result.push(max);\n    for &n in numbers.iter().skip(1)\
    \ {\n        if n > max {\n            max = n;\n        }\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpvb3ob6ta.rs:5:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823096
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max = numbers[0];\n    numbers\n  \
    \      .iter()\n        .map(|&n| {\n            if n > max {\n              \
    \  max = n;\n            }\n            max\n        })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmp6716yfny.rs:4:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823096
- exit_code: 1
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    numbers\n        .iter()\n        .scan(None,\
    \ |state, &n| {\n            if state.is_none() {\n                *state = Some(n);\n\
    \            } else {\n                let state_val = state.unwrap();\n     \
    \           if n > state_val {\n                    *state = Some(n);\n      \
    \          }\n            }\n            Some(*state.unwrap())\n        })\n \
    \       .collect()\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp5fsuo32d.rs:15:18\n\
    \   |\n15 |             Some(*state.unwrap())\n   |                  ^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659823096
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max = std::isize::MIN;\n    let mut\
    \ rolling_max: Vec<isize> = Vec::new();\n\n    for n in numbers {\n        if\
    \ n > max {\n            max = n;\n        }\n        rolling_max.push(max);\n\
    \    }\n\n    rolling_max\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823096
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max = std::isize::MIN;\n    let mut\
    \ result = Vec::new();\n    for n in numbers {\n        max = n.max(max);\n  \
    \      result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823096
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    // final_sequence[i] = max(numbers[i], ..,\
    \ numbers[numbers.len() - 1])\n    let mut final_sequence = Vec::with_capacity(numbers.len());\n\
    \    let mut result = numbers[numbers.len() - 1];\n    for _ in 0..numbers.len()\
    \ {\n        final_sequence.push(result);\n        result = result.max(numbers[final_sequence.len()\
    \ - 1]);\n    }\n    final_sequence.reverse();\n    final_sequence\n}\n\nfn main()\
    \ {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpbvd8fjro.rs:6:30

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823096
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max = std::isize::MIN;\n    let mut\
    \ maxes = Vec::with_capacity(numbers.len());\n    for n in numbers {\n       \
    \ max = std::cmp::max(max, n);\n        maxes.push(max);\n    }\n    maxes\n}\n\
    \nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823096
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut current_max = numbers[0];\n    result.push(current_max);\n    for\
    \ n in numbers.iter().skip(1) {\n        current_max = std::cmp::max(current_max,\
    \ *n);\n        result.push(current_max);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmppvsveha_.rs:5:27

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823096
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max\
    \ = None;\n\n    for number in numbers {\n        max = match max {\n        \
    \    Some(candidate) => Some(if candidate > number {\n                candidate\n\
    \            } else {\n                number\n            }),\n            None\
    \ => Some(number),\n        };\n\n        result.push(max.unwrap());\n    }\n\n\
    \    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823097
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut res = Vec::new();\n    let mut max\
    \ = numbers[0];\n    res.push(max);\n    for i in 1..numbers.len() {\n       \
    \ max = max.max(numbers[i]);\n        res.push(max);\n    }\n    res\n}\n\nfn\
    \ main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmp5seng_vz.rs:5:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823097
- exit_code: 1
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    numbers\n        .iter()\n        .scan(0,\
    \ |acc, x| {\n            *acc = cmp::max(*acc, *x);\n            Some(*acc)\n\
    \        })\n        .collect()\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \ --> /tmp/tmpuuptt2m9.rs:7:20\n  |\n7 |             *acc = cmp::max(*acc, *x);\n\
    \  |                    ^^^ use of undeclared crate or module `cmp`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659823096
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max_element = numbers[0];\n    let\
    \ mut output: Vec<isize> = Vec::new();\n    output.push(max_element);\n\n    for\
    \ n in numbers.iter().skip(1) {\n        if n > &max_element {\n            max_element\
    \ = *n;\n        }\n        output.push(max_element);\n    }\n\n    output\n}\n\
    \nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpkv13eqq6.rs:4:27

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823097
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max: isize = numbers[0];\n    let mut\
    \ rolling_max = vec![max];\n\n    for x in numbers[1..].iter() {\n        if x\
    \ > &max {\n            max = *x;\n        }\n        rolling_max.push(max);\n\
    \    }\n\n    rolling_max\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpkvhs89rw.rs:4:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823097
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut rolling_max = vec![];\n    let mut\
    \ max_so_far = None;\n\n    for number in numbers {\n        match max_so_far\
    \ {\n            Some(max) => {\n                rolling_max.push(max);\n    \
    \            max_so_far = Some(std::cmp::max(max, number));\n            }\n \
    \           None => {\n                rolling_max.push(number);\n           \
    \     max_so_far = Some(number);\n            }\n        }\n    }\n\n    rolling_max\n\
    }\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 2, 3]`,\n right: `[1, 2, 3, 4]`', /tmp/tmp1h39345x.rs:26:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823097
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max: isize = numbers[0];\n    let mut\
    \ rolling_max: Vec<isize> = Vec::new();\n    rolling_max.push(max);\n\n    for\
    \ n in numbers {\n        if n > max {\n            max = n;\n        }\n    \
    \    rolling_max.push(max);\n    }\n\n    rolling_max\n}\n\nfn main() {\n    let\
    \ candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpfp6pj70k.rs:4:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823097
- exit_code: 1
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    result.push(numbers[0]);\n\
    \    for &number in numbers.iter().skip(1) {\n        result.push(std::cmp::max(result.last().unwrap(),\
    \ &number));\n    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp5zliizbw.rs:7:35\n  |\n7 |\
    \         result.push(std::cmp::max(result.last().unwrap(), &number));\n  |  \
    \                                 ^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ `&isize`\n  |\nhelp: consider dereferencing the borrow\n  |\n7 |         result.push(std::cmp::max(*result.last().unwrap(),\
    \ &number));\n  |                                   +\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp5zliizbw.rs:7:59\n  |\n7 |         result.push(std::cmp::max(result.last().unwrap(),\
    \ &number));\n  |                                                           ^^^^^^^\
    \ expected `isize`, found `&isize`\n  |\nhelp: consider removing the borrow\n\
    \  |\n7 -         result.push(std::cmp::max(result.last().unwrap(), &number));\n\
    7 +         result.push(std::cmp::max(result.last().unwrap(), number));\n  | \n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659823096
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut results = Vec::new();\n    let mut\
    \ max = numbers[0];\n    for i in 1..numbers.len() {\n        max = std::cmp::max(max,\
    \ numbers[i]);\n        results.push(max);\n    }\n    results\n}\n\nfn main()\
    \ {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpi93n1h98.rs:5:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823097
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    numbers\n        .iter()\n        .scan(0,\
    \ |acc, &x| {\n            *acc = if x > *acc { x } else { *acc };\n         \
    \   Some(*acc)\n        })\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823097
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    numbers\n        .iter()\n        .enumerate()\n\
    \        .map(|(i, val)| {\n            numbers[0..i + 1]\n                .iter()\n\
    \                .map(|n| *n)\n                .max()\n                .unwrap_or(*val)\n\
    \        })\n        .collect()\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823097
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max\
    \ = 0;\n    for num in numbers {\n        max = std::cmp::max(max, num);\n   \
    \     result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823097
- exit_code: 1
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    numbers\n        .iter()\n        .scan(None,\
    \ |rolling_max, i| {\n            match rolling_max {\n                None =>\
    \ {\n                    *rolling_max = Some(*i);\n                    Some(*i)\n\
    \                }\n                Some(max) => {\n                    if *i\
    \ > max {\n                        *rolling_max = Some(*i);\n                \
    \    }\n                    Some(max)\n                }\n            }\n    \
    \    })\n        .collect()\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptlr0ozre.rs:13:29\n   |\n\
    13 |                     if *i > max {\n   |                             ^^^ expected\
    \ `isize`, found `&mut isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n13 |                     if *i > *max {\n   |                         \
    \    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptlr0ozre.rs:16:26\n  \
    \ |\n16 |                     Some(max)\n   |                          ^^^ expected\
    \ `isize`, found `&mut isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n16 |                     Some(*max)\n   |                          +\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659823096
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut max = isize::min_value();\n\n    for current in numbers {\n     \
    \   if current > max {\n            max = current;\n        }\n\n        result.push(max);\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n   \
    \ assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823097
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut rolling_max: Vec<isize> = Vec::new();\n\
    \    for n in numbers {\n        if rolling_max.is_empty() {\n            rolling_max.push(n);\n\
    \        } else {\n            let last_max = rolling_max.last().unwrap();\n \
    \           if n > *last_max {\n                rolling_max.push(n);\n       \
    \     } else {\n                rolling_max.push(*last_max);\n            }\n\
    \        }\n    }\n    rolling_max\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823097
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    if numbers.is_empty() {\n        return vec![];\n\
    \    }\n\n    let mut rolling_max_numbers = vec![numbers[0]];\n    let mut current_max\
    \ = numbers[0];\n\n    for i in 1..numbers.len() {\n        if numbers[i] > current_max\
    \ {\n            current_max = numbers[i];\n        }\n\n        rolling_max_numbers.push(current_max);\n\
    \    }\n\n    rolling_max_numbers\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823097
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut stack = Vec::new();\n    let mut res\
    \ = Vec::new();\n\n    for number in numbers {\n        // Dropping elements from\
    \ the stack for which we have a bigger element.\n        while let Some(el) =\
    \ stack.last() {\n            if *el < number {\n                stack.pop();\n\
    \            } else {\n                break;\n            }\n        }\n\n  \
    \      // Pushing current element on the stack.\n        stack.push(number);\n\
    \n        // Adding the current maximum number to the result.\n        res.push(*stack.last().unwrap());\n\
    \    }\n\n    res\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 3, 2, 1]`,\n right: `[4, 4, 4, 4]`', /tmp/tmp90bfz81c.rs:31:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823097
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut max_so_far = std::isize::MIN;\n\n    for number in numbers {\n  \
    \      max_so_far = max_so_far.max(number);\n        result.push(max_so_far);\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n   \
    \ assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823097
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut answer = Vec::with_capacity(numbers.len());\n\
    \    let mut max = numbers[0];\n    answer.push(max);\n    for i in 1..numbers.len()\
    \ {\n        max = std::cmp::max(max, numbers[i]);\n        answer.push(max);\n\
    \    }\n    answer\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmphrz0cxz_.rs:5:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823097
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    numbers\n        .iter()\n        .scan(isize::min_value(),\
    \ |state, &x| {\n            if x > *state {\n                *state = x;\n  \
    \          }\n            Some(*state)\n        })\n        .collect()\n}\n\n\
    fn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823097
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max = 0;\n    let mut result = Vec::with_capacity(numbers.len());\n\
    \    for n in numbers {\n        if n > max {\n            max = n;\n        }\n\
    \        result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823097
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut i = 0;\n    let mut max = 0;\n    let\
    \ mut result = Vec::new();\n\n    while i < numbers.len() {\n        if numbers[i]\
    \ > max {\n            max = numbers[i];\n        }\n\n        result.push(max);\n\
    \        i += 1;\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823097
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max: isize = isize::min_value();\n\
    \    let mut result: Vec<isize> = Vec::new();\n\n    for n in numbers {\n    \
    \    if n > max {\n            max = n;\n        }\n        result.push(max);\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n   \
    \ assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823097
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut max = std::isize::MIN;\n    for number in numbers {\n        max\
    \ = std::cmp::max(max, number);\n        result.push(max);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823097
- exit_code: 1
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max = numbers[0];\n    let mut rolling_max:\
    \ Vec<isize> = vec![max];\n\n    for number in numbers.iter().skip(1) {\n    \
    \    max = cmp::max(max, *number);\n        rolling_max.push(max);\n    }\n\n\
    \    rolling_max\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \ --> /tmp/tmp6ds7d2ft.rs:8:15\n  |\n8 |         max = cmp::max(max, *number);\n\
    \  |               ^^^ use of undeclared crate or module `cmp`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659823097
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut current_max\
    \ = 0;\n    for number in numbers {\n        if number > current_max {\n     \
    \       current_max = number;\n        }\n        result.push(current_max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823097
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max\
    \ = isize::min_value();\n\n    for n in numbers {\n        if n > max {\n    \
    \        max = n;\n        }\n\n        result.push(max);\n    }\n\n    result\n\
    }\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823097
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut current_max = numbers[0];\n    result.push(current_max);\n    for\
    \ i in 1..numbers.len() {\n        current_max = std::cmp::max(current_max, numbers[i]);\n\
    \        result.push(current_max);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpf22uv875.rs:5:27

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823097
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max = std::isize::MIN;\n    let mut\
    \ max_list = Vec::with_capacity(numbers.len());\n    for n in numbers {\n    \
    \    max = max.max(n);\n        max_list.push(max);\n    }\n    max_list\n}\n\n\
    fn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823097
- exit_code: 1
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut rolling_max_list = Vec::new();\n  \
    \  for n in numbers {\n        if rolling_max_list.is_empty() {\n            rolling_max_list.push(n);\n\
    \        } else {\n            rolling_max_list.push(cmp::max(rolling_max_list[rolling_max_list.len()\
    \ - 1], n));\n        }\n    }\n    rolling_max_list\n}\n\nfn main() {\n    let\
    \ candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \ --> /tmp/tmpjrvd9s7y.rs:9:35\n  |\n9 |             rolling_max_list.push(cmp::max(rolling_max_list[rolling_max_list.len()\
    \ - 1], n));\n  |                                   ^^^ use of undeclared crate\
    \ or module `cmp`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659823097
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut max = isize::min_value();\n\n    for number in numbers {\n      \
    \  max = if number > max {\n            number\n        } else {\n           \
    \ max\n        };\n\n        result.push(max);\n    }\n\n    result\n}\n\nfn main()\
    \ {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823097
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max_so_far = isize::min_value();\n\
    \    let mut result = Vec::new();\n\n    for number in numbers {\n        if number\
    \ > max_so_far {\n            max_so_far = number;\n        }\n\n        result.push(max_so_far);\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n   \
    \ assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823097
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut current_max = isize::min_value();\n\n    for number in numbers {\n\
    \        if number > current_max {\n            current_max = number;\n      \
    \  }\n\n        result.push(current_max);\n    }\n\n    result\n}\n\nfn main()\
    \ {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823097
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    numbers\n        .iter()\n        .scan(std::isize::MIN,\
    \ |state, &x| {\n            *state = std::cmp::max(*state, x);\n            Some(*state)\n\
    \        })\n        .collect()\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823097
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut maximum\
    \ = std::isize::MIN;\n\n    for n in numbers {\n        maximum = std::cmp::max(maximum,\
    \ n);\n        result.push(maximum);\n    }\n\n    result\n}\n\nfn main() {\n\
    \    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823097
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut numbers = numbers;\n    let mut rolling_max\
    \ = vec![];\n    rolling_max.push(numbers[0]);\n    numbers.remove(0);\n\n   \
    \ for number in numbers {\n        let last_max = rolling_max[rolling_max.len()\
    \ - 1];\n        rolling_max.push(if number > last_max { number } else { last_max\
    \ });\n    }\n\n    rolling_max\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpza9mdnu0.rs:6:22

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823097
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut ret = Vec::new();\n    let mut max\
    \ = numbers[0];\n    ret.push(max);\n    for n in numbers[1..].iter() {\n    \
    \    if *n > max {\n            max = *n;\n        }\n        ret.push(max);\n\
    \    }\n    ret\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmphvzsca91.rs:5:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823097
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max_list = Vec::new();\n    let mut\
    \ curr_max = isize::min_value();\n\n    for number in numbers {\n        if number\
    \ > curr_max {\n            curr_max = number;\n        }\n\n        max_list.push(curr_max);\n\
    \    }\n\n    max_list\n}\n\nfn main() {\n    let candidate = rolling_max;\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823097
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max\
    \ = isize::min_value();\n\n    for x in numbers {\n        max = max.max(x);\n\
    \        result.push(max);\n    }\n\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823097
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut maximum\
    \ = std::isize::MIN;\n\n    for n in numbers {\n        maximum = std::cmp::max(maximum,\
    \ n);\n        result.push(maximum);\n    }\n\n    result\n}\n\nfn main() {\n\
    \    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823097
- exit_code: 1
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    numbers\n        .iter()\n        .fold(Vec::new(),\
    \ |mut acc, &num| {\n            if acc.is_empty() {\n                acc.push(num);\n\
    \            } else {\n                acc.push(acc.last().unwrap().max(num));\n\
    \            }\n            acc\n        })\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpck1mcscv.rs:10:50\n   |\n\
    10 |                 acc.push(acc.last().unwrap().max(num));\n   |           \
    \                                       ^^^\n   |                            \
    \                      |\n   |                                               \
    \   expected `&isize`, found `isize`\n   |                                   \
    \               help: consider borrowing here: `&num`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpck1mcscv.rs:10:26\n   |\n10 |                 acc.push(acc.last().unwrap().max(num));\n\
    \   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n10 |  \
    \               acc.push(*acc.last().unwrap().max(num));\n   |               \
    \           +\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659823097
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max: Vec<isize> = Vec::new();\n   \
    \ max.push(numbers[0]);\n    for i in 1..numbers.len() {\n        max.push(std::cmp::max(max[i\
    \ - 1], numbers[i]));\n    }\n    max\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmprx96invo.rs:5:14

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823097
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut stack = Vec::new();\n    let mut result\
    \ = Vec::new();\n\n    for number in numbers {\n        while !stack.is_empty()\
    \ && stack.last().unwrap() < &number {\n            stack.pop();\n        }\n\n\
    \        stack.push(number);\n        result.push(stack.last().unwrap().clone());\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n   \
    \ assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 3, 2, 1]`,\n right: `[4, 4, 4, 4]`', /tmp/tmp23h1kb0x.rs:23:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823097
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut rolling_max: Vec<isize> = Vec::new();\n\
    \    let mut max = std::isize::MIN;\n    for i in 0..numbers.len() {\n       \
    \ if numbers[i] > max {\n            max = numbers[i];\n        }\n        rolling_max.push(max);\n\
    \    }\n    rolling_max\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823097
- exit_code: 1
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    numbers\n        .into_iter()\n        .scan(None,\
    \ |max, current| {\n            *max = max.map(|m| std::cmp::max(m, current)).or(Some(current));\n\
    \            Some(*max.unwrap())\n        })\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n --> /tmp/tmpbln02_0a.rs:8:18\n\
    \  |\n8 |             Some(*max.unwrap())\n  |                  ^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659823097
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut rolling_max = Vec::with_capacity(numbers.len());\n\
    \    let mut current_max = isize::min_value();\n\n    for number in numbers {\n\
    \        current_max = current_max.max(number);\n        rolling_max.push(current_max);\n\
    \    }\n\n    rolling_max\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823097
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut ret = Vec::new();\n    let mut max_element\
    \ = isize::min_value();\n    for element in numbers {\n        if element > max_element\
    \ {\n            max_element = element;\n        }\n        ret.push(max_element);\n\
    \    }\n    ret\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823097
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut current_max = 0;\n    for number in numbers {\n        if number\
    \ > current_max {\n            current_max = number;\n        }\n        result.push(current_max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823097
- exit_code: 1
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max = numbers[0];\n    let mut result\
    \ = Vec::new();\n    result.push(max);\n\n    for i in 1..numbers.len() {\n  \
    \      max = cmp::max(max, numbers[i]);\n        result.push(max);\n    }\n\n\
    \    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \ --> /tmp/tmprrns8rx8.rs:9:15\n  |\n9 |         max = cmp::max(max, numbers[i]);\n\
    \  |               ^^^ use of undeclared crate or module `cmp`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659823097
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max = isize::min_value();\n    let\
    \ mut result = Vec::new();\n\n    for number in numbers {\n        if number >\
    \ max {\n            max = number;\n        }\n\n        result.push(max);\n \
    \   }\n\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823097
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut rolling_max = Vec::new();\n    let\
    \ mut max_so_far = std::isize::MIN;\n    for number in numbers {\n        max_so_far\
    \ = std::cmp::max(max_so_far, number);\n        rolling_max.push(max_so_far);\n\
    \    }\n    rolling_max\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823097
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut rolling_max: Vec<isize> = Vec::new();\n\
    \    let mut max_val = std::isize::MIN;\n    for i in numbers {\n        if i\
    \ > max_val {\n            max_val = i;\n        }\n        rolling_max.push(max_val);\n\
    \    }\n    rolling_max\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823097
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max\
    \ = numbers[0];\n    result.push(max);\n    for i in 1..numbers.len() {\n    \
    \    max = std::cmp::max(max, numbers[i]);\n        result.push(max);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmp_tak380g.rs:5:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823097
- exit_code: 1
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max_numbers = Vec::new();\n    let\
    \ mut max_number = numbers[0];\n    max_numbers.push(max_number);\n\n    for i\
    \ in 1..numbers.len() {\n        max_number = max(max_number, numbers[i]);\n \
    \       max_numbers.push(max_number);\n    }\n\n    max_numbers\n}\n\nfn main()\
    \ {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n --> /tmp/tmp1eipsx90.rs:9:22\n\
    \  |\n9 |         max_number = max(max_number, numbers[i]);\n  |             \
    \         ^^^ not found in this scope\n  |\nhelp: consider importing this function\n\
    \  |\n1 | use std::cmp::max;\n  |\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823097
- exit_code: 1
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    numbers\n        .iter()\n        .scan(None,\
    \ |maximum, &n| {\n            *maximum = maximum.map_or(Some(n), |maximum| Some(maximum.max(n)));\n\
    \            *maximum\n        })\n        .map(|o| o.unwrap())\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `&mut Option<T>`\n --> /tmp/tmpbvaa3jri.rs:6:22\n\
    \  |\n6 |         .scan(None, |maximum, &n| {\n  |                      ^^^^^^^\
    \ consider giving this closure parameter the explicit type `&mut Option<T>`, with\
    \ the type parameters specified\n  |\n  = note: type must be known at this point\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659823097
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut curr_max\
    \ = std::isize::MIN;\n\n    for num in numbers {\n        curr_max = std::cmp::max(curr_max,\
    \ num);\n        result.push(curr_max);\n    }\n\n    result\n}\n\nfn main() {\n\
    \    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823097
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max = numbers[0];\n    let mut result\
    \ = Vec::new();\n    result.push(max);\n\n    for i in 1..numbers.len() {\n  \
    \      max = max.max(numbers[i]);\n        result.push(max);\n    }\n\n    result\n\
    }\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmp60lbe99u.rs:4:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823097
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max_value = std::isize::MIN;\n    let\
    \ mut result = Vec::new();\n\n    for value in numbers {\n        if value > max_value\
    \ {\n            max_value = value;\n        }\n\n        result.push(max_value);\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n   \
    \ assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823098
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut current_max = 0;\n    let mut rolling_max:\
    \ Vec<isize> = Vec::new();\n\n    for n in numbers {\n        if n > current_max\
    \ {\n            current_max = n;\n        }\n        rolling_max.push(current_max);\n\
    \    }\n\n    rolling_max\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823097
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut res = Vec::new();\n    let mut current_max\
    \ = numbers[0];\n    res.push(current_max);\n    for i in numbers.iter().skip(1)\
    \ {\n        current_max = std::cmp::max(current_max, *i);\n        res.push(current_max);\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpsok1bc0c.rs:5:27

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823098
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    // Create a window of the size of given numbers\
    \ vector, which will slide from left to right\n    // along the vector.\n    let\
    \ mut rolling_max = numbers.iter().cloned().take(numbers.len()).collect::<Vec<isize>>();\n\
    \n    for i in 1..numbers.len() {\n        let previous_value = rolling_max[i\
    \ - 1];\n        let current_value = numbers[i];\n\n        rolling_max[i] = std::cmp::max(previous_value,\
    \ current_value);\n    }\n\n    rolling_max\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823098
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut max = std::isize::MIN;\n    for i in numbers {\n        if i > max\
    \ {\n            max = i;\n        }\n        result.push(max);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823098
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut rolling_max = Vec::new();\n    rolling_max.push(numbers[0]);\n\
    \n    let mut i = 1;\n    while i < numbers.len() {\n        rolling_max.push(std::cmp::max(rolling_max[i\
    \ - 1], numbers[i]));\n        i += 1;\n    }\n\n    rolling_max\n}\n\nfn main()\
    \ {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmp2vlzsp88.rs:5:22

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823098
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    // The current maximum element\n    let mut\
    \ max = isize::min_value();\n\n    numbers\n        .into_iter()\n        .map(|x|\
    \ {\n            // If the current element is greater than the current maximum\
    \ element, update it\n            if x > max {\n                max = x;\n   \
    \         }\n\n            // Return the current maximum element. Since `max`\
    \ can't be `isize::min_value()`,\n            // if the maximum is `isize::min_value()`,\
    \ `x` can't be `isize::min_value()`, hence\n            // `x` must be greater\
    \ than `max` and `max` is updated with `x`.\n            max\n        })\n   \
    \     .collect()\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823098
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut memo = vec![];\n    let mut max = 0;\n\
    \    for num in numbers {\n        if num > max {\n            max = num;\n  \
    \      }\n        memo.push(max);\n    }\n    memo\n}\n\nfn main() {\n    let\
    \ candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823098
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max_values = vec![numbers[0]];\n  \
    \  for (index, number) in numbers.iter().enumerate() {\n        if index == 0\
    \ {\n            continue;\n        }\n        max_values.push(std::cmp::max(max_values[index\
    \ - 1], *number));\n    }\n    max_values\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmp3yzbwskv.rs:4:31

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823098
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut max = std::isize::MIN;\n    for n in numbers {\n        if n > max\
    \ {\n            max = n;\n        }\n        result.push(max);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823098
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max\
    \ = 0;\n    for (i, number) in numbers.iter().enumerate() {\n        if *number\
    \ > max {\n            max = *number;\n        }\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823098
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max_so_far = isize::min_value();\n\
    \    let mut result = Vec::with_capacity(numbers.len());\n\n    for number in\
    \ numbers {\n        if number > max_so_far {\n            max_so_far = number;\n\
    \        }\n\n        result.push(max_so_far);\n    }\n\n    result\n}\n\nfn main()\
    \ {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823098
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut rolling_max: Vec<isize> = vec![];\n\
    \    let mut maximum = std::isize::MIN;\n    for &number in numbers.iter() {\n\
    \        maximum = std::cmp::max(maximum, number);\n        rolling_max.push(maximum);\n\
    \    }\n    rolling_max\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823098
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut rolling_max: Vec<isize> = Vec::new();\n\
    \    let mut max = 0;\n    for &num in numbers.iter() {\n        if num > max\
    \ {\n            max = num;\n        }\n        rolling_max.push(max);\n    }\n\
    \    rolling_max\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823098
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    if numbers.is_empty() {\n        return vec![];\n\
    \    }\n\n    let mut rolling_max = vec![numbers[0]];\n    let mut max = numbers[0];\n\
    \n    for i in 1..numbers.len() {\n        max = max.max(numbers[i]);\n      \
    \  rolling_max.push(max);\n    }\n\n    rolling_max\n}\n\nfn main() {\n    let\
    \ candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823098
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max\
    \ = 0;\n    for n in numbers {\n        max = n.max(max);\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823096
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max = numbers[0];\n    let mut rolling_max\
    \ = vec![];\n    for &n in numbers.iter() {\n        max = std::cmp::max(max,\
    \ n);\n        rolling_max.push(max);\n    }\n    rolling_max\n}\n\nfn main()\
    \ {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpt6wvpyj5.rs:4:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823098
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max_vec = Vec::new();\n    let mut\
    \ max_val = *numbers.first().unwrap();\n    for num in numbers {\n        max_val\
    \ = std::cmp::max(max_val, num);\n        max_vec.push(max_val);\n    }\n    max_vec\n\
    }\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmppyyr3765.rs:5:40

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823098
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut rolling_max = Vec::new();\n    let\
    \ mut current_max = 0;\n    for number in numbers {\n        current_max = std::cmp::max(current_max,\
    \ number);\n        rolling_max.push(current_max);\n    }\n    rolling_max\n}\n\
    \nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823098
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    numbers\n        .iter()\n        .scan(std::isize::MIN,\
    \ |max, &number| {\n            *max = std::cmp::max(*max, number);\n        \
    \    Some(*max)\n        })\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823098
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut curr_max\
    \ = std::isize::MIN;\n\n    for &number in numbers.iter() {\n        if number\
    \ > curr_max {\n            curr_max = number;\n        }\n\n        result.push(curr_max);\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n   \
    \ assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823098
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    numbers\n        .iter()\n        .scan(std::isize::MIN,\
    \ |max, &n| {\n            if n > *max {\n                *max = n;\n        \
    \    }\n            Some(*max)\n        })\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823098
- exit_code: 1
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    if numbers.is_empty() {\n        return vec![];\n\
    \    }\n\n    let mut max_numbers = vec![numbers[0]];\n    for i in 1..numbers.len()\
    \ {\n        max_numbers.push(max(max_numbers[i - 1], numbers[i]));\n    }\n\n\
    \    max_numbers\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmp5dg37w9g.rs:10:26\n\
    \   |\n10 |         max_numbers.push(max(max_numbers[i - 1], numbers[i]));\n \
    \  |                          ^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659823098
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let len = numbers.len();\n    let mut result\
    \ = Vec::with_capacity(len);\n    let mut max_so_far = isize::min_value();\n\n\
    \    for (i, number) in numbers.iter().enumerate() {\n        max_so_far = max_so_far.max(*number);\n\
    \        if i == len - 1 {\n            result.push(max_so_far);\n        } else\
    \ {\n            result.push(max_so_far);\n        }\n    }\n\n    result\n}\n\
    \nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823098
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut max_element = isize::min_value();\n\n    for &i in numbers.iter()\
    \ {\n        if i > max_element {\n            max_element = i;\n        }\n\n\
    \        result.push(max_element);\n    }\n\n    result\n}\n\nfn main() {\n  \
    \  let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823098
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max_values = Vec::new();\n    let mut\
    \ current_max = numbers[0];\n    max_values.push(current_max);\n\n    for number\
    \ in numbers.iter().skip(1) {\n        if *number > current_max {\n          \
    \  current_max = *number;\n        }\n        max_values.push(current_max);\n\
    \    }\n\n    max_values\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmprtajh8r8.rs:5:27

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823098
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max\
    \ = numbers[0];\n    result.push(max);\n    for i in 1..numbers.len() {\n    \
    \    max = std::cmp::max(max, numbers[i]);\n        result.push(max);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmp_tak380g.rs:5:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823097
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max\
    \ = isize::min_value();\n\n    for n in numbers {\n        max = max.max(n);\n\
    \        result.push(max);\n    }\n\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823098
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max\
    \ = numbers[0];\n    result.push(max);\n    for i in 1..numbers.len() {\n    \
    \    max = max.max(numbers[i]);\n        result.push(max);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmp4jk_gg44.rs:5:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823098
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut running_max = 0;\n    let mut result\
    \ = Vec::new();\n\n    for number in numbers {\n        running_max = std::cmp::max(running_max,\
    \ number);\n        result.push(running_max);\n    }\n\n    result\n}\n\nfn main()\
    \ {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823098
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut output = Vec::new();\n    let mut max\
    \ = numbers[0];\n    output.push(max);\n    for current in numbers.iter().skip(1)\
    \ {\n        if *current > max {\n            max = *current;\n        }\n   \
    \     output.push(max);\n    }\n    output\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpevtxlxul.rs:5:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823098
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max\
    \ = isize::min_value();\n\n    for n in numbers {\n        max = std::cmp::max(max,\
    \ n);\n        result.push(max);\n    }\n\n    result\n}\n\nfn main() {\n    let\
    \ candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823098
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    numbers\n        .into_iter()\n        .fold(vec![],\
    \ |mut acc, x| {\n            if acc.is_empty() {\n                acc.push(x);\n\
    \            } else {\n                let previous_max = acc.last().unwrap();\n\
    \                acc.push(std::cmp::max(*previous_max, x));\n            }\n \
    \           acc\n        })\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823098
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max\
    \ = numbers[0];\n    result.push(max);\n    for n in numbers.iter().skip(1) {\n\
    \        max = std::cmp::max(max, *n);\n        result.push(max);\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpmp4y467p.rs:5:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823098
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max_element = 0;\n    let mut result\
    \ = Vec::new();\n\n    for number in numbers {\n        if number > max_element\
    \ {\n            max_element = number;\n        }\n\n        result.push(max_element);\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n   \
    \ assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823098
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let numbers_len = numbers.len();\n    let mut\
    \ sequence: Vec<isize> = Vec::with_capacity(numbers_len);\n    for (index, number)\
    \ in numbers.iter().enumerate() {\n        let mut max = *number;\n        for\
    \ i in index + 1..numbers_len {\n            if max < numbers[i] {\n         \
    \       max = numbers[i];\n            }\n        }\n        sequence.push(max);\n\
    \    }\n    sequence\n}\n\nfn main() {\n    let candidate = rolling_max;\n   \
    \ assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 4, 4, 4]`,\n right: `[1, 2, 3, 4]`', /tmp/tmpcz_oo21c.rs:21:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823098
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut current_max\
    \ = isize::min_value();\n\n    for number in numbers {\n        if number > current_max\
    \ {\n            current_max = number;\n        }\n\n        result.push(current_max);\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n   \
    \ assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823098
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut current_max = numbers[0];\n    let\
    \ mut result = Vec::new();\n    result.push(current_max);\n\n    for number in\
    \ numbers.iter().skip(1) {\n        current_max = isize::max(current_max, *number);\n\
    \        result.push(current_max);\n    }\n\n    result\n}\n\nfn main() {\n  \
    \  let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpid0z4jr5.rs:4:27

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823098
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    numbers\n        .iter()\n        .scan(0,\
    \ |acc, x| {\n            *acc = std::cmp::max(*acc, *x);\n            Some(*acc)\n\
    \        })\n        .collect()\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823098
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut rolling_max = Vec::new();\n    let\
    \ mut max = std::isize::MIN;\n    for n in numbers {\n        max = std::cmp::max(max,\
    \ n);\n        rolling_max.push(max);\n    }\n    rolling_max\n}\n\nfn main()\
    \ {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823098
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut maximums = Vec::new();\n    let mut\
    \ max = numbers[0];\n    for &number in numbers.iter() {\n        max = std::cmp::max(max,\
    \ number);\n        maximums.push(max);\n    }\n    maximums\n}\n\nfn main() {\n\
    \    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpjpb6jhcn.rs:5:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823098
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut rolling_max = Vec::new();\n    let\
    \ mut current_max = std::isize::MIN;\n\n    for number in numbers {\n        if\
    \ number > current_max {\n            current_max = number;\n        }\n\n   \
    \     rolling_max.push(current_max);\n    }\n\n    rolling_max\n}\n\nfn main()\
    \ {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823098
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut rolling_max_values = Vec::new();\n\
    \    let mut current_max = std::isize::MIN;\n\n    for number in numbers {\n \
    \       if number > current_max {\n            current_max = number;\n       \
    \ }\n\n        rolling_max_values.push(current_max);\n    }\n\n    rolling_max_values\n\
    }\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823098
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    numbers\n        .iter()\n        .scan(std::isize::MIN,\
    \ |state, &item| {\n            if item > *state {\n                *state = item;\n\
    \            }\n            Some(*state)\n        })\n        .collect()\n}\n\n\
    fn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823098
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut maximum = numbers[0];\n    let mut\
    \ results = Vec::new();\n    for number in numbers {\n        if number > maximum\
    \ {\n            maximum = number;\n        }\n        results.push(maximum);\n\
    \    }\n    results\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpg73bhnl_.rs:4:23

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823098
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut current_max = 0;\n    let mut results\
    \ = Vec::new();\n\n    for number in numbers {\n        if number > current_max\
    \ {\n            current_max = number;\n        }\n\n        results.push(current_max);\n\
    \    }\n\n    results\n}\n\nfn main() {\n    let candidate = rolling_max;\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823098
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut rolling_max = Vec::new();\n    rolling_max.push(numbers[0]);\n\
    \n    for index in 1..numbers.len() {\n        rolling_max.push(std::cmp::max(rolling_max[index\
    \ - 1], numbers[index]));\n    }\n\n    rolling_max\n}\n\nfn main() {\n    let\
    \ candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmp3snwm8ry.rs:5:22

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823098
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut current_max = 0;\n    let mut result\
    \ = Vec::new();\n\n    for number in numbers {\n        if number > current_max\
    \ {\n            current_max = number;\n        }\n\n        result.push(current_max);\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n   \
    \ assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823098
- exit_code: 1
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut rolling_max = Vec::with_capacity(numbers.len());\n\
    \    let mut current_max = None;\n\n    for number in numbers {\n        current_max\
    \ = Some(current_max.map_or(number, |max| max.max(number)));\n        rolling_max.push(current_max.unwrap());\n\
    \    }\n\n    rolling_max\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n --> /tmp/tmp1yahn268.rs:8:56\n\
    \  |\n8 |         current_max = Some(current_max.map_or(number, |max| max.max(number)));\n\
    \  |                                                        ^^^ consider giving\
    \ this closure parameter a type\n  |\n  = note: type must be known at this point\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659823098
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max_seen = std::isize::MIN;\n    let\
    \ mut result = Vec::new();\n    for number in numbers {\n        max_seen = std::cmp::max(max_seen,\
    \ number);\n        result.push(max_seen);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823098
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max_elements = Vec::with_capacity(numbers.len());\n\
    \    let mut max_element = std::isize::MIN;\n\n    for number in numbers {\n \
    \       if number > max_element {\n            max_element = number;\n       \
    \ }\n\n        max_elements.push(max_element);\n    }\n\n    max_elements\n}\n\
    \nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823098
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    numbers\n        .into_iter()\n        .scan(0,\
    \ |state, x| {\n            *state = std::cmp::max(*state, x);\n            Some(*state)\n\
    \        })\n        .collect()\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823099
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max = numbers[0];\n    numbers.iter().map(|&x|\
    \ {\n        if x > max {\n            max = x;\n        }\n        max\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpd7dg1cmv.rs:4:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823099
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut largest\
    \ = 0;\n    for x in numbers {\n        largest = if x > largest { x } else {\
    \ largest };\n        result.push(largest);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823099
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max = numbers[0];\n    let mut result\
    \ = Vec::new();\n    result.push(max);\n\n    for n in numbers.iter().skip(1)\
    \ {\n        if n > &max {\n            max = *n;\n        }\n        result.push(max);\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n   \
    \ assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmp1ty54gvz.rs:4:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823099
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    if numbers.is_empty() {\n        return vec![];\n\
    \    }\n\n    let mut max: isize = numbers[0];\n    let mut result: Vec<isize>\
    \ = vec![max];\n\n    for n in numbers.iter().skip(1) {\n        if n > &max {\n\
    \            max = *n;\n        }\n        result.push(max);\n    }\n\n    result\n\
    }\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823099
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut max = numbers[0];\n    result.push(max);\n    for i in 1..numbers.len()\
    \ {\n        max = max.max(numbers[i]);\n        result.push(max);\n    }\n  \
    \  result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpe4n9x1ti.rs:5:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823099
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut rolling_max: Vec<isize> = Vec::new();\n\
    \    let mut current_max = numbers[0];\n    rolling_max.push(current_max);\n\n\
    \    for i in 1..numbers.len() {\n        if numbers[i] > current_max {\n    \
    \        current_max = numbers[i];\n        }\n        rolling_max.push(current_max);\n\
    \    }\n\n    rolling_max\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpv6smxprs.rs:5:27

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823099
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max = numbers[0];\n    let mut result\
    \ = Vec::new();\n    result.push(max);\n\n    for i in 1..numbers.len() {\n  \
    \      if numbers[i] > max {\n            max = numbers[i];\n        }\n     \
    \   result.push(max);\n    }\n\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpzbpx8t56.rs:4:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823096
- exit_code: 1
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut rolling_max = Vec::with_capacity(numbers.len());\n\
    \    let mut max_so_far = numbers[0];\n    rolling_max.push(max_so_far);\n\n \
    \   for i in 1..numbers.len() {\n        max_so_far = max(max_so_far, numbers[i]);\n\
    \        rolling_max.push(max_so_far);\n    }\n\n    rolling_max\n}\n\nfn main()\
    \ {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n --> /tmp/tmpe60wdy64.rs:9:22\n\
    \  |\n9 |         max_so_far = max(max_so_far, numbers[i]);\n  |             \
    \         ^^^ not found in this scope\n  |\nhelp: consider importing this function\n\
    \  |\n1 | use std::cmp::max;\n  |\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823098
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max = std::isize::MIN;\n    let mut\
    \ maxes = Vec::new();\n    for num in numbers {\n        max = num.max(max);\n\
    \        maxes.push(max);\n    }\n    maxes\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823099
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    if numbers.is_empty() {\n        return Vec::new();\n\
    \    }\n\n    let mut result = Vec::with_capacity(numbers.len());\n    let mut\
    \ current_max = numbers[0];\n    result.push(current_max);\n\n    for i in 1..numbers.len()\
    \ {\n        if numbers[i] > current_max {\n            current_max = numbers[i];\n\
    \        }\n        result.push(current_max);\n    }\n\n    result\n}\n\nfn main()\
    \ {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823099
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut rolling_max = Vec::new();\n    let\
    \ mut tmp_max = numbers[0];\n    rolling_max.push(tmp_max);\n\n    for i in 1..numbers.len()\
    \ {\n        tmp_max = std::cmp::max(tmp_max, numbers[i]);\n        rolling_max.push(tmp_max);\n\
    \    }\n\n    rolling_max\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmp1xut7nyt.rs:5:23

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823099
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut max = numbers[0];\n    result.push(max);\n    for i in 1..numbers.len()\
    \ {\n        if numbers[i] > max {\n            max = numbers[i];\n        }\n\
    \        result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpzgsv3zw_.rs:5:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823099
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max = numbers[0];\n    let mut result\
    \ = Vec::new();\n    result.push(max);\n\n    for index in 1..numbers.len() {\n\
    \        max = std::cmp::max(max, numbers[index]);\n        result.push(max);\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n   \
    \ assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpqafgu7km.rs:4:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823099
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max = isize::min_value();\n    let\
    \ mut result = Vec::with_capacity(numbers.len());\n\n    for i in numbers {\n\
    \        if i > max {\n            max = i;\n        }\n        result.push(max);\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n   \
    \ assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823099
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut rolling_max: Vec<isize> = Vec::new();\n\
    \    for number in numbers {\n        rolling_max.push(match rolling_max.last()\
    \ {\n            Some(max) => if *max > number { *max } else { number },\n   \
    \         None => number,\n        });\n    }\n    rolling_max\n}\n\nfn main()\
    \ {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823099
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max = numbers[0];\n    let mut result\
    \ = Vec::new();\n    result.push(max);\n\n    for number in numbers {\n      \
    \  if number > max {\n            max = number;\n        }\n        result.push(max);\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n   \
    \ assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmp138hwj0p.rs:4:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823099
- exit_code: 1
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut current_max = numbers[0];\n    result.push(current_max);\n    for\
    \ &number in numbers.iter().skip(1) {\n        current_max = max(current_max,\
    \ number);\n        result.push(current_max);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n --> /tmp/tmpr1ilw0cp.rs:8:23\n\
    \  |\n8 |         current_max = max(current_max, number);\n  |               \
    \        ^^^ not found in this scope\n  |\nhelp: consider importing this function\n\
    \  |\n1 | use std::cmp::max;\n  |\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823098
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut max = std::isize::MIN;\n    for i in 0..numbers.len() {\n       \
    \ max = if numbers[i] > max {\n            numbers[i]\n        } else {\n    \
    \        max\n        };\n        result.push(max);\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823099
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut current_max = numbers[0];\n    let\
    \ mut result = Vec::new();\n    result.push(current_max);\n\n    for &value in\
    \ numbers.iter().skip(1) {\n        current_max = std::cmp::max(current_max, value);\n\
    \        result.push(current_max);\n    }\n\n    result\n}\n\nfn main() {\n  \
    \  let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmp7t6eixqx.rs:4:27

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823099
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max = numbers[0];\n    let mut result\
    \ = Vec::new();\n    result.push(max);\n\n    for &num in numbers.iter().skip(1)\
    \ {\n        max = max.max(num);\n        result.push(max);\n    }\n\n    result\n\
    }\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpbda0ba71.rs:4:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823099
- exit_code: 1
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max = Vec::new();\n    for number in\
    \ numbers {\n        let max_so_far = max.last().unwrap_or(&isize::min_value());\n\
    \        max.push(max(number, *max_so_far));\n    }\n    max\n}\n\nfn main() {\n\
    \    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: SyntaxError
  stderr: "error[E0618]: expected function, found `Vec<isize>`\n --> /tmp/tmpc3di8_dj.rs:7:18\n\
    \  |\n4 |     let mut max = Vec::new();\n  |         ------- `max` has type `Vec<isize>`\n\
    ...\n7 |         max.push(max(number, *max_so_far));\n  |                  ^^^---------------------\n\
    \  |                  |\n  |                  call expression requires function\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0618`.\n"
  stdout: ''
  timestamp: 1659823098
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max\
    \ = -1;\n    for num in numbers {\n        if num > max {\n            max = num;\n\
    \        }\n        result.push(max);\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823099
- exit_code: 1
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    numbers\n        .iter()\n        .scan(isize::min_value(),\
    \ |state, item| {\n            *state = cmp::max(*state, *item);\n           \
    \ Some(*state)\n        })\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \ --> /tmp/tmpz9ajon_q.rs:7:22\n  |\n7 |             *state = cmp::max(*state,\
    \ *item);\n  |                      ^^^ use of undeclared crate or module `cmp`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659823099
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max = std::isize::MIN;\n    let mut\
    \ result = Vec::new();\n    for number in numbers {\n        if number > max {\n\
    \            max = number;\n        }\n        result.push(max);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823099
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut current_max = isize::min_value();\n\
    \    let mut result = Vec::new();\n\n    for number in numbers {\n        if number\
    \ > current_max {\n            current_max = number;\n        }\n\n        result.push(current_max);\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n   \
    \ assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823099
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max_elements = Vec::new();\n    let\
    \ mut max_element = numbers[0];\n    max_elements.push(max_element);\n\n    for\
    \ number in numbers.iter().skip(1) {\n        if number > &max_element {\n   \
    \         max_element = *number;\n        }\n        max_elements.push(max_element);\n\
    \    }\n\n    max_elements\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpi9adnjea.rs:5:27

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823099
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut maximums = Vec::with_capacity(numbers.len());\n\
    \    let mut max = numbers[0];\n    maximums.push(max);\n    for element in numbers.iter().skip(1)\
    \ {\n        max = max.max(*element);\n        maximums.push(max);\n    }\n  \
    \  maximums\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpvul0x6t1.rs:5:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823099
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max = 0;\n    let mut out = Vec::new();\n\
    \    for n in numbers {\n        if n > max {\n            max = n;\n        }\n\
    \        out.push(max);\n    }\n    out\n}\n\nfn main() {\n    let candidate =\
    \ rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823099
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    if numbers.is_empty() {\n        return vec![];\n\
    \    }\n\n    numbers\n        .iter()\n        .scan(numbers[0], |state, value|\
    \ {\n            *state = std::cmp::max(*state, *value);\n            Some(*state)\n\
    \        })\n        .collect()\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823099
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max = 0;\n    let mut result = Vec::with_capacity(numbers.len());\n\
    \    for n in numbers {\n        if n > max {\n            max = n;\n        }\n\
    \        result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823097
- exit_code: 1
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    for n in\
    \ numbers {\n        if result.is_empty() {\n            result.push(n);\n   \
    \     } else {\n            result.push(std::cmp::max(result.last().unwrap(),\
    \ &n));\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmptoxg0da1.rs:9:39\n  |\n9 |\
    \             result.push(std::cmp::max(result.last().unwrap(), &n));\n  |   \
    \                                    ^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `&isize`\n  |\nhelp: consider dereferencing the borrow\n  |\n9 |     \
    \        result.push(std::cmp::max(*result.last().unwrap(), &n));\n  |       \
    \                                +\n\nerror[E0308]: mismatched types\n --> /tmp/tmptoxg0da1.rs:9:63\n\
    \  |\n9 |             result.push(std::cmp::max(result.last().unwrap(), &n));\n\
    \  |                                                               ^^ expected\
    \ `isize`, found `&isize`\n  |\nhelp: consider removing the borrow\n  |\n9 - \
    \            result.push(std::cmp::max(result.last().unwrap(), &n));\n9 +    \
    \         result.push(std::cmp::max(result.last().unwrap(), n));\n  | \n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659823099
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut rolling_maxes = Vec::with_capacity(numbers.len());\n\
    \    rolling_maxes.push(numbers[0]);\n\n    for i in 1..numbers.len() {\n    \
    \    rolling_maxes.push(rolling_maxes[i - 1].max(numbers[i]));\n    }\n\n    rolling_maxes\n\
    }\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpzvh7b_o6.rs:5:24

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823099
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut results = Vec::with_capacity(numbers.len());\n\
    \    let mut max = isize::min_value();\n\n    for item in numbers {\n        max\
    \ = std::cmp::max(max, item);\n        results.push(max);\n    }\n\n    results\n\
    }\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823099
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max: isize = 0;\n    let mut result:\
    \ Vec<isize> = Vec::new();\n\n    for number in numbers {\n        if number >\
    \ max {\n            max = number;\n        }\n\n        result.push(max);\n \
    \   }\n\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823099
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    // TODO implement an actual method\n    numbers\n\
    }\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 3, 2, 1]`,\n right: `[4, 4, 4, 4]`', /tmp/tmp1fgshw64.rs:12:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823099
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut max_so_far = numbers[0];\n    result.push(max_so_far);\n    for i\
    \ in 1..numbers.len() {\n        if numbers[i] > max_so_far {\n            max_so_far\
    \ = numbers[i];\n        }\n        result.push(max_so_far);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmp17gfxabs.rs:5:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823099
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut max = std::isize::MIN;\n    for n in numbers {\n        max = n.max(max);\n\
    \        result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823099
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    numbers\n        .iter()\n        .scan(std::isize::MIN,\
    \ |max, &x| {\n            *max = std::cmp::max(*max, x);\n            Some(*max)\n\
    \        })\n        .collect()\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823099
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max = 0;\n    let mut values = Vec::new();\n\
    \    for number in numbers {\n        max = isize::max(max, number);\n       \
    \ values.push(max);\n    }\n    values\n}\n\nfn main() {\n    let candidate =\
    \ rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823099
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max\
    \ = std::isize::MIN;\n    for number in numbers {\n        max = number.max(max);\n\
    \        result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823099
- exit_code: 1
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max_seen = isize::min_value();\n  \
    \  let mut res = Vec::with_capacity(numbers.len());\n    for x in numbers {\n\
    \        max_seen = max(max_seen, x);\n        res.push(max_seen);\n    }\n  \
    \  res\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n --> /tmp/tmp19r4f_49.rs:7:20\n\
    \  |\n7 |         max_seen = max(max_seen, x);\n  |                    ^^^ not\
    \ found in this scope\n  |\nhelp: consider importing this function\n  |\n1 | use\
    \ std::cmp::max;\n  |\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823099
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    // TODO: Write your code here\n    unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp06__o1w3.rs:5:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823099
- exit_code: 1
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max_until_now = isize::min_value();\n\
    \    let mut rolling_max = Vec::with_capacity(numbers.len());\n\n    for number\
    \ in numbers {\n        max_until_now = max(max_until_now, number);\n        rolling_max.push(max_until_now);\n\
    \    }\n\n    rolling_max\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n --> /tmp/tmpimadls09.rs:8:25\n\
    \  |\n8 |         max_until_now = max(max_until_now, number);\n  |           \
    \              ^^^ not found in this scope\n  |\nhelp: consider importing this\
    \ function\n  |\n1 | use std::cmp::max;\n  |\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823099
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    if numbers.is_empty() {\n        return vec![];\n\
    \    }\n\n    numbers.iter().scan(numbers[0], |state, x| {\n        *state = (*state).max(*x);\n\
    \        Some(*state)\n    }).collect()\n}\n\nfn main() {\n    let candidate =\
    \ rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823099
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut rolling_max: Vec<isize> = Vec::new();\n\
    \    let mut max_so_far = numbers[0];\n    rolling_max.push(max_so_far);\n\n \
    \   for n in numbers.iter().skip(1) {\n        if n > &max_so_far {\n        \
    \    max_so_far = *n;\n        }\n        rolling_max.push(max_so_far);\n    }\n\
    \n    rolling_max\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmp9jz1ff8v.rs:5:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823099
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max\
    \ = std::isize::MIN;\n    for n in numbers {\n        max = std::cmp::max(max,\
    \ n);\n        result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823099
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut rolling_max: Vec<isize> = Vec::new();\n\
    \    let mut max_value = isize::min_value();\n\n    for value in numbers {\n \
    \       if value > max_value {\n            max_value = value;\n        }\n\n\
    \        rolling_max.push(max_value);\n    }\n\n    rolling_max\n}\n\nfn main()\
    \ {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823099
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut rolling_max = numbers[0];\n    result.push(rolling_max);\n    for\
    \ n in numbers[1..].iter() {\n        if *n > rolling_max {\n            rolling_max\
    \ = *n;\n        }\n        result.push(rolling_max);\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmp4s9ikljh.rs:5:27

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823099
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut ret = Vec::new();\n    let mut current_max\
    \ = *numbers.get(0).unwrap();\n    for &n in numbers.iter() {\n        if n >\
    \ current_max {\n            current_max = n;\n        }\n        ret.push(current_max);\n\
    \    }\n    ret\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmpjlt2eqkq.rs:5:43

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823099
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut ret = Vec::new();\n    let mut max_el\
    \ = numbers[0];\n    ret.push(max_el);\n    for i in 1..numbers.len() {\n    \
    \    if numbers[i] > max_el {\n            max_el = numbers[i];\n        }\n \
    \       ret.push(max_el);\n    }\n    ret\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmphj9js82k.rs:5:22

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823099
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max_vec = Vec::new();\n    let mut\
    \ current_max = isize::min_value();\n\n    for number in numbers {\n        if\
    \ number > current_max {\n            current_max = number;\n        }\n\n   \
    \     max_vec.push(current_max);\n    }\n\n    max_vec\n}\n\nfn main() {\n   \
    \ let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823099
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max\
    \ = std::isize::MIN;\n    for n in numbers {\n        if n > max {\n         \
    \   max = n;\n        }\n        result.push(max);\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823099
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max_values = Vec::new();\n    let mut\
    \ current_max = None;\n\n    for number in numbers {\n        current_max = match\
    \ current_max {\n            None => Some(number),\n            Some(current_max)\
    \ => Some(current_max.max(number)),\n        };\n\n        max_values.push(current_max.unwrap());\n\
    \    }\n\n    max_values\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823099
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max\
    \ = isize::min_value();\n\n    for n in numbers {\n        max = if n > max {\
    \ n } else { max };\n        result.push(max);\n    }\n\n    result\n}\n\nfn main()\
    \ {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823099
- exit_code: 1
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut current_max\
    \ = 0;\n    for num in numbers {\n        current_max = cmp::max(current_max,\
    \ num);\n        result.push(current_max);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \ --> /tmp/tmpb8a3jcbo.rs:7:23\n  |\n7 |         current_max = cmp::max(current_max,\
    \ num);\n  |                       ^^^ use of undeclared crate or module `cmp`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659823099
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    if numbers.is_empty() {\n        return vec![];\n\
    \    }\n\n    let mut max_numbers = Vec::with_capacity(numbers.len());\n    let\
    \ mut current_max = numbers[0];\n    max_numbers.push(current_max);\n\n    for\
    \ number in numbers.iter().skip(1) {\n        if number > &current_max {\n   \
    \         current_max = *number;\n        }\n        max_numbers.push(current_max);\n\
    \    }\n\n    max_numbers\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823099
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let n = numbers.len();\n    let mut result\
    \ = Vec::with_capacity(n);\n    let mut max = numbers[0];\n    result.push(max);\n\
    \    for i in 1..n {\n        max = if numbers[i] > max {\n            numbers[i]\n\
    \        } else {\n            max\n        };\n        result.push(max);\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpetz_7d3q.rs:6:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823100
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut out = Vec::new();\n    let mut max\
    \ = std::isize::MIN;\n    for n in numbers {\n        max = std::cmp::max(max,\
    \ n);\n        out.push(max);\n    }\n    out\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823100
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    numbers\n        .into_iter()\n        .scan(0,\
    \ |state, next| {\n            if next > *state {\n                *state = next;\n\
    \            }\n            Some(*state)\n        })\n        .collect()\n}\n\n\
    fn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823100
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max = std::isize::MIN;\n    let mut\
    \ max_sequence = Vec::new();\n    for number in numbers {\n        max = number.max(max);\n\
    \        max_sequence.push(max);\n    }\n    max_sequence\n}\n\nfn main() {\n\
    \    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823100
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max = Vec::new();\n    max.push(numbers[0]);\n\
    \    for i in 1..numbers.len() {\n        let m = max[i - 1];\n        max.push(if\
    \ numbers[i] > m { numbers[i] } else { m });\n    }\n    max\n}\n\nfn main() {\n\
    \    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmp1d3tg1fc.rs:5:14

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823100
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max = std::isize::MIN;\n    let mut\
    \ rolling_max = Vec::with_capacity(numbers.len());\n    for number in numbers\
    \ {\n        if number > max {\n            max = number;\n        }\n       \
    \ rolling_max.push(max);\n    }\n    rolling_max\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823100
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut rmax: Vec<isize> = Vec::new();\n  \
    \  let mut local_max = isize::min_value();\n    for n in numbers {\n        local_max\
    \ = local_max.max(n);\n        rmax.push(local_max);\n    }\n    rmax\n}\n\nfn\
    \ main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823100
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\nfn rolling_max(numbers:\
    \ Vec<isize>) -> Vec<isize> {\n    let mut max_value = isize::min_value();\n \
    \   let mut result = Vec::new();\n\n    for n in numbers {\n        max_value\
    \ = std::cmp::max(max_value, n);\n        result.push(max_value);\n    }\n\n \
    \   result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823100
