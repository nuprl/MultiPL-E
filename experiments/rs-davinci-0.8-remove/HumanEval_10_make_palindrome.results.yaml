language: rs
name: HumanEval_10_make_palindrome
results:
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    if string.is_empty() {\n        return string;\n  \
    \  }\n\n    let mut prefix_length = 0;\n    let len = string.len();\n    while\
    \ prefix_length < len {\n        if is_palindrome(&string[prefix_length..]) {\n\
    \            break;\n        }\n        prefix_length += 1;\n    }\n\n    let\
    \ mut result = string;\n    for i in 0..prefix_length {\n        result.push(string.chars().nth(prefix_length\
    \ - i - 1).unwrap());\n    }\n\n    result\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmptzxeg7o2.rs:13:12\n   |\n13 |         if is_palindrome(&string[prefix_length..])\
    \ {\n   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string;\n    let reversed = string.clone();\n\
    \    string.push('#');\n    string.push_str(&reversed);\n    let z_array = calculate_z_array(&string);\n\
    \    let last_element = z_array.len() - 1;\n    let longest_suffix_length = string.len()\
    \ - z_array[last_element];\n    let prefix = &string[0..longest_suffix_length];\n\
    \    let prefix_reversed = prefix.chars().rev().collect::<String>();\n    prefix_reversed\
    \ + &string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `calculate_z_array` in this scope\n\
    \  --> /tmp/tmpfvyflet4.rs:10:19\n   |\n10 |     let z_array = calculate_z_array(&string);\n\
    \   |                   ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let len = string.len();\n    let mut reverse = string.chars().rev().collect::<String>();\n\
    \    let longest_palindrome = find_longest_palindrome(string);\n    let len_palindrome\
    \ = longest_palindrome.len();\n    if len_palindrome == len {\n        // the\
    \ string is already a palindrome\n        return string;\n    }\n    // build\
    \ a palindrome from the string,\n    // that has the longest palindrome suffix\
    \ and palindrome prefix\n    // reverse - string_prefix - string\n    reverse.drain(..len\
    \ - len_palindrome);\n    reverse.push_str(&string);\n    reverse\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_longest_palindrome` in this scope\n\
    \ --> /tmp/tmpi24_4y2a.rs:8:30\n  |\n8 |     let longest_palindrome = find_longest_palindrome(string);\n\
    \  |                              ^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed = string.clone();\n    reversed.reverse();\n\
    \    let max_suffix_len = max_palindrome_suffix(&string, &reversed);\n    let\
    \ prefix = &string[..string.len() - max_suffix_len];\n    let reversed_prefix\
    \ = prefix.chars().rev().collect::<String>();\n    format!(\"{}{}{}\", reversed_prefix,\
    \ &string, &string[..string.len() - max_suffix_len])\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max_palindrome_suffix` in this scope\n\
    \ --> /tmp/tmpcaekc3po.rs:8:26\n  |\n8 |     let max_suffix_len = max_palindrome_suffix(&string,\
    \ &reversed);\n  |                          ^^^^^^^^^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0599]: no method named `reverse` found for struct `String`\
    \ in the current scope\n --> /tmp/tmpcaekc3po.rs:7:14\n  |\n7 |     reversed.reverse();\n\
    \  |              ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reserve`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0425, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 101
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let str = &string;\n    let len = str.len();\n    let\
    \ half = len / 2;\n    for x in (1..half + 1).rev() {\n        let prefix = &str[..x];\n\
    \        let suffix = &str[len - x..];\n        if prefix == suffix {\n      \
    \      let reverse = suffix.chars().rev().collect::<String>();\n            return\
    \ format!(\"{}{}\", reverse, string);\n        }\n    }\n    format!(\"{}{}\"\
    , str.chars().rev().collect::<String>(), string)\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xx\"`,\n right: `\"x\"`', /tmp/tmprcartsqm.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string;\n    let prefix = find_palindrome_prefix(&string);\n\
    \    let prefix_rev = string[..prefix].chars().rev().collect::<String>();\n  \
    \  string.push_str(&prefix_rev);\n    string\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_palindrome_prefix` in this scope\n\
    \ --> /tmp/tmpnq33nm9a.rs:7:18\n  |\n7 |     let prefix = find_palindrome_prefix(&string);\n\
    \  |                  ^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    match string.len() {\n        0 => string,\n      \
    \  1 => format!(\"{}{}\", string, string),\n        _ => {\n            let index\
    \ = longest_palindrome_substring_index(&string);\n            format!(\"{}{}{}\"\
    , string, &string[0..index].chars().rev().collect::<String>(), string)\n     \
    \   }\n    }\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `longest_palindrome_substring_index`\
    \ in this scope\n  --> /tmp/tmp07qwo_5y.rs:10:25\n   |\n10 |             let index\
    \ = longest_palindrome_substring_index(&string);\n   |                       \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let string = string.as_bytes();\n    let (palindrome_suffix,\
    \ prefix_start) = find_palindrome_suffix(string);\n    let mut palindrome = String::from_utf8(palindrome_suffix.into_iter().rev().cloned().collect()).unwrap();\n\
    \    let prefix = &string[..prefix_start];\n    palindrome.push_str(prefix);\n\
    \    return palindrome;\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_palindrome_suffix` in this scope\n\
    \ --> /tmp/tmp4a3a_4re.rs:7:45\n  |\n7 |     let (palindrome_suffix, prefix_start)\
    \ = find_palindrome_suffix(string);\n  |                                     \
    \        ^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4a3a_4re.rs:10:25\n   |\n10 |     palindrome.push_str(prefix);\n\
    \   |                         ^^^^^^ expected `str`, found slice `[u8]`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&[u8]`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 101
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut s = string.clone();\n    let n = s.len();\n\
    \    let mut prefix_suffix = vec![0; n];\n    let mut i = 1;\n    let mut j =\
    \ 0;\n    while i < n {\n        if s.chars().nth(i).unwrap() == s.chars().nth(j).unwrap()\
    \ {\n            j += 1;\n            prefix_suffix[i] = j;\n            i +=\
    \ 1;\n        } else {\n            if j != 0 {\n                j = prefix_suffix[j\
    \ - 1];\n            } else {\n                prefix_suffix[i] = 0;\n       \
    \         i += 1;\n            }\n        }\n    }\n    let j = prefix_suffix[n\
    \ - 1];\n    let prefix = &s[0..(n - j)];\n    s.push_str(prefix.chars().rev().collect::<String>().as_str());\n\
    \    s\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpzjw3edhg.rs:25:27

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821506
- exit_code: 101
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string;\n    let mut n = string.len();\n\
    \    let mut reversed = string.chars().rev().collect::<String>();\n    let end\
    \ = string.len();\n    string.push('#');\n    string.push_str(&reversed);\n  \
    \  let mut p = vec![0; string.len()];\n    let mut c = 0;\n    let mut r = 0;\n\
    \    for i in 1..string.len() {\n        let mut i_mirror = 2 * c - i;\n     \
    \   p[i] = if r > i {\n            let min = r - i;\n            if p[i_mirror]\
    \ < min {\n                p[i_mirror]\n            } else {\n               \
    \ min\n            }\n        } else {\n            0\n        };\n        while\
    \ string.chars().nth(i + 1 + p[i]) == string.chars().nth(i - 1 - p[i]) {\n   \
    \         p[i] += 1;\n        }\n        if i + p[i] > r {\n            c = i;\n\
    \            r = i + p[i];\n        }\n    }\n    let mut max_len = 0;\n    let\
    \ mut center_index = 0;\n    for i in 1..p.len() {\n        if i - p[i] == 0 {\n\
    \            if p[i] > max_len {\n                max_len = p[i];\n          \
    \      center_index = i;\n            }\n        }\n    }\n    let mut palindrome\
    \ = String::new();\n    for i in 0..(end - max_len) {\n        palindrome.push(string.chars().nth(center_index\
    \ - 1 - max_len + i).unwrap());\n    }\n    palindrome.push_str(&reversed);\n\
    \    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp1pklwij2.rs:16:28

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut s = string.clone();\n    let mut rev_s = s.clone();\n\
    \    rev_s.reverse();\n    s.push_str(&rev_s);\n    let end = kmp_pattern_match(&s).pop().unwrap();\n\
    \    let prefix = string.chars().take(string.len() - end).collect::<String>();\n\
    \    prefix.reverse() + &string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `kmp_pattern_match` in this scope\n\
    \  --> /tmp/tmp_ub7ra4s.rs:10:15\n   |\n10 |     let end = kmp_pattern_match(&s).pop().unwrap();\n\
    \   |               ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]:\
    \ no method named `reverse` found for struct `String` in the current scope\n -->\
    \ /tmp/tmp_ub7ra4s.rs:8:11\n  |\n8 |     rev_s.reverse();\n  |           ^^^^^^^\
    \ help: there is an associated function with a similar name: `reserve`\n\nerror[E0599]:\
    \ no method named `reverse` found for struct `String` in the current scope\n \
    \ --> /tmp/tmp_ub7ra4s.rs:12:12\n   |\n12 |     prefix.reverse() + &string\n \
    \  |            ^^^^^^^ help: there is an associated function with a similar name:\
    \ `reserve`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0425, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let idx = find_longest_palindrome_postfix_idx(&string);\n\
    \    let tail = &string[idx..];\n    let prefix = tail.chars().rev().collect::<String>();\n\
    \    prefix + &string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_longest_palindrome_postfix_idx`\
    \ in this scope\n --> /tmp/tmp1q00q8ei.rs:6:15\n  |\n6 |     let idx = find_longest_palindrome_postfix_idx(&string);\n\
    \  |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let string_reverse = reverse_string(string.clone());\n\
    \    let mut suffix = \"\".to_string();\n    let mut prefix = \"\".to_string();\n\
    \    let (mut chars, mut chars_reverse) = (string.chars(), string_reverse.chars());\n\
    \    while let (Some(c), Some(c_r)) = (chars.next(), chars_reverse.next()) {\n\
    \        if c == c_r {\n            suffix.push(c);\n        } else {\n      \
    \      prefix.push(c);\n        }\n    }\n    format!(\"{}{}{}\", reverse_string(prefix),\
    \ suffix, prefix)\n}\n\nfn main() {\n    let candidate = make_palindrome;\n  \
    \  assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `reverse_string` in this scope\n -->\
    \ /tmp/tmpdtqfbulg.rs:6:26\n  |\n6 |     let string_reverse = reverse_string(string.clone());\n\
    \  |                          ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `reverse_string` in this scope\n  --> /tmp/tmpdtqfbulg.rs:17:23\n\
    \   |\n17 |     format!(\"{}{}{}\", reverse_string(prefix), suffix, prefix)\n\
    \   |                       ^^^^^^^^^^^^^^ help: a local variable with a similar\
    \ name exists: `string_reverse`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    // Find the longest palindromic suffix in the string.\n\
    \    let suffix = match LongestPalindromicSubstring::new().find(&string) {\n \
    \       Some(s) => s,\n        None => return string,\n    };\n\n    // We need\
    \ to append the reverse of the part of string before this suffix to make the string\
    \ a\n    // palindrome.\n    let prefix = &string[..string.len() - suffix.len()];\n\
    \    let reverse_prefix = prefix.chars().rev().collect::<String>();\n    format!(\"\
    {}{}{}\", string, reverse_prefix, suffix)\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `LongestPalindromicSubstring`\n\
    \ --> /tmp/tmpggz88dmr.rs:7:24\n  |\n7 |     let suffix = match LongestPalindromicSubstring::new().find(&string)\
    \ {\n  |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^ use of undeclared\
    \ type `LongestPalindromicSubstring`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut s = string.clone();\n    s.push('$');\n   \
    \ let reverse_string = string.chars().rev().collect::<String>();\n    s.push_str(&reverse_string);\n\
    \    find_longest_prefix_suffix(s)\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_longest_prefix_suffix` in this\
    \ scope\n  --> /tmp/tmp648vu7nt.rs:10:5\n   |\n10 |     find_longest_prefix_suffix(s)\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let s = string.as_bytes();\n    let mut l = vec![0;\
    \ s.len()];\n    let mut r = vec![0; s.len()];\n    // strings are encoded as\
    \ bytes\n    let max_len = s.len();\n    for i in 0..max_len {\n        let mut\
    \ j = 1;\n        // determine the length of the longest palindromic substring\
    \ that starts at position i\n        while j <= i && i + j < max_len && s[i -\
    \ j] == s[i + j] {\n            j += 1;\n        }\n        l[i] = j;\n    }\n\
    \    for i in 0..max_len {\n        let mut j = 0;\n        // determine the length\
    \ of the longest palindromic substring that starts at position i+1\n        while\
    \ j <= i && i + j + 1 < max_len && s[i - j] == s[i + j + 1] {\n            j +=\
    \ 1;\n        }\n        r[i] = j;\n    }\n    // print results\n    let mut best_length\
    \ = 0;\n    let mut best_i = 0;\n    for i in 0..max_len {\n        if l[i] >\
    \ best_length {\n            best_length = l[i];\n            best_i = i;\n  \
    \      }\n        if r[i] > best_length {\n            best_length = r[i];\n \
    \           best_i = i;\n        }\n    }\n    let mut start = best_i - best_length\
    \ + 1;\n    let mut reversed = vec![0; start];\n    for i in 0..start {\n    \
    \    reversed[i] = s[start - i - 1];\n    }\n    for i in 0..reversed.len() {\n\
    \        s.push(reversed[i]);\n    }\n    String::from_utf8(s.to_vec()).unwrap()\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `push` found for reference `&[u8]` in the\
    \ current scope\n  --> /tmp/tmpmmvpn5me.rs:46:11\n   |\n46 |         s.push(reversed[i]);\n\
    \   |           ^^^^ method not found in `&[u8]`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let prefix = rev_string(&string);\n    let string =\
    \ prefix + &string;\n    let mut z = z_function(&string);\n    let mut longest_palindrome\
    \ = 0;\n    for i in (0..z.len()).rev() {\n        if z[i] == i {\n          \
    \  longest_palindrome = i;\n            break;\n        }\n    }\n    let suffix\
    \ = string[longest_palindrome..].to_string();\n    let prefix = rev_string(&suffix);\n\
    \    string + &prefix\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `rev_string` in this scope\n --> /tmp/tmp_eph8vbx.rs:6:18\n\
    \  |\n6 |     let prefix = rev_string(&string);\n  |                  ^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `z_function` in\
    \ this scope\n --> /tmp/tmp_eph8vbx.rs:8:17\n  |\n8 |     let mut z = z_function(&string);\n\
    \  |                 ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `rev_string` in this scope\n  --> /tmp/tmp_eph8vbx.rs:17:18\n\
    \   |\n17 |     let prefix = rev_string(&suffix);\n   |                  ^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut s = string.clone();\n    let i = s.len() -\
    \ get_longest_palindrome_end(&s).unwrap();\n    let prefix = s.split_off(i);\n\
    \    s.push_str(&prefix.chars().rev().collect::<String>());\n    s\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_longest_palindrome_end` in this\
    \ scope\n --> /tmp/tmp2096ds4i.rs:7:23\n  |\n7 |     let i = s.len() - get_longest_palindrome_end(&s).unwrap();\n\
    \  |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut builder = String::new();\n    let reversed\
    \ = string.chars().rev().collect::<String>();\n    let mut palindrome_suffix =\
    \ reversed.split_off(string.len() - common_prefix_postfix_length(&string, &reversed));\n\
    \    builder.push_str(&palindrome_suffix);\n    builder.push_str(&string);\n \
    \   builder\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `common_prefix_postfix_length` in this\
    \ scope\n --> /tmp/tmp8yt1p9q9.rs:8:67\n  |\n8 |     let mut palindrome_suffix\
    \ = reversed.split_off(string.len() - common_prefix_postfix_length(&string, &reversed));\n\
    \  |                                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let prefix = &string[..string.len() - find_longest_suffix_palindrome(&string)];\n\
    \    let prefix_rev = prefix.chars().rev().collect::<String>();\n    format!(\"\
    {}{}{}\", prefix_rev, string, prefix_rev)\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_longest_suffix_palindrome` in\
    \ this scope\n --> /tmp/tmp4d_zfgli.rs:6:43\n  |\n6 |     let prefix = &string[..string.len()\
    \ - find_longest_suffix_palindrome(&string)];\n  |                           \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let string = string.into_bytes();\n    let mut suffix\
    \ = suffix_palindrome(&string);\n    let prefix = &string[..string.len() - suffix.len()];\n\
    \    let prefix_rev = prefix.iter().rev().cloned();\n    let mut palindrome =\
    \ String::from_utf8(suffix.clone()).unwrap();\n    palindrome.extend(prefix_rev);\n\
    \    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `suffix_palindrome` in this scope\n\
    \ --> /tmp/tmph_7q43u3.rs:7:22\n  |\n7 |     let mut suffix = suffix_palindrome(&string);\n\
    \  |                      ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0277]:\
    \ the trait bound `String: Extend<u8>` is not satisfied\n  --> /tmp/tmph_7q43u3.rs:11:16\n\
    \   |\n11 |     palindrome.extend(prefix_rev);\n   |                ^^^^^^ the\
    \ trait `Extend<u8>` is not implemented for `String`\n   |\n   = help: the following\
    \ implementations were found:\n             <String as Extend<&'a char>>\n   \
    \          <String as Extend<&'a str>>\n             <String as Extend<Box<str>>>\n\
    \             <String as Extend<Cow<'a, str>>>\n           and 2 others\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let length = string.len();\n    let mut suffix = Vec::with_capacity(length);\n\
    \    for i in 0..length {\n        suffix.push(string.as_bytes()[length - i -\
    \ 1]);\n    }\n    let longest_palindrome = kmp::search(&string, &suffix).unwrap().1;\n\
    \    let mut out = string;\n    for i in 0..length - longest_palindrome {\n  \
    \      out.push(string.as_bytes()[i] as char);\n    }\n    out\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `kmp`\n\
    \  --> /tmp/tmpxx8q4owb.rs:11:30\n   |\n11 |     let longest_palindrome = kmp::search(&string,\
    \ &suffix).unwrap().1;\n   |                              ^^^ use of undeclared\
    \ crate or module `kmp`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 101
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let string_as_bytes = string.as_bytes();\n    let string_len\
    \ = string_as_bytes.len();\n    let mut start = 0;\n    let mut end = string_len\
    \ - 1;\n    let mut found_palindrome = false;\n    while start < end {\n     \
    \   if string_as_bytes[start] == string_as_bytes[end] {\n            start +=\
    \ 1;\n            end -= 1;\n        } else {\n            found_palindrome =\
    \ false;\n            break;\n        }\n    }\n    if !found_palindrome {\n \
    \       let reversed_prefix = string.as_bytes()[..start].iter().rev();\n     \
    \   let mut string_copy = string.clone();\n        for byte in reversed_prefix\
    \ {\n            string_copy.push(*byte as char);\n        }\n        return string_copy;\n\
    \    }\n    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n \
    \   assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpii2gn804.rs:9:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut suffix = String::new();\n    let mut prefix\
    \ = String::new();\n    for i in (0..string.len()).rev() {\n        if is_palindrome(&string[i..])\
    \ {\n            suffix = string[i..].to_string();\n            prefix = string[..i].to_string();\n\
    \            break;\n        }\n    }\n    format!(\"{}{}{}\", prefix, reverse(&suffix),\
    \ suffix)\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n -->\
    \ /tmp/tmpi4d5punr.rs:9:12\n  |\n9 |         if is_palindrome(&string[i..]) {\n\
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `reverse` in this scope\n  --> /tmp/tmpi4d5punr.rs:15:31\n   |\n\
    15 |     format!(\"{}{}{}\", prefix, reverse(&suffix), suffix)\n   |         \
    \                      ^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let reversed = string.chars().rev().collect::<String>();\n\
    \    let mut concatenated = string.clone() + &reversed;\n    let mut indexes =\
    \ Manacher::new(&concatenated);\n    let longest_match = indexes.iter().max().unwrap();\n\
    \    let (start, end) = indexes.get_bounds(longest_match);\n    if start == 1\
    \ {\n        concatenated\n    } else {\n        let prefix = string.chars().take(string.len()\
    \ - (end - start)).collect::<String>();\n        prefix + &string\n    }\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Manacher`\n -->\
    \ /tmp/tmp7uszky62.rs:8:23\n  |\n8 |     let mut indexes = Manacher::new(&concatenated);\n\
    \  |                       ^^^^^^^^ use of undeclared type `Manacher`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let bytes = string.as_bytes();\n    let mut suffix_length\
    \ = bytes.len();\n    for i in (0..bytes.len()).rev() {\n        if is_palindrome(&bytes[i..suffix_length])\
    \ {\n            suffix_length = i;\n        }\n    }\n    let prefix_end = bytes.len()\
    \ - suffix_length;\n    let mut palindrome = string.clone();\n    palindrome.push_str(&string[..prefix_end].iter().rev().collect::<String>());\n\
    \    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n -->\
    \ /tmp/tmp8375nxtb.rs:9:12\n  |\n9 |         if is_palindrome(&bytes[i..suffix_length])\
    \ {\n  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no\
    \ method named `iter` found for type `str` in the current scope\n  --> /tmp/tmp8375nxtb.rs:15:47\n\
    \   |\n15 |     palindrome.push_str(&string[..prefix_end].iter().rev().collect::<String>());\n\
    \   |                                               ^^^^ method not found in `str`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut str_rev = string.clone();\n    str_rev.chars().rev().collect::<String>();\n\
    \    let lps = longest_palindromic_suffix(&string);\n    let prefix = &string[0..(string.len()\
    \ - lps)];\n    return prefix.chars().rev().collect::<String>() + &string;\n}\n\
    \nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `longest_palindromic_suffix` in this\
    \ scope\n --> /tmp/tmp_enykxmy.rs:8:15\n  |\n8 |     let lps = longest_palindromic_suffix(&string);\n\
    \  |               ^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut palindrome = String::new();\n    let mut prefix\
    \ = String::new();\n    let string_length = string.len();\n    let mut first_half_position\
    \ = string_length / 2;\n    let mut last_half_position = first_half_position;\n\
    \    let second_half_position = string_length - 1;\n    let is_even = string_length\
    \ % 2 == 0;\n\n    // Consider all substrings that have odd or even length.\n\
    \    while first_half_position >= 0 {\n        // Check if there is a palindrome\
    \ with an odd length.\n        if is_palindrome(&string, first_half_position,\
    \ last_half_position) {\n            prefix = String::from(&string[0..first_half_position]);\n\
    \            palindrome = String::from(&string[0..last_half_position]);\n    \
    \        palindrome.push_str(&prefix.chars().rev().collect::<String>());\n   \
    \         break;\n        }\n        first_half_position -= 1;\n        // Do\
    \ not check for a palindrome with an even length if the string is even.\n    \
    \    if is_even {\n            continue;\n        }\n        // Check if there\
    \ is a palindrome with an even length.\n        if is_palindrome(&string, first_half_position,\
    \ last_half_position) {\n            prefix = String::from(&string[0..first_half_position]);\n\
    \            palindrome = String::from(&string[0..last_half_position]);\n    \
    \        palindrome.push_str(&prefix.chars().rev().collect::<String>());\n   \
    \         break;\n        }\n        last_half_position += 1;\n    }\n\n    palindrome\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp2qu2kvf9.rs:17:12\n   |\n17 |         if is_palindrome(&string, first_half_position,\
    \ last_half_position) {\n   |            ^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `palindrome`\n\nerror[E0425]: cannot find function\
    \ `is_palindrome` in this scope\n  --> /tmp/tmp2qu2kvf9.rs:29:12\n   |\n29 | \
    \        if is_palindrome(&string, first_half_position, last_half_position) {\n\
    \   |            ^^^^^^^^^^^^^ help: a local variable with a similar name exists:\
    \ `palindrome`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    if string.is_empty() {\n        return string;\n  \
    \  }\n\n    let string = string.as_bytes();\n    let mut new_string = Vec::with_capacity(string.len()\
    \ * 2);\n    new_string.extend_from_slice(string);\n    new_string.extend_from_slice(string.iter().rev());\n\
    \n    let new_string = String::from_utf8(new_string).unwrap();\n    let result\
    \ = kmp_matching(&new_string, string.len());\n    let result = result.iter().filter(|x|\
    \ *x == &string.len()).nth(0).unwrap();\n    let result = &new_string[result..];\n\
    \    result.to_string()\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `kmp_matching` in this scope\n  -->\
    \ /tmp/tmpceeek6fu.rs:16:18\n   |\n16 |     let result = kmp_matching(&new_string,\
    \ string.len());\n   |                  ^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpceeek6fu.rs:13:34\n   |\n13 |\
    \     new_string.extend_from_slice(string.iter().rev());\n   |               \
    \                   ^^^^^^^^^^^^^^^^^^^ expected `&[u8]`, found struct `Rev`\n\
    \   |\n   = note: expected reference `&[u8]`\n                 found struct `Rev<std::slice::Iter<'_,\
    \ u8>>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let prefix_ptr = find_longest_palindrome_suffix(&string);\n\
    \    let prefix = &string[..prefix_ptr];\n    return format!(\"{}{}{}\", prefix,\
    \ string, prefix.chars().rev().collect::<String>());\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_longest_palindrome_suffix` in\
    \ this scope\n --> /tmp/tmphkx_b7ll.rs:6:22\n  |\n6 |     let prefix_ptr = find_longest_palindrome_suffix(&string);\n\
    \  |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    // Find the longest postfix that is a palindrome.\n\
    \    let postfix = find_longest_palindrome_postfix(&string);\n    let postfix_size\
    \ = postfix.len();\n    // Reverse a part of the string that comes before the\
    \ palindromic suffix.\n    let reversed_prefix = string.chars().take(string.len()\
    \ - postfix_size).rev().collect::<String>();\n    // Append reverse of prefix\
    \ to the end of the string.\n    format!(\"{}{}\", string, reversed_prefix)\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_longest_palindrome_postfix` in\
    \ this scope\n --> /tmp/tmpf9h21op2.rs:7:19\n  |\n7 |     let postfix = find_longest_palindrome_postfix(&string);\n\
    \  |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \  --> /tmp/tmpf9h21op2.rs:10:76\n   |\n10 |     let reversed_prefix = string.chars().take(string.len()\
    \ - postfix_size).rev().collect::<String>();\n   |                           \
    \                                                 ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n   |\n   = note: required because of the\
    \ requirements on the impl of `DoubleEndedIterator` for `std::iter::Take<Chars<'_>>`\n\
    \nerror[E0599]: the method `collect` exists for struct `Rev<std::iter::Take<Chars<'_>>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmpf9h21op2.rs:10:82\n \
    \  |\n10 |        let reversed_prefix = string.chars().take(string.len() - postfix_size).rev().collect::<String>();\n\
    \   |                                                                        \
    \             ^^^^^^^ method cannot be called on `Rev<std::iter::Take<Chars<'_>>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `std::iter::Take<Chars<'_>>: DoubleEndedIterator`\n\
    \           which is required by `Rev<std::iter::Take<Chars<'_>>>: Iterator`\n\
    \           `Rev<std::iter::Take<Chars<'_>>>: Iterator`\n           which is required\
    \ by `&mut Rev<std::iter::Take<Chars<'_>>>: Iterator`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut new_string = string.clone();\n    let substring_end\
    \ = longest_palindrome_index(string.clone());\n    for i in 0..(new_string.len()\
    \ - substring_end) {\n        new_string.push(new_string.chars().nth(i).unwrap());\n\
    \    }\n    new_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `longest_palindrome_index` in this scope\n\
    \ --> /tmp/tmp5wx09p3u.rs:7:25\n  |\n7 |     let substring_end = longest_palindrome_index(string.clone());\n\
    \  |                         ^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 101
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut palindrome = String::new();\n    let mut prefix\
    \ = String::new();\n    let suffix = String::new();\n\n    for c in string.chars().rev()\
    \ {\n        prefix.push(c);\n        palindrome.push(c);\n        if prefix ==\
    \ suffix {\n            return palindrome;\n        }\n    }\n\n    palindrome\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"zyx\"`,\n right: `\"xyzyx\"`', /tmp/tmptr7sddmc.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut s = string.clone();\n    let mut reversed =\
    \ string.chars().rev().collect::<String>();\n    s.push_str(&reversed);\n    let\
    \ mut suffix_tree = SuffixTree::new(&s);\n    suffix_tree.build();\n    let longest_suffix\
    \ = suffix_tree.longest_palindromic_suffix();\n    reversed.truncate(string.len()\
    \ - longest_suffix.len());\n    let mut result = string.clone();\n    result.push_str(&reversed);\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `SuffixTree`\n\
    \ --> /tmp/tmp24ubjae8.rs:9:27\n  |\n9 |     let mut suffix_tree = SuffixTree::new(&s);\n\
    \  |                           ^^^^^^^^^^ use of undeclared type `SuffixTree`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut palindrome = string.clone();\n    let reverse_prefix\
    \ = palindrome.clone().chars().rev().collect::<String>();\n    let mut prefix_idx\
    \ = string.len();\n    while !check_palindrome(&palindrome) {\n        prefix_idx\
    \ -= 1;\n        palindrome = format!(\"{}{}\", palindrome, &reverse_prefix[prefix_idx..]);\n\
    \    }\n    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `check_palindrome` in this scope\n -->\
    \ /tmp/tmpe7ezb60k.rs:9:12\n  |\n9 |     while !check_palindrome(&palindrome)\
    \ {\n  |            ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 101
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let length = string.len();\n    let mut prefix = vec![0;\
    \ length];\n    let mut last_prefix_len = 0;\n    let mut idx = 1;\n    while\
    \ idx < length {\n        if string.chars().nth(idx).unwrap() == string.chars().nth(last_prefix_len).unwrap()\
    \ {\n            last_prefix_len += 1;\n            prefix[idx] = last_prefix_len;\n\
    \            idx += 1;\n        } else {\n            if last_prefix_len == 0\
    \ {\n                prefix[idx] = 0;\n                idx += 1;\n           \
    \ } else {\n                last_prefix_len = prefix[last_prefix_len - 1];\n \
    \           }\n        }\n    }\n    let mut prefix_len = length - last_prefix_len;\n\
    \    let mut palindrome_suffix = if prefix_len == 0 {\n        String::new()\n\
    \    } else {\n        string.chars().skip(prefix_len).collect()\n    };\n   \
    \ let mut palindrome_prefix = palindrome_suffix.chars().rev().collect::<String>();\n\
    \    palindrome_prefix.push_str(&string);\n    palindrome_prefix.push_str(&palindrome_suffix);\n\
    \    palindrome_prefix\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xyz\"`,\n right: `\"xyzyx\"`', /tmp/tmpnyieyknr.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut postfix = String::new();\n    let mut iter\
    \ = string.chars().rev();\n    let mut suffix_len = 0;\n    while let Some(next)\
    \ = iter.next() {\n        postfix.push(next);\n        if is_palindrome(&postfix)\
    \ {\n            suffix_len = postfix.len();\n            break;\n        }\n\
    \    }\n    postfix.clear();\n    let mut iter = string.chars();\n    while let\
    \ Some(next) = iter.nth(suffix_len) {\n        postfix.push(next);\n    }\n  \
    \  let mut string = string;\n    string.push_str(&postfix);\n    string\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpeel4og_p.rs:11:12\n   |\n11 |         if is_palindrome(&postfix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 101
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let len = string.len();\n    // Find the longest postfix\
    \ that is a palindrome.\n    let rev_string = string.chars().rev().collect::<String>();\n\
    \    let longest_palindrome_suffix = string.find(&rev_string).unwrap_or(0);\n\
    \    // Add to the end of a string reverse of string prefix (befor the found palindrome).\n\
    \    format!(\"{}{}\", string, rev_string[..len - longest_palindrome_suffix].chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xx\"`,\n right: `\"x\"`', /tmp/tmp6kxnpayq.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 101
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    // find postfix that is a palindrome\n    let mut postfix\
    \ = String::new();\n    for c in string.chars().rev() {\n        let mut tmp =\
    \ String::new();\n        tmp.push(c);\n        tmp.push_str(&postfix);\n    \
    \    if tmp == postfix {\n            postfix = tmp;\n            break;\n   \
    \     }\n        postfix = tmp;\n    }\n\n    // append reversed prefix to the\
    \ end of the string\n    let mut prefix = String::new();\n    for c in string.chars()\
    \ {\n        let mut tmp = String::new();\n        tmp.push(c);\n        tmp.push_str(&prefix);\n\
    \        if tmp == prefix {\n            prefix = tmp;\n            break;\n \
    \       }\n        prefix = tmp;\n    }\n    let mut reversed_prefix = String::new();\n\
    \    for c in prefix.chars().rev() {\n        reversed_prefix.push(c);\n    }\n\
    \    string + &reversed_prefix\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xx\"`,\n right: `\"x\"`', /tmp/tmpx7l8iue0.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    if string.is_empty() {\n        return String::new();\n\
    \    }\n\n    let mut front_str = String::new();\n    let mut rev_str = string.chars().rev().collect::<String>();\n\
    \n    while !is_palindrome(&(string.clone() + &front_str)) {\n        front_str.push(rev_str.pop().unwrap());\n\
    \    }\n\n    return string + &front_str;\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpcx0_bd9h.rs:13:12\n   |\n13 |     while !is_palindrome(&(string.clone()\
    \ + &front_str)) {\n   |            ^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 101
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let len = string.len();\n    let reverse = string.chars().rev().collect::<String>();\n\
    \    let mut prefix = \"\".to_string();\n    let mut suffix = \"\".to_string();\n\
    \    for i in 0..len {\n        let (p, s) = string.split_at(i);\n        if p.eq_ignore_ascii_case(&reverse[len\
    \ - i..]) {\n            prefix = p.to_string();\n            suffix = s.to_string();\n\
    \            break;\n        }\n    }\n    suffix + &prefix.chars().rev().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xyz\"`,\n right: `\"xyzyx\"`', /tmp/tmpzglv7ojd.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut rev_string = string.clone();\n    rev_string.reverse();\n\
    \    let mut postfix = longest_postfix_palindrome(&string);\n    let prefix =\
    \ &string[..string.len() - postfix.len()];\n    let mut rev_prefix = prefix.to_string();\n\
    \    rev_prefix.reverse();\n    postfix.push_str(&rev_prefix);\n    postfix\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `longest_postfix_palindrome` in this\
    \ scope\n --> /tmp/tmpx0ssdx_u.rs:8:23\n  |\n8 |     let mut postfix = longest_postfix_palindrome(&string);\n\
    \  |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0599]: no method named `reverse` found for struct `String` in the current\
    \ scope\n --> /tmp/tmpx0ssdx_u.rs:7:16\n  |\n7 |     rev_string.reverse();\n \
    \ |                ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reserve`\n\nerror[E0599]: no method named `reverse` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpx0ssdx_u.rs:11:16\n   |\n11 | \
    \    rev_prefix.reverse();\n   |                ^^^^^^^ help: there is an associated\
    \ function with a similar name: `reserve`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let (mut rev_prefix, suffix) = find_longest_palindrome_postfix(string.clone());\n\
    \    let rev_prefix = rev_prefix.chars().rev().collect::<String>();\n    format!(\"\
    {}{}{}\", rev_prefix, suffix, rev_prefix)\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_longest_palindrome_postfix` in\
    \ this scope\n --> /tmp/tmp_6fqi38l.rs:6:36\n  |\n6 |     let (mut rev_prefix,\
    \ suffix) = find_longest_palindrome_postfix(string.clone());\n  |            \
    \                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string;\n    let mut s = string.clone();\n\
    \    let (x, y) = KMP::process(&mut s);\n    let reverse = string.chars().rev().collect::<String>();\n\
    \    let mut suffix = string.chars().skip(string.len() - x[string.len()]).collect::<String>();\n\
    \    let prefix = reverse.chars().take(string.len() - y[string.len()]).collect::<String>();\n\
    \    suffix.push_str(&prefix);\n    suffix\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `KMP`\n --> /tmp/tmp0cbfnhyt.rs:8:18\n\
    \  |\n8 |     let (x, y) = KMP::process(&mut s);\n  |                  ^^^ use\
    \ of undeclared type `KMP`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    // What is the longest palindromic suffix of a string?\n\
    \    let long_suffix = longest_palindromic_suffix(&string);\n    // Take the remaining\
    \ part of the string, reverse it and append to the end of string.\n    format!(\"\
    {}{}\", &string, &string[..string.len() - long_suffix].chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `longest_palindromic_suffix` in this\
    \ scope\n --> /tmp/tmp7em09uec.rs:7:23\n  |\n7 |     let long_suffix = longest_palindromic_suffix(&string);\n\
    \  |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 101
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let reverse = string.chars().rev().collect::<String>();\n\
    \    let mut longest_postfix = string.chars().take(string.len()).collect::<String>();\n\
    \    let mut prefix = String::new();\n    for _ in 0..string.len() {\n       \
    \ if longest_postfix == reverse {\n            break;\n        }\n        longest_postfix.remove(0);\n\
    \        prefix.push(string.chars().nth(string.len() - 1 - prefix.len()).unwrap());\n\
    \    }\n    format!(\"{}{}{}\", string, prefix, longest_postfix)\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xx\"`,\n right: `\"x\"`', /tmp/tmp7jiy2wpp.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string;\n    let suffix = longest_palindromic_suffix(&string);\n\
    \    string.push_str(&reverse_string(&string[..string.len() - suffix.len()]));\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `longest_palindromic_suffix` in this\
    \ scope\n --> /tmp/tmp71ag0h63.rs:7:18\n  |\n7 |     let suffix = longest_palindromic_suffix(&string);\n\
    \  |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `reverse_string` in this scope\n --> /tmp/tmp71ag0h63.rs:8:22\n\
    \  |\n8 |     string.push_str(&reverse_string(&string[..string.len() - suffix.len()]));\n\
    \  |                      ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    if string.is_empty() {\n        return string;\n  \
    \  }\n\n    let mut palindrome_postfix = string.clone();\n    let mut suffix_len\
    \ = 1;\n    let mut palindrome_suffix = String::new();\n\n    while suffix_len\
    \ < palindrome_postfix.len() {\n        if palindrome_postfix.is_palindrome()\
    \ {\n            break;\n        }\n\n        palindrome_postfix.pop();\n    \
    \    suffix_len += 1;\n    }\n\n    let string_prefix = string.chars().take(string.len()\
    \ - suffix_len).collect::<String>();\n    palindrome_suffix.push_str(&string_prefix.chars().rev().collect::<String>());\n\
    \    palindrome_suffix.push_str(&string);\n\n    palindrome_suffix\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_palindrome` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpzmf23mkr.rs:15:31\n   |\n15 |         if\
    \ palindrome_postfix.is_palindrome() {\n   |                               ^^^^^^^^^^^^^\
    \ method not found in `String`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 0
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    if string.is_empty() {\n        return string;\n  \
    \  }\n\n    let len = string.len();\n    let chars: Vec<char> = string.chars().collect();\n\
    \    let mut i = len;\n    while i > 0 {\n        let mut is_palindrome = true;\n\
    \        let first = len - i;\n        let last = len - 1;\n        for j in 0..i\
    \ / 2 {\n            if chars[first + j] != chars[last - j] {\n              \
    \  is_palindrome = false;\n                break;\n            }\n        }\n\
    \        if is_palindrome {\n            break;\n        }\n        i -= 1;\n\
    \    }\n\n    let first = len - i;\n    let rev_prefix: String = chars[..first].iter().rev().collect();\n\
    \    format!(\"{}{}\", string, rev_prefix)\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let reverse = string.clone().chars().rev().collect::<String>();\n\
    \    let mut palindrome = string.clone();\n    for i in 0..string.len() {\n  \
    \      let reversed_prefix = reverse.chars().skip(i).collect::<String>();\n  \
    \      let string_prefix = string.chars().take(string.len() - i).collect::<String>();\n\
    \        if reversed_prefix == string_prefix {\n            return palindrome\
    \ + reversed_prefix.chars().skip(1).collect::<String>();\n        }\n    }\n \
    \   return palindrome;\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk8ihixea.rs:12:33\n   |\n\
    12 |             return palindrome + reversed_prefix.chars().skip(1).collect::<String>();\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                                 |\n   |                                \
    \ expected `&str`, found struct `String`\n   |                               \
    \  help: consider borrowing here: `&reversed_prefix.chars().skip(1).collect::<String>()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string.clone();\n    reversed_string.reverse();\n\
    \    let mut string = string.into_bytes();\n    let mut reversed_string = reversed_string.into_bytes();\n\
    \    let palindrome_suffix = longest_palindrome_suffix(&string);\n    let reversed_palindrome_prefix\
    \ = &reversed_string[..string.len() - palindrome_suffix.len()];\n    let mut result\
    \ = string;\n    result.extend_from_slice(reversed_palindrome_prefix);\n    String::from_utf8(result).unwrap()\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `longest_palindrome_suffix` in this\
    \ scope\n  --> /tmp/tmpiyvympbf.rs:10:29\n   |\n10 |     let palindrome_suffix\
    \ = longest_palindrome_suffix(&string);\n   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0599]: no method named `reverse` found for\
    \ struct `String` in the current scope\n --> /tmp/tmpiyvympbf.rs:7:21\n  |\n7\
    \ |     reversed_string.reverse();\n  |                     ^^^^^^^ help: there\
    \ is an associated function with a similar name: `reserve`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 101
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let length = string.len();\n    let mut suffix_start\
    \ = length;\n    for i in (0..length).rev() {\n        if &string[i..] == &string[i..suffix_start].chars().rev().collect::<String>()\
    \ {\n            suffix_start = i;\n        }\n    }\n    let prefix = string[..suffix_start].chars().rev().collect::<String>();\n\
    \    let mut suffix = string[suffix_start..].to_string();\n    suffix.push_str(&prefix);\n\
    \    suffix\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"zyx\"`,\n right: `\"xyzyx\"`', /tmp/tmpap7oopzc.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut suffix = string.clone();\n    suffix.reverse();\n\
    \    let (mut string, mut prefix) = string.split_at(string.len() / 2);\n    let\
    \ mut palindrome_found = false;\n    let mut last_prefix_len = string.len();\n\
    \    while !palindrome_found {\n        if string.ends_with(prefix) {\n      \
    \      palindrome_found = true;\n        } else {\n            last_prefix_len\
    \ -= 1;\n            string = &string[..last_prefix_len];\n            prefix\
    \ = &string[..last_prefix_len];\n        }\n    }\n    let mut result = string.to_string();\n\
    \    result.push_str(&suffix[..last_prefix_len]);\n    result.push_str(string);\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpmz7urebe.rs:7:12\n  |\n7 |     suffix.reverse();\n\
    \  |            ^^^^^^^ help: there is an associated function with a similar name:\
    \ `reserve`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    if is_palindrome(&string) {\n        return string;\n\
    \    }\n\n    let longest_palindrome_suffix = longest_palindrome_suffix(&string);\n\
    \    let prefix = &string[0..string.len() - longest_palindrome_suffix.len()];\n\
    \    let mut result = prefix.chars().rev().collect::<String>();\n    result.push_str(&string);\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n -->\
    \ /tmp/tmp7z1s1gi_.rs:6:8\n  |\n6 |     if is_palindrome(&string) {\n  |     \
    \   ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `longest_palindrome_suffix` in this scope\n  --> /tmp/tmp7z1s1gi_.rs:10:37\n\
    \   |\n10 |     let longest_palindrome_suffix = longest_palindrome_suffix(&string);\n\
    \   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string;\n    let length = string.len();\n\
    \    let mut reverse_position = 0;\n    let mut prefix_position = 0;\n    let\
    \ mut prefix_length = 0;\n    let mut max_palindrome_length = 0;\n    let mut\
    \ current_palindrome_length = 0;\n    let mut i = 0;\n    while i < length {\n\
    \        let c = string.chars().nth(i).unwrap();\n        if is_palindrome(&string,\
    \ i, i) {\n            current_palindrome_length = 1;\n            while i + current_palindrome_length\
    \ < length && i - current_palindrome_length >= 0 {\n                if string.chars().nth(i\
    \ + current_palindrome_length).unwrap() ==\n                   string.chars().nth(i\
    \ - current_palindrome_length).unwrap() {\n                    current_palindrome_length\
    \ += 1;\n                } else {\n                    break;\n              \
    \  }\n            }\n            if current_palindrome_length > max_palindrome_length\
    \ {\n                max_palindrome_length = current_palindrome_length;\n    \
    \            reverse_position = i + 1;\n                prefix_position = i -\
    \ current_palindrome_length + 1;\n                prefix_length = current_palindrome_length\
    \ - 1;\n            }\n        }\n        if i < length - 1 && string.chars().nth(i\
    \ + 1).unwrap() == c {\n            current_palindrome_length = 1;\n         \
    \   while i + current_palindrome_length + 1 < length && i - current_palindrome_length\
    \ >= 0 {\n                if string.chars().nth(i + current_palindrome_length\
    \ + 1).unwrap() ==\n                   string.chars().nth(i - current_palindrome_length).unwrap()\
    \ {\n                    current_palindrome_length += 1;\n                } else\
    \ {\n                    break;\n                }\n            }\n          \
    \  if current_palindrome_length > max_palindrome_length {\n                max_palindrome_length\
    \ = current_palindrome_length;\n                reverse\n}\n\nfn main() {\n  \
    \  let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpxmtqbt58.rs:55:3\n\
    \   |\n5  | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n14 |     while i\
    \ < length {\n   |                      - unclosed delimiter\n...\n20 |      \
    \              string.chars().nth(i - current_palindrome_length).unwrap() {\n\
    \   |                                                                        \
    \       - this delimiter might not be properly closed...\n21 |               \
    \      current_palindrome_length += 1;\n22 |                 } else {\n   |  \
    \               - ...as it matches this but it has different indentation\n...\n\
    33 |         if i < length - 1 && string.chars().nth(i + 1).unwrap() == c {\n\
    \   |                                                                      - unclosed\
    \ delimiter\n...\n55 | }\n   |   ^\n\nerror[E0425]: cannot find function `is_palindrome`\
    \ in this scope\n  --> /tmp/tmpxmtqbt58.rs:16:12\n   |\n16 |         if is_palindrome(&string,\
    \ i, i) {\n   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `reverse` in this scope\n  --> /tmp/tmpxmtqbt58.rs:45:17\n\
    \   |\n45 |                 reverse\n   |                 ^^^^^^^ not found in\
    \ this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxmtqbt58.rs:14:5\n\
    \   |\n5  |   fn make_palindrome(string: String) -> String {\n   |           \
    \                              ------ expected `String` because of return type\n\
    ...\n14 | /     while i < length {\n15 | |         let c = string.chars().nth(i).unwrap();\n\
    16 | |         if is_palindrome(&string, i, i) {\n17 | |             current_palindrome_length\
    \ = 1;\n...  |\n54 | |     assert_eq!(candidate(String::from(\"jerry\")), String::from(\"\
    jerryrrej\"));\n55 | | }\n   | |__^ expected struct `String`, found `()`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let bytes = string.into_bytes();\n    let len = bytes.len();\n\
    \    let mut result = Vec::with_capacity(len * 2);\n    result.extend_from_slice(&bytes);\n\
    \    let mut offset = 0;\n    while offset < len {\n        if is_palindrome_at(&bytes,\
    \ offset) {\n            break;\n        }\n        offset += 1;\n    }\n    if\
    \ offset == len {\n        offset -= 1;\n    }\n    for i in 0..offset {\n   \
    \     result.push(bytes[offset - i - 1]);\n    }\n    let result_str = String::from_utf8(result).unwrap();\n\
    \    println!(\"{}\", result_str);\n    result_str\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome_at` in this scope\n \
    \ --> /tmp/tmparusaxbt.rs:12:12\n   |\n12 |         if is_palindrome_at(&bytes,\
    \ offset) {\n   |            ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 101
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut chars = string.chars().collect::<Vec<char>>();\n\
    \    let mut reverse_chars = chars.clone();\n    reverse_chars.reverse();\n  \
    \  for i in 0..chars.len() {\n        let suffix = &chars[i..];\n        let prefix\
    \ = &reverse_chars[..chars.len() - i];\n        if suffix == prefix {\n      \
    \      let mut result = string.clone();\n            result.push_str(&prefix.iter().rev().collect::<String>());\n\
    \            return result;\n        }\n    }\n    // Suffix == prefix\n    let\
    \ mut result = string.clone();\n    result.push_str(&string.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xx\"`,\n right: `\"x\"`', /tmp/tmp_7lsvowi.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut s = string.clone();\n    s.push('#');\n   \
    \ s.push_str(&string.chars().rev().collect::<String>());\n    let mut z = vec![0;\
    \ s.len()];\n    z[0] = s.len();\n    let mut l = 0;\n    let mut r = 0;\n   \
    \ for i in 1..s.len() {\n        if i > r {\n            l = r = i;\n        \
    \    while r < s.len() && s[r - l] == s[r] {\n                r += 1;\n      \
    \      }\n            z[i] = r - l;\n            r -= 1;\n        } else {\n \
    \           let k = i - l;\n            if z[k] < r - i + 1 {\n              \
    \  z[i] = z[k];\n            } else {\n                l = i;\n              \
    \  while r < s.len() && s[r - l] == s[r] {\n                    r += 1;\n    \
    \            }\n                z[i] = r - l;\n                r -= 1;\n     \
    \       }\n        }\n    }\n    let mut prefix = string[..z[s.len() - 1]].to_string();\n\
    \    prefix.push_str(&string);\n    prefix\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqv197l5d.rs:15:17\n   |\n\
    15 |             l = r = i;\n   |                 ^^^^^ expected integer, found\
    \ `()`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  -->\
    \ /tmp/tmpqv197l5d.rs:16:34\n   |\n16 |             while r < s.len() && s[r -\
    \ l] == s[r] {\n   |                                  ^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpqv197l5d.rs:16:46\n   |\n16 |             while r < s.len() &&\
    \ s[r - l] == s[r] {\n   |                                              ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpqv197l5d.rs:27:38\n   |\n27 |                 while\
    \ r < s.len() && s[r - l] == s[r] {\n   |                                    \
    \  ^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpqv197l5d.rs:27:50\n   |\n27 |  \
    \               while r < s.len() && s[r - l] == s[r] {\n   |                \
    \                                  ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 101
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut postfix = String::new();\n    let mut prefix\
    \ = String::new();\n    let mut longest_palindrome = String::new();\n    for idx\
    \ in 0..string.len() {\n        let (s1, s2) = string.split_at(idx);\n       \
    \ if s1 == s2.chars().rev().collect::<String>() {\n            if s1.len() > longest_palindrome.len()\
    \ {\n                longest_palindrome = s1.to_string();\n                postfix\
    \ = s2.to_string();\n                prefix = s1.to_string();\n            }\n\
    \        }\n    }\n    let mut res = string;\n    res.push_str(&postfix.chars().rev().collect::<String>());\n\
    \    res\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xyz\"`,\n right: `\"xyzyx\"`', /tmp/tmpd02lhrqx.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut result = string.clone();\n    let mut rev =\
    \ string.chars().rev().collect::<String>();\n    result.push_str(&rev);\n    let\
    \ suffix = longest_palindrome_suffix(&result);\n    if suffix != string {\n  \
    \      result.push_str(&rev[..string.len() - suffix.len()]);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `longest_palindrome_suffix` in this\
    \ scope\n --> /tmp/tmpeoywryvu.rs:9:18\n  |\n9 |     let suffix = longest_palindrome_suffix(&result);\n\
    \  |                  ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    if is_palindrome(&string) {\n        return string;\n\
    \    }\n\n    let mut longest_suffix = 0;\n    for i in 0..string.len() {\n  \
    \      let j = string.len() - i - 1;\n        if string.chars().nth(i) == string.chars().nth(j)\
    \ {\n            longest_suffix = i + 1;\n        }\n    }\n\n    let mut prefix\
    \ = string.chars().take(string.len() - longest_suffix).collect::<String>();\n\
    \    prefix.push_str(&string);\n    prefix.push_str(&reverse(&string).chars().take(string.len()\
    \ - longest_suffix).collect::<String>());\n    prefix\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n -->\
    \ /tmp/tmpmr4ldttg.rs:6:8\n  |\n6 |     if is_palindrome(&string) {\n  |     \
    \   ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `reverse` in this scope\n  --> /tmp/tmpmr4ldttg.rs:20:22\n   |\n20 |     prefix.push_str(&reverse(&string).chars().take(string.len()\
    \ - longest_suffix).collect::<String>());\n   |                      ^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let string_as_bytes = string.as_bytes();\n    let mut\
    \ result = Vec::new();\n    let mut palindrome_suffix = find_palindrome_suffix(string_as_bytes);\n\
    \    let mut index = palindrome_suffix.len();\n    let mut loop_count = palindrome_suffix.len();\n\
    \    while loop_count > 0 {\n        result.push(string_as_bytes[index]);\n  \
    \      loop_count -= 1;\n        index += 1;\n    }\n    result.reverse();\n \
    \   result.extend(string_as_bytes);\n    String::from_utf8(result).unwrap()\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_palindrome_suffix` in this scope\n\
    \ --> /tmp/tmptg52jc8j.rs:8:33\n  |\n8 |     let mut palindrome_suffix = find_palindrome_suffix(string_as_bytes);\n\
    \  |                                 ^^^^^^^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let len = string.len();\n    if len == 0 {\n      \
    \  return string;\n    }\n    let mut prefix = string.clone();\n    let mut suffix\
    \ = String::new();\n    // This loop will append to the suffix reverse of the\
    \ first\n    // characters of prefix. The last element of suffix will be the\n\
    \    // first letter of prefix.\n    for _ in 0..len {\n        suffix.push(prefix.remove(0));\n\
    \    }\n    if is_palindrome(&prefix) {\n        prefix.push_str(&suffix);\n \
    \       return prefix;\n    }\n    // Remove the last letter of suffix, because\
    \ this letter is\n    // equal to the first letter of prefix.\n    suffix.pop();\n\
    \    // This loop will append to suffix reverse of the first\n    // characters\
    \ of prefix. The last element of suffix will be the\n    // second letter of prefix.\n\
    \    for _ in 0..len - 1 {\n        suffix.push(prefix.remove(0));\n    }\n  \
    \  prefix.push_str(&suffix);\n    if is_palindrome(&prefix) {\n        return\
    \ prefix;\n    }\n    // Remove the last letter of suffix, because this letter\
    \ is\n    // equal to the second letter of prefix.\n    suffix.pop();\n    //\
    \ This loop will append to suffix reverse of the first\n    // characters of prefix.\
    \ The last element of suffix will be the\n    // third letter of prefix.\n   \
    \ for _ in 0..len - 2 {\n        suffix.push(prefix.remove(0));\n    }\n    prefix.push_str(&suffix);\n\
    \    if is_palindrome(&prefix) {\n        return prefix;\n    }\n    // Remove\
    \ the last letter of suffix, because this letter is\n    // equal to the third\
    \ letter of prefix.\n    suffix.pop();\n    // This loop will append to suffix\
    \ reverse of the first\n    // characters of prefix. The last element of suffix\
    \ will be the\n    // fourth letter of prefix.\n    for _ in 0..len - 3 {\n  \
    \      suffix.push(prefix.remove(0));\n    }\n    prefix.push_str(&suffix);\n\
    \    if is_palindrome(&prefix) {\n        return prefix;\n    }\n    // Remove\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmptam39tx_.rs:18:8\n   |\n18 |     if is_palindrome(&prefix) {\n   | \
    \       ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `is_palindrome` in this scope\n  --> /tmp/tmptam39tx_.rs:32:8\n   |\n32 |  \
    \   if is_palindrome(&prefix) {\n   |        ^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `is_palindrome` in this scope\n  --> /tmp/tmptam39tx_.rs:45:8\n\
    \   |\n45 |     if is_palindrome(&prefix) {\n   |        ^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `is_palindrome` in this\
    \ scope\n  --> /tmp/tmptam39tx_.rs:58:8\n   |\n58 |     if is_palindrome(&prefix)\
    \ {\n   |        ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0317]: `if` may\
    \ be missing an `else` clause\n  --> /tmp/tmptam39tx_.rs:58:5\n   |\n5  |   fn\
    \ make_palindrome(string: String) -> String {\n   |                          \
    \               ------ expected `String` because of this return type\n...\n58\
    \ | /     if is_palindrome(&prefix) {\n59 | |         return prefix;\n60 | | \
    \    }\n   | |_____^ expected struct `String`, found `()`\n   |\n   = note: `if`\
    \ expressions without `else` evaluate to `()`\n   = help: consider adding an `else`\
    \ block that evaluates to the expected type\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0317, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0317`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 101
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut chars = string.chars().collect::<Vec<char>>();\n\
    \    let mut chars_rev = chars.clone();\n    chars_rev.reverse();\n    let mut\
    \ len = 0;\n    while chars.len() - len - 1 >= 0 && chars[chars.len() - len -\
    \ 1] == chars_rev[len] {\n        len += 1;\n    }\n    chars.append(&mut chars_rev[len..].iter().cloned().collect::<Vec<char>>());\n\
    \    chars.iter().cloned().collect::<String>()\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpaj48eivd.rs:10:11

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821507
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.len();\n    let mut prefix_length\
    \ = string_length;\n    let mut suffix_length = string_length;\n    while suffix_length\
    \ > 0 {\n        let suffix = &string[string_length - suffix_length..];\n    \
    \    let prefix = &string[..prefix_length];\n        if is_palindrome(suffix)\
    \ {\n            return prefix.chars().rev().collect::<String>() + suffix;\n \
    \       } else {\n            prefix_length -= 1;\n            suffix_length -=\
    \ 1;\n        }\n    }\n    unreachable!()\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpmocd8yl_.rs:12:12\n   |\n12 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let string_reverse = string.chars().rev().collect::<String>();\n\
    \    let mut z = z_array(string.clone() + \"#\" + &string_reverse);\n    let mut\
    \ result = String::from(\"\");\n    let mut prev_char = \"\";\n    let mut count\
    \ = 0;\n    for (i, char) in string.chars().enumerate() {\n        if i > 0 &&\
    \ char == *prev_char {\n            count += 1;\n        } else {\n          \
    \  count = 0;\n        }\n        if z[string.len() + i + 1] == (string.len()\
    \ - i - count) as usize {\n            result.push(char);\n        }\n       \
    \ prev_char = &char.to_string();\n    }\n    result.chars().rev().collect::<String>()\
    \ + &string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `z_array` in this scope\n --> /tmp/tmptvxpge4x.rs:7:17\n\
    \  |\n7 |     let mut z = z_array(string.clone() + \"#\" + &string_reverse);\n\
    \  |                 ^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmptvxpge4x.rs:12:29\n   |\n12 |         if i > 0 && char\
    \ == *prev_char {\n   |                             ^^^^^^^^^^ expected `char`,\
    \ found `str`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0425.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut prefix_end = 1;\n    let chars = string.chars().collect::<Vec<_>>();\n\
    \    let mut suffix_end = chars.len();\n    let mut prefix = Vec::new();\n   \
    \ let mut chars = chars;\n    // Find the longest postfix of string that is a\
    \ palindrome\n    while suffix_end > prefix_end {\n        if is_palindrome(&chars[prefix_end..suffix_end])\
    \ {\n            prefix_end = suffix_end;\n        }\n        suffix_end -= 1;\n\
    \    }\n    // Reverse and append a string prefix that comes before the palindromic\
    \ suffix.\n    chars.reverse();\n    prefix.extend_from_slice(&chars[0..chars.len()\
    \ - prefix_end]);\n    let mut string = String::new();\n    string.extend(chars);\n\
    \    string.extend(prefix);\n    string\n}\n\nfn main() {\n    let candidate =\
    \ make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpb2oaxvd4.rs:13:12\n   |\n13 |         if is_palindrome(&chars[prefix_end..suffix_end])\
    \ {\n   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    if string.is_empty() {\n        return string;\n  \
    \  }\n\n    let string_len = string.len();\n    let string_chars: Vec<char> =\
    \ string.chars().collect();\n\n    let mut prefix_size = string_len - 1;\n   \
    \ while prefix_size > 0 {\n        if is_palindrome(&string_chars[0..prefix_size])\
    \ {\n            let mut result = string;\n            for i in (0..prefix_size).rev()\
    \ {\n                result.push(string_chars[i]);\n            }\n          \
    \  return result;\n        }\n        prefix_size -= 1;\n    }\n\n    // When\
    \ we got here, it means that the supplied string is a palindrome.\n    // In this\
    \ case, we just return the string itself.\n    string\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp8y44d_a5.rs:15:12\n   |\n15 |         if is_palindrome(&string_chars[0..prefix_size])\
    \ {\n   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    if string.is_empty() {\n        return string;\n  \
    \  }\n\n    let reversed_string = reverse_string(string.clone());\n    let suffix\
    \ = find_largest_common_suffix(string.clone(), reversed_string);\n    let prefix\
    \ = string.replace(&suffix, \"\");\n    let reversed_prefix = reverse_string(prefix);\n\
    \    let palindrome = format!(\"{}{}{}\", prefix, suffix, reversed_prefix);\n\
    \    return palindrome;\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `reverse_string` in this scope\n  -->\
    \ /tmp/tmpigpemjbu.rs:10:27\n   |\n10 |     let reversed_string = reverse_string(string.clone());\n\
    \   |                           ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `find_largest_common_suffix` in this scope\n  --> /tmp/tmpigpemjbu.rs:11:18\n\
    \   |\n11 |     let suffix = find_largest_common_suffix(string.clone(), reversed_string);\n\
    \   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find function `reverse_string` in this scope\n  --> /tmp/tmpigpemjbu.rs:13:27\n\
    \   |\n13 |     let reversed_prefix = reverse_string(prefix);\n   |          \
    \                 ^^^^^^^^^^^^^^ help: a local variable with a similar name exists:\
    \ `reversed_string`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut longest_palindrome_index = longest_palindrome_suffix(&string);\n\
    \    let reversed_prefix = string.get(0..longest_palindrome_index).unwrap().chars().rev().collect::<String>();\n\
    \    let palindrome = format!(\"{}{}{}\", string, reversed_prefix, string);\n\
    \    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `longest_palindrome_suffix` in this\
    \ scope\n --> /tmp/tmpi_de5qyi.rs:6:40\n  |\n6 |     let mut longest_palindrome_index\
    \ = longest_palindrome_suffix(&string);\n  |                                 \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let chars: Vec<char> = string.chars().collect();\n\
    \    let chars_len = chars.len();\n    let mut reversed_prefix: Vec<char> = Vec::new();\n\
    \    let mut max_prefix_len = 0;\n    for i in 0..chars_len {\n        if is_palindrome(&chars[i..chars_len])\
    \ {\n            max_prefix_len = i;\n            break;\n        }\n        reversed_prefix.push(chars[i]);\n\
    \    }\n    reversed_prefix.reverse();\n    let mut result: String = String::new();\n\
    \    result.push_str(&string);\n    for char in reversed_prefix {\n        result.push(char);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n \
    \   assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpdmua1tzy.rs:11:12\n   |\n11 |         if is_palindrome(&chars[i..chars_len])\
    \ {\n   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let reverse = string.chars().rev().collect::<String>();\n\
    \    let mut palindrome = string.clone();\n    let mut prefix = string.chars().take(string.len()\
    \ - palindrome.len()).collect::<String>();\n    let reverse_prefix = prefix.chars().rev().collect::<String>();\n\
    \    while !is_palindrome(&palindrome) {\n        palindrome.push_str(&reverse_prefix);\n\
    \        prefix = string.chars().take(string.len() - palindrome.len()).collect::<String>();\n\
    \        reverse_prefix.chars().rev().collect::<String>();\n    }\n    palindrome\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpbhk8cq7j.rs:10:12\n   |\n10 |     while !is_palindrome(&palindrome)\
    \ {\n   |            ^^^^^^^^^^^^^ help: a local variable with a similar name\
    \ exists: `palindrome`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 101
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let n = string.len();\n    let string_bytes = string.as_bytes();\n\
    \    let mut palindrome_len = 0;\n    for i in 0..n {\n        let prefix_len\
    \ = n - i;\n        let mut palindrome_len_inc = 0;\n        while string_bytes[i\
    \ + palindrome_len_inc] == string_bytes[i + palindrome_len_inc - prefix_len] {\n\
    \            palindrome_len_inc += 1;\n        }\n        if i + palindrome_len_inc\
    \ == n {\n            palindrome_len = prefix_len;\n            break;\n     \
    \   }\n    }\n    let mut result = string.clone();\n    let mut i = 0;\n    let\
    \ mut j = n - palindrome_len - 1;\n    while i < j {\n        result.push(result.chars().nth(j).unwrap());\n\
    \        i += 1;\n        j -= 1;\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpwnlbv7v9.rs:22:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821507
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut suffix = String::new();\n    let mut suffix_ptr\
    \ = string.len();\n    let mut prefix = String::new();\n    let mut prefix_ptr\
    \ = 0;\n\n    // Find the longest palindromic suffix of the string.\n    while\
    \ suffix_ptr > 0 {\n        if is_palindrome(&string[0..suffix_ptr]) {\n     \
    \       suffix.push_str(&string[suffix_ptr..]);\n            prefix_ptr = suffix_ptr;\n\
    \            break;\n        }\n        suffix_ptr -= 1;\n    }\n\n    // Reverse\
    \ a string prefix that comes before the palindromic suffix.\n    while prefix_ptr\
    \ > 0 {\n        prefix.push(string.chars().nth(prefix_ptr - 1).unwrap());\n \
    \       prefix_ptr -= 1;\n    }\n\n    // Return a new string that is a concatenation\
    \ of the reversed prefix and suffix.\n    prefix + &string\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpzawzil3_.rs:13:12\n   |\n13 |         if is_palindrome(&string[0..suffix_ptr])\
    \ {\n   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let reverse_string = reverse_string(string.clone());\n\
    \    let mut palindrome = string.clone();\n    if reverse_string == string {\n\
    \        // No need to do anything for palindromes.\n        return palindrome;\n\
    \    }\n    let substring = longest_substring(&string, &reverse_string);\n   \
    \ let mut prefix = string.clone();\n    prefix.truncate(prefix.len() - substring.len());\n\
    \    prefix = reverse_string(prefix);\n    palindrome.push_str(&prefix);\n   \
    \ palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `reverse_string` in this scope\n -->\
    \ /tmp/tmpye1nwk8k.rs:6:26\n  |\n6 |     let reverse_string = reverse_string(string.clone());\n\
    \  |                          ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `longest_substring` in this scope\n  --> /tmp/tmpye1nwk8k.rs:12:21\n\
    \   |\n12 |     let substring = longest_substring(&string, &reverse_string);\n\
    \   |                     ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let lcp = longest_common_postfix(string.clone());\n\
    \    let mut prefix = String::from(&string[0..string.len() - lcp.len()]);\n  \
    \  prefix.reverse();\n    let mut result = string;\n    result.push_str(&prefix);\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `longest_common_postfix` in this scope\n\
    \ --> /tmp/tmp6rmjodhm.rs:6:15\n  |\n6 |     let lcp = longest_common_postfix(string.clone());\n\
    \  |               ^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]:\
    \ no method named `reverse` found for struct `String` in the current scope\n -->\
    \ /tmp/tmp6rmjodhm.rs:8:12\n  |\n8 |     prefix.reverse();\n  |            ^^^^^^^\
    \ help: there is an associated function with a similar name: `reserve`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let string = string.as_bytes();\n    let mut pattern\
    \ = String::new();\n    let mut longest_palindrome_len = 0;\n    for i in 0..string.len()\
    \ {\n        pattern.push(string[i] as char);\n        if check_palindrome(&pattern)\
    \ {\n            longest_palindrome_len = i + 1;\n        }\n    }\n    let mut\
    \ new_string = String::from_utf8(string.to_vec()).unwrap();\n    new_string.push_str(&String::from_utf8(string[0..string.len()\
    \ - longest_palindrome_len].to_vec()).unwrap().chars().rev().collect::<String>());\n\
    \    new_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `check_palindrome` in this scope\n \
    \ --> /tmp/tmpoboo89m0.rs:11:12\n   |\n11 |         if check_palindrome(&pattern)\
    \ {\n   |            ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659821506
- exit_code: 101
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    if string.is_empty() {\n        return String::new();\n\
    \    }\n\n    let mut suffix = String::new();\n    let mut index = 0;\n    let\
    \ length = string.len();\n    let bytes = string.as_bytes();\n\n    while index\
    \ < length {\n        let mut is_palindrome = true;\n        for i in 0..=index\
    \ {\n            if bytes[i] != bytes[length - index + i - 1] {\n            \
    \    is_palindrome = false;\n                break;\n            }\n        }\n\
    \n        if is_palindrome {\n            break;\n        }\n\n        index +=\
    \ 1;\n    }\n\n    let mut index = length - index - 1;\n    while index > 0 {\n\
    \        suffix.push(bytes[index] as char);\n        index -= 1;\n    }\n\n  \
    \  string + &suffix\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xyz\"`,\n right: `\"xyzyx\"`', /tmp/tmpsil662am.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 101
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut chars = string.chars().collect::<Vec<char>>();\n\
    \    let mut chars_rev = chars.clone();\n    chars_rev.reverse();\n    let mut\
    \ offset = 0;\n    for (c, c_rev) in chars.iter().zip(chars_rev.iter()) {\n  \
    \      if c != c_rev {\n            offset += 1;\n        } else {\n         \
    \   break;\n        }\n    }\n    let mut prefix = chars.split_off(chars.len()\
    \ - offset);\n    prefix.reverse();\n    let mut palindrome = string.clone();\n\
    \    palindrome.push_str(&prefix.into_iter().collect::<String>());\n    palindrome\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xyzz\"`,\n right: `\"xyzyx\"`', /tmp/tmph3nleyov.rs:28:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 101
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut palindrome = string.clone();\n    let n = string.len();\n\
    \    let end = string.as_bytes().get(n - 1).cloned();\n    let mut i = 0;\n  \
    \  while i < n {\n        if i < n - 1 && string.as_bytes().get(i).cloned() ==\
    \ end {\n            palindrome = string[0..n - i].chars().rev().collect::<String>()\
    \ + &palindrome;\n            return palindrome;\n        }\n        i += 1;\n\
    \    }\n    let mut s = string.clone();\n    s.remove(0);\n    s = s.chars().rev().collect::<String>();\n\
    \    palindrome += &s;\n    palindrome\n}\n\nfn main() {\n    let candidate =\
    \ make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpd85s6j3d.rs:8:37

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821507
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut longest_palindrome_len = 0;\n    for i in (0..string.len()).rev()\
    \ {\n        let prefix = &string[0..i];\n        let suffix = &string[i..];\n\
    \        if is_palindrome(prefix) {\n            if is_palindrome(suffix) {\n\
    \                // We've found the longest possible palindrome\n            \
    \    longest_palindrome_len = i;\n                break;\n            }\n    \
    \    }\n    }\n    let prefix = &string[0..longest_palindrome_len];\n    let mut\
    \ prefix_reversed = prefix.chars().rev().collect::<String>();\n    prefix_reversed.push_str(&string);\n\
    \    prefix_reversed\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp4un6i7dh.rs:10:12\n   |\n10 |         if is_palindrome(prefix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `is_palindrome` in this scope\n  --> /tmp/tmp4un6i7dh.rs:11:16\n\
    \   |\n11 |             if is_palindrome(suffix) {\n   |                ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    if string.is_empty() {\n        return string;\n  \
    \  }\n\n    let mut s_rev = string.clone();\n    s_rev.make_ascii_lowercase();\n\
    \    s_rev.retain(|c| c.is_ascii_alphanumeric());\n    s_rev = s_rev.chars().rev().collect();\n\
    \n    let lps = longest_palindromic_suffix(&string);\n    let prefix = string.chars().take(string.len()\
    \ - lps).collect();\n\n    let mut new_string = string;\n    new_string.push_str(&prefix);\n\
    \    new_string.make_ascii_lowercase();\n    new_string.retain(|c| c.is_ascii_alphanumeric());\n\
    \n    return new_string;\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `longest_palindromic_suffix` in this\
    \ scope\n  --> /tmp/tmp6zpadj_e.rs:15:15\n   |\n15 |     let lps = longest_palindromic_suffix(&string);\n\
    \   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n  -->\
    \ /tmp/tmp6zpadj_e.rs:16:9\n   |\n16 |     let prefix = string.chars().take(string.len()\
    \ - lps).collect();\n   |         ^^^^^^ doesn't have a size known at compile-time\n\
    \   |\n   = help: the trait `Sized` is not implemented for `str`\n   = note: all\
    \ local variables must have a statically known size\n   = help: unsized locals\
    \ are gated as an unstable feature\n\nerror[E0277]: a value of type `str` cannot\
    \ be built from an iterator over elements of type `char`\n  --> /tmp/tmp6zpadj_e.rs:16:58\n\
    \   |\n16 |     let prefix = string.chars().take(string.len() - lps).collect();\n\
    \   |                                                          ^^^^^^^ value of\
    \ type `str` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `str`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 101
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    // Find the longest postfix of a string that is a palindrome.\n\
    \    let mut string_chars = string.chars().collect::<Vec<char>>();\n    let mut\
    \ suffix_len = string_chars.len();\n    let mut is_palindrome = false;\n    while\
    \ !is_palindrome {\n        suffix_len -= 1;\n        is_palindrome = true;\n\
    \        for i in 0..suffix_len {\n            if string_chars[i] != string_chars[string_chars.len()\
    \ - 1 - i] {\n                is_palindrome = false;\n                break;\n\
    \            }\n        }\n    }\n\n    // Append to the end of a string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    let mut prefix\
    \ = string_chars[0..string_chars.len() - suffix_len].iter().rev().cloned().collect::<Vec<char>>();\n\
    \    string_chars.append(&mut prefix);\n    string_chars.iter().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmptlk1o3iu.rs:11:9

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821507
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let reversed_string = reverse(string.clone());\n  \
    \  let common_prefix = reversed_string.common_prefix(string.clone());\n    let\
    \ suffix = string[common_prefix.len()..].to_string();\n    reverse(suffix.clone())\
    \ + string.as_str()\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `reverse` in this scope\n --> /tmp/tmpfkmu6heo.rs:6:27\n\
    \  |\n6 |     let reversed_string = reverse(string.clone());\n  |            \
    \               ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `reverse` in this scope\n --> /tmp/tmpfkmu6heo.rs:9:5\n  |\n9 |     reverse(suffix.clone())\
    \ + string.as_str()\n  |     ^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut rev_string = string.clone();\n    rev_string.reverse();\n\
    \    let rev_str_no_self_palindrome = get_string_prefix(rev_string.clone());\n\
    \    rev_str_no_self_palindrome + string.as_str()\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_string_prefix` in this scope\n\
    \ --> /tmp/tmp90f2a5bf.rs:8:38\n  |\n8 |     let rev_str_no_self_palindrome =\
    \ get_string_prefix(rev_string.clone());\n  |                                \
    \      ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named\
    \ `reverse` found for struct `String` in the current scope\n --> /tmp/tmp90f2a5bf.rs:7:16\n\
    \  |\n7 |     rev_string.reverse();\n  |                ^^^^^^^ help: there is\
    \ an associated function with a similar name: `reserve`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let suffix_length = longest_suffix_palindrome(&string);\n\
    \    let prefix = &string[..string.len() - suffix_length];\n    let reverse_prefix\
    \ = reverse_string(prefix);\n    return reverse_prefix + &string;\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `longest_suffix_palindrome` in this\
    \ scope\n --> /tmp/tmp3iq7zcab.rs:6:25\n  |\n6 |     let suffix_length = longest_suffix_palindrome(&string);\n\
    \  |                         ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `reverse_string` in this scope\n --> /tmp/tmp3iq7zcab.rs:8:26\n\
    \  |\n8 |     let reverse_prefix = reverse_string(prefix);\n  |              \
    \            ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut prefix = string.chars().collect::<Vec<char>>();\n\
    \    let mut suffix = prefix.clone();\n    suffix.reverse();\n    let mut palindrome\
    \ = string.clone();\n    let mut shift = -1;\n    for length in (1..prefix.len()\
    \ + 1).rev() {\n        if is_palindrome(&prefix[..length]) {\n            shift\
    \ = prefix.len() - length;\n            break;\n        }\n    }\n    if shift\
    \ != -1 {\n        palindrome.push_str(&suffix[shift..]);\n    }\n    palindrome\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpp6fjcx85.rs:12:12\n   |\n12 |         if is_palindrome(&prefix[..length])\
    \ {\n   |            ^^^^^^^^^^^^^ help: a local variable with a similar name\
    \ exists: `palindrome`\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmpp6fjcx85.rs:10:21\n   |\n10 |     let mut shift = -1;\n   |   \
    \                  ^^ the trait `Neg` is not implemented for `usize`\n\nerror[E0600]:\
    \ cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmpp6fjcx85.rs:17:17\n\
    \   |\n17 |     if shift != -1 {\n   |                 ^^\n   |              \
    \   |\n   |                 cannot apply unary operator `-`\n   |            \
    \     help: you may have meant the maximum value of `usize`: `usize::MAX`\n  \
    \ |\n   = note: unsigned values cannot be negated\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpp6fjcx85.rs:18:29\n   |\n18 |         palindrome.push_str(&suffix[shift..]);\n\
    \   |                             ^^^^^^^^^^^^^^^^ expected `str`, found slice\
    \ `[char]`\n   |\n   = note: expected reference `&str`\n              found reference\
    \ `&[char]`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0425, E0600.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 101
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    if string.is_empty() {\n        return String::new();\n\
    \    }\n\n    let (mut prefix, mut suffix) = (string.clone(), string.clone());\n\
    \    while prefix.len() > 0 {\n        let rev_prefix = prefix.chars().rev().collect::<String>();\n\
    \        if suffix.starts_with(&rev_prefix) {\n            break;\n        }\n\
    \        prefix.pop();\n    }\n\n    let rev_prefix = prefix.chars().rev().collect::<String>();\n\
    \    rev_prefix + &string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xx\"`,\n right: `\"x\"`', /tmp/tmpkudq1xcr.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let longest_palindrome_suffix = find_longest_palindrome_suffix(&string).unwrap();\n\
    \    let prefix = &string[0..string.len() - longest_palindrome_suffix.len()];\n\
    \    return format!(\"{}{}{}\", prefix, longest_palindrome_suffix, prefix.chars().rev().collect::<String>());\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_longest_palindrome_suffix` in\
    \ this scope\n --> /tmp/tmppeph8hvc.rs:6:37\n  |\n6 |     let longest_palindrome_suffix\
    \ = find_longest_palindrome_suffix(&string).unwrap();\n  |                   \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    // Search for the longest palindromic suffix of the\
    \ supplied string.\n    let palindrome_suffix = find_palindrome_suffix(&string);\n\
    \n    // Append reverse of the string prefix to the original string.\n    format!(\"\
    {}{}\", &string, &string[..string.len() - palindrome_suffix.len()].chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_palindrome_suffix` in this scope\n\
    \ --> /tmp/tmpjhv46q0f.rs:7:29\n  |\n7 |     let palindrome_suffix = find_palindrome_suffix(&string);\n\
    \  |                             ^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 101
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let reversed = string.chars().rev().collect::<String>();\n\
    \    let to_append = reversed.trim_left_matches(&string).to_string();\n    let\
    \ mut result = string.clone();\n    result.push_str(&to_append);\n    result\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xyzzyx\"`,\n right: `\"xyzyx\"`', /tmp/tmpjziqr_ai.rs:17:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let original_string_length = string.len();\n    let\
    \ reverse_string = string.chars().rev().collect::<String>();\n    let max_suffix_len\
    \ = find_longest_palindromic_suffix_length(&string);\n    if max_suffix_len ==\
    \ original_string_length {\n        return string;\n    }\n    let prefix = &string[..string.len()\
    \ - max_suffix_len];\n    let reverse_prefix = &reverse_string[..reverse_string.len()\
    \ - max_suffix_len];\n    let mut result = string.clone();\n    result.push_str(reverse_prefix);\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_longest_palindromic_suffix_length`\
    \ in this scope\n --> /tmp/tmplpran6jg.rs:8:26\n  |\n8 |     let max_suffix_len\
    \ = find_longest_palindromic_suffix_length(&string);\n  |                    \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let string_rev = string.chars().rev().collect::<String>();\n\
    \    let longest_postfix = longest_common_postfix(string.clone(), string_rev.clone());\n\
    \    let string_prefix = string.chars().take(string.len() - longest_postfix.len()).collect::<String>();\n\
    \    let string_prefix_rev = string_prefix.chars().rev().collect::<String>();\n\
    \    return format!(\"{}{}{}\", string_prefix_rev, string, string_prefix_rev);\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `longest_common_postfix` in this scope\n\
    \ --> /tmp/tmpsc0v2vcr.rs:7:27\n  |\n7 |     let longest_postfix = longest_common_postfix(string.clone(),\
    \ string_rev.clone());\n  |                           ^^^^^^^^^^^^^^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    // Create a new String that is the reverse of the supplied\
    \ string.\n    let reverse_string = string.chars().rev().collect::<String>();\n\
    \n    // Create a z-function for the supplied string.\n    let z_function = z_function(&string);\n\
    \n    // The length of the longest palindromic postfix is the length of the string\n\
    \    // minus the z-function value at index (length of the string - 1).\n    let\
    \ longest_palindromic_postfix_length = z_function[string.len() - 1];\n\n    //\
    \ The prefix to reverse is the substring of the supplied string\n    // that ends\
    \ at index (length of the string - length of the longest palindromic postfix).\n\
    \    let prefix_to_reverse = &string[0..string.len() - longest_palindromic_postfix_length];\n\
    \n    // Concatenate the prefix to reverse and the reverse of the prefix to reverse\
    \ to the supplied string.\n    format!(\"{}{}{}\", string, prefix_to_reverse.chars().rev().collect::<String>(),\
    \ reverse_string)\n}\n\nfn main() {\n    let candidate = make_palindrome;\n  \
    \  assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `z_function` in this scope\n  --> /tmp/tmprmjrw87_.rs:10:22\n\
    \   |\n10 |     let z_function = z_function(&string);\n   |                  \
    \    ^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    if string.is_empty() {\n        return String::new();\n\
    \    }\n\n    let mut chars = string.chars().collect::<Vec<char>>();\n    if chars.len()\
    \ == 1 {\n        return string;\n    }\n\n    let reversed_string = chars.clone().into_iter().rev().collect::<String>();\n\
    \    let reversed_suffix = longest_common_suffix(chars.clone(), reversed_string.clone());\n\
    \    let reversed_prefix = chars.into_iter().rev().collect::<String>();\n    let\
    \ reversed_prefix = reversed_prefix.chars().skip(reversed_suffix.len()).collect::<String>();\n\
    \n    reversed_prefix + &string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `longest_common_suffix` in this scope\n\
    \  --> /tmp/tmp15mi9mov.rs:16:27\n   |\n16 |     let reversed_suffix = longest_common_suffix(chars.clone(),\
    \ reversed_string.clone());\n   |                           ^^^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string.clone();\n    reversed_string.make_ascii_lowercase();\n\
    \    reversed_string.reverse();\n\n    let mut longest_palindrome = String::new();\n\
    \    for i in 0..string.len() {\n        let test_string = string[i..].to_string();\n\
    \        if reversed_string.starts_with(&test_string) {\n            longest_palindrome\
    \ = test_string;\n        }\n    }\n\n    let mut result = string;\n    result.push_str(&reversed_string[longest_palindrome.len()..]);\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n --> /tmp/tmp_h9ft1hh.rs:8:21\n  |\n8 |     reversed_string.reverse();\n\
    \  |                     ^^^^^^^ help: there is an associated function with a\
    \ similar name: `reserve`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let max_suffix_len = find_max_suffix_palindrome_len(&string);\n\
    \    let prefix = &string[..string.len() - max_suffix_len];\n    let suffix =\
    \ &string[string.len() - max_suffix_len..];\n    // Make sure that suffix is a\
    \ palindrome\n    assert!(suffix == &suffix.chars().rev().collect::<String>());\n\
    \    format!(\"{}{}\", prefix, &suffix.chars().rev().collect::<String>())\n}\n\
    \nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_max_suffix_palindrome_len` in\
    \ this scope\n --> /tmp/tmp3lwibyvz.rs:6:26\n  |\n6 |     let max_suffix_len =\
    \ find_max_suffix_palindrome_len(&string);\n  |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 101
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let string = string.into_bytes();\n    let len = string.len();\n\
    \    let mut suffix = string.clone();\n    let mut rsuffix = string.clone();\n\
    \    suffix.reverse();\n    let common_prefix = suffix.iter().zip(rsuffix.iter()).take_while(|&(a,\
    \ b)| a == b).count();\n    let prefix_len = len - common_prefix;\n    suffix.truncate(prefix_len);\n\
    \    suffix.reverse();\n    suffix.extend(string);\n    String::from_utf8(suffix).unwrap()\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xyzxyz\"`,\n right: `\"xyzyx\"`', /tmp/tmpn03rr3b8.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 101
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let length = string.len();\n    // find the longest\
    \ postfix that is a palindrome\n    for length in (0..length).rev() {\n      \
    \  let prefix = &string[0..length];\n        let postfix = &string[length..];\n\
    \        if prefix == postfix.chars().rev().collect::<String>() {\n          \
    \  // we've found the longest palindromic postfix\n            let prefix = &string[0..(length\
    \ - 1)];\n            let postfix = &string[(length - 1)..(length - 1)];\n   \
    \         let mut rest = postfix.chars().rev().collect::<String>();\n        \
    \    rest.push_str(string.as_str());\n            return rest;\n        }\n  \
    \  }\n    // if no palindromic postfix, the whole string is a palindrome\n   \
    \ string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xyz\"`,\n right: `\"xyzyx\"`', /tmp/tmpcjd90xkq.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let reversed_string = string.chars().rev().collect::<String>();\n\
    \    if string == reversed_string {\n        return string;\n    }\n\n    let\
    \ prefix_len = string.len() - palindrome_suffix_length(&string);\n    format!(\"\
    {}{}\", string, &reversed_string[..prefix_len])\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `palindrome_suffix_length` in this scope\n\
    \  --> /tmp/tmpzr96b3y3.rs:11:37\n   |\n11 |     let prefix_len = string.len()\
    \ - palindrome_suffix_length(&string);\n   |                                 \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 101
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let length = string.len();\n    let mut reverse = string.chars().rev().collect::<String>();\n\
    \    for i in 0..length {\n        let prefix = &string[0..length - i];\n    \
    \    let suffix = &reverse[0..i];\n        if prefix == suffix {\n           \
    \ let mut palindrome = prefix.to_string();\n            palindrome.push_str(&reverse[i..]);\n\
    \            return palindrome;\n        }\n    }\n    unreachable!()\n}\n\nfn\
    \ main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''internal error: entered unreachable code'',
    /tmp/tmp037gwfo0.rs:17:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821507
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    if is_palindrome(&string) {\n        return string;\n\
    \    }\n\n    let reversed_prefix = string.chars().rev().collect::<String>();\n\
    \    let mut postfix = String::new();\n    let mut start = 0;\n    let len = string.len();\n\
    \n    while start < len {\n        let next_len = len - start;\n        let substring\
    \ = string.get(start..);\n        let reversed_substring = reversed_prefix.get(..next_len);\n\
    \n        if substring.is_some() && reversed_substring.is_some() {\n         \
    \   let substring = substring.unwrap();\n            let reversed_substring =\
    \ reversed_substring.unwrap();\n\n            if substring == reversed_substring\
    \ {\n                postfix = substring.to_string();\n                break;\n\
    \            }\n        }\n\n        start += 1;\n    }\n\n    let prefix = &string[..start];\n\
    \    let reversed_prefix = prefix.chars().rev().collect::<String>();\n\n    let\
    \ mut result = String::new();\n    result.push_str(&prefix);\n    result.push_str(&postfix);\n\
    \    result.push_str(&reversed_prefix);\n\n    result\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n -->\
    \ /tmp/tmp3z5azm26.rs:6:8\n  |\n6 |     if is_palindrome(&string) {\n  |     \
    \   ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    // Make a copy of the string.\n    let mut string =\
    \ string.clone();\n\n    // Find the longest suffix that is a palindrome.\n  \
    \  let mut longest_palindrome_suffix_length = 0;\n    while !string.is_empty()\
    \ {\n        if let Some(n) = get_longest_palindrome_suffix_length(&string) {\n\
    \            longest_palindrome_suffix_length = n;\n            break;\n     \
    \   }\n        string.pop();\n    }\n\n    // Append the reverse of the prefix\
    \ that comes before the palindromic suffix to the end of the string.\n    let\
    \ prefix = &string[..string.len() - longest_palindrome_suffix_length];\n    string.push_str(prefix.chars().rev().collect::<String>().as_str());\n\
    \n    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_longest_palindrome_suffix_length`\
    \ in this scope\n  --> /tmp/tmpofdyxmyg.rs:12:26\n   |\n12 |         if let Some(n)\
    \ = get_longest_palindrome_suffix_length(&string) {\n   |                    \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a local variable with a similar\
    \ name exists: `longest_palindrome_suffix_length`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let rev_string = string.chars().rev().collect::<String>();\n\
    \    // Returns overlap between reversed string and string\n    let overlap =\
    \ overlap_kmp(&string, &rev_string);\n    let prefix = &string[..string.len()\
    \ - overlap];\n    format!(\"{}{}{}\", string, rev_string[overlap..].chars().rev().collect::<String>(),\
    \ prefix)\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `overlap_kmp` in this scope\n --> /tmp/tmp9sat1dra.rs:8:19\n\
    \  |\n8 |     let overlap = overlap_kmp(&string, &rev_string);\n  |          \
    \         ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 101
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let string_rev = string.chars().rev().collect::<String>();\n\
    \    let mut suffix = string_rev;\n    let mut prefix = String::new();\n    while\
    \ !suffix.is_empty() {\n        let s_str = suffix.as_str();\n        let p_str\
    \ = prefix.as_str();\n        if s_str.contains(p_str) {\n            let substr\
    \ = &s_str[s_str.find(p_str).unwrap()..];\n            return String::from(substr)\
    \ + &string;\n        }\n        let mut ch = suffix.pop().unwrap();\n       \
    \ prefix.push(ch);\n    }\n    String::from(\"\")\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xx\"`,\n right: `\"x\"`', /tmp/tmp7pcy2w0b.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let reversed = string.chars().rev().collect::<String>();\n\
    \    let postfix = &string[0..string.len() - lps(&string, &reversed).len()];\n\
    \    format!(\"{}{}{}\", string, postfix.chars().rev().collect::<String>(), postfix)\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `lps` in this scope\n --> /tmp/tmpae5udhei.rs:7:45\n\
    \  |\n7 |     let postfix = &string[0..string.len() - lps(&string, &reversed).len()];\n\
    \  |                                             ^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut palindrome = find_longest_postfix(string.clone());\n\
    \    let prefix = string[0..string.len() - palindrome.len()].chars().rev().collect::<String>();\n\
    \    palindrome.push_str(&prefix);\n    palindrome\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_longest_postfix` in this scope\n\
    \ --> /tmp/tmpgcs29c13.rs:6:26\n  |\n6 |     let mut palindrome = find_longest_postfix(string.clone());\n\
    \  |                          ^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 101
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let length = string.len();\n    let mut prefix = String::new();\n\
    \    let mut suffix = String::new();\n    let mut pos = 0;\n    while pos < length\
    \ {\n        prefix.push(string.chars().nth(pos).unwrap());\n        suffix.push(string.chars().nth(length\
    \ - pos - 1).unwrap());\n        if suffix == prefix {\n            break;\n \
    \       }\n        pos += 1;\n    }\n    format!(\"{}{}{}\", string, suffix.chars().rev().collect::<String>(),\
    \ string)\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xxx\"`,\n right: `\"x\"`', /tmp/tmp5ndutthn.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let original_string = string.clone();\n    let mut\
    \ string = string.into_bytes();\n    let size = string.len();\n    let suffix\
    \ = find_suffix(&string, size);\n    let prefix = &string[..size - suffix];\n\
    \    let prefix = prefix.iter().rev();\n    let mut out = string.into_iter().take(suffix).collect::<Vec<_>>();\n\
    \    for &c in prefix {\n        out.push(c);\n    }\n    out.extend(original_string.into_bytes().into_iter());\n\
    \    String::from_utf8(out).unwrap()\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_suffix` in this scope\n --> /tmp/tmpxai7ucqg.rs:9:18\n\
    \  |\n9 |     let suffix = find_suffix(&string, size);\n  |                  ^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let rev = string.chars().rev().collect::<String>();\n\
    \    let mut prefix = string.clone();\n    prefix.push('$');\n    prefix.push_str(&rev);\n\
    \    let mut z_func = vec![0; prefix.len()];\n    let mut l = 0;\n    let mut\
    \ r = 0;\n    for i in 1..prefix.len() {\n        z_func[i] = if r < i { 0 } else\
    \ { i32::min(r - i + 1, z_func[i - l]) };\n        while i + z_func[i] < prefix.len()\
    \ && prefix.chars().nth(z_func[i]).unwrap() == prefix.chars().nth(i + z_func[i]).unwrap()\
    \ {\n            z_func[i] += 1;\n        }\n        if i + z_func[i] - 1 > r\
    \ {\n            l = i;\n            r = i + z_func[i] - 1;\n        }\n    }\n\
    \    let mut result = string.clone();\n    let prefix_len = string.len() - z_func[prefix.len()\
    \ - 1];\n    for i in 0..prefix_len {\n        result.push(string.chars().nth(i).unwrap());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n \
    \   assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzbfba1fv.rs:14:52\n   |\n\
    14 |         z_func[i] = if r < i { 0 } else { i32::min(r - i + 1, z_func[i -\
    \ l]) };\n   |                                                    ^^^^^^^^^ expected\
    \ `i32`, found `usize`\n   |\nhelp: you can convert a `usize` to an `i32` and\
    \ panic if the converted value doesn't fit\n   |\n14 |         z_func[i] = if\
    \ r < i { 0 } else { i32::min((r - i + 1).try_into().unwrap(), z_func[i - l])\
    \ };\n   |                                                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpzbfba1fv.rs:15:19\n   |\n15 |\
    \         while i + z_func[i] < prefix.len() && prefix.chars().nth(z_func[i]).unwrap()\
    \ == prefix.chars().nth(i + z_func[i]).unwrap() {\n   |                   ^^^^^^^^^\
    \ expected `usize`, found `i32`\n\nerror[E0277]: cannot add `i32` to `usize`\n\
    \  --> /tmp/tmpzbfba1fv.rs:15:17\n   |\n15 |         while i + z_func[i] < prefix.len()\
    \ && prefix.chars().nth(z_func[i]).unwrap() == prefix.chars().nth(i + z_func[i]).unwrap()\
    \ {\n   |                 ^ no implementation for `usize + i32`\n   |\n   = help:\
    \ the trait `Add<i32>` is not implemented for `usize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpzbfba1fv.rs:15:66\n   |\n15 |         while i + z_func[i]\
    \ < prefix.len() && prefix.chars().nth(z_func[i]).unwrap() == prefix.chars().nth(i\
    \ + z_func[i]).unwrap() {\n   |                                              \
    \                    ^^^^^^^^^ expected `usize`, found `i32`\n   |\nhelp: you\
    \ can convert an `i32` to a `usize` and panic if the converted value doesn't fit\n\
    \   |\n15 |         while i + z_func[i] < prefix.len() && prefix.chars().nth(z_func[i].try_into().unwrap()).unwrap()\
    \ == prefix.chars().nth(i + z_func[i]).unwrap() {\n   |                      \
    \                                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpzbfba1fv.rs:15:112\n   |\n15 | \
    \        while i + z_func[i] < prefix.len() && prefix.chars().nth(z_func[i]).unwrap()\
    \ == prefix.chars().nth(i + z_func[i]).unwrap() {\n   |    "
  stdout: ''
  timestamp: 1659821507
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut rev_string = string.clone();\n    rev_string.reverse();\n\
    \    let string_length = string.len();\n    let suffix_length = suffix_length(&string,\
    \ &rev_string);\n    let prefix = &string[..string_length - suffix_length];\n\
    \    let mut prefix_rev = prefix.to_string();\n    prefix_rev.reverse();\n   \
    \ format!(\"{}{}{}\", prefix_rev, &string[suffix_length..], prefix)\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `suffix_length` in this scope\n -->\
    \ /tmp/tmp5_oddkga.rs:9:25\n  |\n9 |     let suffix_length = suffix_length(&string,\
    \ &rev_string);\n  |                         ^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0599]: no method named `reverse` found for struct `String` in the current\
    \ scope\n --> /tmp/tmp5_oddkga.rs:7:16\n  |\n7 |     rev_string.reverse();\n \
    \ |                ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reserve`\n\nerror[E0599]: no method named `reverse` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmp5_oddkga.rs:12:16\n   |\n12 | \
    \    prefix_rev.reverse();\n   |                ^^^^^^^ help: there is an associated\
    \ function with a similar name: `reserve`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut suffix = get_palindromic_suffix(&string);\n\
    \    let mut prefix = string.chars().take(string.len() - suffix.len()).collect::<String>();\n\
    \    prefix.reverse();\n    suffix.push_str(&prefix);\n    suffix\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_palindromic_suffix` in this scope\n\
    \ --> /tmp/tmpp4e2pf9l.rs:6:22\n  |\n6 |     let mut suffix = get_palindromic_suffix(&string);\n\
    \  |                      ^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]:\
    \ no method named `reverse` found for struct `String` in the current scope\n -->\
    \ /tmp/tmpp4e2pf9l.rs:8:12\n  |\n8 |     prefix.reverse();\n  |            ^^^^^^^\
    \ help: there is an associated function with a similar name: `reserve`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 101
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let rev_string = string.chars().rev().collect::<String>();\n\
    \    let mut string = string;\n    let i = rev_string.rfind(&string);\n    if\
    \ let Some(i) = i {\n        string.push_str(&rev_string[..i].chars().rev().collect::<String>());\n\
    \    } else {\n        string.push_str(&rev_string);\n    }\n    string\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xyzzyx\"`,\n right: `\"xyzyx\"`', /tmp/tmpfdzh81lo.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821508
- exit_code: 101
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let bytes = string.into_bytes();\n    let len = bytes.len();\n\
    \    let mut palindrome_bytes = bytes.clone();\n    let mut end = len - 1;\n \
    \   let mut start = 0;\n    while end >= 0 {\n        if bytes[start] == bytes[end]\
    \ {\n            start += 1;\n        }\n        end -= 1;\n    }\n    for i in\
    \ 0..(len - start) {\n        palindrome_bytes.push(bytes[len - 1 - i]);\n   \
    \ }\n    String::from_utf8(palindrome_bytes).unwrap()\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpv24za6mm.rs:9:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821508
- exit_code: 101
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let size = string.len();\n    let mut palindrome =\
    \ string.clone();\n    let mut reversed_prefix = \"\".to_string();\n    let suffix_begin\
    \ = size / 2 + size % 2;\n    let prefix_end = size / 2;\n    // Reversed prefix\n\
    \    for i in 0..prefix_end {\n        reversed_prefix.push(string.chars().nth(prefix_end\
    \ - i - 1).unwrap());\n    }\n    palindrome.push_str(&reversed_prefix);\n   \
    \ // Check if there is a palindromic suffix.\n    for i in suffix_begin..size\
    \ {\n        if string.chars().nth(i).unwrap() == string.chars().nth(size - i\
    \ - 1).unwrap() {\n            palindrome.push_str(&reversed_prefix);\n      \
    \      return palindrome;\n        }\n    }\n    // If there is no palindromic\
    \ suffix, just reverse the prefix.\n    let reversed_prefix = reversed_prefix.chars().rev().collect::<String>();\n\
    \    palindrome.push_str(&reversed_prefix);\n    palindrome\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xyzxx\"`,\n right: `\"xyzyx\"`', /tmp/tmp3h9mjsjr.rs:33:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821508
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string;\n    let mut i = 0;\n    let\
    \ mut j = string.len() - 1;\n    while i < j {\n        if string.chars().nth(i)\
    \ != string.chars().nth(j) {\n            break;\n        }\n        i += 1;\n\
    \        j -= 1;\n    }\n    if i >= j {\n        return string;\n    }\n    let\
    \ mut reverse_prefix = string.chars().take(i).collect::<String>();\n    reverse_prefix.reverse();\n\
    \    let mut suffix = string.chars().skip(i).collect::<String>();\n    suffix.push_str(&reverse_prefix);\n\
    \    suffix\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpmktyrokm.rs:20:20\n   |\n20 |     reverse_prefix.reverse();\n\
    \   |                    ^^^^^^^ help: there is an associated function with a\
    \ similar name: `reserve`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 101
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut characters = string.chars().collect::<Vec<char>>();\n\
    \    let mut reverse_characters = characters.clone();\n    reverse_characters.reverse();\n\
    \n    let mut longest_match = 0;\n    for (i, _) in characters.iter().enumerate()\
    \ {\n        if reverse_characters[i] == characters[i] {\n            longest_match\
    \ += 1;\n        } else {\n            break;\n        }\n    }\n\n    let mut\
    \ prefix = characters[..characters.len() - longest_match].to_vec();\n    prefix.reverse();\n\
    \    for c in prefix {\n        characters.push(c);\n    }\n\n    let mut palindrome:\
    \ String = characters.into_iter().collect();\n    println!(\"{}\", palindrome);\n\
    \    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xyzzyx\"`,\n right: `\"xyzyx\"`', /tmp/tmpilg2s0d6.rs:34:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: '

    x

    xyzzyx

    '
  timestamp: 1659821507
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let s = string.as_bytes();\n    let mut i = 0;\n  \
    \  while i < s.len() {\n        let rev_i = s.len() - i - 1;\n        if s[i]\
    \ == s[rev_i] {\n            i += 1;\n        } else {\n            break;\n \
    \       }\n    }\n    if i == s.len() {\n        return string;\n    }\n    let\
    \ mut prefix = String::from_utf8(s[..i].to_vec()).unwrap();\n    prefix.reverse();\n\
    \    let mut palindrome = String::from_utf8(s[i..].to_vec()).unwrap();\n    palindrome.push_str(&prefix);\n\
    \    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp49kex_o_.rs:20:12\n   |\n20 |     prefix.reverse();\n\
    \   |            ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reserve`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    if is_palindrome(&string) {\n        return string;\n\
    \    }\n\n    let longest_postfix = find_longest_palindromic_postfix(&string);\n\
    \    let prefix = &string[0..(string.len() - longest_postfix.len())];\n    let\
    \ mut palindrome = String::new();\n    palindrome.push_str(prefix);\n    palindrome.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    palindrome.push_str(&string[(string.len() - longest_postfix.len())..]);\n\
    \    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n -->\
    \ /tmp/tmpu1564lkx.rs:6:8\n  |\n6 |     if is_palindrome(&string) {\n  |     \
    \   ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `find_longest_palindromic_postfix` in this scope\n  --> /tmp/tmpu1564lkx.rs:10:27\n\
    \   |\n10 |     let longest_postfix = find_longest_palindromic_postfix(&string);\n\
    \   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    if string.is_empty() {\n        return string;\n  \
    \  }\n\n    let length = string.len();\n    let mut i = 0;\n    let mut new_string\
    \ = String::new();\n\n    while i < length {\n        if is_palindrome(&string[i..])\
    \ {\n            new_string.push_str(&string[..i].chars().rev().collect::<String>());\n\
    \            new_string.push_str(&string);\n            return new_string;\n \
    \       }\n\n        i += 1;\n    }\n\n    // If we made it here, then the string\
    \ is a palindrome and we should just return it.\n    string\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpjlguxqsz.rs:15:12\n   |\n15 |         if is_palindrome(&string[i..])\
    \ {\n   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reverse = string.chars().rev().collect::<String>();\n\
    \    let mut pre_palindrome = \"\".to_string();\n    let mut post_palindrome =\
    \ string.chars().rev().collect::<String>();\n    let mut longest_palindrome =\
    \ \"\".to_string();\n\n    while reverse != pre_palindrome {\n        let current_palindrome\
    \ = pre_palindrome.clone() + &post_palindrome;\n        if is_palindrome(&current_palindrome)\
    \ {\n            longest_palindrome = current_palindrome;\n        }\n       \
    \ pre_palindrome.push(post_palindrome.pop().unwrap());\n    }\n\n    let reverse_string\
    \ = string.chars().rev().collect::<String>();\n    let prefix = reverse_string.split_off(longest_palindrome.len());\n\
    \    String::from(string) + &prefix\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpx_z1xbyl.rs:13:12\n   |\n13 |         if is_palindrome(&current_palindrome)\
    \ {\n   |            ^^^^^^^^^^^^^ help: a local variable with a similar name\
    \ exists: `post_palindrome`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 101
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let reverse_string = string.chars().rev().collect::<String>();\n\
    \    let string_length = string.len();\n    let mut max_length = 1;\n    let mut\
    \ max_prefix_size = 1;\n    let mut index = 1;\n    let mut table = vec![0; string_length];\n\
    \    table[0] = 0;\n    table[1] = 0;\n    while index < string_length {\n   \
    \     let index_reverse = string_length - index - 1;\n        if string.chars().nth(index).unwrap()\
    \ == reverse_string.chars().nth(index_reverse).unwrap() {\n            table[index\
    \ + 1] = table[index] + 1;\n            if table[index + 1] > max_length {\n \
    \               max_length = table[index + 1];\n                max_prefix_size\
    \ = index + 1;\n            }\n        }\n        index += 1;\n    }\n    let\
    \ string_prefix = string.chars().take(string_length - max_length).collect::<String>();\n\
    \    let reverse_prefix = string_prefix.chars().rev().collect::<String>();\n \
    \   let result = string + &reverse_prefix;\n    result\n}\n\nfn main() {\n   \
    \ let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmp0wa8v7pe.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821507
- exit_code: 101
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let string = string.as_bytes();\n    let mut length\
    \ = 0;\n    for (i, x) in string.iter().enumerate() {\n        let j = string.len()\
    \ - i - 1;\n        if *x == string[j] {\n            length += 1;\n        }\
    \ else {\n            break;\n        }\n    }\n    let mut new_string = string.to_vec();\n\
    \    new_string.reverse();\n    new_string.split_off(string.len() - length);\n\
    \    new_string.append(&mut string.to_vec());\n    String::from_utf8(new_string).unwrap()\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"zyxxyz\"`,\n right: `\"xyzyx\"`', /tmp/tmphp2spnen.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let prefix_len = longest_palindromic_prefix_len(&string);\n\
    \    let reversed_prefix = {\n        let prefix = &string[..prefix_len];\n  \
    \      let reversed_prefix: String = prefix.chars().rev().collect();\n       \
    \ reversed_prefix\n    };\n    format!(\"{}{}{}\", reversed_prefix, &string[prefix_len..],\
    \ reversed_prefix)\n}\n\nfn main() {\n    let candidate = make_palindrome;\n \
    \   assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `longest_palindromic_prefix_len` in\
    \ this scope\n --> /tmp/tmpup2wj0d5.rs:6:22\n  |\n6 |     let prefix_len = longest_palindromic_prefix_len(&string);\n\
    \  |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 101
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    // find the longest palindromic suffix\n    let n =\
    \ string.len();\n    let suffix_str = &string[n-n/2..];\n    let mut suffix =\
    \ String::new();\n    for c in suffix_str.chars().rev() {\n        suffix.push(c);\n\
    \    }\n    let found = string.find(&suffix);\n    // if we didn't find a suffix,\
    \ the supplied string is a palindrome\n    if found.is_none() {\n        return\
    \ string;\n    }\n    // calculate how much of the supplied string is a palindrome\n\
    \    let found = found.unwrap();\n    // the prefix is the non-palindromic part\n\
    \    let prefix = &string[..found];\n    // the prefix is appended to the end\
    \ of the supplied string after reversing\n    let mut ret = String::new();\n \
    \   ret.push_str(&string);\n    for c in prefix.chars().rev() {\n        ret.push(c);\n\
    \    }\n    return ret;\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jerry\"`,\n right: `\"jerryrrej\"`', /tmp/tmpuserm05j.rs:37:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    if string.is_empty() {\n        return String::new();\n\
    \    }\n\n    let mut reversed = string.clone();\n    reversed.make_ascii_lowercase();\n\
    \    reversed.reverse();\n\n    let mut string = string.clone();\n    string.make_ascii_lowercase();\n\
    \n    let (longest_suffix, _, _) = find_longest_prefix_suffix(&string, &reversed);\n\
    \n    let (prefix, suffix) = string.split_at(string.len() - longest_suffix);\n\
    \n    prefix.to_string() + suffix.chars().rev().collect::<String>().as_str()\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_longest_prefix_suffix` in this\
    \ scope\n  --> /tmp/tmpy6iv4_ys.rs:17:34\n   |\n17 |     let (longest_suffix,\
    \ _, _) = find_longest_prefix_suffix(&string, &reversed);\n   |              \
    \                    ^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]:\
    \ no method named `reverse` found for struct `String` in the current scope\n \
    \ --> /tmp/tmpy6iv4_ys.rs:12:14\n   |\n12 |     reversed.reverse();\n   |    \
    \          ^^^^^^^ help: there is an associated function with a similar name:\
    \ `reserve`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0425, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    if is_palindrome(&string) {\n        return string;\n\
    \    }\n\n    let (palindrome_suffix, prefix) = find_longest_palindrome_suffix(&string);\n\
    \    let prefix_reversed = prefix.chars().rev().collect::<String>();\n    format!(\"\
    {}{}{}\", prefix_reversed, string, palindrome_suffix)\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n -->\
    \ /tmp/tmpy3hjx4nj.rs:6:8\n  |\n6 |     if is_palindrome(&string) {\n  |     \
    \   ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `find_longest_palindrome_suffix` in this scope\n  --> /tmp/tmpy3hjx4nj.rs:10:39\n\
    \   |\n10 |     let (palindrome_suffix, prefix) = find_longest_palindrome_suffix(&string);\n\
    \   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    // Compute the reverse of the string prefix that comes\
    \ before the palindromic suffix.\n    let mut reversed_prefix = &string[0..string.len()\
    \ - common_string::substring::longest_palindrome_suffix(&string).len()];\n   \
    \ reversed_prefix = reversed_prefix.chars().rev().collect::<String>();\n\n   \
    \ // Return the concatenation of the reverse prefix and the original string.\n\
    \    format!(\"{}{}\", reversed_prefix, string)\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `common_string`\n\
    \ --> /tmp/tmpzjvixf48.rs:7:57\n  |\n7 |     let mut reversed_prefix = &string[0..string.len()\
    \ - common_string::substring::longest_palindrome_suffix(&string).len()];\n  |\
    \                                                         ^^^^^^^^^^^^^ use of\
    \ undeclared crate or module `common_string`\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpzjvixf48.rs:8:23\n  |\n8 |     reversed_prefix = reversed_prefix.chars().rev().collect::<String>();\n\
    \  |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \  |                       |\n  |                       expected `&str`, found\
    \ struct `String`\n  |                       help: consider borrowing here: `&reversed_prefix.chars().rev().collect::<String>()`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut s = string.clone();\n    let (mut l, mut r)\
    \ = (0, s.len() - 1);\n    for _ in 0..r {\n        if s[l] == s[r] {\n      \
    \      l += 1;\n            r -= 1;\n        } else {\n            let mut ss\
    \ = s.clone();\n            ss.remove(0);\n            let ss = make_palindrome(ss);\n\
    \            return format!(\"{}{}\", s[0], ss);\n        }\n    }\n    s\n}\n\
    \nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n -->\
    \ /tmp/tmp_3p__ndt.rs:9:12\n  |\n9 |         if s[l] == s[r] {\n  |          \
    \  ^^^^ `String` cannot be indexed by `{integer}`\n  |\n  = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n --> /tmp/tmp_3p__ndt.rs:9:20\n  |\n9 |         if s[l]\
    \ == s[r] {\n  |                    ^^^^ `String` cannot be indexed by `usize`\n\
    \  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp_3p__ndt.rs:16:36\n\
    \   |\n16 |             return format!(\"{}{}\", s[0], ss);\n   |            \
    \                        ^^^^ `String` cannot be indexed by `{integer}`\n   |\n\
    \   = help: the trait `Index<{integer}>` is not implemented for `String`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let longest_postfix = find_longest_postfix(string.clone());\n\
    \    let reverse_string = string.chars().rev().collect::<String>();\n    let prefix\
    \ = &reverse_string[..&reverse_string.len() - longest_postfix.len()];\n    String::from(string)\
    \ + prefix\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_longest_postfix` in this scope\n\
    \ --> /tmp/tmpg0utdceh.rs:6:27\n  |\n6 |     let longest_postfix = find_longest_postfix(string.clone());\n\
    \  |                           ^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let string = String::from(string.trim());\n    let\
    \ mut s = string.clone();\n    let mut p = String::new();\n    while !is_palindrome(&s)\
    \ {\n        p.push(s.pop().unwrap());\n    }\n    s.push_str(&p);\n    s\n}\n\
    \nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n -->\
    \ /tmp/tmp8up1wscd.rs:9:12\n  |\n9 |     while !is_palindrome(&s) {\n  |     \
    \       ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let split_index = get_max_palindrome_postfix_index(&string);\n\
    \    let prefix = &string[..split_index];\n    let suffix = &string[split_index..];\n\
    \    format!(\"{}{}{}\", prefix, reverse(suffix), suffix)\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_max_palindrome_postfix_index` in\
    \ this scope\n --> /tmp/tmp7euxjcy9.rs:6:23\n  |\n6 |     let split_index = get_max_palindrome_postfix_index(&string);\n\
    \  |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `reverse` in this scope\n --> /tmp/tmp7euxjcy9.rs:9:31\n\
    \  |\n9 |     format!(\"{}{}{}\", prefix, reverse(suffix), suffix)\n  |      \
    \                         ^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let str_bytes = string.as_bytes();\n    let str_len\
    \ = str_bytes.len();\n    let (mut suffix_begin, mut suffix_end) = (0, 0);\n \
    \   for i in 0..str_len {\n        // i is the start of a suffix.\n        if\
    \ is_palindrome(str_bytes, i, str_len - 1) {\n            suffix_begin = i;\n\
    \            break;\n        }\n    }\n    if suffix_begin == 0 {\n        //\
    \ Can't do anything to the supplied string.\n        return string;\n    }\n \
    \   suffix_end = str_len - 1;\n    // From suffix_begin to suffix_end we have\
    \ a palindrome.\n    // Now append a reverse of string[0..suffix_begin].\n   \
    \ let mut prefix_begin = 0;\n    let mut prefix_end = suffix_begin - 1;\n    let\
    \ mut suffix_start = suffix_begin;\n    let mut suffix_len = suffix_end - suffix_begin\
    \ + 1;\n    while prefix_begin < prefix_end {\n        // Check if prefix is a\
    \ palindrome.\n        if is_palindrome(str_bytes, prefix_begin, prefix_end) {\n\
    \            suffix_len = suffix_end - prefix_begin + 1;\n            suffix_start\
    \ = prefix_begin;\n            break;\n        }\n        prefix_begin += 1;\n\
    \        prefix_end -= 1;\n    }\n    // Append to the result a reverse of string[0..suffix_start].\n\
    \    let mut result = String::from(&string[suffix_start..suffix_end + 1]);\n \
    \   let prefix_len = suffix_start;\n    let mut prefix_end = prefix_len - 1;\n\
    \    while prefix_end >= 0 {\n        let c = str_bytes[prefix_end] as char;\n\
    \        result.push(c);\n        prefix_end -= 1;\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpl8hrnv73.rs:11:12\n   |\n11 |         if is_palindrome(str_bytes, i,\
    \ str_len - 1) {\n   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_palindrome` in this scope\n  --> /tmp/tmpl8hrnv73.rs:29:12\n\
    \   |\n29 |         if is_palindrome(str_bytes, prefix_begin, prefix_end) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let chars: Vec<char> = string.chars().collect();\n\
    \    let mut postfix_length = chars.len();\n    while postfix_length > 0 {\n \
    \       let (postfix, prefix) = chars.split_at(chars.len() - postfix_length);\n\
    \        if is_palindrome(postfix) {\n            let prefix_reversed: String\
    \ = prefix.iter().rev().collect();\n            return format!(\"{}{}\", prefix_reversed,\
    \ string);\n        }\n        postfix_length -= 1;\n    }\n    return string;\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpty60kgxn.rs:10:12\n   |\n10 |         if is_palindrome(postfix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut result = string.clone();\n    let mut palindrome_length\
    \ = 0;\n    for i in 0..(string.len() / 2) {\n        if string.as_bytes()[i]\
    \ == string.as_bytes()[string.len() - i - 1] {\n            palindrome_length\
    \ += 1;\n        } else {\n            break;\n        }\n    }\n    if palindrome_length\
    \ < string.len() {\n        let mut tmp = &string[..(string.len() - palindrome_length)];\n\
    \        tmp = tmp.chars().rev().collect::<String>().as_str();\n        result.push_str(tmp);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n \
    \   assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmpoana_qtg.rs:17:15\n\
    \   |\n17 |         tmp = tmp.chars().rev().collect::<String>().as_str();\n  \
    \ |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^         - temporary value\
    \ is freed at the end of this statement\n   |               |\n   |          \
    \     creates a temporary which is freed while still in use\n18 |         result.push_str(tmp);\n\
    \   |                         --- borrow later used here\n   |\n   = note: consider\
    \ using a `let` binding to create a longer lived value\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0716`.\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let string_length = string.len();\n    let right =\
    \ right_longest_palindrome(string);\n    format!(\"{}{}\", &string[right + 1..],\
    \ string[..=right].chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `right_longest_palindrome` in this scope\n\
    \ --> /tmp/tmpvyqwavo5.rs:7:17\n  |\n7 |     let right = right_longest_palindrome(string);\n\
    \  |                 ^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut prefix = String::new();\n    let mut suffix\
    \ = String::new();\n    let mut string = string;\n    for i in (0..string.len()).rev()\
    \ {\n        prefix.push(string.remove(i));\n        suffix.push(string.remove(i));\n\
    \        if is_palindrome(&string) {\n            break;\n        }\n    }\n \
    \   prefix + &suffix\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpq7rfccdj.rs:12:12\n   |\n12 |         if is_palindrome(&string) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    if string.is_empty() {\n        return string;\n  \
    \  }\n\n    let n = string.len();\n    let mut t = String::with_capacity(2 * n\
    \ + 1);\n    t.push('#');\n    for c in string.chars() {\n        t.push(c);\n\
    \        t.push('#');\n    }\n\n    let mut dp = vec![0; t.len()];\n    let mut\
    \ i = 0;\n    let mut j = 1;\n    let mut r = 0;\n    let mut c = 0;\n    while\
    \ j < t.len() {\n        if j <= r {\n            dp[j] = cmp::min(dp[2 * c -\
    \ j], r - j);\n        }\n\n        while i - dp[i] >= 0 && j + dp[j] < t.len()\
    \ && t.chars().nth(i - dp[i]).unwrap() == t.chars().nth(j + dp[j]).unwrap() {\n\
    \            dp[j] += 1;\n        }\n\n        if j + dp[j] > r {\n          \
    \  r = j + dp[j];\n            c = j;\n        }\n\n        i += 1;\n        j\
    \ = i;\n    }\n\n    let mut prefix = String::new();\n    let mut suffix = String::new();\n\
    \    let mut l = 0;\n    for i in 0..dp.len() {\n        if dp[i] > l {\n    \
    \        l = dp[i];\n            suffix = t[i - l + 1..i + 1].replace(\"#\", \"\
    \");\n        }\n    }\n\n    prefix = string[..n - suffix.len()].chars().rev().collect();\n\
    \    format!(\"{}{}{}\", prefix, suffix, prefix.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmptr_f4ja3.rs:25:21\n   |\n25 |             dp[j] = cmp::min(dp[2\
    \ * c - j], r - j);\n   |                     ^^^ use of undeclared crate or module\
    \ `cmp`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let string_chars: Vec<char> = string.chars().collect();\n\
    \    let length = string_chars.len();\n    let palindrome_length = find_longest_palindrome(string_chars,\
    \ length);\n    let mut output = string.clone();\n    for i in 0..(length - palindrome_length)\
    \ {\n        output.push(string_chars[length - i - 1]);\n    }\n    output\n}\n\
    \nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_longest_palindrome` in this scope\n\
    \ --> /tmp/tmpxunfolqf.rs:8:29\n  |\n8 |     let palindrome_length = find_longest_palindrome(string_chars,\
    \ length);\n  |                             ^^^^^^^^^^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string;\n    let reversed = string.chars().rev().collect::<String>();\n\
    \    let (mut palindrome_suffix, _) = longest_common_subsequence(string.clone(),\
    \ reversed);\n    let prefix = string.split_off(palindrome_suffix.len());\n  \
    \  palindrome_suffix.push_str(&prefix);\n    palindrome_suffix\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `longest_common_subsequence` in this\
    \ scope\n --> /tmp/tmp2rvsb0yk.rs:8:38\n  |\n8 |     let (mut palindrome_suffix,\
    \ _) = longest_common_subsequence(string.clone(), reversed);\n  |            \
    \                          ^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 101
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let longest_palindrome_end = string.clone().into_bytes().iter().rev().position(|&c|\
    \ c != b'.').unwrap();\n    let palindrome_end = &string[0..longest_palindrome_end];\n\
    \    let palindrome_begin = palindrome_end.chars().rev().collect::<String>();\n\
    \    let mut result = String::from(string);\n    result.push_str(&palindrome_begin);\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmpcd8g99ns.rs:6:100

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821508
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    // Find the longest palindromic suffix.\n    let mut\
    \ suffix = string;\n    for _ in 0..string.len() {\n        if is_palindrome(&suffix)\
    \ {\n            break;\n        }\n        suffix.remove(0);\n    }\n\n    //\
    \ We know that suffix is a palindrome, so only missing part is a prefix.\n   \
    \ // Extend the string with the reverse of the prefix.\n    let prefix = string.chars().take(string.len()\
    \ - suffix.len()).collect::<String>();\n    string + &prefix.chars().rev().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n -->\
    \ /tmp/tmpo9lxu1te.rs:9:12\n  |\n9 |         if is_palindrome(&suffix) {\n  |\
    \            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: -1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut first_half = string.chars().collect::<Vec<char>>();\n\
    \    let mut second_half = first_half.clone();\n    second_half.reverse();\n \
    \   let mut palindrome = String::new();\n    let mut shift = 0;\n    while palindrome.len()\
    \ != string.len() {\n        first_half.rotate_left(1);\n        palindrome =\
    \ first_half.iter().collect::<String>() + &second_half.iter().collect::<String>();\n\
    \        shift += 1;\n    }\n    palindrome\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659821513
- exit_code: 101
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut result = string.clone();\n    let length =\
    \ string.len();\n    let mut reverse = string.chars().rev().collect::<String>();\n\
    \    // Find the longest postfix of the string that is a palindrome\n    for i\
    \ in 0..length {\n        if string[i..] == reverse[length - i..] {\n        \
    \    // Append the prefix that comes before the palindromic suffix\n         \
    \   result.push_str(&reverse[..length - i]);\n            break;\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n \
    \   assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xyz\"`,\n right: `\"xyzyx\"`', /tmp/tmp7ut0lnsv.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821508
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let rev_string = string.chars().rev().collect::<String>();\n\
    \    let suffix = longest_common_suffix(&string, &rev_string);\n    let prefix\
    \ = string.chars().take(string.len() - suffix.len()).collect::<String>();\n  \
    \  let rev_prefix = prefix.chars().rev().collect::<String>();\n    format!(\"\
    {}{}{}\", prefix, rev_prefix, suffix)\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `longest_common_suffix` in this scope\n\
    \ --> /tmp/tmp7ps2zi1_.rs:7:18\n  |\n7 |     let suffix = longest_common_suffix(&string,\
    \ &rev_string);\n  |                  ^^^^^^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 101
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let n = string.len();\n    let s = string.as_bytes();\n\
    \    let mut suffix_pals = vec![];\n    for i in 0..n {\n        let mut j = 0;\n\
    \        while i + j < n && i - j >= 0 && s[i + j] == s[i - j] {\n           \
    \ suffix_pals.push(j);\n            j += 1;\n        }\n    }\n    let mut prefix_pals\
    \ = vec![];\n    for i in 0..n {\n        let mut j = 0;\n        while i + j\
    \ + 1 < n && i - j >= 0 && s[i + j + 1] == s[i - j] {\n            prefix_pals.push(j);\n\
    \            j += 1;\n        }\n    }\n    let mut suf_idx = 0;\n    let mut\
    \ suf_len = 0;\n    let mut pref_idx = 0;\n    let mut pref_len = 0;\n    for\
    \ (i, &p) in suffix_pals.iter().enumerate() {\n        if p > suf_len {\n    \
    \        suf_idx = i;\n            suf_len = p;\n        }\n    }\n    for (i,\
    \ &p) in prefix_pals.iter().enumerate() {\n        if p > pref_len {\n       \
    \     pref_idx = i;\n            pref_len = p;\n        }\n    }\n    if suf_len\
    \ >= pref_len {\n        let mut pal = string.clone();\n        let prefix = string[0..(n\
    \ - suf_idx - suf_len)].chars().rev().collect::<String>();\n        pal.push_str(&prefix);\n\
    \        pal\n    } else {\n        let mut pal = string.clone();\n        let\
    \ prefix = string[0..(n - pref_idx - pref_len - 1)].chars().rev().collect::<String>();\n\
    \        pal.push_str(&prefix);\n        pal\n    }\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xx\"`,\n right: `\"x\"`', /tmp/tmpb9r_7nnk.rs:56:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821508
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut palindrome = string.clone();\n    let end_index\
    \ = find_palindrome_end_index(&string);\n    let prefix = string.chars().take(string.len()\
    \ - end_index - 1).collect::<String>();\n    let prefix_reversed = prefix.chars().rev().collect::<String>();\n\
    \    palindrome.push_str(&prefix_reversed);\n    palindrome\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_palindrome_end_index` in this\
    \ scope\n --> /tmp/tmp8y0j3539.rs:7:21\n  |\n7 |     let end_index = find_palindrome_end_index(&string);\n\
    \  |                     ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821508
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut suffix = string.clone();\n    let mut prefix\
    \ = String::from(\"\");\n    let mut prefix_position = 0;\n    let mut palindrome_length\
    \ = 0;\n\n    while suffix.len() > 0 {\n        if is_palindrome(&suffix) {\n\
    \            palindrome_length = suffix.len();\n            break;\n        }\n\
    \        prefix.push(suffix.remove(0));\n        prefix_position += 1;\n    }\n\
    \n    let reversed_prefix = prefix.chars().rev().collect::<String>();\n    string\
    \ + &reversed_prefix[palindrome_length..]\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpvkvpckgp.rs:12:12\n   |\n12 |         if is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659821508
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    // Find the longest prefix of the string that is also\
    \ a palindrome.\n    let prefix = find_palindrome_prefix(&string);\n\n    // Add\
    \ the reverse of the string up to the prefix\n    let mut palindrome = string.clone();\n\
    \    palindrome.push_str(&string[..string.len() - prefix].chars().rev().collect::<String>());\n\
    \n    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n   \
    \ assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_palindrome_prefix` in this scope\n\
    \ --> /tmp/tmp2mcmqmco.rs:7:18\n  |\n7 |     let prefix = find_palindrome_prefix(&string);\n\
    \  |                  ^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string;\n    let reverse = string.clone();\n\
    \    let reverse = reverse.chars().rev().collect::<String>();\n    string.push_str(&reverse);\n\
    \    string = manacher(&string);\n    string.truncate(string.len() / 2);\n   \
    \ let mut string = string.chars().rev().collect::<String>();\n    string.push_str(&reverse);\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `manacher` in this scope\n  --> /tmp/tmp3r6nx4am.rs:10:14\n\
    \   |\n10 |     string = manacher(&string);\n   |              ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut prefix = String::new();\n    let mut suffix\
    \ = String::new();\n    let mut found = false;\n    let char_vec: Vec<char> =\
    \ string.chars().collect();\n    let rev_char_vec: Vec<char> = char_vec.clone().into_iter().rev().collect();\n\
    \    for i in (0..char_vec.len()).rev() {\n        if rev_char_vec[i] == char_vec[0]\
    \ {\n            if !is_palindrome(&char_vec[0..i + 1]) {\n                continue;\n\
    \            }\n            prefix = string[0..i + 1].to_string();\n         \
    \   suffix = string[i + 1..].to_string();\n            found = true;\n       \
    \     break;\n        }\n    }\n    if !found {\n        return String::new();\n\
    \    }\n    let mut res = String::new();\n    res.push_str(&prefix);\n    let\
    \ rev_prefix: Vec<char> = prefix.chars().collect();\n    let rev_prefix_slice:\
    \ &[char] = &rev_prefix;\n    let rev_prefix_rev: Vec<char> = rev_prefix_slice.iter().rev().cloned().collect();\n\
    \    let rev_prefix_rev_slice: &[char] = &rev_prefix_rev;\n    res.push_str(&suffix);\n\
    \    res.push_str(&String::from_iter(rev_prefix_rev_slice.iter().cloned()));\n\
    \    res\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpj1_1l4w5.rs:13:17\n   |\n13 |             if !is_palindrome(&char_vec[0..i\
    \ + 1]) {\n   |                 ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]:\
    \ no function or associated item named `from_iter` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpj1_1l4w5.rs:32:27\n   |\n32 |     res.push_str(&String::from_iter(rev_prefix_rev_slice.iter().cloned()));\n\
    \   |                           ^^^^^^^^^ function or associated item not found\
    \ in `String`\n   |\n   = help: items from traits can only be used if the trait\
    \ is in scope\nhelp: the following trait is implemented but not in scope; perhaps\
    \ add a `use` for it:\n   |\n1  | use std::iter::FromIterator;\n   |\nhelp: there\
    \ is an associated function with a similar name\n   |\n32 |     res.push_str(&String::from_utf8(rev_prefix_rev_slice.iter().cloned()));\n\
    \   |                           ~~~~~~~~~\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821508
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut max_postfix_len = 0;\n    for i in 0..string.len()\
    \ {\n        if is_palindrome(&string[i..]) {\n            max_postfix_len = string.len()\
    \ - i;\n            break;\n        }\n    }\n    let prefix = &string[..string.len()\
    \ - max_postfix_len];\n    let suffix = &string[max_postfix_len..];\n    format!(\"\
    {}{}{}\", prefix, reverse(suffix), suffix)\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n -->\
    \ /tmp/tmpq4a4q5xb.rs:8:12\n  |\n8 |         if is_palindrome(&string[i..]) {\n\
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `reverse` in this scope\n  --> /tmp/tmpq4a4q5xb.rs:15:31\n   |\n\
    15 |     format!(\"{}{}{}\", prefix, reverse(suffix), suffix)\n   |          \
    \                     ^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659821507
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string;\n    let mut rev_string =\
    \ string.clone();\n    rev_string.reverse();\n    let mut new_string = string\
    \ + \"*\" + &rev_string;\n    // Compute the pi prefix function for new_string\n\
    \    let mut prefix_function = vec![0; new_string.len()];\n    for i in 1..new_string.len()\
    \ {\n        let mut j = prefix_function[i - 1];\n        while j > 0 && new_string.chars().nth(i).unwrap()\
    \ != new_string.chars().nth(j).unwrap() {\n            j = prefix_function[j -\
    \ 1];\n        }\n        if new_string.chars().nth(i).unwrap() == new_string.chars().nth(j).unwrap()\
    \ {\n            j += 1;\n        }\n        prefix_function[i] = j;\n    }\n\
    \    // The length of the longest postfix that is a palindrome\n    let longest_palindrome_length\
    \ = prefix_function[new_string.len() - 1];\n    // Append a string prefix to the\
    \ end of the string.\n    string.push_str(&rev_string[..rev_string.len() - longest_palindrome_length]);\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpgzdg95oi.rs:8:16\n  |\n8 |     rev_string.reverse();\n\
    \  |                ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reserve`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659821508
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let (palindrome_suffix, prefix) =\n        string.chars().enumerate().fold((0,\
    \ Vec::new()), |(max_palindrome_len, prefix), (i, ch)| {\n            let mut\
    \ palindrome_len = max_palindrome_len;\n            if i < palindrome_len {\n\
    \                palindrome_len = i;\n            }\n            while palindrome_len\
    \ > 0 && ch != prefix[i - palindrome_len] {\n                palindrome_len -=\
    \ 1;\n            }\n            if palindrome_len != 0 || ch == prefix[i - palindrome_len]\
    \ {\n                palindrome_len += 1;\n            }\n            prefix.push(ch);\n\
    \            (palindrome_len, prefix)\n        });\n    let (palindrome_prefix,\
    \ _) = prefix.iter().rev().take(palindrome_suffix).fold(\n        (String::new(),\
    \ palindrome_suffix),\n        |(mut prefix, i), ch| {\n            if i != palindrome_suffix\
    \ {\n                prefix.push(*ch);\n            }\n            (prefix, i\
    \ - 1)\n        },\n    );\n    let palindrome_suffix = prefix\n        .iter()\n\
    \        .rev()\n        .take(palindrome_suffix)\n        .map(|&ch| ch)\n  \
    \      .collect();\n    [palindrome_prefix, string, palindrome_suffix].concat()\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `prefix` as mutable, as it is not declared\
    \ as mutable\n  --> /tmp/tmptza054ve.rs:18:13\n   |\n7  |         string.chars().enumerate().fold((0,\
    \ Vec::new()), |(max_palindrome_len, prefix), (i, ch)| {\n   |               \
    \                                                                 ------ help:\
    \ consider changing this to be mutable: `mut prefix`\n...\n18 |             prefix.push(ch);\n\
    \   |             ^^^^^^ cannot borrow as mutable\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659821508
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut s = string.as_bytes();\n    let n = s.len();\n\
    \    let mut rev_s = s.to_vec();\n    rev_s.reverse();\n    let mut z = vec![0u8;\
    \ 2 * n];\n    z[0] = n as u8;\n    let mut l = 0;\n    let mut r = 0;\n    for\
    \ i in 1..2 * n {\n        let j = if i > r {\n            0\n        } else {\n\
    \            i.min(2 * n - 1 - r + l)\n        };\n        while i + j < 2 * n\
    \ && j < n && s[j] == rev_s[i + j] {\n            j += 1;\n        }\n       \
    \ z[i] = j as u8;\n        if i + j - 1 > r {\n            l = i;\n          \
    \  r = i + j - 1;\n        }\n    }\n    let mut res = string.clone();\n    let\
    \ mut prefix = &string[..n - (z[n] as usize)];\n    let mut rev_prefix = prefix.as_bytes().to_vec();\n\
    \    rev_prefix.reverse();\n    for c in rev_prefix {\n        res.push(c as char);\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n --> /tmp/tmp7_ob2g3_.rs:6:9\n\
    \  |\n6 |     let mut s = string.as_bytes();\n  |         ----^\n  |         |\n\
    \  |         help: remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]` on\
    \ by default\n\nwarning: variable does not need to be mutable\n  --> /tmp/tmp7_ob2g3_.rs:30:9\n\
    \   |\n30 |     let mut prefix = &string[..n - (z[n] as usize)];\n   |       \
    \  ----^^^^^^\n   |         |\n   |         help: remove this `mut`\n\nerror[E0384]:\
    \ cannot assign twice to immutable variable `j`\n  --> /tmp/tmp7_ob2g3_.rs:21:13\n\
    \   |\n15 |         let j = if i > r {\n   |             -\n   |             |\n\
    \   |             first assignment to `j`\n   |             help: consider making\
    \ this binding mutable: `mut j`\n...\n21 |             j += 1;\n   |         \
    \    ^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to\
    \ previous error; 2 warnings emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659821508
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let palindrome_suffix = find_longest_palindrome_suffix(&string);\n\
    \    let mut result = String::from(&string[palindrome_suffix.len()..]);\n    result.push_str(&reverse_string(&string[..palindrome_suffix.len()]));\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_longest_palindrome_suffix` in\
    \ this scope\n --> /tmp/tmptps3lfwb.rs:6:29\n  |\n6 |     let palindrome_suffix\
    \ = find_longest_palindrome_suffix(&string);\n  |                            \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `reverse_string` in this scope\n --> /tmp/tmptps3lfwb.rs:8:22\n\
    \  |\n8 |     result.push_str(&reverse_string(&string[..palindrome_suffix.len()]));\n\
    \  |                      ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821508
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let s = string.as_bytes();\n    let mut s_rev = s.clone();\n\
    \    s_rev.reverse();\n    let s_len = s.len();\n    let mut i = 0;\n    while\
    \ i < s_len {\n        if &s[i..] == &s_rev[..s_len - i] {\n            break;\n\
    \        }\n        i += 1;\n    }\n    let mut new_string = String::from_utf8(s.to_vec()).unwrap();\n\
    \    new_string.push_str(&String::from_utf8(s_rev[..s_len - i].to_vec()).unwrap());\n\
    \    new_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n --> /tmp/tmpsmla3a8r.rs:7:9\n\
    \  |\n7 |     let mut s_rev = s.clone();\n  |         ----^^^^^\n  |         |\n\
    \  |         help: remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]` on\
    \ by default\n\nerror[E0596]: cannot borrow `*s_rev` as mutable, as it is behind\
    \ a `&` reference\n --> /tmp/tmpsmla3a8r.rs:8:5\n  |\n7 |     let mut s_rev =\
    \ s.clone();\n  |         --------- help: consider changing this to be a mutable\
    \ reference: `&mut [u8]`\n8 |     s_rev.reverse();\n  |     ^^^^^ `s_rev` is a\
    \ `&` reference, so the data it refers to cannot be borrowed as mutable\n\nerror:\
    \ aborting due to previous error; 1 warning emitted\n\nFor more information about\
    \ this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659821508
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let reversed = string.chars().rev().collect::<String>();\n\
    \    let lps = longest_postfix_palindrome(&string);\n    let pre = &string[..string.len()\
    \ - lps.len()];\n    let prefix = pre.chars().rev().collect::<String>();\n   \
    \ prefix + &string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n \
    \   assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `longest_postfix_palindrome` in this\
    \ scope\n --> /tmp/tmpda2x0v9f.rs:7:15\n  |\n7 |     let lps = longest_postfix_palindrome(&string);\n\
    \  |               ^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821508
- exit_code: 101
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut suffix = vec![];\n    for &ch in string.as_bytes().iter().rev()\
    \ {\n        let mut added = false;\n        for &i in suffix.iter() {\n     \
    \       if string.as_bytes()[i] == ch {\n                suffix.push(i + 1);\n\
    \                added = true;\n                break;\n            }\n      \
    \  }\n        if !added {\n            suffix.push(0);\n        }\n    }\n   \
    \ let mut prefix = String::new();\n    for i in suffix.iter().rev() {\n      \
    \  if i == &0 {\n            prefix.push(string.chars().nth(string.len() - 1).unwrap());\n\
    \        } else {\n            prefix.push(string.chars().nth(i - 1).unwrap());\n\
    \        }\n    }\n    let mut s = string;\n    s.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    s\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xx\"`,\n right: `\"x\"`', /tmp/tmp1xio38ml.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821508
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let end_index = find_palindrome_postfix_length(&string);\n\
    \    string.clone() + &string[..end_index].chars().rev().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_palindrome_postfix_length` in\
    \ this scope\n --> /tmp/tmpyjr553_8.rs:6:21\n  |\n6 |     let end_index = find_palindrome_postfix_length(&string);\n\
    \  |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821508
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut palindrome = string.clone();\n    let reverse\
    \ = string.chars().rev().collect::<String>();\n    let range = string.len() +\
    \ 1;\n    let mut left = 1;\n    let mut right = range;\n    let mut longest_palindrome\
    \ = String::new();\n    let mut longest_index = 0;\n\n    while left < right {\n\
    \        let (current_palindrome, current_index) = longest_common_suffix(palindrome.clone(),\
    \ reverse.clone(), left, right);\n        if current_palindrome.len() > longest_palindrome.len()\
    \ {\n            longest_palindrome = current_palindrome;\n            longest_index\
    \ = current_index;\n        }\n        left += 1;\n        right -= 1;\n    }\n\
    \n    let prefix = palindrome.drain(..longest_index).collect::<String>();\n  \
    \  palindrome.push_str(&prefix.chars().rev().collect::<String>());\n\n    palindrome\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `longest_common_suffix` in this scope\n\
    \  --> /tmp/tmp5q3jdsv1.rs:15:51\n   |\n15 |         let (current_palindrome,\
    \ current_index) = longest_common_suffix(palindrome.clone(), reverse.clone(),\
    \ left, right);\n   |                                                   ^^^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821508
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut suffix = palindrome_suffix(string.clone());\n\
    \    let mut prefix = prefix(string);\n    prefix.reverse();\n    if !suffix.is_empty()\
    \ {\n        suffix.pop();\n    }\n    format!(\"{}{}{}\", string, prefix, suffix)\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `palindrome_suffix` in this scope\n\
    \ --> /tmp/tmp9_d0qtw4.rs:6:22\n  |\n6 |     let mut suffix = palindrome_suffix(string.clone());\n\
    \  |                      ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `prefix` in this scope\n --> /tmp/tmp9_d0qtw4.rs:7:22\n\
    \  |\n7 |     let mut prefix = prefix(string);\n  |                      ^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821508
- exit_code: 101
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let chars: Vec<char> = string.chars().collect();\n\
    \    let mut end = chars.len();\n    let mut pivot = 0;\n    while pivot < end\
    \ {\n        let mut j = 0;\n        while j <= pivot && end - j - 1 > pivot {\n\
    \            if chars[pivot - j] != chars[end - j - 1] {\n                break;\n\
    \            }\n            j += 1;\n        }\n        if j > pivot {\n     \
    \       break;\n        }\n        end -= 1;\n    }\n    let reversed = chars[..pivot].iter().rev().cloned().collect::<String>();\n\
    \    string + &reversed\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xyz\"`,\n right: `\"xyzyx\"`', /tmp/tmpdvn1_ybw.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821508
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let palindrome_length = get_max_palindrome_length(string.as_str());\n\
    \    let mut new_string = string.as_str()[palindrome_length..].to_string();\n\
    \    new_string.push_str(string.as_str());\n    new_string.push_str(string.as_str()[..palindrome_length].chars().rev().collect::<String>().as_str());\n\
    \    new_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_max_palindrome_length` in this\
    \ scope\n --> /tmp/tmpjox7p5ta.rs:6:29\n  |\n6 |     let palindrome_length = get_max_palindrome_length(string.as_str());\n\
    \  |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821508
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut palindrome = String::from(string.as_str());\n\
    \    let mut reverse = string.chars().rev().collect::<String>();\n    if !is_palindrome(&string)\
    \ {\n        let suffix = find_palindrome_suffix(&string);\n        let prefix\
    \ = reverse.split_off(string.len() - suffix.len());\n        palindrome.push_str(prefix.as_str());\n\
    \    }\n    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n -->\
    \ /tmp/tmpab3g5j63.rs:8:9\n  |\n8 |     if !is_palindrome(&string) {\n  |    \
    \     ^^^^^^^^^^^^^ help: a local variable with a similar name exists: `palindrome`\n\
    \nerror[E0425]: cannot find function `find_palindrome_suffix` in this scope\n\
    \ --> /tmp/tmpab3g5j63.rs:9:22\n  |\n9 |         let suffix = find_palindrome_suffix(&string);\n\
    \  |                      ^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821508
- exit_code: 0
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let reverse = string.chars().rev().collect::<String>();\n\
    \    if string == reverse {\n        return string;\n    }\n\n    for i in (0..string.len()).rev()\
    \ {\n        if string[i..].chars().eq(reverse[..string.len() - i].chars()) {\n\
    \            return String::from(&string[..i]) + &reverse;\n        }\n    }\n\
    \n    unreachable!();\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821508
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let suffix = get_longest_suffix_palindrome(&string);\n\
    \    let prefix = &string[..string.len() - suffix.len()];\n    let mut result\
    \ = prefix.chars().rev().collect::<String>();\n    result.push_str(&string);\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_longest_suffix_palindrome` in this\
    \ scope\n --> /tmp/tmpro1lmu60.rs:6:18\n  |\n6 |     let suffix = get_longest_suffix_palindrome(&string);\n\
    \  |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821508
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let suffix_length = find_longest_palindromic_suffix_length(&string);\n\
    \    let prefix_length = string.len() - suffix_length;\n    let mut reverse_prefix\
    \ = string[..prefix_length].chars().rev().collect::<String>();\n    let mut suffix\
    \ = string[prefix_length..].to_string();\n    suffix.push_str(&reverse_prefix);\n\
    \    suffix\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_longest_palindromic_suffix_length`\
    \ in this scope\n --> /tmp/tmpi35ghws9.rs:6:25\n  |\n6 |     let suffix_length\
    \ = find_longest_palindromic_suffix_length(&string);\n  |                    \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821508
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let i = find_palindrome_length(&string);\n    let prefix\
    \ = &string[0..i];\n    let reverse_prefix = prefix.chars().rev().collect::<String>();\n\
    \    format!(\"{}{}{}\", prefix, &string[i..], reverse_prefix)\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_palindrome_length` in this scope\n\
    \ --> /tmp/tmpruemzyjg.rs:6:13\n  |\n6 |     let i = find_palindrome_length(&string);\n\
    \  |             ^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659821508
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed = string.clone();\n    reversed.reverse();\n\
    \    let mut sum = string + \"*\" + &reversed;\n    let mut z: Vec<usize> = kmp::KMP::new(&sum).build();\n\
    \    let mut max_z_index = 0;\n    let mut max_z = 0;\n    for i in 0..z.len()\
    \ {\n        if z[i] > max_z {\n            max_z = z[i];\n            max_z_index\
    \ = i;\n        }\n    }\n    sum.insert_str(\n        max_z_index + 1,\n    \
    \    &reversed[0..(string.len() - max_z)].to_string(),\n    );\n    sum\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `kmp`\n\
    \ --> /tmp/tmpo1qm1tl8.rs:9:29\n  |\n9 |     let mut z: Vec<usize> = kmp::KMP::new(&sum).build();\n\
    \  |                             ^^^ use of undeclared crate or module `kmp`\n\
    \nerror[E0599]: no method named `reverse` found for struct `String` in the current\
    \ scope\n --> /tmp/tmpo1qm1tl8.rs:7:14\n  |\n7 |     reversed.reverse();\n  |\
    \              ^^^^^^^ help: there is an associated function with a similar name:\
    \ `reserve`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0433, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0433`.\n"
  stdout: ''
  timestamp: 1659821508
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let suffix_result = suffix(string.as_str());\n    let\
    \ (longest_suffix, suffix_index) = suffix_result.iter().enumerate().rev().find(|(_,\
    \ v)| v.is_some()).unwrap();\n    let rev_prefix = string.chars().take(suffix_index\
    \ - longest_suffix).collect::<String>().chars().rev().collect::<String>();\n \
    \   let rev_suffix = string.chars().skip(suffix_index).collect::<String>();\n\
    \    format!(\"{}{}{}\", rev_prefix, string, rev_suffix)\n}\n\nfn main() {\n \
    \   let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `suffix` in this scope\n --> /tmp/tmpa9v0z0z6.rs:6:25\n\
    \  |\n6 |     let suffix_result = suffix(string.as_str());\n  |              \
    \           ^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821508
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut longest_suffix_start = 0;\n    let mut longest_suffix_len\
    \ = 0;\n    let mut palindrome_start = 0;\n    let mut palindrome_len = 0;\n \
    \   let mut suffix_start = 0;\n    let mut suffix_len = 0;\n    let mut prefix_start\
    \ = 0;\n    let mut prefix_len = 0;\n    let mut first_char = 0;\n    let mut\
    \ last_char = 0;\n    let mut end = 0;\n    let mut end_suffix = 0;\n    let mut\
    \ end_prefix = 0;\n    let mut next_suffix_start = 0;\n    let mut next_suffix_len\
    \ = 0;\n    let mut next_prefix_start = 0;\n    let mut next_prefix_len = 0;\n\
    \    let mut next_first_char = 0;\n    let mut next_last_char = 0;\n    let mut\
    \ next_end = 0;\n    let mut next_end_suffix = 0;\n    let mut next_end_prefix\
    \ = 0;\n    let string = string.as_bytes();\n    let string_len = string.len();\n\
    \    for curr_char in 0..string_len {\n        if curr_char + longest_suffix_len\
    \ > string_len - 1 {\n            break;\n        }\n        next_end = curr_char\
    \ + 1;\n        next_first_char = curr_char;\n        next_last_char = curr_char;\n\
    \        if string[next_first_char] == string[next_last_char] {\n            next_end_suffix\
    \ = next_end;\n            next_suffix_start = next_first_char;\n            next_suffix_len\
    \ = 1;\n            while next_end_suffix < string_len && string[next_first_char]\
    \ == string[next_last_char] {\n                next_first_char -= 1;\n       \
    \         next_last_char += 1;\n                next_end_suffix += 1;\n      \
    \          next_suffix_len += 2;\n            }\n            if next_suffix_len\
    \ > longest_suffix_len {\n                longest_suffix_\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpvg14s5ie.rs:58:3\n\
    \   |\n5  | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n30 |     for curr_char\
    \ in 0..string_len {\n   |                                    - unclosed delimiter\n\
    ...\n37 |         if string[next_first_char] == string[next_last_char] {\n   |\
    \                                                              - unclosed delimiter\n\
    ...\n47 |             if next_suffix_len > longest_suffix_len {\n   |        \
    \                                             - this delimiter might not be properly\
    \ closed...\n48 |                 longest_suffix_\n49 | }\n   | - ...as it matches\
    \ this but it has different indentation\n...\n58 | }\n   |   ^\n\nerror[E0425]:\
    \ cannot find value `longest_suffix_` in this scope\n  --> /tmp/tmpvg14s5ie.rs:48:17\n\
    \   |\n48 |                 longest_suffix_\n   |                 ^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `longest_suffix_len`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpvg14s5ie.rs:30:5\n   |\n5  |   fn\
    \ make_palindrome(string: String) -> String {\n   |                          \
    \               ------ expected `String` because of return type\n...\n30 | / \
    \    for curr_char in 0..string_len {\n31 | |         if curr_char + longest_suffix_len\
    \ > string_len - 1 {\n32 | |             break;\n33 | |         }\n...  |\n57\
    \ | |     assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n58 | | }\n   | |__^ expected struct `String`, found `()`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659821508
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let str_len = string.len();\n    if str_len == 0 {\n\
    \        return string;\n    }\n\n    let mut longest_suffix = String::new();\n\
    \    let mut longest_suffix_len = 0;\n    for i in 0..str_len {\n        if is_palindrome(&string[i..])\
    \ {\n            if i > longest_suffix_len {\n                longest_suffix =\
    \ string[i..].to_string();\n                longest_suffix_len = i;\n        \
    \    }\n        }\n    }\n\n    if longest_suffix_len == 0 {\n        return string;\n\
    \    }\n\n    let prefix = string[..longest_suffix_len].chars().rev().collect::<String>();\n\
    \    let mut result = string.clone();\n    result.push_str(&prefix);\n    result\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp56irfvft.rs:14:12\n   |\n14 |         if is_palindrome(&string[i..])\
    \ {\n   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659821508
- exit_code: 101
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let string_as_bytes = string.as_bytes();\n    let string_size\
    \ = string_as_bytes.len();\n    let mut offsets = vec![0usize; string_size];\n\
    \    let mut i = 1usize;\n    let mut candidate = 0usize;\n    while i < string_size\
    \ {\n        if candidate + offsets[candidate] == i {\n            while i + offsets[i]\
    \ < string_size\n                && string_as_bytes[offsets[i]] == string_as_bytes[i\
    \ + offsets[i]]\n            {\n                offsets[i] += 1;\n           \
    \ }\n            candidate = i;\n            i += 1;\n        } else {\n     \
    \       let mirror = candidate - (i - candidate);\n            if offsets[mirror]\
    \ < candidate + offsets[candidate] - i {\n                offsets[i] = offsets[mirror];\n\
    \                i += 1;\n            } else {\n                offsets[i] = candidate\
    \ + offsets[candidate] - i;\n                candidate = i;\n            }\n \
    \       }\n    }\n    let postfix_palindrome_size = offsets[string_size - 1];\n\
    \    let prefix_size = string_size - postfix_palindrome_size;\n    let prefix\
    \ = string[..prefix_size].chars().rev().collect::<String>();\n    [string, prefix].concat()\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpw10pz9k9.rs:31:43

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821508
- exit_code: 101
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let reversed = string.chars().rev().collect::<String>();\n\
    \    let mut reversed_string = string.clone();\n    let mut result = String::new();\n\
    \    for (i, c) in reversed.chars().enumerate() {\n        if c == string.chars().nth(i).unwrap()\
    \ {\n            result.push(c);\n        } else {\n            result.push(c);\n\
    \            reversed_string.push_str(&result);\n            return reversed_string;\n\
    \        }\n    }\n    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xyzz\"`,\n right: `\"xyzyx\"`', /tmp/tmphplt0m30.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821508
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut prefix_length: i32 = 0;\n    let mut postfix_length:\
    \ i32 = string.len() as i32 - 1;\n    let mut completed: bool = false;\n    let\
    \ mut candidate_string: String = string.clone();\n\n    while postfix_length >=\
    \ 0 && !completed {\n        if is_palindrome(&candidate_string) {\n         \
    \   completed = true;\n        } else {\n            candidate_string = string.clone();\n\
    \            let string_prefix: String = candidate_string\n                .drain(0..prefix_length\
    \ as usize)\n                .collect();\n            let string_prefix_reversed:\
    \ String = string_prefix.chars().rev().collect();\n            candidate_string.push_str(&string_prefix_reversed);\n\
    \            prefix_length += 1;\n            postfix_length -= 1;\n        }\n\
    \    }\n\n    candidate_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpbatzslcj.rs:12:12\n   |\n12 |         if is_palindrome(&candidate_string)\
    \ {\n   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659821508
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    // From the answer on https://stackoverflow.com/questions/17392769/how-to-find-the-longest-palindromic-substring-in-linear-time-in-java\n\
    \    let s = string.as_bytes();\n    let n = s.len();\n    let mut l = 0;\n  \
    \  let mut r = 0;\n    for i in 0..n {\n        let mut len1 = expand_around_center(s,\
    \ i, i);\n        let mut len2 = expand_around_center(s, i, i + 1);\n        let\
    \ len = max(len1, len2);\n        if len > r - l {\n            l = i - (len -\
    \ 1) / 2;\n            r = i + len / 2;\n        }\n    }\n    return string.chars().skip(r\
    \ + 1).collect::<String>() + string.chars().take(l).rev().collect::<String>().as_str();\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `expand_around_center` in this scope\n\
    \  --> /tmp/tmpy1snusta.rs:12:24\n   |\n12 |         let mut len1 = expand_around_center(s,\
    \ i, i);\n   |                        ^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `expand_around_center` in this scope\n  -->\
    \ /tmp/tmpy1snusta.rs:13:24\n   |\n13 |         let mut len2 = expand_around_center(s,\
    \ i, i + 1);\n   |                        ^^^^^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpy1snusta.rs:14:19\n\
    \   |\n14 |         let len = max(len1, len2);\n   |                   ^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this function\n   |\n1 \
    \ | use std::cmp::max;\n   |\n\nerror[E0277]: the trait bound `Chars<'_>: ExactSizeIterator`\
    \ is not satisfied\n  --> /tmp/tmpy1snusta.rs:20:84\n   |\n20 |     return string.chars().skip(r\
    \ + 1).collect::<String>() + string.chars().take(l).rev().collect::<String>().as_str();\n\
    \   |                                                                        \
    \            ^^^ the trait `ExactSizeIterator` is not implemented for `Chars<'_>`\n\
    \   |\n   = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `std::iter::Take<Chars<'_>>`\n\nerror[E0599]: the method `collect` exists\
    \ for struct `Rev<std::iter::Take<Chars<'_>>>`, but its trait bounds were not\
    \ satisfied\n  --> /tmp/tmpy1snusta.rs:20:90\n   |\n20 |        return string.chars().skip(r\
    \ + 1).collect::<String>() + string.chars().take(l).rev().collect::<String>().as_str();\n\
    \   |                                                                        \
    \                     ^^^^^^^ method cannot be called on `Rev<std::iter::Take<Chars<'_>>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `std::iter::Take<Chars<'_>>: DoubleEndedIterator`\n\
    \           which is required by `Rev<std::iter::Take<Chars<'_>>>: Iterator`\n\
    \           `Rev<std::iter::Take<Chars<'_>>>: Iterator`\n           which is required\
    \ by `"
  stdout: ''
  timestamp: 1659821508
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut palindrome = string.clone();\n    let suffix\
    \ = longest_suffix_palindrome(&string);\n    let string_len = string.len();\n\
    \    let suffix_len = suffix.len();\n    let prefix = if suffix_len == string_len\
    \ {\n        String::new()\n    } else {\n        string[0..(string_len - suffix_len)].to_string()\n\
    \    };\n    palindrome.push_str(&reverse_string(&prefix));\n    palindrome\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `longest_suffix_palindrome` in this\
    \ scope\n --> /tmp/tmps8mlchb5.rs:7:18\n  |\n7 |     let suffix = longest_suffix_palindrome(&string);\n\
    \  |                  ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `reverse_string` in this scope\n  --> /tmp/tmps8mlchb5.rs:15:26\n\
    \   |\n15 |     palindrome.push_str(&reverse_string(&prefix));\n   |         \
    \                 ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659821508
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut new_string = string.clone();\n    let reverse_string\
    \ = string.chars().rev().collect::<String>();\n    new_string.push_str(&reverse_string[..reverse_string.len()\
    \ - lps(&string)]);\n    new_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `lps` in this scope\n --> /tmp/tmpzsbtn107.rs:8:66\n\
    \  |\n8 |     new_string.push_str(&reverse_string[..reverse_string.len() - lps(&string)]);\n\
    \  |                                                                  ^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821508
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let lps = longest_palindromic_suffix(&string);\n  \
    \  let mut palindrome = String::new();\n    for ch in lps.chars().rev() {\n  \
    \      palindrome.push(ch);\n    }\n    palindrome.push_str(&string);\n    palindrome\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `longest_palindromic_suffix` in this\
    \ scope\n --> /tmp/tmp06t1fg02.rs:6:15\n  |\n6 |     let lps = longest_palindromic_suffix(&string);\n\
    \  |               ^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821508
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut prefix = String::from(\"\");\n    for (i, _)\
    \ in string.chars().enumerate() {\n        let s = string.chars().take(i).collect::<String>();\n\
    \        if is_palindrome(&s) {\n            prefix = s;\n        }\n    }\n \
    \   prefix.chars().rev().collect::<String>() + &string\n}\n\nfn main() {\n   \
    \ let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n -->\
    \ /tmp/tmp4w4k5ey2.rs:9:12\n  |\n9 |         if is_palindrome(&s) {\n  |     \
    \       ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821508
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let s = string.as_bytes();\n    let r = s.iter().rev().cloned();\n\
    \    let ns = s.len();\n    let mut z = vec![0; 2 * ns + 1];\n    z[0] = ns;\n\
    \    z[2 * ns] = 0;\n    let mut l = 0;\n    let mut r = 0;\n    for i in 1..2\
    \ * ns {\n        if i > r {\n            l = r = i;\n            while r < 2\
    \ * ns && s[(r - l) / 2] == z[r] {\n                r += 1;\n            }\n \
    \           z[i] = r - l;\n            r -= 1;\n        } else {\n           \
    \ let i1 = l + z[l - i];\n            if i1 < r {\n                z[i] = z[l\
    \ - i];\n            } else {\n                l = i;\n                while r\
    \ < 2 * ns && s[(r - l) / 2] == z[r] {\n                    r += 1;\n        \
    \        }\n                z[i] = r - l;\n                r -= 1;\n         \
    \   }\n        }\n    }\n    let mut pos = -1;\n    for i in (0..2 * ns + 1).rev()\
    \ {\n        if i % 2 == 0 && z[i] >= i && z[i] % 2 == 1 {\n            pos =\
    \ i;\n            break;\n        }\n    }\n    if pos >= ns {\n        string\n\
    \    } else {\n        let (prefix, _) = string.split_at(pos / 2);\n        prefix.to_string()\
    \ + &string\n    }\n}\n\nfn main() {\n    let candidate = make_palindrome;\n \
    \   assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2o6n2xj8.rs:16:17\n   |\n\
    16 |             l = r = i;\n   |                 ^^^^^ expected integer, found\
    \ `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2o6n2xj8.rs:17:51\n  \
    \ |\n17 |             while r < 2 * ns && s[(r - l) / 2] == z[r] {\n   |     \
    \                                              ^^^^ expected `u8`, found `usize`\n\
    \   |\nhelp: you can convert `s[(r - l) / 2]` from `u8` to `usize`, matching the\
    \ type of `z[r]`\n   |\n17 |             while r < 2 * ns && usize::from(s[(r\
    \ - l) / 2]) == z[r] {\n   |                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2o6n2xj8.rs:28:55\n   |\n28 |\
    \                 while r < 2 * ns && s[(r - l) / 2] == z[r] {\n   |         \
    \                                              ^^^^ expected `u8`, found `usize`\n\
    \   |\nhelp: you can convert `s[(r - l) / 2]` from `u8` to `usize`, matching the\
    \ type of `z[r]`\n   |\n28 |                 while r < 2 * ns && usize::from(s[(r\
    \ - l) / 2]) == z[r] {\n   |                                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp2o6n2xj8.rs:36:19\n\
    \   |\n36 |     let mut pos = -1;\n   |                   ^^ the trait `Neg` is\
    \ not implemented for `usize`\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659821508
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let rev_string = string.chars().rev().collect::<String>();\n\
    \    let prefix = find_common_prefix(string.clone(), rev_string);\n    let rev_prefix\
    \ = prefix.chars().rev().collect::<String>();\n    format!(\"{}{}{}\", string,\
    \ rev_prefix, rev_string)\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_common_prefix` in this scope\n\
    \ --> /tmp/tmptgx5z8qp.rs:7:18\n  |\n7 |     let prefix = find_common_prefix(string.clone(),\
    \ rev_string);\n  |                  ^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821508
- exit_code: 101
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed = String::new();\n    for c in string.chars().rev()\
    \ {\n        reversed.push(c);\n    }\n    let mut result = String::new();\n \
    \   let mut prefix = String::new();\n    for c in string.chars() {\n        prefix.push(c);\n\
    \        if prefix == reversed {\n            result.push_str(&prefix);\n    \
    \        break;\n        }\n    }\n    for c in string.chars().rev() {\n     \
    \   if c != result.chars().next().unwrap() {\n            result.push(c);\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmpcidu6z45.rs:20:39

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821508
- exit_code: 101
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut postfix = String::new();\n    let mut prefix\
    \ = String::new();\n    let mut longest_suffix_palindrome_length = 0;\n    for\
    \ (i, c) in string.chars().enumerate() {\n        let n = string.len();\n    \
    \    let reversed_index = n - i - 1;\n        postfix.push(c);\n        if postfix\
    \ == string[reversed_index..].chars().rev().collect::<String>() {\n          \
    \  prefix = string[..i + 1].to_string();\n            longest_suffix_palindrome_length\
    \ = i + 1;\n        }\n    }\n    let mut result = string.clone();\n    result.push_str(&prefix[longest_suffix_palindrome_length..].chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xyz\"`,\n right: `\"xyzyx\"`', /tmp/tmput3jrnsz.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821508
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let suffix_len = longest_palindromic_suffix_len(&string);\n\
    \    let prefix = &string[..string.len() - suffix_len];\n    let mut palindrome\
    \ = String::from(prefix);\n    palindrome.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `longest_palindromic_suffix_len` in\
    \ this scope\n --> /tmp/tmpszirnhag.rs:6:22\n  |\n6 |     let suffix_len = longest_palindromic_suffix_len(&string);\n\
    \  |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821508
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut str_bytes = string.into_bytes();\n    let mut\
    \ palindrome = Vec::new();\n    let mut postfix_length = 0;\n    let mut back_index\
    \ = str_bytes.len() - 1;\n    while back_index >= 0 {\n        if str_bytes[back_index]\
    \ == str_bytes[postfix_length] {\n            postfix_length += 1;\n        }\n\
    \        back_index -= 1;\n    }\n    if postfix_length == str_bytes.len() {\n\
    \        return string;\n    }\n    palindrome.extend_from_slice(&str_bytes[postfix_length..]);\n\
    \    palindrome.reverse();\n    palindrome.extend_from_slice(&str_bytes);\n  \
    \  String::from_utf8(palindrome).unwrap()\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n --> /tmp/tmpoemlyue9.rs:6:9\n\
    \  |\n6 |     let mut str_bytes = string.into_bytes();\n  |         ----^^^^^^^^^\n\
    \  |         |\n  |         help: remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `string`\n   --> /tmp/tmpoemlyue9.rs:17:16\n\
    \    |\n5   | fn make_palindrome(string: String) -> String {\n    |          \
    \          ------ move occurs because `string` has type `String`, which does not\
    \ implement the `Copy` trait\n6   |     let mut str_bytes = string.into_bytes();\n\
    \    |                                ------------ `string` moved due to this\
    \ method call\n...\n17  |         return string;\n    |                ^^^^^^\
    \ value used here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `string`\n\nerror: aborting due to previous error;\
    \ 1 warning emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659821508
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut reversed_string = string.clone();\n    reversed_string.reverse();\n\
    \    let string_len = string.len();\n    let mut result_string = String::new();\n\
    \    let mut max_palindrome_len = 0;\n    for i in 0..string_len {\n        let\
    \ candidate_palindrome = String::from(&string[i..]);\n        if candidate_palindrome\
    \ == reversed_string[0..candidate_palindrome.len()] {\n            max_palindrome_len\
    \ = candidate_palindrome.len();\n            break;\n        }\n    }\n    result_string.push_str(&string[max_palindrome_len..]);\n\
    \    result_string.push_str(&string[0..max_palindrome_len].chars().rev().collect::<String>());\n\
    \    result_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n \
    \   assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n --> /tmp/tmp9sdayjz7.rs:7:21\n  |\n7 |     reversed_string.reverse();\n\
    \  |                     ^^^^^^^ help: there is an associated function with a\
    \ similar name: `reserve`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659821508
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    if string.is_empty() {\n        return string;\n  \
    \  }\n\n    let postfix = match string.chars().next().map(|c| c.to_lowercase().next().unwrap())\
    \ {\n        Some('a') => string,\n        _ => make_palindrome(string[1..].to_string()),\n\
    \    };\n\n    let mut prefix = postfix.clone();\n    prefix.reverse();\n    format!(\"\
    {}{}\", prefix, postfix)\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp471h3ydy.rs:16:12\n   |\n16 |     prefix.reverse();\n\
    \   |            ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reserve`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659821508
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut result = String::from(&string);\n    let mut\
    \ i = result.len() - 1;\n    while i > 0 {\n        if is_palindrome(result.clone())\
    \ {\n            break;\n        }\n        let c = result.remove(i);\n      \
    \  result.insert(0, c);\n        i -= 1;\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n -->\
    \ /tmp/tmp1zki_r5a.rs:9:12\n  |\n9 |         if is_palindrome(result.clone())\
    \ {\n  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659821508
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    // Longest postfix of the string which is a palindrome.\n\
    \    let (max_postfix_len, _) = string.find_max_postfix_palindrome();\n\n    //\
    \ The prefix that is not a palindrome. This will be concatenated to the reversed\
    \ string.\n    let prefix = string.split_at(string.len() - max_postfix_len).0;\n\
    \n    // Concatenate prefix to the reversed string.\n    format!(\"{}{}\", prefix,\
    \ prefix.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `find_max_postfix_palindrome` found for struct\
    \ `String` in the current scope\n --> /tmp/tmpgxo0rork.rs:7:39\n  |\n7 |     let\
    \ (max_postfix_len, _) = string.find_max_postfix_palindrome();\n  |          \
    \                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in\
    \ `String`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659821508
- exit_code: 101
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut s = string.as_bytes();\n    let n = s.len();\n\
    \    let mut i = 0;\n    while i < n / 2 && s[i] == s[n - i - 1] {\n        i\
    \ += 1;\n    }\n    let mut prefix = &s[i..];\n    if prefix.is_empty() {\n  \
    \      return string;\n    }\n    prefix = &s[..n - i];\n    let prefix_len =\
    \ prefix.len();\n    let mut res = String::from_utf8(prefix.to_vec()).unwrap();\n\
    \    res.push_str(&string);\n    for j in 0..prefix_len {\n        res.push(prefix[prefix_len\
    \ - j - 1] as char);\n    }\n    res\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xxx\"`,\n right: `\"x\"`', /tmp/tmpj3sfomjr.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821508
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut result = String::new();\n    result.push_str(&string);\n\
    \    let (start, end) = find_palindrome_indexes(&string);\n    result.push_str(&reverse_string(&string[0..start]));\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_palindrome_indexes` in this scope\n\
    \ --> /tmp/tmpc657pnqw.rs:8:24\n  |\n8 |     let (start, end) = find_palindrome_indexes(&string);\n\
    \  |                        ^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find function `reverse_string` in this scope\n --> /tmp/tmpc657pnqw.rs:9:22\n\
    \  |\n9 |     result.push_str(&reverse_string(&string[0..start]));\n  |      \
    \                ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659821508
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut string = string;\n    let longest_palindrome_postfix\
    \ = find_longest_palindrome_postfix(&string);\n    let len = string.len();\n \
    \   let palindrome_postfix_len = longest_palindrome_postfix.len();\n    string.push_str(&string[..len\
    \ - palindrome_postfix_len].chars().rev().collect::<String>());\n    string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_longest_palindrome_postfix` in\
    \ this scope\n --> /tmp/tmpuwqz5o0r.rs:7:38\n  |\n7 |     let longest_palindrome_postfix\
    \ = find_longest_palindrome_postfix(&string);\n  |                           \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821508
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let reverse = string.clone().chars().rev().collect::<String>();\n\
    \    let longest_common_substring = longest_common_substring(string.clone(), reverse);\n\
    \    let missing_part = string.chars().take(string.len() - longest_common_substring.len()).collect::<String>();\n\
    \    missing_part + &string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `longest_common_substring` in this scope\n\
    \ --> /tmp/tmpt2dv8mjn.rs:7:36\n  |\n7 |     let longest_common_substring = longest_common_substring(string.clone(),\
    \ reverse);\n  |                                    ^^^^^^^^^^^^^^^^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821508
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let suffix_len = longest_palindromic_suffix_len(&string);\n\
    \    let prefix = &string[..string.len() - suffix_len];\n    let prefix_reversed\
    \ = prefix.chars().rev().collect::<String>();\n    format!(\"{}{}{}\", prefix_reversed,\
    \ &string, prefix_reversed)\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `longest_palindromic_suffix_len` in\
    \ this scope\n --> /tmp/tmpuiw1jf6g.rs:6:22\n  |\n6 |     let suffix_len = longest_palindromic_suffix_len(&string);\n\
    \  |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821508
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut s = string.clone();\n    let mut p = string.chars().rev().collect::<String>();\n\
    \    let mut s_r = s.clone();\n    s_r.reverse();\n    let n = s.len();\n    let\
    \ z = z_algorithm(p + \"$\" + &s);\n    let i = z.iter().position(|&x| x == n).unwrap();\n\
    \    let j = (i + n) - 1;\n    s.push_str(&s_r[..n - j - 1].chars().rev().collect::<String>());\n\
    \    s\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `z_algorithm` in this scope\n  --> /tmp/tmpr92k093d.rs:11:13\n\
    \   |\n11 |     let z = z_algorithm(p + \"$\" + &s);\n   |             ^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0599]: no method named `reverse` found for\
    \ struct `String` in the current scope\n --> /tmp/tmpr92k093d.rs:9:9\n  |\n9 |\
    \     s_r.reverse();\n  |         ^^^^^^^ help: there is an associated function\
    \ with a similar name: `reserve`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821508
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let (longest_postfix, prefix) = find_longest_palindromic_suffix(&string);\n\
    \    let palindrome = prefix.chars().rev().collect::<String>() + &string;\n  \
    \  let result = palindrome + &longest_postfix;\n    result\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_longest_palindromic_suffix` in\
    \ this scope\n --> /tmp/tmpinjpebhd.rs:6:37\n  |\n6 |     let (longest_postfix,\
    \ prefix) = find_longest_palindromic_suffix(&string);\n  |                   \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821508
- exit_code: 101
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let mut palindrome = String::from(string.as_str());\n\
    \    let mut reversed_prefix = String::new();\n    let mut longest_palindrome_length\
    \ = 0;\n    for (index, _) in string.char_indices().rev() {\n        reversed_prefix.push(string.chars().nth(index).unwrap());\n\
    \        if palindrome.starts_with(reversed_prefix.as_str()) {\n            if\
    \ palindrome.len() % 2 == 0 && palindrome.len() / 2 == index + 1 {\n         \
    \       longest_palindrome_length = index + 1;\n                break;\n     \
    \       } else if palindrome.len() % 2 == 1 && palindrome.len() / 2 == index {\n\
    \                longest_palindrome_length = index;\n                break;\n\
    \            }\n        }\n    }\n    if longest_palindrome_length != 0 {\n  \
    \      for i in (longest_palindrome_length..string.len()).rev() {\n          \
    \  palindrome.push(string.chars().nth(i).unwrap());\n        }\n    }\n    palindrome\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xyz\"`,\n right: `\"xyzyx\"`', /tmp/tmpck12j257.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821508
- exit_code: 101
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfn make_palindrome(string:\
    \ String) -> String {\n    let start_pos = string.find(|c: char| c != '#').unwrap_or(string.len());\n\
    \    let (mut v, mut w) = string[..start_pos].split_at(start_pos / 2);\n    if\
    \ start_pos % 2 == 0 {\n        v = &v[..v.len() - 1];\n    }\n    // now v is\
    \ the prefix and w is the suffix\n    // v is reversed\n    let mut result = String::new();\n\
    \    result.push_str(w);\n    result.push_str(v.chars().rev().collect::<String>().as_str());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmppdsbq9kb.rs:9:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821508
