language: rs
name: HumanEval_7_filter_by_substring
results:
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut filtered_strings = Vec::new();\n    for string in strings {\n\
    \        if string.contains(&substring) {\n            filtered_strings.push(string);\n\
    \        }\n    }\n    filtered_strings\n}\n\nfn main() {\n    let candidate =\
    \ filter_by_substring;\n    assert_eq!(candidate(Vec::<String>::new(), String::from(\"\
    john\")), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"xxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xxx\")), vec![String::from(\"\
    xxx\"), String::from(\"xxxAAA\"), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|string| string.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    for s in strings {\n        if s.contains(&substring)\
    \ {\n            result.push(s);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = filter_by_substring;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ String::from(\"john\")), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"xxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xxx\")), vec![String::from(\"\
    xxx\"), String::from(\"xxxAAA\"), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    for string in strings {\n        if\
    \ string.contains(&substring) {\n            result.push(string);\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|string| string.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    for string in strings {\n        if\
    \ string.contains(&substring) {\n            result.push(string);\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|string| string.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut filtered: Vec<String> = Vec::new();\n    for s in strings {\n\
    \        if s.contains(&substring) {\n            filtered.push(s);\n        }\n\
    \    }\n    filtered\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let v2: Vec<String> = strings\n        .into_iter()\n        .filter(|x|\
    \ x.contains(&substring))\n        .collect();\n    v2\n}\n\nfn main() {\n   \
    \ let candidate = filter_by_substring;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ String::from(\"john\")), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"xxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xxx\")), vec![String::from(\"\
    xxx\"), String::from(\"xxxAAA\"), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let lower_substring = substring.to_lowercase();\n    strings\n      \
    \  .into_iter()\n        .filter(|string| string.to_lowercase().contains(&lower_substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut result: Vec<String> = Vec::new();\n    for strng in strings {\n\
    \        if strng.contains(&substring) {\n            result.push(strng);\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n  strings.into_iter().filter(|s| s.contains(&substring)).collect()\n}\n\n\
    fn main() {\n    let candidate = filter_by_substring;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ String::from(\"john\")), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"xxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xxx\")), vec![String::from(\"\
    xxx\"), String::from(\"xxxAAA\"), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut new_list: Vec<String> = Vec::new();\n    for string in strings\
    \ {\n        if string.contains(&substring) {\n            new_list.push(string);\n\
    \        }\n    }\n    new_list\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    for string in strings {\n        if\
    \ string.contains(&substring) {\n            result.push(string)\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let lower_substring = substring.to_lowercase();\n    strings\n      \
    \  .into_iter()\n        .filter(|string| string.to_lowercase().contains(&lower_substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|string| string.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|string| string.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut result: Vec<String> = Vec::new();\n    for s in strings {\n \
    \       if s.contains(&substring) {\n            result.push(s);\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut filtered: Vec<String> = Vec::new();\n    for s in strings {\n\
    \        if s.contains(&substring) {\n            filtered.push(s);\n        }\n\
    \    }\n    filtered\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    for e in strings {\n        if e.contains(&substring)\
    \ {\n            result.push(e);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = filter_by_substring;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ String::from(\"john\")), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"xxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xxx\")), vec![String::from(\"\
    xxx\"), String::from(\"xxxAAA\"), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|string| string.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut out: Vec<String> = Vec::new();\n    for s in strings {\n    \
    \    if s.contains(&substring) {\n            out.push(s);\n        }\n    }\n\
    \    out\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ String::from(\"john\")), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"xxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xxx\")), vec![String::from(\"\
    xxx\"), String::from(\"xxxAAA\"), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|string| string.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|x| x.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    for string in strings {\n        if\
    \ string.contains(&substring) {\n            result.push(string)\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut res = Vec::new();\n    for s in strings {\n        if s.contains(&substring)\
    \ {\n            res.push(s);\n        }\n    }\n    res\n}\n\nfn main() {\n \
    \   let candidate = filter_by_substring;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ String::from(\"john\")), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"xxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xxx\")), vec![String::from(\"\
    xxx\"), String::from(\"xxxAAA\"), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut out: Vec<String> = Vec::new();\n    for string in strings {\n\
    \        if string.contains(&substring) {\n            out.push(string);\n   \
    \     }\n    }\n    out\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|string| string.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    for e in strings {\n        if e.contains(&substring)\
    \ {\n            result.push(e);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = filter_by_substring;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ String::from(\"john\")), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"xxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xxx\")), vec![String::from(\"\
    xxx\"), String::from(\"xxxAAA\"), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|string| string.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut result: Vec<String> = Vec::new();\n    for string in strings\
    \ {\n        if string.contains(&substring) {\n            result.push(string);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|string| string.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    for string in strings {\n        if\
    \ string.contains(&substring) {\n            result.push(string);\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|string| string.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut ret_vec = Vec::new();\n    for s in strings {\n        if s.contains(&substring)\
    \ {\n            ret_vec.push(s);\n        }\n    }\n    ret_vec\n}\n\nfn main()\
    \ {\n    let candidate = filter_by_substring;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ String::from(\"john\")), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"xxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xxx\")), vec![String::from(\"\
    xxx\"), String::from(\"xxxAAA\"), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let filtered_strings: Vec<String> = strings\n        .into_iter()\n \
    \       .filter(|s| s.contains(&substring))\n        .collect();\n    filtered_strings\n\
    }\n\nfn main() {\n    let candidate = filter_by_substring;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ String::from(\"john\")), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"xxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xxx\")), vec![String::from(\"\
    xxx\"), String::from(\"xxxAAA\"), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|string| string.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut filtered: Vec<String> = Vec::new();\n    for string in strings\
    \ {\n        if string.contains(&substring) {\n            filtered.push(string);\n\
    \        }\n    }\n    filtered\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|string| string.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|string| string.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|string| string.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|str| str.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|string| string.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|string| string.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|string| string.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut filtered: Vec<String> = Vec::new();\n    for string in strings\
    \ {\n        if string.contains(&substring) {\n            filtered.push(string);\n\
    \        }\n    }\n    filtered\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    for ref s in strings {\n        if\
    \ s.contains(&substring) {\n            result.push(s.clone());\n        }\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut filtered: Vec<String> = Vec::new();\n    for string in strings\
    \ {\n        if string.contains(&substring) {\n            filtered.push(string)\n\
    \        }\n    }\n    filtered\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n  strings.into_iter().filter(|s| s.contains(&substring)).collect()\n}\n\n\
    fn main() {\n    let candidate = filter_by_substring;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ String::from(\"john\")), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"xxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xxx\")), vec![String::from(\"\
    xxx\"), String::from(\"xxxAAA\"), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let lowercase_substring = substring.to_lowercase();\n    strings\n  \
    \      .into_iter()\n        .filter(|file_name| file_name.to_lowercase().contains(&lowercase_substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let filtered: Vec<String> = strings\n        .into_iter()\n        .filter(|v|\
    \ v.contains(&substring))\n        .collect();\n    filtered\n}\n\nfn main() {\n\
    \    let candidate = filter_by_substring;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ String::from(\"john\")), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"xxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xxx\")), vec![String::from(\"\
    xxx\"), String::from(\"xxxAAA\"), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut filtered_strings = Vec::new();\n    for string in strings {\n\
    \        if string.contains(&substring) {\n            filtered_strings.push(string);\n\
    \        }\n    }\n    filtered_strings\n}\n\nfn main() {\n    let candidate =\
    \ filter_by_substring;\n    assert_eq!(candidate(Vec::<String>::new(), String::from(\"\
    john\")), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"xxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xxx\")), vec![String::from(\"\
    xxx\"), String::from(\"xxxAAA\"), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 1
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n  let substring_bytes = substring.as_bytes();\n  let substring_len = substring_bytes.len();\n\
    \  let mut filtered_strings = Vec::new();\n  for s in strings {\n    let string_bytes\
    \ = s.as_bytes();\n    if string_bytes.len() < substring_len {\n      continue;\n\
    \    }\n    let mut c = 0;\n    while c <= string_bytes.len() - substring_len\
    \ {\n      if string_bytes[c..c + substring_len] == substring_bytes {\n      \
    \  filtered_strings.push(s.clone());\n        break;\n      }\n      c += 1;\n\
    \    }\n  }\n  filtered_strings\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `[u8]` with `&[u8]`\n  --> /tmp/tmpxuwcqzr0.rs:13:45\n\
    \   |\n13 |       if string_bytes[c..c + substring_len] == substring_bytes {\n\
    \   |                                             ^^ no implementation for `[u8]\
    \ == &[u8]`\n   |\n   = help: the trait `PartialEq<&[u8]>` is not implemented\
    \ for `[u8]`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|str| str.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|string| string.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    return strings.into_iter().filter(|string| string.contains(&substring)).collect();\n\
    }\n\nfn main() {\n    let candidate = filter_by_substring;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ String::from(\"john\")), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"xxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xxx\")), vec![String::from(\"\
    xxx\"), String::from(\"xxxAAA\"), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut filtered_strings = Vec::new();\n    for s in strings {\n    \
    \    if s.contains(&substring) {\n            filtered_strings.push(s);\n    \
    \    }\n    }\n    filtered_strings\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut filtered_strings = Vec::new();\n    for string in strings {\n\
    \        if string.contains(&substring) {\n            filtered_strings.push(string);\n\
    \        }\n    }\n    filtered_strings\n}\n\nfn main() {\n    let candidate =\
    \ filter_by_substring;\n    assert_eq!(candidate(Vec::<String>::new(), String::from(\"\
    john\")), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"xxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xxx\")), vec![String::from(\"\
    xxx\"), String::from(\"xxxAAA\"), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|string| string.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|x| x.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut filtered_strings = Vec::new();\n    for string in strings {\n\
    \        if string.contains(&substring) {\n            filtered_strings.push(string);\n\
    \        }\n    }\n    filtered_strings\n}\n\nfn main() {\n    let candidate =\
    \ filter_by_substring;\n    assert_eq!(candidate(Vec::<String>::new(), String::from(\"\
    john\")), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"xxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xxx\")), vec![String::from(\"\
    xxx\"), String::from(\"xxxAAA\"), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut matches = Vec::new();\n    for string in strings {\n        if\
    \ string.contains(&substring) {\n            matches.push(string);\n        }\n\
    \    }\n    matches\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|string| string.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|string| string.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut filtered_strings = Vec::new();\n    for string in strings {\n\
    \        if string.contains(&substring) {\n            filtered_strings.push(string);\n\
    \        }\n    }\n    filtered_strings\n}\n\nfn main() {\n    let candidate =\
    \ filter_by_substring;\n    assert_eq!(candidate(Vec::<String>::new(), String::from(\"\
    john\")), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"xxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xxx\")), vec![String::from(\"\
    xxx\"), String::from(\"xxxAAA\"), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|string| string.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut filtered: Vec<String> = Vec::new();\n    for string in strings\
    \ {\n        if string.contains(&substring) {\n            filtered.push(string)\n\
    \        }\n    }\n    filtered\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|string| string.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|string| string.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|string| string.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut filtered: Vec<String> = Vec::new();\n    for string in strings\
    \ {\n        if string.contains(&substring) {\n            filtered.push(string)\n\
    \        }\n    }\n    filtered\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|string| string.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let filtered: Vec<String> = strings\n        .into_iter()\n        .filter(|string|\
    \ string.contains(&substring))\n        .collect();\n    filtered\n}\n\nfn main()\
    \ {\n    let candidate = filter_by_substring;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ String::from(\"john\")), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"xxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xxx\")), vec![String::from(\"\
    xxx\"), String::from(\"xxxAAA\"), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let filtered: Vec<String> = strings\n        .into_iter()\n        .filter(|s|\
    \ s.contains(&substring))\n        .collect();\n    filtered\n}\n\nfn main() {\n\
    \    let candidate = filter_by_substring;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ String::from(\"john\")), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"xxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xxx\")), vec![String::from(\"\
    xxx\"), String::from(\"xxxAAA\"), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|x| x.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n  return strings.into_iter().filter(|s| s.contains(&substring)).collect();\n\
    }\n\nfn main() {\n    let candidate = filter_by_substring;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ String::from(\"john\")), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"xxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xxx\")), vec![String::from(\"\
    xxx\"), String::from(\"xxxAAA\"), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut filtered_strings = Vec::new();\n    for s in strings {\n    \
    \    if s.contains(&substring) {\n            filtered_strings.push(s);\n    \
    \    }\n    }\n    filtered_strings\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|string| string.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|string| string.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    return strings.into_iter().filter(|s| s.contains(&substring)).collect();\n\
    }\n\nfn main() {\n    let candidate = filter_by_substring;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ String::from(\"john\")), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"xxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xxx\")), vec![String::from(\"\
    xxx\"), String::from(\"xxxAAA\"), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    return strings.into_iter().filter(|string| string.contains(&substring)).collect();\n\
    }\n\nfn main() {\n    let candidate = filter_by_substring;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ String::from(\"john\")), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"xxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xxx\")), vec![String::from(\"\
    xxx\"), String::from(\"xxxAAA\"), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut filtered: Vec<String> = Vec::new();\n    for s in strings {\n\
    \        if s.contains(&substring) {\n            filtered.push(s);\n        }\n\
    \    }\n    filtered\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut strings_new = Vec::new();\n    for string in strings {\n    \
    \    if string.contains(&substring) {\n            strings_new.push(string);\n\
    \        }\n    }\n    strings_new\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let uppercase_substring = substring.to_uppercase();\n    strings\n  \
    \      .into_iter()\n        .filter(|string| string.to_uppercase().contains(&uppercase_substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    for string in strings {\n        if\
    \ string.contains(&substring) {\n            result.push(string);\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|word| word.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823169
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut filtered: Vec<String> = Vec::new();\n    for s in strings {\n\
    \        if s.contains(&substring) {\n            filtered.push(s);\n        }\n\
    \    }\n    filtered\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut filtered_strings = Vec::new();\n    for s in strings {\n    \
    \    if s.contains(&substring) {\n            filtered_strings.push(s);\n    \
    \    }\n    }\n    filtered_strings\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    return strings.into_iter().filter(|s| s.contains(&substring)).collect();\n\
    }\n\nfn main() {\n    let candidate = filter_by_substring;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ String::from(\"john\")), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"xxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xxx\")), vec![String::from(\"\
    xxx\"), String::from(\"xxxAAA\"), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let substring = substring.to_lowercase();\n    strings\n        .into_iter()\n\
    \        .filter(|s| s.to_lowercase().contains(&substring))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = filter_by_substring;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ String::from(\"john\")), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"xxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xxx\")), vec![String::from(\"\
    xxx\"), String::from(\"xxxAAA\"), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut ret = Vec::new();\n    for string in strings {\n        if string.contains(&substring)\
    \ {\n            ret.push(string);\n        }\n    }\n    ret\n}\n\nfn main()\
    \ {\n    let candidate = filter_by_substring;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ String::from(\"john\")), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"xxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xxx\")), vec![String::from(\"\
    xxx\"), String::from(\"xxxAAA\"), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    for s in strings {\n        if s.contains(&substring)\
    \ {\n            result.push(s);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = filter_by_substring;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ String::from(\"john\")), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"xxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xxx\")), vec![String::from(\"\
    xxx\"), String::from(\"xxxAAA\"), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    for string in strings {\n        if\
    \ string.contains(&substring) {\n            result.push(string);\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|x| x.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|string| string.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut result: Vec<String> = Vec::new();\n    for string in strings\
    \ {\n        if string.contains(&substring) {\n            result.push(string)\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut vector: Vec<String> = Vec::new();\n    for i in strings {\n \
    \       if i.contains(&substring) {\n            vector.push(i);\n        }\n\
    \    }\n    vector\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823169
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut new_list: Vec<String> = Vec::new();\n    for s in strings {\n\
    \        if s.contains(&substring) {\n            new_list.push(s);\n        }\n\
    \    }\n    new_list\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut filtered_strings = Vec::new();\n    for s in strings {\n    \
    \    if s.contains(&substring) {\n            filtered_strings.push(s);\n    \
    \    }\n    }\n    filtered_strings\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut filtered_words = Vec::new();\n    for item in strings {\n   \
    \     if item.contains(&substring) {\n            filtered_words.push(item)\n\
    \        }\n    }\n    filtered_words\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823169
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut filtered: Vec<String> = Vec::new();\n    for string in strings\
    \ {\n        if string.contains(&substring) {\n            filtered.push(string);\n\
    \        }\n    }\n    filtered\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|x| x.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut results = Vec::new();\n    for s in strings {\n        if s.contains(&substring)\
    \ {\n            results.push(s);\n        }\n    }\n    results\n}\n\nfn main()\
    \ {\n    let candidate = filter_by_substring;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ String::from(\"john\")), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"xxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xxx\")), vec![String::from(\"\
    xxx\"), String::from(\"xxxAAA\"), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823169
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    for string in strings {\n        if\
    \ string.contains(&substring) {\n            result.push(string);\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|string| string.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut filtered_strings = Vec::new();\n    for s in strings {\n    \
    \    if s.contains(&substring) {\n            filtered_strings.push(s);\n    \
    \    }\n    }\n    filtered_strings\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|value| value.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    for string in strings {\n        if\
    \ string.contains(&substring) {\n            result.push(string);\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|string| string.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    return strings.into_iter().filter(|x| x.contains(&substring)).collect();\n\
    }\n\nfn main() {\n    let candidate = filter_by_substring;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ String::from(\"john\")), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"xxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xxx\")), vec![String::from(\"\
    xxx\"), String::from(\"xxxAAA\"), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823169
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|string| string.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|string| string.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let res = strings\n        .into_iter()\n        .filter(|a| a.contains(&substring))\n\
    \        .collect();\n    res\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823169
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|string| string.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut filtered_strings = Vec::new();\n    for string in strings {\n\
    \        if string.contains(&substring) {\n            filtered_strings.push(string);\n\
    \        }\n    }\n    filtered_strings\n}\n\nfn main() {\n    let candidate =\
    \ filter_by_substring;\n    assert_eq!(candidate(Vec::<String>::new(), String::from(\"\
    john\")), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"xxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xxx\")), vec![String::from(\"\
    xxx\"), String::from(\"xxxAAA\"), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|str| str.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    for string in strings {\n        if\
    \ string.contains(&substring) {\n            result.push(string);\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    return strings.into_iter().filter(|string| string.contains(&substring)).collect();\n\
    }\n\nfn main() {\n    let candidate = filter_by_substring;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ String::from(\"john\")), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"xxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xxx\")), vec![String::from(\"\
    xxx\"), String::from(\"xxxAAA\"), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    for s in strings {\n        if s.contains(&substring)\
    \ {\n            result.push(s);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = filter_by_substring;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ String::from(\"john\")), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"xxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xxx\")), vec![String::from(\"\
    xxx\"), String::from(\"xxxAAA\"), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut filtered: Vec<String> = Vec::new();\n    for s in strings {\n\
    \        if s.contains(&substring) {\n            filtered.push(s);\n        }\n\
    \    }\n    filtered\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut ret = Vec::new();\n    for s in strings {\n        if s.contains(&substring)\
    \ {\n            ret.push(s);\n        }\n    }\n    ret\n}\n\nfn main() {\n \
    \   let candidate = filter_by_substring;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ String::from(\"john\")), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"xxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xxx\")), vec![String::from(\"\
    xxx\"), String::from(\"xxxAAA\"), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823169
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|string| string.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|string| string.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut filtered_strings = Vec::new();\n    for string in strings {\n\
    \        if string.contains(&substring) {\n            filtered_strings.push(string);\n\
    \        }\n    }\n    filtered_strings\n}\n\nfn main() {\n    let candidate =\
    \ filter_by_substring;\n    assert_eq!(candidate(Vec::<String>::new(), String::from(\"\
    john\")), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"xxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xxx\")), vec![String::from(\"\
    xxx\"), String::from(\"xxxAAA\"), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let substring = substring.to_lowercase();\n    let filtered: Vec<String>\
    \ = strings\n        .into_iter()\n        .filter(|s| s.to_lowercase().contains(&substring))\n\
    \        .collect();\n    filtered\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823169
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut new_vec = Vec::new();\n    for string in strings {\n        if\
    \ string.contains(&substring) {\n            new_vec.push(string)\n        }\n\
    \    }\n    new_vec\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823169
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|string| string.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|string| string.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|x| x.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|string| string.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    strings\n        .into_iter()\n        .filter(|item| item.contains(&substring))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823169
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut results = Vec::new();\n    for s in strings {\n        if s.contains(&substring)\
    \ {\n            results.push(s)\n        }\n    }\n    results\n}\n\nfn main()\
    \ {\n    let candidate = filter_by_substring;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ String::from(\"john\")), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"xxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xxx\")), vec![String::from(\"\
    xxx\"), String::from(\"xxxAAA\"), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    xxx\"), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823169
- exit_code: 0
  program: "/// Filter an input list of strings only for ones that contain given substring\n\
    fn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String>\
    \ {\n    let mut filtered: Vec<String> = Vec::new();\n    for string in strings\
    \ {\n        if string.contains(&substring) {\n            filtered.push(string);\n\
    \        }\n    }\n    filtered\n}\n\nfn main() {\n    let candidate = filter_by_substring;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), String::from(\"john\")), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"xxx\"), String::from(\"asd\"), String::from(\"\
    xxy\"), String::from(\"john doe\"), String::from(\"xxxAAA\"), String::from(\"\
    xxx\")], String::from(\"xxx\")), vec![String::from(\"xxx\"), String::from(\"xxxAAA\"\
    ), String::from(\"xxx\")]);\n    assert_eq!(candidate(vec![String::from(\"xxx\"\
    ), String::from(\"asd\"), String::from(\"aaaxxy\"), String::from(\"john doe\"\
    ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xx\")), vec![String::from(\"\
    xxx\"), String::from(\"aaaxxy\"), String::from(\"xxxAAA\"), String::from(\"xxx\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"grunt\"), String::from(\"trumpet\"\
    ), String::from(\"prune\"), String::from(\"gruesome\")], String::from(\"run\"\
    )), vec![String::from(\"grunt\"), String::from(\"prune\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823168
