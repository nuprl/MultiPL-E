language: rs
name: HumanEval_8_sum_product
results:
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let (mut sum, mut product) = (0, 1);\n    for num in\
    \ numbers {\n        sum += num;\n        product *= num;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (\n        numbers.iter().sum(),\n        numbers.iter().product()\n\
    \    )\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let (mut sum, mut product) = (0, 1);\n    for n in\
    \ numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ number in numbers {\n        sum += number;\n        product *= number;\n  \
    \  }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ i in numbers {\n        sum += i;\n        product *= i;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 1);\n \
    \   }\n    numbers.iter().fold((0, 1), |acc, &item| (acc.0 + item, acc.1 * item))\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().fold((0, 1), |acc, n| (acc.0 + n, acc.1\
    \ * n))\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().sum();\n    let product =\
    \ if numbers.len() == 0 { 1 } else { numbers.iter().product() };\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (numbers.iter().sum(), numbers.iter().product())\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().fold((0, 1), |acc, x| (acc.0 + x, acc.1\
    \ * x))\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ n in numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    // let mut sum = 0;\n    // let mut product = 1;\n\
    \    //\n    // for num in numbers {\n    //     sum += num;\n    //     product\
    \ *= num;\n    // }\n    //\n    // (sum, product)\n\n    // let sum = numbers.iter().fold(0,\
    \ |acc, &x| acc + x);\n    // let product = numbers.iter().fold(1, |acc, &x| acc\
    \ * x);\n    //\n    // (sum, product)\n\n    numbers.iter().fold((0, 1), |(sum,\
    \ product), &num| (sum + num, product * num))\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 101
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpao66ezby.rs:4:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().fold((0, 1), |acc, x| (acc.0 + x, acc.1\
    \ * x))\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (numbers.iter().sum(), numbers.iter().product())\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 1);\n \
    \   }\n\n    let sum = numbers.iter().sum();\n    let product = numbers.iter().product();\n\
    \n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n   \
    \ assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |acc, x| acc + x);\n\
    \    let product = numbers.iter().fold(1, |acc, x| acc * x);\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    // Write your code here\n    let sum = numbers.iter().fold(0,\
    \ |a, &b| a + b);\n    let product = numbers.iter().fold(1, |a, &b| a * b);\n\
    \    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ i in numbers {\n        sum += i;\n        product *= i;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 101
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    // TODO: implement the function\n    unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpo3d9cmer.rs:5:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().sum();\n    let product =\
    \ numbers.iter().product();\n    (sum, product)\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let len = numbers.len();\n    match len {\n       \
    \ 0 => (0, 1),\n        _ => (numbers.iter().sum(), numbers.iter().product()),\n\
    \    }\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut s = 0;\n    let mut p = 1;\n    for n in numbers\
    \ {\n        s += n;\n        p *= n;\n    }\n    (s, p)\n}\n\nfn main() {\n \
    \   let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ i in numbers {\n        sum += i;\n        product *= i;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |acc, &n| acc + n);\n\
    \    let product = numbers.iter().fold(1, |acc, &n| acc * n);\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ i in numbers {\n        sum += i;\n        product *= i;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (numbers.iter().fold(0, |acc, num| acc + num), numbers.iter().fold(1,\
    \ |acc, num| acc * num))\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (numbers.iter().sum(), numbers.iter().product())\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (\n        numbers.iter().sum(),\n        numbers.iter().product(),\n\
    \    )\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (\n        numbers.iter().sum(),\n        numbers.iter().product()\n\
    \    )\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    // Implement me!\n    let mut sum = 0;\n    let mut\
    \ product = 1;\n    for number in numbers {\n        sum += number;\n        product\
    \ *= number;\n    }\n    (sum, product)\n}\n\nfn main() {\n    let candidate =\
    \ sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |sum, num| sum + num);\n\
    \    let product = numbers.iter().fold(1, |prod, num| prod * num);\n    (sum,\
    \ product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (numbers.iter().sum(), numbers.iter().product())\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (numbers.iter().sum(), numbers.iter().product())\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 101
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    // TODO\n    unimplemented!();\n}\n\nfn main() {\n\
    \    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpvr_ftq2l.rs:5:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ n in numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (numbers.iter().sum(), numbers.iter().product())\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ i in numbers {\n        sum += i;\n        product *= i;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 101
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (0, 1)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0, 1)`,\n right: `(3, 1)`', /tmp/tmpvvtd1stf.rs:10:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut product = 1;\n    let mut sum = 0;\n    for\
    \ i in numbers {\n        product *= i;\n        sum += i;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ n in numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |sum, num| sum + num);\n\
    \    let product = numbers.iter().fold(1, |product, num| product * num);\n   \
    \ (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |acc, x| acc + x);\n\
    \    let product = numbers.iter().fold(1, |acc, x| acc * x);\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 101
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpml8_y2nj.rs:4:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut res = (0, 1);\n    for n in numbers {\n   \
    \     res.0 += n;\n        res.1 *= n;\n    }\n    res\n}\n\nfn main() {\n   \
    \ let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (\n        numbers.iter().sum(),\n        numbers.iter().product(),\n\
    \    )\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let res = numbers.iter().fold((0, 1), |acc, &x| (acc.0\
    \ + x, acc.1 * x));\n    (res.0, res.1)\n}\n\nfn main() {\n    let candidate =\
    \ sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ n in numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ i in numbers {\n        sum += i;\n        product *= i;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |acc, v| acc + v);\n\
    \    let prod = numbers.iter().fold(1, |acc, v| acc * v);\n    (sum, prod)\n}\n\
    \nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().fold((0, 1), |(sum, product), &number|\
    \ (sum + number, product * number))\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ i in numbers {\n        sum += i;\n        product *= i;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |acc, &x| acc + x);\n\
    \    let product = numbers.iter().fold(1, |acc, &x| acc * x);\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (numbers.iter().sum(), numbers.iter().product())\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ n in numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ number in numbers {\n        sum += number;\n        product *= number;\n  \
    \  }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n  // TODO\n  let (sum, product) = (numbers.iter().fold(0,\
    \ |sum, i| sum + i), numbers.iter().fold(1, |prod, i| prod * i));\n  (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut prod = 1;\n    let mut sum = 0;\n    for i\
    \ in numbers {\n        prod *= i;\n        sum += i;\n    }\n    (sum, prod)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (numbers.iter().sum(), numbers.iter().product())\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().fold((0, 1), |acc, n| (acc.0 + n, acc.1\
    \ * n))\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().sum();\n    let product =\
    \ if numbers.is_empty() {\n        1\n    } else {\n        numbers.iter().product()\n\
    \    };\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = if numbers.is_empty() {\n        0\n    }\
    \ else {\n        numbers.iter().fold(0, |sum, i| sum + i)\n    };\n    let product\
    \ = if numbers.is_empty() {\n        1\n    } else {\n        numbers.iter().fold(1,\
    \ |prod, i| prod * i)\n    };\n    (sum, product)\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ n in numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |acc, &x| acc + x);\n\
    \    let product = numbers.iter().fold(1, |acc, &x| acc * x);\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let product = numbers.iter().fold(1, |acc, &x| acc\
    \ * x);\n    let sum = numbers.iter().fold(0, |acc, &x| acc + x);\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |acc, x| acc + x);\n\
    \    let product = numbers.iter().fold(1, |acc, x| acc * x);\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 101
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpml8_y2nj.rs:4:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823244
- exit_code: 101
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (0, 1)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0, 1)`,\n right: `(3, 1)`', /tmp/tmpvvtd1stf.rs:10:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ num in numbers {\n        sum += num;\n        product *= num;\n    }\n    (sum,\
    \ product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 101
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (0, 1)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0, 1)`,\n right: `(3, 1)`', /tmp/tmpvvtd1stf.rs:10:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ number in numbers {\n        sum += number;\n        product *= number;\n  \
    \  }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut s = 0;\n    let mut p = 1;\n    for x in numbers\
    \ {\n        s += x;\n        p *= x;\n    }\n    (s, p)\n}\n\nfn main() {\n \
    \   let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (\n        numbers.iter().fold(0, |sum, n| sum + n),\n\
    \        numbers.iter().fold(1, |prod, n| prod * n),\n    )\n}\n\nfn main() {\n\
    \    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 101
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpml8_y2nj.rs:4:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().sum();\n    let product =\
    \ numbers.iter().product();\n    (sum, product)\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut product = 1;\n    let mut sum = 0;\n    for\
    \ num in numbers {\n        product *= num;\n        sum += num;\n    }\n    (sum,\
    \ product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ i in numbers {\n        sum += i;\n        product *= i;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().sum();\n    let product =\
    \ numbers.iter().product();\n    (sum, product)\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ num in numbers {\n        sum += num;\n        product *= num;\n    }\n    (sum,\
    \ product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 1);\n \
    \   }\n    let mut sum = 0;\n    let mut product = 1;\n    for number in numbers\
    \ {\n        sum += number;\n        product *= number;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().fold((0, 1), |acc, &x| (acc.0 + x, acc.1\
    \ * x))\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().sum();\n    let product =\
    \ numbers.iter().product();\n    (sum, product)\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 1);\n \
    \   }\n    numbers.iter().fold((0, 1), |(s, p), n| (s + n, p * n))\n}\n\nfn main()\
    \ {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |acc, x| acc + x);\n\
    \    let product = numbers.iter().fold(1, |acc, x| acc * x);\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut s = 0;\n    let mut p = 1;\n    for n in numbers\
    \ {\n        s += n;\n        p *= n;\n    }\n    (s, p)\n}\n\nfn main() {\n \
    \   let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ n in numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 1);\n \
    \   }\n    let sum = numbers.iter().sum();\n    let product = numbers.iter().product();\n\
    \    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 101
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpao66ezby.rs:4:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ x in numbers {\n        sum += x;\n        product *= x;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (numbers.iter().fold(0, |sum, n| sum + n),\n     numbers.iter().fold(1,\
    \ |prod, n| prod * n))\n}\n\nfn main() {\n    let candidate = sum_product;\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |sum, x| sum + x);\n\
    \    let product = numbers.iter().fold(1, |product, x| product * x);\n    (sum,\
    \ product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let (sum, product) = numbers.iter().fold((0, 1), |tup,\
    \ elem| {\n        (tup.0 + elem, tup.1 * elem)\n    });\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut s: isize = 0;\n    let mut p: isize = 1;\n\
    \    for n in numbers {\n        s += n;\n        p *= n;\n    }\n    (s, p)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 101
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpml8_y2nj.rs:4:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (numbers.iter().sum(), numbers.iter().product())\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().fold((0, 1), |acc, x| (acc.0 + x, acc.1\
    \ * x))\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (numbers.iter().sum(), numbers.iter().product())\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (numbers.iter().sum(), numbers.iter().product())\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 101
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpao66ezby.rs:4:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().fold((0, 1), |(acc1, acc2), x| (acc1\
    \ + x, acc2 * x))\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (numbers.iter().fold(0, |sum, v| sum + v), numbers.iter().fold(1,\
    \ |prod, v| prod * v))\n}\n\nfn main() {\n    let candidate = sum_product;\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |acc, &cur| acc +\
    \ cur);\n    let product = numbers.iter().fold(1, |acc, &cur| acc * cur);\n  \
    \  (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().fold((0, 1), |acc, x| (acc.0 + x, acc.1\
    \ * x))\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |acc, cur| acc + cur);\n\
    \    let product = numbers.iter().fold(1, |acc, cur| acc * cur);\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |acc, &x| acc + x);\n\
    \    let product = numbers.iter().fold(1, |acc, &x| acc * x);\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 101
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpao66ezby.rs:4:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().fold((0, 1), |(sum, product), i| (sum\
    \ + i, product * i))\n}\n\nfn main() {\n    let candidate = sum_product;\n   \
    \ assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let (mut sum, mut product) = (0, 1);\n    for n in\
    \ numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ i in numbers {\n        sum += i;\n        product *= i;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ number in numbers {\n        sum += number;\n        product *= number;\n  \
    \  }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().fold((0, 1), |acc, n| (acc.0 + n, acc.1\
    \ * n))\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().fold((0, 1), |(acc, acc1), &n| (acc\
    \ + n, acc1 * n))\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 101
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpao66ezby.rs:4:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ n in numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 1);\n \
    \   }\n\n    let sum = numbers.iter().sum();\n    let product = numbers.iter().product();\n\
    \n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n   \
    \ assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |a, &b| a + b);\n\
    \    let product = numbers.iter().fold(1, |a, &b| a * b);\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ num in numbers {\n        sum += num;\n        product *= num;\n    }\n    (sum,\
    \ product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ i in &numbers {\n        sum += i;\n        product *= i;\n    }\n    (sum,\
    \ product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 101
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    // TODO: replace with your code\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpgh8ssnkr.rs:5:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ number in numbers {\n        sum += number;\n        product *= number;\n  \
    \  }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (numbers.iter().sum(), numbers.iter().product())\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (numbers.iter().fold(0, |acc, i| acc + i), numbers.iter().fold(1,\
    \ |acc, i| acc * i))\n}\n\nfn main() {\n    let candidate = sum_product;\n   \
    \ assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 101
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpao66ezby.rs:4:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().sum();\n    let product =\
    \ numbers.iter().product();\n    (sum, product)\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let s = numbers.iter().fold(0, |acc, x| acc + x);\n\
    \    let p = numbers.iter().fold(1, |acc, x| acc * x);\n    (s, p)\n}\n\nfn main()\
    \ {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let (sum, product) = numbers.iter().fold((0, 1), |(sum,\
    \ product), x| (sum + x, product * x));\n    (sum, product)\n}\n\nfn main() {\n\
    \    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (\n        numbers.iter().fold(0, |acc, x| acc + x),\n\
    \        numbers.iter().fold(1, |acc, x| acc * x),\n    )\n}\n\nfn main() {\n\
    \    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 1);\n \
    \   }\n    let mut sum = 0;\n    let mut product = 1;\n    for i in numbers {\n\
    \        sum += i;\n        product *= i;\n    }\n    (sum, product)\n}\n\nfn\
    \ main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (numbers.iter().sum(), numbers.iter().product())\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().sum();\n    let product =\
    \ numbers.iter().product();\n    (sum, product)\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |sum, x| sum + x);\n\
    \    let product = numbers.iter().fold(1, |product, x| product * x);\n    (sum,\
    \ product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ num in numbers {\n        sum += num;\n        product *= num;\n    }\n    (sum,\
    \ product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 1
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let empty_vector = Vec::new();\n    if numbers.is_empty()\
    \ {\n        return (0, 1);\n    } else {\n        let mut sum = 0;\n        let\
    \ mut product = 1;\n        for num in numbers {\n            sum += num;\n  \
    \          product *= num;\n        }\n        return (sum, product);\n    }\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n --> /tmp/tmpoyh30699.rs:4:24\n\
    \  |\n4 |     let empty_vector = Vec::new();\n  |         ------------   ^^^^^^^^\
    \ cannot infer type for type parameter `T`\n  |         |\n  |         consider\
    \ giving `empty_vector` the explicit type `Vec<T>`, where the type parameter `T`\
    \ is specified\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659823244
- exit_code: 101
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpao66ezby.rs:4:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().sum();\n    let product =\
    \ numbers.iter().product();\n    (sum, product)\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ num in numbers {\n        sum += num;\n        product *= num;\n    }\n    (sum,\
    \ product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 101
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpml8_y2nj.rs:4:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (\n        numbers.iter().fold(0, |acc, x| acc + x),\n\
    \        numbers.iter().fold(1, |acc, x| acc * x),\n    )\n}\n\nfn main() {\n\
    \    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (\n        numbers.iter().sum(),\n        numbers.iter().product(),\n\
    \    )\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (numbers.iter().sum(), numbers.iter().product())\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ i in numbers {\n        sum += i;\n        product *= i;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 101
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpml8_y2nj.rs:4:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().sum();\n    let product =\
    \ numbers.iter().product();\n    (sum, product)\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().sum();\n    let product =\
    \ numbers.iter().product();\n    (sum, product)\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().fold((0, 1), |acc, n| (acc.0 + n, acc.1\
    \ * n))\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().sum();\n    let product =\
    \ if sum == 0 { 1 } else { numbers.iter().product() };\n    (sum, product)\n}\n\
    \nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ n in numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 1);\n \
    \   }\n\n    let mut product = 1;\n    let mut sum = 0;\n\n    for n in numbers\
    \ {\n        product *= n;\n        sum += n;\n    }\n\n    (sum, product)\n}\n\
    \nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ i in numbers {\n        sum += i;\n        product *= i;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (numbers.iter().sum(), numbers.iter().product())\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().fold((0, 1), |acc, x| (acc.0 + x, acc.1\
    \ * x))\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n  if numbers.len() == 0 {\n    return (0, 1);\n  }\n  (numbers.iter().fold(0,\
    \ |acc, &val| acc + val), numbers.iter().fold(1, |acc, &val| acc * val))\n}\n\n\
    fn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().fold((0, 1), |(sum, product), &current|\
    \ (sum + current, product * current))\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 1);\n \
    \   }\n\n    numbers.iter().fold((0, 1), |acc, &x| (acc.0 + x, acc.1 * x))\n}\n\
    \nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ n in numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().fold((0, 1), |acc, number| (acc.0 +\
    \ number, acc.1 * number))\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 101
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpao66ezby.rs:4:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let (mut sum, mut product) = (0, 1);\n    for number\
    \ in numbers {\n        sum += number;\n        product *= number;\n    }\n  \
    \  (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (numbers.iter().fold(0, |sum, x| sum + x),\n    numbers.iter().fold(1,\
    \ |prod, x| prod * x))\n}\n\nfn main() {\n    let candidate = sum_product;\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (numbers.iter().sum(), numbers.iter().product())\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (numbers.iter().sum(), numbers.iter().product())\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().fold((0, 1), |(sum, prod), num| (sum\
    \ + num, prod * num))\n}\n\nfn main() {\n    let candidate = sum_product;\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (numbers.iter().fold(0, |acc, x| acc + x),\n     numbers.iter().fold(1,\
    \ |acc, x| acc * x))\n}\n\nfn main() {\n    let candidate = sum_product;\n   \
    \ assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ i in numbers {\n        sum += i;\n        product *= i;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ i in numbers {\n        sum += i;\n        product *= i;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ i in numbers {\n        sum += i;\n        product *= i;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().sum();\n    let product =\
    \ numbers.iter().product();\n    (sum, product)\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().sum();\n    let product =\
    \ numbers.iter().product();\n    (sum, product)\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (numbers.iter().sum(), numbers.iter().product())\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |acc, x| acc + x);\n\
    \    let product = numbers.iter().fold(1, |acc, x| acc * x);\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 101
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpao66ezby.rs:4:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (\n        numbers.iter().fold(0, |acc, x| acc + x),\n\
    \        numbers.iter().fold(1, |acc, x| acc * x),\n    )\n}\n\nfn main() {\n\
    \    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().fold((0, 1), |acc, n| (acc.0 + n, acc.1\
    \ * n))\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |sum, n| sum + n);\n\
    \    let product = numbers.iter().fold(1, |product, n| product * n);\n    (sum,\
    \ product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (\n        numbers.iter().fold(0, |acc, &x| acc + x),\n\
    \        numbers.iter().fold(1, |acc, &x| acc * x),\n    )\n}\n\nfn main() {\n\
    \    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |acc, x| acc + x);\n\
    \    let product = numbers.iter().fold(1, |acc, x| acc * x);\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().sum();\n    let product =\
    \ if numbers.is_empty() {\n        1\n    } else {\n        numbers.iter().product()\n\
    \    };\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().fold((0, 1), |(s, p), &n| (s + n, p\
    \ * n))\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut res = (0, 1);\n    for x in numbers {\n   \
    \     res.0 += x;\n        res.1 *= x;\n    }\n    res\n}\n\nfn main() {\n   \
    \ let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 1
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (\n        sum(numbers.clone()),\n        product(numbers.clone()),\n\
    \    )\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sum` in this scope\n --> /tmp/tmp0cl_c_t1.rs:5:9\n\
    \  |\n5 |         sum(numbers.clone()),\n  |         ^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `product` in this scope\n --> /tmp/tmp0cl_c_t1.rs:6:9\n\
    \  |\n6 |         product(numbers.clone()),\n  |         ^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    // TODO\n    let mut sum: isize = 0;\n    let mut product:\
    \ isize = 1;\n    for i in numbers.iter() {\n        sum += i;\n        product\
    \ *= i;\n    }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().fold((0, 1), |acc, &x| (acc.0 + x, acc.1\
    \ * x))\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (numbers.iter().sum(), numbers.iter().product())\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let product = numbers.iter().fold(1, |acc, &x| acc\
    \ * x);\n    let sum = numbers.iter().fold(0, |acc, &x| acc + x);\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ x in numbers {\n        sum += x;\n        product *= x;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (numbers.iter().sum(), numbers.iter().product())\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 101
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (0, 1)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0, 1)`,\n right: `(3, 1)`', /tmp/tmpvvtd1stf.rs:10:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823244
- exit_code: 101
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    // TODO: sum_product\n    (0, 0)\n}\n\nfn main() {\n\
    \    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0, 0)`,\n right: `(0, 1)`', /tmp/tmpzzr4hj8r.rs:10:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823245
- exit_code: 101
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    // YOUR SOLUTION HERE\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp_t556sw0.rs:5:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |a, b| a + b);\n \
    \   let product = numbers.iter().fold(1, |a, b| a * b);\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let (s, p) = numbers.iter().fold((0, 1), |(sum, product),\
    \ i| (sum + i, product * i));\n    (s, p)\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 101
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpao66ezby.rs:4:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().fold((0, 1), |acc, x| (acc.0 + x, acc.1\
    \ * x))\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    // TODO\n    let mut sum: isize = 0;\n    let mut product:\
    \ isize = 1;\n    for n in numbers.iter() {\n        sum += n;\n        product\
    \ *= n;\n    }\n    return (sum, product);\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 101
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpao66ezby.rs:4:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (\n        numbers.iter().fold(0, |acc, x| acc + x),\n\
    \        numbers.iter().fold(1, |acc, x| acc * x),\n    )\n}\n\nfn main() {\n\
    \    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ i in numbers {\n        sum += i;\n        product *= i;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ num in numbers {\n        sum += num;\n        product *= num;\n    }\n    (sum,\
    \ product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().fold((0, 1), |acc, x| (acc.0 + x, acc.1\
    \ * x))\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823244
- exit_code: 0
  program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let is_empty = numbers.is_empty();\n    let sum = numbers.iter().sum();\n\
    \    let product = if is_empty { 1 } else { numbers.iter().product() };\n    (sum,\
    \ product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823245
