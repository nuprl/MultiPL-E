language: rs
name: HumanEval_127_intersection
results:
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start, end)\
    \ = match (interval1.0, interval1.1, interval2.0, interval2.1) {\n        (a,\
    \ b, c, d) if a > b => (b, a),\n        (a, b, c, d) if c > d => (d, c),\n   \
    \     (a, b, c, d) if a <= c && c <= b && b <= d => (c, b),\n        (a, b, c,\
    \ d) if a <= c && c <= d && d <= b => (c, d),\n        (a, b, c, d) if c <= a\
    \ && a <= d && d <= b => (a, d),\n        (a, b, c, d) if c <= a && a <= b &&\
    \ b <= d => (a, b),\n        _ => (0, 0),\n    };\n    let mut primes = vec![2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97];\n    primes.retain(|p| start <= *p && *p <= end);\n    if primes.len()\
    \ > 0 {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n\
    \    }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpgkouc9m4.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821493
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    let mut start = 0;\n    let mut end = 0;\n \
    \   let mut result = \"NO\";\n    if b >= c && d >= a {\n        start = a > c\
    \ ? a : c;\n        end = b < d ? b : d;\n        let len = end - start + 1;\n\
    \        if len > 1 {\n            let mut is_prime = true;\n            for i\
    \ in 2..len {\n                if len % i == 0 {\n                    is_prime\
    \ = false;\n                    break;\n                }\n            }\n   \
    \         if is_prime {\n                result = \"YES\";\n            }\n  \
    \      }\n    }\n    result.to_string()\n}\n\nfn main() {\n    let candidate =\
    \ intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `a`\n\
    \  --> /tmp/tmpzfcrk92n.rs:21:25\n   |\n21 |         start = a > c ? a : c;\n\
    \   |                         ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\
    \nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659821493
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    if interval1.0 >\
    \ interval2.1 || interval2.0 > interval1.1 {\n        return \"NO\".to_string();\n\
    \    }\n    let mut arr = [0; 50];\n    let mut i = 0;\n    for j in 2..50 {\n\
    \        if arr[j] == 0 {\n            arr[i] = j;\n            i += 1;\n    \
    \        let mut k = j * 2;\n            while k < 50 {\n                arr[k]\
    \ = 1;\n                k += j;\n            }\n        }\n    }\n    let mut\
    \ max: isize = 0;\n    let mut min: isize = isize::max_value();\n    let mut interval_length\
    \ = 0;\n    if interval1.0 > interval2.0 {\n        max = interval1.0;\n     \
    \   min = interval2.1;\n    } else {\n        max = interval2.0;\n        min\
    \ = interval1.1;\n    }\n    interval_length = min - max;\n    for a in 0..i {\n\
    \        if arr[a] as isize == interval_length {\n            return \"YES\".to_string();\n\
    \        }\n    }\n    \"NO\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"NO\"`,\n right: `\"YES\"`', /tmp/tmpsy6ka8nr.rs:54:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821493
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let mut i1 = interval1;\n\
    \    let mut i2 = interval2;\n    i1.0 = std::cmp::max(i1.0, i2.0);\n    i1.1\
    \ = std::cmp::min(i1.1, i2.1);\n    if i1.0 > i1.1 {\n        return \"NO\".to_string();\n\
    \    }\n    is_prime(i1.1 - i1.0 + 1)\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpiuvbyf3x.rs:22:5\n\
    \   |\n22 |     is_prime(i1.1 - i1.0 + 1)\n   |     ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821493
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let start = if start1\
    \ > start2 { start1 } else { start2 };\n    let end = if end1 < end2 { end1 }\
    \ else { end2 };\n    let diff = if start <= end { end - start } else { 0 };\n\
    \    if diff == 1 {\n        return \"NO\".to_string();\n    }\n    for i in 2..diff\
    \ {\n        if diff % i == 0 {\n            return \"NO\".to_string();\n    \
    \    }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate =\
    \ intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp3jimfuls.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821493
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (interval1_min,\
    \ interval1_max) = interval1;\n    let (interval2_min, interval2_max) = interval2;\n\
    \    if interval1_min > interval2_max || interval2_min > interval1_max {\n   \
    \     return \"NO\".to_string();\n    }\n    let (interval_min, interval_max)\
    \ = (\n        interval1_min.max(interval2_min),\n        interval1_max.min(interval2_max),\n\
    \    );\n    if is_prime(interval_max - interval_min) {\n        \"YES\".to_string()\n\
    \    } else {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp9b3mr_pq.rs:24:8\n\
    \   |\n24 |     if is_prime(interval_max - interval_min) {\n   |        ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821493
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    if interval1.0 >\
    \ interval2.1 || interval2.0 > interval1.1 {\n        return \"NO\".to_string();\n\
    \    }\n    let start = std::cmp::max(interval1.0, interval2.0);\n    let end\
    \ = std::cmp::min(interval1.1, interval2.1);\n    if start > end {\n        return\
    \ \"NO\".to_string();\n    }\n    if is_prime(end - start + 1) {\n        return\
    \ \"YES\".to_string();\n    }\n    return \"NO\".to_string();\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpyin4juye.rs:23:8\n\
    \   |\n23 |     if is_prime(end - start + 1) {\n   |        ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821493
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let start = max(interval1.0,\
    \ interval2.0);\n    let end = min(interval1.1, interval2.1);\n    if start <=\
    \ end {\n        if primes::is_prime(end - start + 1) {\n            return \"\
    YES\".to_string();\n        }\n    }\n    \"NO\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `primes`\n\
    \  --> /tmp/tmpz0jk85tw.rs:18:12\n   |\n18 |         if primes::is_prime(end -\
    \ start + 1) {\n   |            ^^^^^^ use of undeclared crate or module `primes`\n\
    \nerror[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpz0jk85tw.rs:15:17\n\
    \   |\n15 |     let start = max(interval1.0, interval2.0);\n   |             \
    \    ^^^ not found in this scope\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::max;\n   |\n\nerror[E0425]: cannot find function `min`\
    \ in this scope\n  --> /tmp/tmpz0jk85tw.rs:16:15\n   |\n16 |     let end = min(interval1.1,\
    \ interval2.1);\n   |               ^^^\n...\n25 | fn main() {\n   | ---------\
    \ similarly named function `main` defined here\n   |\nhelp: a function with a\
    \ similar name exists\n   |\n16 |     let end = main(interval1.1, interval2.1);\n\
    \   |               ~~~~\nhelp: consider importing this function\n   |\n1  | use\
    \ std::cmp::min;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0425, E0433.\nFor more information about an error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821493
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = start1.max(start2);\n\
    \    let end = end1.min(end2);\n    if is_prime(end - start + 1) {\n        \"\
    YES\".to_string()\n    } else {\n        \"NO\".to_string()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpqx9cmda4.rs:22:8\n\
    \   |\n22 |     if is_prime(end - start + 1) {\n   |        ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821493
- exit_code: 0
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let mut start =\
    \ interval1.0;\n    let mut end = interval1.1;\n    let mut result = 0;\n    if\
    \ interval2.0 > interval1.0 {\n        start = interval2.0;\n    }\n    if interval2.1\
    \ < interval1.1 {\n        end = interval2.1;\n    }\n    if start > end {\n \
    \       return \"NO\".to_string();\n    }\n    result = end - start;\n    if result\
    \ < 2 {\n        return \"NO\".to_string();\n    }\n    for i in 2..result-1 {\n\
    \        if result % i == 0 {\n            return \"NO\".to_string();\n      \
    \  }\n    }\n    return \"YES\".to_string();\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821493
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if end1 < start2 || end2\
    \ < start1 {\n        return \"NO\".to_string();\n    }\n    let start = if start1\
    \ > start2 { start1 } else { start2 };\n    let end = if end1 < end2 { end1 }\
    \ else { end2 };\n    (end - start + 1).is_prime().to_string()\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_prime` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpxkuml5jw.rs:22:23\n   |\n22 |     (end - start\
    \ + 1).is_prime().to_string()\n   |                       ^^^^^^^^ method not\
    \ found in `isize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659821493
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let mut res = \"\
    NO\";\n    let (mut min1, mut max1) = (interval1.0, interval1.1);\n    let (mut\
    \ min2, mut max2) = (interval2.0, interval2.1);\n    if min1 > max1 {\n      \
    \  std::mem::swap(&mut min1, &mut max1);\n    }\n    if min2 > max2 {\n      \
    \  std::mem::swap(&mut min2, &mut max2);\n    }\n    if min1 < min2 {\n      \
    \  std::mem::swap(&mut min1, &mut min2);\n        std::mem::swap(&mut max1, &mut\
    \ max2);\n    }\n    if min1 <= max2 {\n        let mut length = max2 - min1 +\
    \ 1;\n        if max1 < max2 {\n            length = max1 - min1 + 1;\n      \
    \  }\n        let mut is_prime = true;\n        for i in 2..(length + 1) {\n \
    \           if length % i == 0 {\n                is_prime = false;\n        \
    \        break;\n            }\n        }\n        if is_prime {\n           \
    \ res = \"YES\";\n        }\n    }\n    res.to_string()\n}\n\nfn main() {\n  \
    \  let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n \
    \   assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2,\
    \ 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1,\
    \ -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpmayc4sbu.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821493
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (interval1_start,\
    \ interval1_end) = interval1;\n    let (interval2_start, interval2_end) = interval2;\n\
    \    let intersection_start = interval1_start.max(interval2_start);\n    let intersection_end\
    \ = interval1_end.min(interval2_end);\n    let intersection_len = (intersection_end\
    \ - intersection_start + 1).abs();\n    if intersection_len < 2 {\n        return\
    \ \"NO\".to_string();\n    }\n    for i in 2..intersection_len {\n        if intersection_len\
    \ % i == 0 {\n            return \"NO\".to_string();\n        }\n    }\n    \"\
    YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp91dt3z2b.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821493
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (mut i1_start,\
    \ mut i1_end) = interval1;\n    let (mut i2_start, mut i2_end) = interval2;\n\
    \    let (mut start, mut end) = (0, 0);\n    if i1_start > i1_end {\n        std::mem::swap(&mut\
    \ i1_start, &mut i1_end);\n    }\n    if i2_start > i2_end {\n        std::mem::swap(&mut\
    \ i2_start, &mut i2_end);\n    }\n    if i1_start <= i2_start {\n        start\
    \ = i2_start;\n    } else {\n        start = i1_start;\n    }\n    if i1_end >=\
    \ i2_end {\n        end = i2_end;\n    } else {\n        end = i1_end;\n    }\n\
    \    if start > end {\n        return \"NO\".to_string();\n    } else {\n    \
    \    let mut length = end - start + 1;\n        if length == 1 {\n           \
    \ return \"YES\".to_string();\n        }\n        let mut prime = false;\n   \
    \     let mut i = length / 2;\n        while i > 1 {\n            if length %\
    \ i == 0 {\n                prime = false;\n                break;\n         \
    \   } else {\n                prime = true;\n            }\n            i -= 1;\n\
    \        }\n        if prime {\n            return \"YES\".to_string();\n    \
    \    } else {\n            return \"NO\".to_string();\n        }\n    }\n}\n\n\
    fn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2),\
    \ (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpgda7985v.rs:62:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821493
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let mut vec = vec![];\n\
    \    if interval1.0 <= interval2.0 && interval2.0 <= interval1.1 {\n        vec.push(interval2.0);\n\
    \    }\n    if interval1.0 <= interval2.1 && interval2.1 <= interval1.1 {\n  \
    \      vec.push(interval2.1);\n    }\n    if interval2.0 <= interval1.0 && interval1.0\
    \ <= interval2.1 {\n        vec.push(interval1.0);\n    }\n    if interval2.0\
    \ <= interval1.1 && interval1.1 <= interval2.1 {\n        vec.push(interval1.1);\n\
    \    }\n    if vec.len() == 2 {\n        println!(\"{:?}\", vec);\n        let\
    \ res = vec[1] - vec[0];\n        if res == 1 {\n            return \"NO\".to_string();\n\
    \        }\n        for i in 2..res {\n            if res % i == 0 {\n       \
    \         return \"NO\".to_string();\n            }\n        }\n        return\
    \ \"YES\".to_string();\n    }\n    return \"NO\".to_string();\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpe0h9aex_.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: '[2, 2]

    '
  timestamp: 1659821493
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (intersection,\
    \ result) = if interval1.0 <= interval2.0 {\n        (interval1.0..=interval2.1,\
    \ interval2.0..=interval1.1)\n    } else {\n        (interval2.0..=interval1.1,\
    \ interval1.0..=interval2.1)\n    };\n    let intersects = intersection.start\
    \ <= intersection.end;\n    if intersects {\n        if is_prime(intersection.end\
    \ - intersection.start) {\n            return \"YES\".to_string();\n        }\n\
    \    }\n    if !intersects {\n        return \"NO\".to_string();\n    }\n    if\
    \ is_prime(result.end - result.start) {\n        return \"YES\".to_string();\n\
    \    }\n    \"NO\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpubl94n0w.rs:22:12\n\
    \   |\n22 |         if is_prime(intersection.end - intersection.start) {\n   |\
    \            ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `is_prime` in this scope\n  --> /tmp/tmpubl94n0w.rs:29:8\n   |\n29 |     if\
    \ is_prime(result.end - result.start) {\n   |        ^^^^^^^^ not found in this\
    \ scope\n\nerror[E0616]: field `start` of struct `RangeInclusive` is private\n\
    \  --> /tmp/tmpubl94n0w.rs:20:35\n   |\n20 |     let intersects = intersection.start\
    \ <= intersection.end;\n   |                                   ^^^^^ private field\n\
    \   |\nhelp: a method `start` also exists, call it with parentheses\n   |\n20\
    \ |     let intersects = intersection.start() <= intersection.end;\n   |     \
    \                                   ++\n\nerror[E0616]: field `end` of struct\
    \ `RangeInclusive` is private\n  --> /tmp/tmpubl94n0w.rs:20:57\n   |\n20 |   \
    \  let intersects = intersection.start <= intersection.end;\n   |            \
    \                                             ^^^ private field\n   |\nhelp: a\
    \ method `end` also exists, call it with parentheses\n   |\n20 |     let intersects\
    \ = intersection.start <= intersection.end();\n   |                          \
    \                                  ++\n\nerror[E0616]: field `end` of struct `RangeInclusive`\
    \ is private\n  --> /tmp/tmpubl94n0w.rs:22:34\n   |\n22 |         if is_prime(intersection.end\
    \ - intersection.start) {\n   |                                  ^^^ private field\n\
    \   |\nhelp: a method `end` also exists, call it with parentheses\n   |\n22 |\
    \         if is_prime(intersection.end() - intersection.start) {\n   |       \
    \                              ++\n\nerror[E0616]: field `start` of struct `RangeInclusive`\
    \ is private\n  --> /tmp/tmpubl94n0w.rs:22:53\n   |\n22 |         if is_prime(intersection.end\
    \ - intersection.start) {\n   |                                              \
    \       ^^^^^ private field\n   |\nhelp: a method `start` also exists, call it\
    \ with parentheses\n   |\n22 |         if is_prime(intersection.end - intersectio"
  stdout: ''
  timestamp: 1659821493
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (min, max) =\
    \ if interval1.0 > interval2.0 {\n        (interval1.0, interval2.1)\n    } else\
    \ {\n        (interval2.0, interval1.1)\n    };\n    if min > max {\n        return\
    \ \"NO\".to_string();\n    }\n    if is_prime(max - min + 1) {\n        \"YES\"\
    .to_string()\n    } else {\n        \"NO\".to_string()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpr6833xfw.rs:23:8\n\
    \   |\n23 |     if is_prime(max - min + 1) {\n   |        ^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821493
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    // Find bounds of\
    \ intersection\n    let (min_x, max_x) = if interval1.0 <= interval2.0 {\n   \
    \     (interval2.0, interval1.1)\n    } else {\n        (interval1.0, interval2.1)\n\
    \    };\n    let (max_x, min_x) = if max_x <= min_x {\n        (min_x, max_x)\n\
    \    } else {\n        (max_x, min_x)\n    };\n    // If no intersection, return\
    \ no\n    if max_x < min_x {\n        return \"NO\".to_string();\n    }\n    //\
    \ Get length of intersection\n    let diff = max_x - min_x;\n    // Find if prime\n\
    \    let mut is_prime = true;\n    if diff > 1 {\n        let mut i = 2;\n   \
    \     while i * i <= diff {\n            if diff % i == 0 {\n                is_prime\
    \ = false;\n                break;\n            }\n            i += 1;\n     \
    \   }\n    }\n    // Return\n    if is_prime {\n        \"YES\".to_string()\n\
    \    } else {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp4fuayocg.rs:54:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821493
- exit_code: -1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    if interval1.0 >\
    \ interval2.1 || interval2.0 > interval1.1 {\n        return \"NO\".to_string();\n\
    \    }\n    let mut range = Vec::new();\n    range.push(interval1.0);\n    range.push(interval1.1);\n\
    \    range.push(interval2.0);\n    range.push(interval2.1);\n    range.sort();\n\
    \    let start = range[1];\n    let end = range[2];\n    let mut length = end\
    \ - start;\n    if length == 1 {\n        return \"NO\".to_string();\n    }\n\
    \    if length == 2 {\n        return \"YES\".to_string();\n    }\n    while length\
    \ % 2 == 0 {\n        length /= 2;\n    }\n    while length % 3 == 0 {\n     \
    \   length /= 3;\n    }\n    while length % 5 == 0 {\n        length /= 5;\n \
    \   }\n    while length % 7 == 0 {\n        length /= 7;\n    }\n    if length\
    \ == 1 {\n        return \"YES\".to_string();\n    }\n    return \"NO\".to_string();\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659821498
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    //! Declare variables\
    \ to hold the intervals start and end values\n    let mut interval1_start = interval1.0;\n\
    \    let mut interval1_end = interval1.1;\n    let mut interval2_start = interval2.0;\n\
    \    let mut interval2_end = interval2.1;\n    //! if interval1_start > interval1_end\
    \ swap them\n    if interval1_start > interval1_end {\n        interval1_start\
    \ = interval1.1;\n        interval1_end = interval1.0;\n    }\n    //! if interval2_start\
    \ > interval2_end swap them\n    if interval2_start > interval2_end {\n      \
    \  interval2_start = interval2.1;\n        interval2_end = interval2.0;\n    }\n\
    \    //! if the two intervals don't intersect return \"NO\"\n    if interval1_end\
    \ < interval2_start || interval2_end < interval1_start {\n        return \"NO\"\
    .to_string();\n    }\n    //! Get the start and end values of the new interval\n\
    \    let start = if interval1_start > interval2_start {\n        interval1_start\n\
    \    } else {\n        interval2_start\n    };\n    let end = if interval1_end\
    \ < interval2_end {\n        interval1_end\n    } else {\n        interval2_end\n\
    \    };\n    //! Check if the length of the new interval is a prime number\n \
    \   if is_prime(end - start) {\n        \"YES\".to_string()\n    } else {\n  \
    \      \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0753]: expected outer doc comment\n  --> /tmp/tmpsi6083ze.rs:20:5\n\
    \   |\n20 |     //! if interval1_start > interval1_end swap them\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |\n   = note: inner doc comments like this (starting with `//!` or `/*!`)\
    \ can only appear before items\n\nerror[E0753]: expected outer doc comment\n \
    \ --> /tmp/tmpsi6083ze.rs:25:5\n   |\n25 |     //! if interval2_start > interval2_end\
    \ swap them\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n\
    \   = note: inner doc comments like this (starting with `//!` or `/*!`) can only\
    \ appear before items\n\nerror[E0753]: expected outer doc comment\n  --> /tmp/tmpsi6083ze.rs:30:5\n\
    \   |\n30 |     //! if the two intervals don't intersect return \"NO\"\n   | \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: inner\
    \ doc comments like this (starting with `//!` or `/*!`) can only appear before\
    \ items\n\nerror[E0753]: expected outer doc comment\n  --> /tmp/tmpsi6083ze.rs:34:5\n\
    \   |\n34 |     //! Get the start and end values of the new interval\n   |   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: inner\
    \ doc comments like this (starting with `//!` or `/*!`) can only appear before\
    \ items\n\nerror[E0753]: expected outer doc comment\n  --> /tmp/tmpsi6083ze.rs:45:5\n\
    \   |\n45 |     //! Check if the length of the new interval is a prime number\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n\
    \   = note: inner doc comments like this (starting with `//!` or `/*!`) can only\
    \ appear before items\n\nerror[E0425]: cannot find function `is_prime` in this\
    \ scope\n  --> /tmp/tmpsi6083ze.rs:46:8\n   |\n46 |     if is_prime(end - start)\
    \ {\n   |        ^^^^^^^^ not found in this scope\n\nwarning: unused doc comment\n\
    \  --> /tmp/tmpsi6083ze.rs:20:5\n   |\n20 |       //! if interval1_start > interval1_end\
    \ swap them\n   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n21 |\
    \ /     if interval1_start > interval1_end {\n22 | |         interval1_start =\
    \ interval1.1;\n23 | |         interval1_end = interval1.0;\n24 | |     "
  stdout: ''
  timestamp: 1659821493
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let lower = if interval1.0\
    \ > interval2.0 {\n        interval1.0\n    } else {\n        interval2.0\n  \
    \  };\n    let upper = if interval1.1 < interval2.1 {\n        interval1.1\n \
    \   } else {\n        interval2.1\n    };\n    if lower <= upper {\n        return\
    \ if is_prime(upper - lower + 1) {\n            \"YES\".to_string()\n        }\
    \ else {\n            \"NO\".to_string()\n        };\n    }\n    \"NO\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpqafrw_ht.rs:26:19\n\
    \   |\n26 |         return if is_prime(upper - lower + 1) {\n   |            \
    \       ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821493
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let a = max(interval1.0,\
    \ interval2.0);\n    let b = min(interval1.1, interval2.1);\n    if a > b {\n\
    \        return \"NO\".to_string();\n    }\n\n    let length = b - a + 1;\n  \
    \  if length == 2 {\n        return \"YES\".to_string();\n    }\n    if length\
    \ % 2 == 0 {\n        return \"NO\".to_string();\n    }\n    for i in 3..length\
    \ + 1 {\n        if length % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpkpcxalzm.rs:15:13\n\
    \   |\n15 |     let a = max(interval1.0, interval2.0);\n   |             ^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this function\n   |\n1 \
    \ | use std::cmp::max;\n   |\n\nerror[E0425]: cannot find function `min` in this\
    \ scope\n  --> /tmp/tmpkpcxalzm.rs:16:13\n   |\n16 |     let b = min(interval1.1,\
    \ interval2.1);\n   |             ^^^\n...\n36 | fn main() {\n   | --------- similarly\
    \ named function `main` defined here\n   |\nhelp: a function with a similar name\
    \ exists\n   |\n16 |     let b = main(interval1.1, interval2.1);\n   |       \
    \      ~~~~\nhelp: consider importing this function\n   |\n1  | use std::cmp::min;\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821493
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (min, max) =\
    \ (cmp::max(interval1.0, interval2.0), cmp::min(interval1.1, interval2.1));\n\
    \    if min > max {\n        return \"NO\".to_string();\n    }\n    let len =\
    \ (max - min) + 1;\n    if len == 1 {\n        return \"NO\".to_string();\n  \
    \  }\n    let mut is_prime = true;\n    let mut i = 2;\n    while i < len {\n\
    \        if len % i == 0 {\n            is_prime = false;\n            break;\n\
    \        }\n        i += 1;\n    }\n    if is_prime {\n        return \"YES\"\
    .to_string();\n    }\n    \"NO\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmpxep663ci.rs:15:23\n   |\n15 |     let (min, max) = (cmp::max(interval1.0,\
    \ interval2.0), cmp::min(interval1.1, interval2.1));\n   |                   \
    \    ^^^ use of undeclared crate or module `cmp`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared crate or module `cmp`\n  --> /tmp/tmpxep663ci.rs:15:59\n \
    \  |\n15 |     let (min, max) = (cmp::max(interval1.0, interval2.0), cmp::min(interval1.1,\
    \ interval2.1));\n   |                                                       \
    \    ^^^ use of undeclared crate or module `cmp`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659821493
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let a = interval1.0;\n\
    \    let b = interval1.1;\n    let c = interval2.0;\n    let d = interval2.1;\n\
    \    // if (d < a || b < c) {\n    //     return \"NO\";\n    // }\n    if a >=\
    \ d || b <= c {\n        return \"NO\".to_string();\n    }\n    let start = std::cmp::max(a,\
    \ c);\n    let end = std::cmp::min(b, d);\n    let len = end - start + 1;\n  \
    \  if len == 1 {\n        return \"NO\".to_string();\n    }\n    if (2..=(len\
    \ as f64).sqrt() as isize).any(|i| len % i == 0) {\n        return \"NO\".to_string();\n\
    \    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpqrg8gdr6.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821493
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    match (interval1,\
    \ interval2) {\n        ((x, y), (a, b)) if x >= a && x <= b && y >= a && y <=\
    \ b =>\n            if (x - a + 1).is_prime() { \"YES\".to_string() } else { \"\
    NO\".to_string() },\n        ((x, y), (a, b)) if x <= a && y >= a && y <= b =>\n\
    \            if (y - a + 1).is_prime() { \"YES\".to_string() } else { \"NO\".to_string()\
    \ },\n        ((x, y), (a, b)) if x >= a && x <= b && y >= b =>\n            if\
    \ (b - x + 1).is_prime() { \"YES\".to_string() } else { \"NO\".to_string() },\n\
    \        ((x, y), (a, b)) if x <= a && y >= b =>\n            if (b - a + 1).is_prime()\
    \ { \"YES\".to_string() } else { \"NO\".to_string() },\n        _ => \"NO\".to_string()\n\
    \    }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_prime` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpkp4ld2j2.rs:17:28\n   |\n17 |             if (x\
    \ - a + 1).is_prime() { \"YES\".to_string() } else { \"NO\".to_string() },\n \
    \  |                            ^^^^^^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `is_prime` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmpkp4ld2j2.rs:19:28\n   |\n19 |             if (y - a + 1).is_prime()\
    \ { \"YES\".to_string() } else { \"NO\".to_string() },\n   |                 \
    \           ^^^^^^^^ method not found in `isize`\n\nerror[E0599]: no method named\
    \ `is_prime` found for type `isize` in the current scope\n  --> /tmp/tmpkp4ld2j2.rs:21:28\n\
    \   |\n21 |             if (b - x + 1).is_prime() { \"YES\".to_string() } else\
    \ { \"NO\".to_string() },\n   |                            ^^^^^^^^ method not\
    \ found in `isize`\n\nerror[E0599]: no method named `is_prime` found for type\
    \ `isize` in the current scope\n  --> /tmp/tmpkp4ld2j2.rs:23:28\n   |\n23 |  \
    \           if (b - a + 1).is_prime() { \"YES\".to_string() } else { \"NO\".to_string()\
    \ },\n   |                            ^^^^^^^^ method not found in `isize`\n\n\
    error: aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659821493
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let start = interval1.0.max(interval2.0);\n\
    \    let end = interval1.1.min(interval2.1);\n    if start >= end {\n        return\
    \ \"NO\".to_string();\n    }\n    if primes::is_prime(end - start) {\n       \
    \ return \"YES\".to_string();\n    }\n    \"NO\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `primes`\n\
    \  --> /tmp/tmprhirg_ve.rs:20:8\n   |\n20 |     if primes::is_prime(end - start)\
    \ {\n   |        ^^^^^^ use of undeclared crate or module `primes`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659821493
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let start = if interval1.0\
    \ > interval2.0 {\n        interval1.0\n    } else {\n        interval2.0\n  \
    \  };\n    let end = if interval1.1 < interval2.1 {\n        interval1.1\n   \
    \ } else {\n        interval2.1\n    };\n    let length = end - start;\n    if\
    \ length < 0 {\n        \"NO\".to_string()\n    } else {\n        if prime(length)\
    \ {\n            \"YES\".to_string()\n        } else {\n            \"NO\".to_string()\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `prime` in this scope\n  --> /tmp/tmpxi7523j7.rs:29:12\n\
    \   |\n29 |         if prime(length) {\n   |            ^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821493
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n  let (x1, x2) = interval1;\n\
    \  let (y1, y2) = interval2;\n  if x2 < y1 || y2 < x1 {\n    return \"NO\".to_string();\n\
    \  }\n  let (x_start, x_end) = if x1 <= y1 { (y1, y2) } else { (x1, x2) };\n \
    \ let x_len = x_end - x_start;\n  if x_len < 2 {\n    return \"NO\".to_string();\n\
    \  }\n  let mut i = 2;\n  while i * i <= x_len {\n    if x_len % i == 0 {\n  \
    \    return \"NO\".to_string();\n    }\n    i += 1;\n  }\n  \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"NO\"`,\n right: `\"YES\"`', /tmp/tmppt4qhai4.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821493
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    if b < c || d < a { return \"NO\".to_string();\
    \ }\n    let interval = (cmp::max(a, c), cmp::min(b, d));\n    is_prime(interval.1\
    \ - interval.0 + 1)\n}\n\nfn main() {\n    let candidate = intersection;\n   \
    \ assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmpgbfdbkr5.rs:18:21\n   |\n18 |     let interval = (cmp::max(a, c),\
    \ cmp::min(b, d));\n   |                     ^^^ use of undeclared crate or module\
    \ `cmp`\n\nerror[E0433]: failed to resolve: use of undeclared crate or module\
    \ `cmp`\n  --> /tmp/tmpgbfdbkr5.rs:18:37\n   |\n18 |     let interval = (cmp::max(a,\
    \ c), cmp::min(b, d));\n   |                                     ^^^ use of undeclared\
    \ crate or module `cmp`\n\nerror[E0425]: cannot find function `is_prime` in this\
    \ scope\n  --> /tmp/tmpgbfdbkr5.rs:19:5\n   |\n19 |     is_prime(interval.1 -\
    \ interval.0 + 1)\n   |     ^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821493
- exit_code: 0
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    if interval1.0 >\
    \ interval2.1 || interval2.0 > interval1.1 {\n        return \"NO\".to_string();\n\
    \    }\n    let mut min = interval1.0;\n    let mut max = interval1.1;\n    if\
    \ interval2.0 > min {\n        min = interval2.0;\n    }\n    if interval2.1 <\
    \ max {\n        max = interval2.1;\n    }\n    let value = (max - min) + 1;\n\
    \    if value <= 2 {\n        return \"NO\".to_string();\n    }\n    for i in\
    \ 2..value {\n        if value % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821493
- exit_code: 0
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    if interval1.0 >\
    \ interval2.1 || interval2.0 > interval1.1 {\n        return \"NO\".to_string();\n\
    \    }\n    let start = interval1.0.max(interval2.0);\n    let end = interval1.1.min(interval2.1);\n\
    \    if end - start <= 1 {\n        return \"NO\".to_string();\n    }\n    for\
    \ i in 2..end {\n        if end % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821493
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start, end)\
    \ = get_overlap(interval1, interval2);\n    if is_prime(end - start + 1) {\n \
    \       return \"YES\".to_string();\n    }\n    \"NO\".to_string()\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_overlap` in this scope\n  --> /tmp/tmpj50d6cty.rs:15:24\n\
    \   |\n15 |     let (start, end) = get_overlap(interval1, interval2);\n   |  \
    \                      ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `is_prime` in this scope\n  --> /tmp/tmpj50d6cty.rs:16:8\n   |\n\
    16 |     if is_prime(end - start + 1) {\n   |        ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821493
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n  let int_len = |(mut\
    \ a, mut b): (isize, isize)| {\n    if a > b {\n      let t = a;\n      a = b;\n\
    \      b = t;\n    }\n    let a = if a <= 0 { 1 } else { a };\n    (a..b+1).count()\
    \ as isize\n  };\n  let is_prime = |x: isize| {\n    let r = (x as f64).sqrt()\
    \ as isize;\n    let mut is_prime = true;\n    for i in 2..r+1 {\n      if x %\
    \ i == 0 {\n        is_prime = false;\n        break;\n      }\n    }\n    is_prime\n\
    \  };\n  let (mut a, mut b) = interval1;\n  let (mut c, mut d) = interval2;\n\
    \  if b < c || d < a {\n    return \"NO\".to_string();\n  }\n  if a > c {\n  \
    \  let t = a;\n    a = c;\n    c = t;\n  }\n  if b > d {\n    let t = b;\n   \
    \ b = d;\n    d = t;\n  }\n  let interval = (a, b);\n  let interval2 = (c, d);\n\
    \  if interval == interval2 {\n    if is_prime(int_len(interval)) {\n      return\
    \ \"YES\".to_string();\n    }\n    return \"NO\".to_string();\n  }\n  let inter\
    \ = (c, b);\n  if is_prime(int_len(inter)) {\n    return \"YES\".to_string();\n\
    \  }\n  return \"NO\".to_string();\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpo3jc14ol.rs:67:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821493
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 >= end2 ||\
    \ start2 >= end1 {\n        return \"NO\".to_string();\n    }\n    let start =\
    \ if start1 > start2 { start1 } else { start2 };\n    let end = if end1 < end2\
    \ { end1 } else { end2 };\n    let is_prime = |val: isize| -> bool {\n       \
    \ let mut i = 2;\n        while i < val {\n            if val % i == 0 {\n   \
    \             return false;\n            }\n            i += 1;\n        }\n \
    \       true\n    };\n    if is_prime(end - start) {\n        \"YES\".to_string()\n\
    \    } else {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpk0b_3xn2.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821493
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (mut start,\
    \ mut end) = if interval1.0 < interval2.0 {\n        (interval2.0, interval1.1)\n\
    \    } else {\n        (interval1.0, interval2.1)\n    };\n    if start > end\
    \ {\n        end = start;\n    }\n    while start <= end {\n        if is_prime(start)\
    \ {\n            return \"YES\".to_string();\n        }\n        start += 1;\n\
    \    }\n    \"NO\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp7v657x3e.rs:24:12\n\
    \   |\n24 |         if is_prime(start) {\n   |            ^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821493
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (i1s, i1e) =\
    \ interval1;\n    let (i2s, i2e) = interval2;\n    if i1e < i2s || i2e < i1s {\n\
    \        return \"NO\".to_string();\n    }\n    let mut range: Vec<isize> = vec![];\n\
    \    for i in i1s..=i1e {\n        if i >= i2s && i <= i2e {\n            range.push(i);\n\
    \        }\n    }\n    for i in i2s..=i2e {\n        if i >= i1s && i <= i1e {\n\
    \            range.push(i);\n        }\n    }\n    if range.is_empty() {\n   \
    \     return \"NO\".to_string();\n    }\n    let max = range.iter().max().unwrap();\n\
    \    let min = range.iter().min().unwrap();\n    let range_size = (max - min)\
    \ + 1;\n    if is_prime(range_size) {\n        return \"YES\".to_string();\n \
    \   }\n    \"NO\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpto31irvb.rs:37:8\n\
    \   |\n37 |     if is_prime(range_size) {\n   |        ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821493
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    let mut res = (cmp::max(a, c), cmp::min(b, d));\n\
    \    if res.0 >= res.1 {\n        return \"NO\".to_string();\n    }\n    res.1\
    \ -= res.0;\n    if res.1 < 2 {\n        return \"NO\".to_string();\n    }\n \
    \   if res.1 == 2 {\n        return \"YES\".to_string();\n    }\n    let mut i\
    \ = 2;\n    while i * i <= res.1 {\n        if res.1 % i == 0 {\n            return\
    \ \"NO\".to_string();\n        }\n        i += 1;\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmp6up9djcp.rs:17:20\n   |\n17 |     let mut res = (cmp::max(a, c),\
    \ cmp::min(b, d));\n   |                    ^^^ use of undeclared crate or module\
    \ `cmp`\n\nerror[E0433]: failed to resolve: use of undeclared crate or module\
    \ `cmp`\n  --> /tmp/tmp6up9djcp.rs:17:36\n   |\n17 |     let mut res = (cmp::max(a,\
    \ c), cmp::min(b, d));\n   |                                    ^^^ use of undeclared\
    \ crate or module `cmp`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659821493
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    // Determine the\
    \ first and last of the two intervals\n    let first = interval1.0.min(interval2.0);\n\
    \    let last = interval1.1.max(interval2.1);\n    // Build a list of factors\
    \ between the first and last\n    let mut factors = Vec::new();\n    for i in\
    \ first..=last {\n        if i % first == 0 && i % last == 0 {\n            factors.push(i);\n\
    \        }\n    }\n    // Determine if the length of the intersection is a prime\
    \ number\n    if factors.len() == 2 {\n        \"YES\".to_string()\n    } else\
    \ {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate =\
    \ intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp572ck8nx.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821493
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    if interval1.0 >\
    \ interval2.1 || interval2.0 > interval1.1 {\n        return \"NO\".to_string();\n\
    \    }\n    let start = std::cmp::max(interval1.0, interval2.0);\n    let end\
    \ = std::cmp::min(interval1.1, interval2.1);\n    if is_prime(end - start + 1)\
    \ {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n \
    \   }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpprhwtuki.rs:20:8\n\
    \   |\n20 |     if is_prime(end - start + 1) {\n   |        ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821493
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let low = interval1.0.max(interval2.0);\n\
    \    let high = interval1.1.min(interval2.1);\n    if low > high {\n        return\
    \ \"NO\".to_string();\n    }\n    let length = high - low + 1;\n    let half =\
    \ (length as f64).sqrt() as isize;\n    for d in 2..half {\n        if length\
    \ % d == 0 {\n            return \"NO\".to_string();\n        }\n    }\n    return\
    \ \"YES\".to_string();\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpudhhunb6.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821493
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let start = std::cmp::max(interval1.0,\
    \ interval2.0);\n    let end = std::cmp::min(interval1.1, interval2.1);\n    if\
    \ start >= end {\n        return \"NO\".to_string();\n    }\n    if is_prime(end\
    \ - start) {\n        return \"YES\".to_string();\n    }\n    return \"NO\".to_string();\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpx7v2qsk5.rs:20:8\n\
    \   |\n20 |     if is_prime(end - start) {\n   |        ^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821493
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (mut min, mut\
    \ max) = (interval1.0, interval1.1);\n    let (mut min2, mut max2) = (interval2.0,\
    \ interval2.1);\n    // swap the order if needed\n    if max < min {\n       \
    \ let temp = min;\n        min = max;\n        max = temp;\n    }\n    if max2\
    \ < min2 {\n        let temp = min2;\n        min2 = max2;\n        max2 = temp;\n\
    \    }\n    // no intersection\n    if min > max2 || min2 > max {\n        return\
    \ \"NO\".to_string();\n    }\n    // intersection\n    if min > min2 {\n     \
    \   min = min2;\n    }\n    if max < max2 {\n        max = max2;\n    }\n    let\
    \ diff = max - min;\n    let is_prime = primes::is_prime(diff as usize);\n   \
    \ if is_prime {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n\
    \    }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `primes`\n\
    \  --> /tmp/tmpo8rbgxi7.rs:40:20\n   |\n40 |     let is_prime = primes::is_prime(diff\
    \ as usize);\n   |                    ^^^^^^ use of undeclared crate or module\
    \ `primes`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659821493
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n  let (start1, end1)\
    \ = interval1;\n  let (start2, end2) = interval2;\n  let intersection = (\n  \
    \  start1.max(start2),\n    end1.min(end2)\n  );\n  if intersection.0 >= intersection.1\
    \ {\n    return \"NO\".to_string();\n  }\n  let mut sieve = vec![true; (intersection.1\
    \ - intersection.0) as usize];\n  let mut i = 0;\n  while i < sieve.len() {\n\
    \    if sieve[i] {\n      let mut j = i;\n      while j < sieve.len() {\n    \
    \    sieve[j] = false;\n        j += i + 1;\n      }\n    }\n    i += 1;\n  }\n\
    \  let result = if sieve[0] { \"YES\" } else { \"NO\" };\n  result.to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"NO\"`,\n right: `\"YES\"`', /tmp/tmpgxcla9w7.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821493
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let mut start =\
    \ if interval1.0 > interval2.0 {\n        interval1.0\n    } else {\n        interval2.0\n\
    \    };\n    let mut end = if interval1.1 < interval2.1 {\n        interval1.1\n\
    \    } else {\n        interval2.1\n    };\n    if end < start {\n        return\
    \ \"NO\".to_string();\n    }\n    let mut count = 0;\n    while start <= end {\n\
    \        count += 1;\n        start += 1;\n    }\n    let mut is_prime = true;\n\
    \    for i in 2..count {\n        if count % i == 0 {\n            is_prime =\
    \ false;\n            break;\n        }\n    }\n    if is_prime {\n        \"\
    YES\".to_string()\n    } else {\n        \"NO\".to_string()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpzjdvsen0.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let start = interval1.0.max(interval2.0);\n\
    \    let end = interval1.1.min(interval2.1);\n    if start > end {\n        \"\
    NO\".to_string()\n    } else {\n        if is_prime(end - start + 1) {\n     \
    \       \"YES\".to_string()\n        } else {\n            \"NO\".to_string()\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp0qskw6qe.rs:20:12\n\
    \   |\n20 |         if is_prime(end - start + 1) {\n   |            ^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821493
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (x1, x2) = interval1;\n\
    \    let (y1, y2) = interval2;\n    let start = if x1 > y1 { x1 } else { y1 };\n\
    \    let end = if x2 < y2 { x2 } else { y2 };\n    if start > end { return \"\
    NO\".to_string(); }\n    let length = end - start + 1;\n    if length == 1 { return\
    \ \"NO\".to_string(); }\n    let primes = vec![2, 3, 5, 7, 11, 13, 17, 19, 23,\
    \ 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    if primes.iter().find(|&&x|\
    \ x == length) != None { return \"YES\".to_string(); }\n    return \"NO\".to_string();\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpcm8z0kzp.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let start = std::cmp::max(interval1.0,\
    \ interval2.0);\n    let end = std::cmp::min(interval1.1, interval2.1);\n    if\
    \ start > end {\n        return \"NO\".to_string();\n    }\n    if start == end\
    \ {\n        return is_prime(start) ? \"YES\".to_string() : \"NO\".to_string();\n\
    \    }\n    if is_prime(end - start + 1) {\n        return \"YES\".to_string();\n\
    \    }\n    return \"NO\".to_string();\n}\n\nfn main() {\n    let candidate =\
    \ intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `\"YES\"\
    `\n  --> /tmp/tmpa5on0chl.rs:21:34\n   |\n21 |         return is_prime(start)\
    \ ? \"YES\".to_string() : \"NO\".to_string();\n   |                          \
    \        ^^^^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0425]:\
    \ cannot find function `is_prime` in this scope\n  --> /tmp/tmpa5on0chl.rs:23:8\n\
    \   |\n23 |     if is_prime(end - start + 1) {\n   |        ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821493
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    // your code here\n\
    \    let mut result = \"NO\";\n    let (x1, y1) = interval1;\n    let (x2, y2)\
    \ = interval2;\n    if y1 >= x2 && y2 >= x1 {\n        let (a, b) = if x1 >= x2\
    \ { (x1, y2) } else { (x2, y1) };\n        if b - a == 1 {\n            result\
    \ = \"YES\";\n        }\n    }\n    result.to_string()\n}\n\nfn main() {\n   \
    \ let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n \
    \   assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2,\
    \ 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1,\
    \ -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpvjlzmxfr.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    if a > b || c > d {\n        return \"NO\".to_string();\n\
    \    }\n    if b < c || d < a {\n        return \"NO\".to_string();\n    }\n \
    \   if b < d {\n        let len = b - c + 1;\n        if len > 1 && is_prime(len)\
    \ {\n            return \"YES\".to_string();\n        }\n    } else {\n      \
    \  let len = d - a + 1;\n        if len > 1 && is_prime(len) {\n            return\
    \ \"YES\".to_string();\n        }\n    }\n    \"NO\".to_string()\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpoxl_1lfz.rs:25:23\n\
    \   |\n25 |         if len > 1 && is_prime(len) {\n   |                      \
    \ ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_prime`\
    \ in this scope\n  --> /tmp/tmpoxl_1lfz.rs:30:23\n   |\n30 |         if len >\
    \ 1 && is_prime(len) {\n   |                       ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821493
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    if interval1.0 >\
    \ interval2.1 || interval2.0 > interval1.1 {\n        return \"NO\".to_string();\n\
    \    }\n    let (s, e) = (interval1.0.max(interval2.0), interval1.1.min(interval2.1));\n\
    \    if (2..e).any(|x| s % x == 0 && e % x == 0) {\n        return \"NO\".to_string();\n\
    \    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpuoe37k9w.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 0
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n  let mut result = (0,\
    \ 0);\n  if interval1.0 <= interval2.0 && interval2.0 <= interval1.1 {\n    result.0\
    \ = interval2.0;\n  } else if interval2.0 <= interval1.0 && interval1.0 <= interval2.1\
    \ {\n    result.0 = interval1.0;\n  } else {\n    return \"NO\".to_string();\n\
    \  }\n  if interval1.0 <= interval2.1 && interval2.1 <= interval1.1 {\n    result.1\
    \ = interval2.1;\n  } else if interval2.0 <= interval1.1 && interval1.1 <= interval2.1\
    \ {\n    result.1 = interval1.1;\n  } else {\n    return \"NO\".to_string();\n\
    \  }\n  let range = result.1 - result.0;\n  if range < 2 {\n    return \"NO\"\
    .to_string();\n  }\n  let mut is_prime = true;\n  let range_sqrt = (range as f64).sqrt().ceil()\
    \ as isize;\n  for i in 2..range_sqrt {\n    if range % i == 0 {\n      is_prime\
    \ = false;\n      break;\n    }\n  }\n  if is_prime {\n    \"YES\".to_string()\n\
    \  } else {\n    \"NO\".to_string()\n  }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821494
- exit_code: 0
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (mut start,\
    \ mut end) = (interval1.0, interval1.1);\n    if start > end {\n        start\
    \ = interval1.1;\n        end = interval1.0;\n    }\n    let (start2, end2) =\
    \ (interval2.0, interval2.1);\n    let (mut start3, mut end3) = (0, 0);\n    if\
    \ start < start2 {\n        start3 = start2;\n    } else {\n        start3 = start;\n\
    \    }\n    if end > end2 {\n        end3 = end2;\n    } else {\n        end3\
    \ = end;\n    }\n    let count = end3 - start3;\n    if count > 1 {\n        if\
    \ count == 2 {\n            return \"YES\".to_string();\n        }\n        for\
    \ i in 2..count {\n            if count % i == 0 {\n                return \"\
    NO\".to_string();\n            }\n        }\n        return \"YES\".to_string();\n\
    \    }\n    \"NO\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821494
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let mut intervals\
    \ = vec![interval1, interval2];\n    intervals.sort_by(|a, b| a.0.cmp(&b.0));\n\
    \    let (start, end) = (intervals[0].1, intervals[1].0);\n    if start < end\
    \ {\n        if is_prime(end - start) {\n            return \"YES\".to_string();\n\
    \        }\n    }\n    \"NO\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp76qbujzm.rs:19:12\n\
    \   |\n19 |         if is_prime(end - start) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821493
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let i1s = interval1.0;\n\
    \    let i1e = interval1.1;\n    let i2s = interval2.0;\n    let i2e = interval2.1;\n\
    \    let is = if i1s > i2s { i1s } else { i2s };\n    let ie = if i1e < i2e {\
    \ i1e } else { i2e };\n    if is > ie {\n        \"NO\".to_string()\n    } else\
    \ {\n        let len = ie - is + 1;\n        if len > 2 && (2..((len as f64).sqrt()\
    \ as isize + 1)).any(|i| len % i == 0) {\n            \"NO\".to_string()\n   \
    \     } else {\n            \"YES\".to_string()\n        }\n    }\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpz7v4dmvk.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    // Since the intervals\
    \ are inclusive, the length of the intersection is\n    // the length of either\
    \ interval minus the distance between the intervals.\n    // There might be a\
    \ problem with negative numbers?\n    let (start, end) = intersection_range(interval1,\
    \ interval2);\n    let length = end - start + 1;\n    // println!(\"Intersection\
    \ range: ({}, {})\", start, end);\n    // println!(\"Intersection length: {}\"\
    , length);\n    if length < 0 {\n        \"NO\".to_string()\n    } else {\n  \
    \      if is_prime(length) {\n            \"YES\".to_string()\n        } else\
    \ {\n            \"NO\".to_string()\n        }\n    }\n}\n\nfn main() {\n    let\
    \ candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n \
    \   assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2,\
    \ 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1,\
    \ -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `intersection_range` in this scope\n\
    \  --> /tmp/tmp_r0t4fjp.rs:18:24\n   |\n18 |     let (start, end) = intersection_range(interval1,\
    \ interval2);\n   |                        ^^^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `is_prime` in this scope\n  -->\
    \ /tmp/tmp_r0t4fjp.rs:25:12\n   |\n25 |         if is_prime(length) {\n   |  \
    \          ^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821493
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    // get the intersection\
    \ and check if it is a prime number\n    if interval1.0 <= interval2.1 && interval2.0\
    \ <= interval1.1 {\n        return if (interval2.0 - interval1.0).abs() % 2 ==\
    \ 0 {\n            \"NO\".to_string()\n        } else {\n            \"YES\".to_string()\n\
    \        };\n    }\n    \"NO\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp8k475i27.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (mut x, mut\
    \ y) = (interval1.0, interval1.1);\n    let (mut z, mut w) = (interval2.0, interval2.1);\n\
    \    if x > y {\n        ::std::mem::swap(&mut x, &mut y);\n    }\n    if z >\
    \ w {\n        ::std::mem::swap(&mut z, &mut w);\n    }\n    if y < z || w < x\
    \ {\n        return \"NO\".to_string();\n    }\n    if z <= x && w >= y {\n  \
    \      return \"YES\".to_string();\n    }\n    if x <= z && y >= w {\n       \
    \ return \"YES\".to_string();\n    }\n    if z <= x && w <= y {\n        let n\
    \ = w - x;\n        if n == 1 {\n            return \"NO\".to_string();\n    \
    \    }\n        if n <= 3 {\n            return \"YES\".to_string();\n       \
    \ }\n        if n % 2 == 0 || n % 3 == 0 {\n            return \"NO\".to_string();\n\
    \        }\n        let mut i = 5;\n        while i * i <= n {\n            if\
    \ n % i == 0 || n % (i + 2) == 0 {\n                return \"NO\".to_string();\n\
    \            }\n            i += 6;\n        }\n        return \"YES\".to_string();\n\
    \    }\n    if x <= z && y <= w {\n        let n = y - z;\n        if n == 1 {\n\
    \            return \"NO\".to_string();\n        }\n        if n <= 3 {\n    \
    \        return \"YES\".to_string();\n        }\n        if n % 2 == 0 || n %\
    \ 3 == 0 {\n            return \"NO\".to_string();\n        }\n        let mut\
    \ i = 5;\n        while i * i <= n {\n            if n % i == 0 || n % (i + 2)\
    \ == 0 {\n                return \"NO\".to_string();\n            }\n        \
    \    i += 6;\n        }\n        return \"YES\".to_string();\n    }\n    unreachable!()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpguhzv26e.rs:77:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let mut primes =\
    \ vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151,\
    \ 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239,\
    \ 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337,\
    \ 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433,\
    \ 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541,\
    \ 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641,\
    \ 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743,\
    \ 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857,\
    \ 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971,\
    \ 977, 983, 991, 997];\n    primes.reverse();\n    let mut max = isize::min_value();\n\
    \    let mut min = isize::max_value();\n    if (interval1.0 < interval2.0 && interval1.1\
    \ > interval2.0) || (interval2.0 < interval1.0 && interval2.1 > interval1.0) {\n\
    \        if interval1\n}\n\nfn main() {\n    let candidate = intersection;\n \
    \   assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpc17w3kph.rs:33:3\n\
    \   |\n14 | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n   |                                                          \
    \                       - unclosed delimiter\n...\n19 |     if (interval1.0 <\
    \ interval2.0 && interval1.1 > interval2.0) || (interval2.0 < interval1.0 && interval2.1\
    \ > interval1.0) {\n   |                                                     \
    \                                                                        - this\
    \ delimiter might not be properly closed...\n20 |         if interval1\n21 | }\n\
    \   | - ...as it matches this but it has different indentation\n...\n33 | }\n\
    \   |   ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmpc17w3kph.rs:21:1\n\
    \   |\n20 |         if interval1\n   |         -- this `if` expression has a condition,\
    \ but no block\n21 | }\n   | ^ expected `{`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpc17w3kph.rs:14:74\n   |\n14 | fn intersection(interval1: (isize,\
    \ isize), interval2: (isize, isize)) -> String {\n   |    ------------       \
    \                                                   ^^^^^^ expected struct `String`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659821493
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    if interval1.0 >=\
    \ interval2.1 || interval2.0 >= interval1.1 {\n        return \"NO\".to_string();\n\
    \    }\n    let mut lower = interval1.0;\n    let mut upper = interval1.1;\n \
    \   if interval2.0 > lower {\n        lower = interval2.0;\n    }\n    if interval2.1\
    \ < upper {\n        upper = interval2.1;\n    }\n    if is_prime(upper - lower)\
    \ {\n        return \"YES\".to_string();\n    }\n    return \"NO\".to_string();\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp8vapla2u.rs:26:8\n\
    \   |\n26 |     if is_prime(upper - lower) {\n   |        ^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821493
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let mut result =\
    \ 0;\n    let (x1, y1) = interval1;\n    let (x2, y2) = interval2;\n    if x1\
    \ > y2 || x2 > y1 {\n        return \"NO\".to_string();\n    }\n    if x1 <= x2\
    \ && y1 >= x2 {\n        result = y1 - x2 + 1;\n    } else if x2 <= x1 && y2 >=\
    \ x1 {\n        result = y2 - x1 + 1;\n    } else if x1 <= x2 && y2 >= y1 {\n\
    \        result = y1 - x2 + 1;\n    } else if x2 <= x1 && y1 >= y2 {\n       \
    \ result = y2 - x1 + 1;\n    } else {\n        return \"NO\".to_string();\n  \
    \  }\n    if result % 2 == 0 || result % 3 == 0 || result % 5 == 0 || result %\
    \ 7 == 0 || result % 11 == 0 || result % 13 == 0 || result % 17 == 0 || result\
    \ % 19 == 0 || result % 23 == 0 || result % 29 == 0 || result % 31 == 0 || result\
    \ % 37 == 0 || result % 41 == 0 || result % 43 == 0 || result % 47 == 0 || result\
    \ % 53 == 0 || result % 59 == 0 || result % 61 == 0 || result % 67 == 0 || result\
    \ % 71 == 0 || result % 73 == 0 || result % 79 == 0 || result % 83 == 0 || result\
    \ % 89 == 0 || result % 97 == 0 {\n        return \"NO\".to_string();\n    }\n\
    \    return \"YES\".to_string();\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp_owjn3fu.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    let length = end - start\
    \ + 1;\n    if length <= 1 {\n        return \"NO\".to_string();\n    }\n    if\
    \ (2..length-1).all(|n| length % n != 0) {\n        return \"YES\".to_string();\n\
    \    }\n    \"NO\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpy9ytomg8.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let interval1 =\
    \ interval1.0.max(interval2.0)..=interval1.1.min(interval2.1);\n    if interval1.start()\
    \ > interval1.end() {\n        return \"NO\".to_string();\n    }\n    interval1.end()\
    \ - interval1.start() + 1 == 2 || interval1.end() - interval1.start() + 1 == 3\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwtq3stch.rs:19:5\n   |\n\
    14 | fn intersection(interval1: (isize, isize), interval2: (isize, isize)) ->\
    \ String {\n   |                                                             \
    \             ------ expected `String` because of return type\n...\n19 |     interval1.end()\
    \ - interval1.start() + 1 == 2 || interval1.end() - interval1.start() + 1 == 3\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `bool`\n   |\nhelp: try using a conversion method\n\
    \   |\n19 |     (interval1.end() - interval1.start() + 1 == 2 || interval1.end()\
    \ - interval1.start() + 1 == 3).to_string()\n   |     +                      \
    \                                                                      +++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (s1, e1) = interval1;\n\
    \    let (s2, e2) = interval2;\n    let (s, e) = (s1.max(s2), e1.min(e2));\n \
    \   if s <= e {\n        if (2..(e - s + 1)).all(|x| (e - s + 1) % x != 0) {\n\
    \            \"YES\".to_string()\n        } else {\n            \"NO\".to_string()\n\
    \        }\n    } else {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpzalayan7.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    if interval1.0 >\
    \ interval2.1 || interval2.0 > interval1.1 {\n        return \"NO\".to_string();\n\
    \    }\n    let start = interval1.0.max(interval2.0);\n    let end = interval1.1.min(interval2.1);\n\
    \    let n = end - start + 1;\n    match n {\n        2 | 3 | 5 | 7 => \"YES\"\
    .to_string(),\n        _ => \"NO\".to_string(),\n    }\n}\n\nfn main() {\n   \
    \ let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n \
    \   assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2,\
    \ 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1,\
    \ -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpssblc3oj.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (max_left, min_right)\
    \ = if interval1.0 > interval2.0 {\n        (interval1.0, interval2.1)\n    }\
    \ else {\n        (interval2.0, interval1.1)\n    };\n    if max_left > min_right\
    \ {\n        \"NO\".to_string()\n    } else {\n        let interval_size = min_right\
    \ - max_left + 1;\n        if interval_size == 2 {\n            \"YES\".to_string()\n\
    \        } else {\n            for i in 2..(interval_size as f64).sqrt() as isize\
    \ + 1 {\n                if interval_size % i == 0 {\n                    return\
    \ \"NO\".to_string();\n                }\n            }\n            \"YES\".to_string()\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp8pk8izjv.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n  if interval1.0 < interval2.0\
    \ {\n    return match (interval2.0, interval1.1) {\n      (start, end) if start\
    \ <= end => if primes::is_prime(end - start + 1) {\n        \"YES\".to_string()\n\
    \      } else {\n        \"NO\".to_string()\n      },\n      _ => \"NO\".to_string(),\n\
    \    };\n  } else {\n    return match (interval1.0, interval2.1) {\n      (start,\
    \ end) if start <= end => if primes::is_prime(end - start + 1) {\n        \"YES\"\
    .to_string()\n      } else {\n        \"NO\".to_string()\n      },\n      _ =>\
    \ \"NO\".to_string(),\n    };\n  }\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `primes`\n\
    \  --> /tmp/tmp9b8nwvbu.rs:17:42\n   |\n17 |       (start, end) if start <= end\
    \ => if primes::is_prime(end - start + 1) {\n   |                            \
    \              ^^^^^^ use of undeclared crate or module `primes`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `primes`\n  --> /tmp/tmp9b8nwvbu.rs:26:42\n\
    \   |\n26 |       (start, end) if start <= end => if primes::is_prime(end - start\
    \ + 1) {\n   |                                          ^^^^^^ use of undeclared\
    \ crate or module `primes`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659821493
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let mut i1 = interval1;\n\
    \    let mut i2 = interval2;\n    if i1.0 > i1.1 {\n        std::mem::swap(&mut\
    \ i1.0, &mut i1.1);\n    }\n    if i2.0 > i2.1 {\n        std::mem::swap(&mut\
    \ i2.0, &mut i2.1);\n    }\n    let mut isect = (0, 0);\n    if i1.0 > i2.1 ||\
    \ i2.0 > i1.1 {\n        return \"NO\".to_string();\n    }\n    if i1.0 < i2.0\
    \ {\n        isect.0 = i2.0;\n    } else {\n        isect.0 = i1.0;\n    }\n \
    \   if i1.1 < i2.1 {\n        isect.1 = i1.1;\n    } else {\n        isect.1 =\
    \ i2.1;\n    }\n    if isect.0 == isect.1 {\n        return \"YES\".to_string();\n\
    \    }\n    for i in 2..isect.1 {\n        if i as isize * i as isize > isect.1\
    \ {\n            return \"YES\".to_string();\n        }\n        if isect.0 %\
    \ i == 0 || isect.1 % i == 0 {\n            return \"NO\".to_string();\n     \
    \   }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpq9hztqit.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (i1_start, i1_end)\
    \ = interval1;\n    let (i2_start, i2_end) = interval2;\n    let mut start = i1_start;\n\
    \    let mut end = i1_end;\n    if i2_start > start {\n        start = i2_start;\n\
    \    }\n    if i2_end < end {\n        end = i2_end;\n    }\n    if start > end\
    \ {\n        return \"NO\".to_string();\n    }\n    let mut is_prime = true;\n\
    \    for i in 2..end {\n        if start % i == 0 {\n            is_prime = false;\n\
    \            break;\n        }\n    }\n    if is_prime {\n        \"YES\".to_string()\n\
    \    } else {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpkl4jdd68.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (x, y) = (interval1.0,\
    \ interval1.1);\n    let (a, b) = (interval2.0, interval2.1);\n    let (mut l,\
    \ mut r) = (0, 0);\n    if x <= a && a <= y {\n        l = a;\n    } else if a\
    \ <= x && x <= b {\n        l = x;\n    } else {\n        return \"NO\".to_string();\n\
    \    }\n    if x <= b && b <= y {\n        r = b;\n    } else if a <= y && y <=\
    \ b {\n        r = y;\n    } else {\n        return \"NO\".to_string();\n    }\n\
    \    let mut i = 2;\n    while i < (r - l + 1) {\n        if (r - l + 1) % i ==\
    \ 0 {\n            return \"NO\".to_string();\n        }\n        i += 1;\n  \
    \  }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpxewngwjc.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let mut start =\
    \ interval1.0;\n    let mut end = interval1.1;\n    let mut tmp;\n    if interval1.0\
    \ > interval1.1 {\n        tmp = interval1.0;\n        start = interval1.1;\n\
    \        end = tmp;\n    }\n    if interval2.0 > interval2.1 {\n        tmp =\
    \ interval2.0;\n        interval2.0 = interval2.1;\n        interval2.1 = tmp;\n\
    \    }\n    if interval2.0 < start {\n        start = interval2.0;\n    }\n  \
    \  if interval2.1 > end {\n        end = interval2.1;\n    }\n    if start >=\
    \ end {\n        return \"NO\".to_string();\n    }\n    let mut i = start;\n \
    \   let mut sum = 0;\n    while i <= end {\n        sum += i;\n        i += 1;\n\
    \    }\n    if sum == 5 || sum == 7 || sum == 13 || sum == 17 || sum == 23 ||\
    \ sum == 29 || sum == 31 {\n        return \"YES\".to_string();\n    }\n    \"\
    NO\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0594]: cannot assign to `interval2.0`, as `interval2` is not declared\
    \ as mutable\n  --> /tmp/tmpneel2mp9.rs:25:9\n   |\n14 | fn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n   |               \
    \                             --------- help: consider changing this to be mutable:\
    \ `mut interval2`\n...\n25 |         interval2.0 = interval2.1;\n   |        \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign\n\nerror[E0594]: cannot assign to `interval2.1`,\
    \ as `interval2` is not declared as mutable\n  --> /tmp/tmpneel2mp9.rs:26:9\n\
    \   |\n14 | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n   |                                            --------- help:\
    \ consider changing this to be mutable: `mut interval2`\n...\n26 |         interval2.1\
    \ = tmp;\n   |         ^^^^^^^^^^^^^^^^^ cannot assign\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0594`.\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    if interval1.0 >\
    \ interval2.1 || interval2.0 > interval1.1 {\n        return \"NO\".to_string();\n\
    \    }\n    let a = interval1.0.max(interval2.0);\n    let b = interval1.1.min(interval2.1);\n\
    \    let n = b - a + 1;\n    if is_prime(n) {\n        \"YES\".to_string()\n \
    \   } else {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp7c95zd71.rs:21:8\n\
    \   |\n21 |     if is_prime(n) {\n   |        ^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n  let len = if interval1.0\
    \ <= interval2.0 {\n    if interval1.1 <= interval2.0 {\n      0\n    } else if\
    \ interval1.1 <= interval2.1 {\n      interval1.1 - interval2.0\n    } else {\n\
    \      interval2.1 - interval2.0\n    }\n  } else {\n    if interval2.1 <= interval1.0\
    \ {\n      0\n    } else if interval2.1 <= interval1.1 {\n      interval2.1 -\
    \ interval1.0\n    } else {\n      interval1.1 - interval1.0\n    }\n  };\n  if\
    \ len == 0 {\n    return \"NO\".to_string();\n  }\n  let mut count = 0;\n  for\
    \ i in 2..len {\n    if len % i == 0 {\n      count += 1;\n    }\n  }\n  if count\
    \ >= 1 {\n    \"NO\".to_string()\n  } else {\n    \"YES\".to_string()\n  }\n}\n\
    \nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpd7fw_o6a.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    if interval1.0 >\
    \ interval2.1 || interval2.0 > interval1.1 {\n        return \"NO\".to_string();\n\
    \    }\n    let start = interval1.0.max(interval2.0);\n    let end = interval1.1.min(interval2.1);\n\
    \    if start == end || (start - end).abs() == 1 {\n        return \"NO\".to_string();\n\
    \    }\n    if is_prime(end - start) {\n        return \"YES\".to_string();\n\
    \    }\n    \"NO\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpjncxti68.rs:23:8\n\
    \   |\n23 |     if is_prime(end - start) {\n   |        ^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    match intersection_imp(interval1,\
    \ interval2) {\n        None => \"NO\".to_string(),\n        Some(n) => if util::is_prime(n)\
    \ { \"YES\".to_string() } else { \"NO\".to_string() }\n    }\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `util`\n\
    \  --> /tmp/tmp7q_t5ck0.rs:17:23\n   |\n17 |         Some(n) => if util::is_prime(n)\
    \ { \"YES\".to_string() } else { \"NO\".to_string() }\n   |                  \
    \     ^^^^ use of undeclared crate or module `util`\n\nerror[E0425]: cannot find\
    \ function `intersection_imp` in this scope\n  --> /tmp/tmp7q_t5ck0.rs:15:11\n\
    \   |\n15 |     match intersection_imp(interval1, interval2) {\n   |         \
    \  ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let mut s = None;\n \
    \   let mut e = None;\n    if start1 >= start2 && start1 <= end2 {\n        s\
    \ = Some(start1);\n    } else if start2 >= start1 && start2 <= end1 {\n      \
    \  s = Some(start2);\n    }\n    if end1 >= start2 && end1 <= end2 {\n       \
    \ e = Some(end1);\n    } else if end2 >= start1 && end2 <= end1 {\n        e =\
    \ Some(end2);\n    }\n    match (s, e) {\n        (Some(s), Some(e)) => {\n  \
    \          let d = e - s;\n            let mut c = 0;\n            for i in 2..d\
    \ {\n                if d % i == 0 {\n                    c += 1;\n          \
    \      }\n            }\n            if c == 0 {\n                \"YES\".to_string()\n\
    \            } else {\n                \"NO\".to_string()\n            }\n   \
    \     }\n        _ => \"NO\".to_string(),\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpx2dpl_36.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let vec = [interval1,\
    \ interval2];\n    let mut first = (0, 0);\n    let mut last = (0, 0);\n    for\
    \ &(start, end) in vec.iter() {\n        if start > last.1 {\n            first\
    \ = (start, end);\n            last = (start, end);\n        } else if start <\
    \ last.1 && end > last.1 {\n            last = (last.0, end);\n        }\n   \
    \ }\n    let mut length = 0;\n    for i in first.0..=last.1 {\n        if (first.0..=last.1).any(|x|\
    \ x == i) && (interval1.0..=interval1.1).any(|x| x == i) && (interval2.0..=interval2.1).any(|x|\
    \ x == i) {\n            length += 1;\n        }\n    }\n    if length == 0 {\n\
    \        return \"NO\".to_string();\n    }\n    if length == 1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let mut counter = 0;\n    for i in 2..length\
    \ {\n        if length % i == 0 {\n            counter += 1;\n        }\n    }\n\
    \    if counter == 0 {\n        return \"YES\".to_string();\n    }\n    return\
    \ \"NO\".to_string();\n}\n\nfn main() {\n    let candidate = intersection;\n \
    \   assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp7b5hsuw1.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let start = max(interval1.0,\
    \ interval2.0);\n    let end = min(interval1.1, interval2.1);\n    if start >\
    \ end {\n        return \"NO\".to_string();\n    }\n\n    let len = end - start\
    \ + 1;\n    if len == 2 {\n        return \"YES\".to_string();\n    }\n\n    for\
    \ i in 2..len {\n        if len % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmp4_ew7ud0.rs:15:17\n\
    \   |\n15 |     let start = max(interval1.0, interval2.0);\n   |             \
    \    ^^^ not found in this scope\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::max;\n   |\n\nerror[E0425]: cannot find function `min`\
    \ in this scope\n  --> /tmp/tmp4_ew7ud0.rs:16:15\n   |\n16 |     let end = min(interval1.1,\
    \ interval2.1);\n   |               ^^^\n...\n35 | fn main() {\n   | ---------\
    \ similarly named function `main` defined here\n   |\nhelp: a function with a\
    \ similar name exists\n   |\n16 |     let end = main(interval1.1, interval2.1);\n\
    \   |               ~~~~\nhelp: consider importing this function\n   |\n1  | use\
    \ std::cmp::min;\n   |\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = start1.max(start2);\n\
    \    let end = end1.min(end2);\n    if is_prime(end - start + 1) {\n        \"\
    YES\".to_string()\n    } else {\n        \"NO\".to_string()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpqx9cmda4.rs:22:8\n\
    \   |\n22 |     if is_prime(end - start + 1) {\n   |        ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821493
- exit_code: 0
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    if interval1.0 >\
    \ interval2.1 || interval2.0 > interval1.1 {\n        return \"NO\".to_string();\n\
    \    }\n    let start = if interval1.0 > interval2.0 { interval1.0 } else { interval2.0\
    \ };\n    let end = if interval1.1 < interval2.1 { interval1.1 } else { interval2.1\
    \ };\n    let length = end - start + 1;\n    if length == 1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let limit = (length as f64).sqrt() as isize;\n\
    \    if length % 2 == 0 {\n        return \"NO\".to_string();\n    }\n    for\
    \ i in 3..limit {\n        if length % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821494
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n  let len_a = if interval1.0\
    \ < interval2.0 {\n    interval2.0 - interval1.0\n  } else {\n    interval1.0\
    \ - interval2.0\n  };\n  let len_b = if interval1.1 < interval2.1 {\n    interval2.1\
    \ - interval1.1\n  } else {\n    interval1.1 - interval2.1\n  };\n  let len =\
    \ if len_a < len_b {\n    len_a\n  } else {\n    len_b\n  };\n  if len == 0 {\n\
    \    return \"NO\".to_string();\n  }\n  if (2..=len).all(|i| len % i != 0) {\n\
    \    return \"YES\".to_string();\n  }\n  \"NO\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmptnsq5h_f.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let a = interval1.0.max(interval2.0);\n\
    \    let b = interval1.1.min(interval2.1);\n    if a <= b {\n        is_prime((b\
    \ - a + 1) as usize)\n    } else {\n        \"NO\".to_string()\n    }\n}\n\nfn\
    \ main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2),\
    \ (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp1x93axq2.rs:18:9\n\
    \   |\n18 |         is_prime((b - a + 1) as usize)\n   |         ^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let start = if interval1.0\
    \ > interval2.0 {\n        interval1.0\n    } else {\n        interval2.0\n  \
    \  };\n    let end = if interval1.1 < interval2.1 {\n        interval1.1\n   \
    \ } else {\n        interval2.1\n    };\n    let num_of_elements = end - start\
    \ + 1;\n    if num_of_elements > 0 {\n        if num_of_elements == 1 || num_of_elements\
    \ == 2 {\n            return \"YES\".to_string();\n        }\n        if num_of_elements\
    \ % 2 == 0 {\n            return \"NO\".to_string();\n        }\n        let mut\
    \ divisor = 3;\n        while divisor <= (num_of_elements as f64).sqrt() as isize\
    \ {\n            if num_of_elements % divisor == 0 {\n                return \"\
    NO\".to_string();\n            }\n            divisor += 2;\n        }\n     \
    \   return \"YES\".to_string();\n    }\n    \"NO\".to_string()\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpvs0cz3tj.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (i1_s, i1_e)\
    \ = interval1;\n    let (i2_s, i2_e) = interval2;\n    if i1_e < i2_s || i2_e\
    \ < i1_s {\n        \"NO\".to_string()\n    } else {\n        let start = if i1_s\
    \ > i2_s { i1_s } else { i2_s };\n        let end = if i1_e < i2_e { i1_e } else\
    \ { i2_e };\n        let intersection_length = (end - start) + 1;\n        if\
    \ is_prime(intersection_length) {\n            \"YES\".to_string()\n        }\
    \ else {\n            \"NO\".to_string()\n        }\n    }\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpyrq8h9ln.rs:23:12\n\
    \   |\n23 |         if is_prime(intersection_length) {\n   |            ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let start = max(interval1.0,\
    \ interval2.0);\n    let end = min(interval1.1, interval2.1);\n    if start >\
    \ end {\n        return \"NO\".to_string();\n    }\n    let interval = (start,\
    \ end);\n    let len = interval.1 - interval.0 + 1;\n    if is_prime(len) {\n\
    \        return \"YES\".to_string();\n    }\n    return \"NO\".to_string();\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmp_hkhzmsj.rs:15:17\n\
    \   |\n15 |     let start = max(interval1.0, interval2.0);\n   |             \
    \    ^^^ not found in this scope\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::max;\n   |\n\nerror[E0425]: cannot find function `min`\
    \ in this scope\n  --> /tmp/tmp_hkhzmsj.rs:16:15\n   |\n16 |     let end = min(interval1.1,\
    \ interval2.1);\n   |               ^^^\n...\n28 | fn main() {\n   | ---------\
    \ similarly named function `main` defined here\n   |\nhelp: a function with a\
    \ similar name exists\n   |\n16 |     let end = main(interval1.1, interval2.1);\n\
    \   |               ~~~~\nhelp: consider importing this function\n   |\n1  | use\
    \ std::cmp::min;\n   |\n\nerror[E0425]: cannot find function `is_prime` in this\
    \ scope\n  --> /tmp/tmp_hkhzmsj.rs:22:8\n   |\n22 |     if is_prime(len) {\n \
    \  |        ^^^^^^^^ not found in this scope\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n  if interval1.0 > interval2.1\
    \ || interval2.0 > interval1.1 {\n    return \"NO\".to_string();\n  }\n  let low\
    \ = std::cmp::max(interval1.0, interval2.0);\n  let high = std::cmp::min(interval1.1,\
    \ interval2.1);\n  let l = (high - low) + 1;\n  if l <= 1 {\n    return \"NO\"\
    .to_string();\n  }\n  for n in 2..l {\n    if l % n == 0 {\n      return \"NO\"\
    .to_string();\n    }\n  }\n  \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp9svsckv6.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = isize::max(start1,\
    \ start2);\n    let end = isize::min(end1, end2);\n    let length = (end - start)\
    \ + 1;\n    if (2..length).any(|x| length % x == 0) {\n        return \"NO\".to_string();\n\
    \    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp31csa8ra.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 0
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    if interval1.0 >\
    \ interval2.1 || interval2.0 > interval1.1 {\n        return \"NO\".to_string();\n\
    \    }\n    let max = isize::max(interval1.0, interval2.0);\n    let min = isize::min(interval1.1,\
    \ interval2.1);\n    if min - max < 2 {\n        return \"NO\".to_string();\n\
    \    }\n    for i in 2..min - max {\n        if (min - max) % i == 0 {\n     \
    \       return \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821494
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (i1, i2) = if\
    \ interval1.0 < interval2.0 { (interval1, interval2) } else { (interval2, interval1)\
    \ };\n    if i1.1 < i2.0 {\n        \"NO\".to_string()\n    } else {\n       \
    \ let mut primes = vec![];\n        let len = if i1.1 < i2.1 { i1.1 - i2.0 + 1\
    \ } else { i2.1 - i2.0 + 1 };\n        for i in 2..len {\n            if is_prime(i)\
    \ {\n                primes.push(i);\n            }\n        }\n        if primes.len()\
    \ == 0 {\n            \"NO\".to_string()\n        } else {\n            \"YES\"\
    .to_string()\n        }\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpzo90axgf.rs:22:16\n\
    \   |\n22 |             if is_prime(i) {\n   |                ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (x1, y1) = interval1;\n\
    \    let (x2, y2) = interval2;\n    //println!(\"{} {} {} {}\", x1, y1, x2, y2);\n\
    \    if y1 < x2 || y2 < x1 {\n        return \"NO\".to_string();\n    }\n    let\
    \ a = x1.max(x2);\n    let b = y1.min(y2);\n    let c = b - a + 1;\n    if is_prime(c)\
    \ {\n        return \"YES\".to_string();\n    }\n    \"NO\".to_string()\n}\n\n\
    fn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2),\
    \ (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpnqgpnpvb.rs:24:8\n\
    \   |\n24 |     if is_prime(c) {\n   |        ^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    if interval1.0 >\
    \ interval2.1 || interval2.0 > interval1.1 {\n        return \"NO\".to_string();\n\
    \    }\n    let min = interval1.0.max(interval2.0);\n    let max = interval1.1.min(interval2.1);\n\
    \    if min > max {\n        return \"NO\".to_string();\n    }\n    let length\
    \ = max - min + 1;\n    if length == 1 {\n        return \"NO\".to_string();\n\
    \    }\n    if length == 2 {\n        return \"YES\".to_string();\n    }\n   \
    \ if length % 2 == 0 {\n        return \"NO\".to_string();\n    }\n    for i in\
    \ 3..(length / 2 + 1) {\n        if length % i == 0 {\n            return \"NO\"\
    .to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n \
    \   let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n \
    \   assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2,\
    \ 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1,\
    \ -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpci58siap.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let x1 = interval1.0;\n\
    \    let x2 = interval1.1;\n    let y1 = interval2.0;\n    let y2 = interval2.1;\n\
    \    let max_left = std::cmp::max(x1, y1);\n    let min_right = std::cmp::min(x2,\
    \ y2);\n    if max_left > min_right {\n        \"NO\".to_string()\n    } else\
    \ {\n        let len = min_right - max_left + 1;\n        if len == 2 {\n    \
    \        \"YES\".to_string()\n        } else {\n            let mut found = false;\n\
    \            for i in 2..len {\n                if len % i == 0 {\n          \
    \          found = true;\n                    break;\n                }\n    \
    \        }\n            if found {\n                \"NO\".to_string()\n     \
    \       } else {\n                \"YES\".to_string()\n            }\n       \
    \ }\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpbouqkc4f.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let mut result =\
    \ \"NO\";\n    let mut min = interval1.0;\n    let mut max = interval1.1;\n  \
    \  if interval2.0 > min {\n        min = interval2.0;\n    }\n    if interval2.1\
    \ < max {\n        max = interval2.1;\n    }\n    if max >= min {\n        let\
    \ length = max - min + 1;\n        let is_prime = (2..length-1).all(|x| length\
    \ % x != 0);\n        if is_prime {\n            result = \"YES\";\n        }\n\
    \    }\n    result.to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp2b95_8rt.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let start = max(interval1.0,\
    \ interval2.0);\n    let end = min(interval1.1, interval2.1);\n    if start >\
    \ end {\n        return \"NO\".to_string();\n    }\n    let length = end - start\
    \ + 1;\n    if length == 1 {\n        return \"NO\".to_string();\n    }\n    if\
    \ length == 2 {\n        return \"YES\".to_string();\n    }\n    let mut is_prime\
    \ = true;\n    for i in 2..length {\n        if length % i == 0 {\n          \
    \  is_prime = false;\n            break;\n        }\n    }\n    if is_prime {\n\
    \        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n    }\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpzhqzlkko.rs:15:17\n\
    \   |\n15 |     let start = max(interval1.0, interval2.0);\n   |             \
    \    ^^^ not found in this scope\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::max;\n   |\n\nerror[E0425]: cannot find function `min`\
    \ in this scope\n  --> /tmp/tmpzhqzlkko.rs:16:15\n   |\n16 |     let end = min(interval1.1,\
    \ interval2.1);\n   |               ^^^\n...\n41 | fn main() {\n   | ---------\
    \ similarly named function `main` defined here\n   |\nhelp: a function with a\
    \ similar name exists\n   |\n16 |     let end = main(interval1.1, interval2.1);\n\
    \   |               ~~~~\nhelp: consider importing this function\n   |\n1  | use\
    \ std::cmp::min;\n   |\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let interval_max_start\
    \ = interval1.0.max(interval2.0);\n    let interval_min_end = interval1.1.min(interval2.1);\n\
    \    let interval_range = interval_min_end - interval_max_start;\n    if interval_range\
    \ <= 0 {\n        return \"NO\".to_string();\n    }\n    if is_prime(interval_range)\
    \ {\n        return \"YES\".to_string();\n    }\n    return \"NO\".to_string();\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp0q0g1t0i.rs:21:8\n\
    \   |\n21 |     if is_prime(interval_range) {\n   |        ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    if interval1.0 <=\
    \ interval2.1 && interval2.0 <= interval1.1 {\n        let start = interval1.0.max(interval2.0);\n\
    \        let end = interval1.1.min(interval2.1);\n        (end - start + 1).is_prime().to_string()\n\
    \    } else {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_prime` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmptpq06rmy.rs:18:27\n   |\n18 |         (end - start\
    \ + 1).is_prime().to_string()\n   |                           ^^^^^^^^ method\
    \ not found in `isize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (interval1_start,\
    \ interval1_end) = interval1;\n    let (interval2_start, interval2_end) = interval2;\n\
    \    if interval1_end < interval2_start || interval2_end < interval1_start {\n\
    \        return \"NO\".to_string();\n    }\n    let intersection_start = if interval1_start\
    \ > interval2_start {\n        interval1_start\n    } else {\n        interval2_start\n\
    \    };\n    let intersection_end = if interval1_end < interval2_end {\n     \
    \   interval1_end\n    } else {\n        interval2_end\n    };\n    if is_prime(intersection_end\
    \ - intersection_start + 1) {\n        \"YES\".to_string()\n    } else {\n   \
    \     \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpnzy_cxot.rs:30:8\n\
    \   |\n30 |     if is_prime(intersection_end - intersection_start + 1) {\n   |\
    \        ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    let start = std::cmp::max(a, c);\n    let end\
    \ = std::cmp::min(b, d);\n    if start > end {\n        return \"NO\".to_string();\n\
    \    }\n    let diff = end - start + 1;\n    if is_prime(diff) {\n        return\
    \ \"YES\".to_string();\n    }\n    \"NO\".to_string()\n}\n\nfn main() {\n    let\
    \ candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n \
    \   assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2,\
    \ 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1,\
    \ -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp1jg5kr27.rs:23:8\n\
    \   |\n23 |     if is_prime(diff) {\n   |        ^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let start = std::cmp::max(interval1.0,\
    \ interval2.0);\n    let end = std::cmp::min(interval1.1, interval2.1);\n    if\
    \ start > end {\n        return \"NO\".to_string();\n    }\n    let len = end\
    \ - start + 1;\n    let prime = (2..).take_while(|x| x * x <= len).all(|x| len\
    \ % x != 0);\n    if prime {\n        \"YES\".to_string()\n    } else {\n    \
    \    \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp09bsmm1m.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    if interval1.0 >\
    \ interval2.1 || interval2.0 > interval1.1 {\n        return \"NO\".to_string();\n\
    \    }\n    let (a, b) = if interval1.0 > interval2.0 {\n        (interval1.0,\
    \ interval2.1)\n    } else {\n        (interval2.0, interval1.1)\n    };\n   \
    \ let len = b - a + 1;\n    if len <= 1 {\n        return \"NO\".to_string();\n\
    \    }\n    for i in 2..len {\n        if len % i == 0 {\n            return \"\
    NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpgsjo3030.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let mut int_list\
    \ = vec![];\n    if interval1.0 <= interval2.0 && interval2.0 <= interval1.1 &&\
    \ interval1.1 <= interval2.1 {\n        int_list.push(interval2.0);\n        int_list.push(interval1.1);\n\
    \    } else if interval2.0 <= interval1.0 && interval1.0 <= interval2.1 && interval2.1\
    \ <= interval1.1 {\n        int_list.push(interval1.0);\n        int_list.push(interval2.1);\n\
    \    } else if interval1.0 <= interval2.0 && interval2.1 <= interval1.1 {\n  \
    \      int_list.push(interval2.0);\n        int_list.push(interval2.1);\n    }\
    \ else if interval2.0 <= interval1.0 && interval1.1 <= interval2.1 {\n       \
    \ int_list.push(interval1.0);\n        int_list.push(interval1.1);\n    } else\
    \ {\n        return \"NO\".to_string();\n    }\n    if int_list.len() == 0 {\n\
    \        return \"NO\".to_string();\n    } else {\n        if int_list[1] - int_list[0]\
    \ == 1 {\n            return \"YES\".to_string();\n        } else {\n        \
    \    return \"NO\".to_string();\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpqm861pju.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    if start >= end {\n\
    \        return \"NO\".to_string();\n    }\n    let number = (end - start) + 1;\n\
    \    if number < 2 {\n        return \"NO\".to_string();\n    }\n    if number\
    \ == 2 {\n        return \"YES\".to_string();\n    }\n    let half = (number as\
    \ f64 / 2.0).floor() as isize;\n    for x in 2..half + 1 {\n        if number\
    \ % x == 0 {\n            return \"NO\".to_string();\n        }\n    }\n    \"\
    YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpydpsh6fz.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let mut s = 0;\n\
    \    let mut e = 0;\n    if interval1.0 <= interval2.0 {\n        s = interval2.0;\n\
    \    } else {\n        s = interval1.0;\n    }\n    if interval1.1 <= interval2.1\
    \ {\n        e = interval1.1;\n    } else {\n        e = interval2.1;\n    }\n\
    \    if s >= e {\n        return \"NO\".to_string();\n    }\n    let n = e - s\
    \ + 1;\n    let mut i = 2;\n    while i * i <= n {\n        if n % i == 0 {\n\
    \            return \"NO\".to_string();\n        }\n        i += 1;\n    }\n \
    \   \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp4bbafj6m.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    if interval1.0 >\
    \ interval2.1 || interval2.0 > interval1.1 {\n        \"NO\".to_string()\n   \
    \ } else {\n        let mut inter = if interval1.0 > interval2.0 {\n         \
    \   (interval1.0, interval2.1)\n        } else {\n            (interval2.0, interval1.1)\n\
    \        };\n        if inter.0 > inter.1 {\n            inter = (inter.1, inter.0);\n\
    \        }\n        if inter.1 - inter.0 == 1 {\n            \"NO\".to_string()\n\
    \        } else {\n            if is_prime(inter.1 - inter.0) {\n            \
    \    \"YES\".to_string()\n            } else {\n                \"NO\".to_string()\n\
    \            }\n        }\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpp4ayfm7e.rs:29:16\n\
    \   |\n29 |             if is_prime(inter.1 - inter.0) {\n   |               \
    \ ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    match (interval1,\
    \ interval2) {\n        ((a, b), (c, d)) if (a > d) || (b < c) => \"NO\".to_string(),\n\
    \        ((a, b), (c, d)) => match (a..b).intersection(c..d).count() {\n     \
    \       0 => \"NO\".to_string(),\n            2 => \"YES\".to_string(),\n    \
    \        _ => \"NO\".to_string(),\n        }\n    }\n}\n\nfn main() {\n    let\
    \ candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n \
    \   assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2,\
    \ 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1,\
    \ -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `intersection` found for struct `std::ops::Range`\
    \ in the current scope\n  --> /tmp/tmprnhkxq31.rs:17:42\n   |\n17 |         ((a,\
    \ b), (c, d)) => match (a..b).intersection(c..d).count() {\n   |             \
    \                             ^^^^^^^^^^^^ method not found in `std::ops::Range<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let interval_int\
    \ = (max(interval1.0, interval2.0), min(interval1.1, interval2.1));\n    let len\
    \ = interval_int.1 - interval_int.0;\n    let len = if len < 0 {0} else {len};\n\
    \    let len = len + 1;\n    if is_prime(len) {\n        \"YES\".to_string()\n\
    \    } else {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpg4_72z8j.rs:15:25\n\
    \   |\n15 |     let interval_int = (max(interval1.0, interval2.0), min(interval1.1,\
    \ interval2.1));\n   |                         ^^^ not found in this scope\n \
    \  |\nhelp: consider importing this function\n   |\n1  | use std::cmp::max;\n\
    \   |\n\nerror[E0425]: cannot find function `min` in this scope\n  --> /tmp/tmpg4_72z8j.rs:15:56\n\
    \   |\n15 |     let interval_int = (max(interval1.0, interval2.0), min(interval1.1,\
    \ interval2.1));\n   |                                                       \
    \ ^^^\n...\n26 | fn main() {\n   | --------- similarly named function `main` defined\
    \ here\n   |\nhelp: a function with a similar name exists\n   |\n15 |     let\
    \ interval_int = (max(interval1.0, interval2.0), main(interval1.1, interval2.1));\n\
    \   |                                                        ~~~~\nhelp: consider\
    \ importing this function\n   |\n1  | use std::cmp::min;\n   |\n\nerror[E0425]:\
    \ cannot find function `is_prime` in this scope\n  --> /tmp/tmpg4_72z8j.rs:19:8\n\
    \   |\n19 |     if is_prime(len) {\n   |        ^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let mut start =\
    \ cmp::max(interval1.0, interval2.0);\n    let mut end = cmp::min(interval1.1,\
    \ interval2.1);\n    if start > end {\n        return \"NO\".to_string();\n  \
    \  }\n    if is_prime(end - start + 1) {\n        return \"YES\".to_string();\n\
    \    }\n    return \"NO\".to_string();\n}\n\nfn main() {\n    let candidate =\
    \ intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmpik10_kx4.rs:15:21\n   |\n15 |     let mut start = cmp::max(interval1.0,\
    \ interval2.0);\n   |                     ^^^ use of undeclared crate or module\
    \ `cmp`\n\nerror[E0433]: failed to resolve: use of undeclared crate or module\
    \ `cmp`\n  --> /tmp/tmpik10_kx4.rs:16:19\n   |\n16 |     let mut end = cmp::min(interval1.1,\
    \ interval2.1);\n   |                   ^^^ use of undeclared crate or module\
    \ `cmp`\n\nerror[E0425]: cannot find function `is_prime` in this scope\n  -->\
    \ /tmp/tmpik10_kx4.rs:20:8\n   |\n20 |     if is_prime(end - start + 1) {\n  \
    \ |        ^^^^^^^^ not found in this scope\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (i1a, i1b) =\
    \ interval1;\n    let (i2a, i2b) = interval2;\n    if i1a > i2b || i2a > i1b {\n\
    \        return \"NO\".to_string();\n    }\n    let sorted = if i1a < i2a {\n\
    \        (i1a, i2b)\n    } else {\n        (i2a, i1b)\n    };\n    let (sorted_start,\
    \ sorted_end) = sorted;\n    let interval_length = sorted_end - sorted_start;\n\
    \    if interval_length == 1 {\n        return \"NO\".to_string();\n    }\n  \
    \  if interval_length == 2 {\n        return \"YES\".to_string();\n    }\n   \
    \ let mut is_prime = true;\n    for i in 2..interval_length - 1 {\n        if\
    \ interval_length % i == 0 {\n            is_prime = false;\n            break;\n\
    \        }\n    }\n    if is_prime {\n        \"YES\".to_string()\n    } else\
    \ {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate =\
    \ intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp1tq2b0ma.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 >= end2 ||\
    \ start2 >= end1 {\n        return \"NO\".to_string();\n    }\n    let (start,\
    \ end) = (std::cmp::max(start1, start2), std::cmp::min(end1, end2));\n    if is_prime(end\
    \ - start) {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n\
    \    }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp5p0j3hjm.rs:21:8\n\
    \   |\n21 |     if is_prime(end - start) {\n   |        ^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    // first check for\
    \ overlap\n    let interval1_start = interval1.0;\n    let interval1_end = interval1.1;\n\
    \    let interval2_start = interval2.0;\n    let interval2_end = interval2.1;\n\
    \    let mut length = 0;\n    if interval1_start > interval2_start {\n       \
    \ if interval1_start > interval2_end {\n            // no overlap\n          \
    \  return \"NO\".to_string();\n        } else {\n            // overlap\n    \
    \        if interval1_end < interval2_end {\n                length = interval1_end\
    \ - interval1_start;\n            } else {\n                length = interval2_end\
    \ - interval1_start;\n            }\n        }\n    } else {\n        if interval2_start\
    \ > interval1_end {\n            // no overlap\n            return \"NO\".to_string();\n\
    \        } else {\n            // overlap\n            if interval2_end < interval1_end\
    \ {\n                length = interval2_end - interval2_start;\n            }\
    \ else {\n                length = interval1_end - interval2_start;\n        \
    \    }\n        }\n    }\n    // if no overlap, return \"NO\"\n    // if overlap,\
    \ check that length is prime\n    if length == 1 {\n        return \"YES\".to_string();\n\
    \    }\n    if length <= 0 {\n        return \"NO\".to_string();\n    }\n    for\
    \ i in 2..length {\n        if length % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    return \"YES\".to_string();\n}\n\nfn main() {\n    let\
    \ candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n \
    \   assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2,\
    \ 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1,\
    \ -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmprsncme5u.rs:65:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    let start = if a > c { a } else { c };\n   \
    \ let end = if b < d { b } else { d };\n    let distance = if start > end {\n\
    \        0\n    } else {\n        end - start\n    };\n    println!(\"start {}\
    \ end {}\", start, end);\n    println!(\"distance {}\", distance);\n    if distance\
    \ < 0 {\n        \"NO\".to_string()\n    } else if distance == 0 {\n        \"\
    NO\".to_string()\n    } else if distance == 1 {\n        \"NO\".to_string()\n\
    \    } else if distance == 2 {\n        \"YES\".to_string()\n    } else if distance\
    \ == 3 {\n        \"YES\".to_string()\n    } else if distance == 5 {\n       \
    \ \"YES\".to_string()\n    } else if distance == 7 {\n        \"YES\".to_string()\n\
    \    } else if distance == 11 {\n        \"YES\".to_string()\n    } else if distance\
    \ == 13 {\n        \"YES\".to_string()\n    } else if distance == 17 {\n     \
    \   \"YES\".to_string()\n    } else if distance == 19 {\n        \"YES\".to_string()\n\
    \    } else if distance == 23 {\n        \"YES\".to_string()\n    } else if distance\
    \ == 29 {\n        \"YES\".to_string()\n    } else if distance == 31 {\n     \
    \   \"YES\".to_string()\n    } else if distance == 37 {\n        \"YES\".to_string()\n\
    \    } else if distance == 41 {\n        \"YES\".to_string()\n    } else if distance\
    \ == 43 {\n        \"YES\".to_string()\n    } else if distance == 47 {\n     \
    \   \"YES\".to_string()\n    } else if distance == 53 {\n        \"YES\".to_string()\n\
    \    } else if distance == 59 {\n        \"YES\".to_string()\n    } else if distance\
    \ == 61 {\n        \"YES\".to_string()\n    } else if distance == 67 {\n     \
    \   \"YES\".to_string()\n    } else if distance == 71 {\n        \"\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpti1tanlz.rs:83:63\n\
    \   |\n83 |       assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"\
    ));\n   |  _______________________________________________________________^\n\
    84 | | }\n   | |__^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let start = interval1.0.max(interval2.0);\n\
    \    let end = interval1.1.min(interval2.1);\n    if start <= end {\n        (end\
    \ - start + 1).is_prime().to_string()\n    } else {\n        \"NO\".to_string()\n\
    \    }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_prime` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpaomrls_8.rs:18:27\n   |\n18 |         (end - start\
    \ + 1).is_prime().to_string()\n   |                           ^^^^^^^^ method\
    \ not found in `isize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (interval1_start,\
    \ interval1_end) = interval1;\n    let (interval2_start, interval2_end) = interval2;\n\
    \    if interval1_end < interval2_start || interval2_end < interval1_start {\n\
    \        return \"NO\".to_string();\n    }\n    let max_start = std::cmp::max(interval1_start,\
    \ interval2_start);\n    let min_end = std::cmp::min(interval1_end, interval2_end);\n\
    \    let intersection_length = min_end - max_start + 1;\n    return if is_prime(intersection_length)\
    \ {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n \
    \   };\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp7w3i3psp.rs:23:15\n\
    \   |\n23 |     return if is_prime(intersection_length) {\n   |              \
    \ ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 0
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    if interval1.0 >\
    \ interval2.1 || interval2.0 > interval1.1 {\n        return \"NO\".to_string();\n\
    \    }\n    let mut xs = vec![interval1.0, interval1.1, interval2.0, interval2.1];\n\
    \    xs.sort();\n    let x = xs[1] - xs[0];\n    if x < 2 {\n        return \"\
    NO\".to_string();\n    }\n    if x == 2 {\n        return \"YES\".to_string();\n\
    \    }\n    if x == 3 {\n        return \"YES\".to_string();\n    }\n    for i\
    \ in 2..x {\n        if x % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821494
- exit_code: 0
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let mut start = start1;\n\
    \    let mut end = end1;\n    if start2 > start1 {\n        start = start2;\n\
    \    }\n    if end2 < end1 {\n        end = end2;\n    }\n    if start > end {\n\
    \        return \"NO\".to_string();\n    }\n    let length = end - start + 1;\n\
    \    if length <= 2 {\n        return \"NO\".to_string();\n    }\n    let mut\
    \ flag = true;\n    for i in 2..(length / 2 + 1) {\n        if length % i == 0\
    \ {\n            flag = false;\n            break;\n        }\n    }\n    if flag\
    \ {\n        return \"YES\".to_string();\n    }\n    \"NO\".to_string()\n}\n\n\
    fn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2),\
    \ (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821494
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let mut prime =\
    \ false;\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n    let mut\
    \ length = 0;\n    if a >= c && a <= d || b >= c && b <= d || c >= a && c <= b\
    \ || d >= a && d <= b {\n        if a >= c && a <= d {\n            if b <= d\
    \ {\n                length = b - a;\n            } else {\n                length\
    \ = d - a;\n            }\n        } else if b >= c && b <= d {\n            if\
    \ a <= c {\n                length = b - c;\n            } else {\n          \
    \      length = b - a;\n            }\n        } else if c >= a && c <= b {\n\
    \            if d <= b {\n                length = d - c;\n            } else\
    \ {\n                length = b - c;\n            }\n        } else if d >= a\
    \ && d <= b {\n            if c <= a {\n                length = d - a;\n    \
    \        } else {\n                length = d - c;\n            }\n        }\n\
    \        prime = is_prime(length);\n    } else {\n        return \"NO\".to_string();\n\
    \    }\n    if prime {\n        return \"YES\".to_string();\n    } else {\n  \
    \      return \"NO\".to_string();\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpp2g1ajl5.rs:45:17\n\
    \   |\n45 |         prime = is_prime(length);\n   |                 ^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (left1, right1)\
    \ = interval1;\n    let (left2, right2) = interval2;\n    if left1 >= right2 ||\
    \ left2 >= right1 {\n        return \"NO\".to_string();\n    }\n    let is_prime\
    \ = (0..left1.max(left2) - right1.min(right2)).any(|x| x.is_prime());\n    if\
    \ is_prime {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n\
    \    }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_prime` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpgbd19780.rs:20:73\n   |\n20 |     let is_prime\
    \ = (0..left1.max(left2) - right1.min(right2)).any(|x| x.is_prime());\n   |  \
    \                                                                       ^^^^^^^^\
    \ method not found in `isize`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    // Your code here\n\
    \    let mut start = interval1.0;\n    let mut end = interval1.1;\n    if interval2.0\
    \ > start {\n        start = interval2.0;\n    }\n    if interval2.1 < end {\n\
    \        end = interval2.1;\n    }\n    if start > end {\n        return \"NO\"\
    .to_string();\n    }\n    if is_prime(end - start + 1) {\n        return \"YES\"\
    .to_string();\n    }\n    \"NO\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp1cohk0k5.rs:27:8\n\
    \   |\n27 |     if is_prime(end - start + 1) {\n   |        ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let i1_start = interval1.0;\n\
    \    let i1_end = interval1.1;\n    let i2_start = interval2.0;\n    let i2_end\
    \ = interval2.1;\n    let mut left = i1_start;\n    let mut right = i1_end;\n\
    \    if i2_start > i1_start {\n        left = i2_start;\n    }\n    if i2_end\
    \ < i1_end {\n        right = i2_end;\n    }\n    let diff = right - left;\n \
    \   if diff < 0 {\n        return \"NO\".to_string();\n    }\n    let mut not_prime\
    \ = false;\n    for i in 2..diff {\n        if diff % i == 0 {\n            not_prime\
    \ = true;\n            break;\n        }\n    }\n    if not_prime {\n        return\
    \ \"NO\".to_string();\n    }\n    return \"YES\".to_string();\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp7k1eq291.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    // TODO: implement\
    \ this function\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp13ms987d.rs:16:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821494
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    // Interval (a, b) doesn't intersect with (c,\
    \ d)\n    if a > d || b < c {\n        return \"NO\".to_string();\n    }\n   \
    \ // Interval (a, b) contains (c, d)\n    if a <= c && b >= d {\n        return\
    \ is_prime(d - c) ? \"YES\" : \"NO\";\n    }\n    // Interval (c, d) contains\
    \ (a, b)\n    if c <= a && d >= b {\n        return is_prime(b - a) ? \"YES\"\
    \ : \"NO\";\n    }\n    // (a, b) is completely above (c, d)\n    if a > c &&\
    \ b > d {\n        return is_prime(b - c) ? \"YES\" : \"NO\";\n    }\n    // (a,\
    \ b) is completely below (c, d)\n    if a < c && b < d {\n        return is_prime(d\
    \ - a) ? \"YES\" : \"NO\";\n    }\n    // (a, b) intersects partially with (c,\
    \ d)\n    let left = if a > c { a } else { c };\n    let right = if b < d { b\
    \ } else { d };\n    return is_prime(right - left) ? \"YES\" : \"NO\";\n}\n\n\
    fn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2),\
    \ (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `\"YES\"\
    `\n  --> /tmp/tmpr2ra9n9j.rs:23:34\n   |\n23 |         return is_prime(d - c)\
    \ ? \"YES\" : \"NO\";\n   |                                  ^^^^^ expected one\
    \ of `.`, `;`, `?`, `}`, or an operator\n\nerror: expected one of `.`, `;`, `?`,\
    \ `}`, or an operator, found `\"YES\"`\n  --> /tmp/tmpr2ra9n9j.rs:27:34\n   |\n\
    27 |         return is_prime(b - a) ? \"YES\" : \"NO\";\n   |                \
    \                  ^^^^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\n\
    error: expected one of `.`, `;`, `?`, `}`, or an operator, found `\"YES\"`\n \
    \ --> /tmp/tmpr2ra9n9j.rs:31:34\n   |\n31 |         return is_prime(b - c) ? \"\
    YES\" : \"NO\";\n   |                                  ^^^^^ expected one of `.`,\
    \ `;`, `?`, `}`, or an operator\n\nerror: expected one of `.`, `;`, `?`, `}`,\
    \ or an operator, found `\"YES\"`\n  --> /tmp/tmpr2ra9n9j.rs:35:34\n   |\n35 |\
    \         return is_prime(d - a) ? \"YES\" : \"NO\";\n   |                   \
    \               ^^^^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror:\
    \ expected one of `.`, `;`, `?`, `}`, or an operator, found `\"YES\"`\n  --> /tmp/tmpr2ra9n9j.rs:40:37\n\
    \   |\n40 |     return is_prime(right - left) ? \"YES\" : \"NO\";\n   |      \
    \                               ^^^^^ expected one of `.`, `;`, `?`, `}`, or an\
    \ operator\n\nerror: aborting due to 5 previous errors\n\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (x1, y1) = interval1;\n\
    \    let (x2, y2) = interval2;\n    if y1 < x2 || y2 < x1 {\n        return \"\
    NO\".to_string();\n    }\n    let x = std::cmp::max(x1, x2);\n    let y = std::cmp::min(y1,\
    \ y2);\n    if x >= y {\n        return \"NO\".to_string();\n    }\n    let mut\
    \ ans = \"YES\".to_string();\n    if x != 1 {\n        for i in 2..x {\n     \
    \       if x % i == 0 {\n                ans = \"NO\".to_string();\n         \
    \       break;\n            }\n        }\n    }\n    ans\n}\n\nfn main() {\n \
    \   let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n \
    \   assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2,\
    \ 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1,\
    \ -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpqkxzdg9r.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (i1_start, i1_end)\
    \ = interval1;\n    let (i2_start, i2_end) = interval2;\n    if i1_end < i2_start\
    \ || i2_end < i1_start {\n        return \"NO\".to_string();\n    }\n    let left\
    \ = if i1_start < i2_start { i2_start } else { i1_start };\n    let right = if\
    \ i1_end < i2_end { i1_end } else { i2_end };\n    let length = (right - left)\
    \ + 1;\n    if length == 1 {\n        return \"NO\".to_string();\n    }\n    if\
    \ length == 2 {\n        return \"YES\".to_string();\n    }\n    let mut flag\
    \ = true;\n    for i in 2..length/2 {\n        if length % i == 0 {\n        \
    \    flag = false;\n            break;\n        }\n    }\n    if flag {\n    \
    \    return \"YES\".to_string();\n    }\n    \"NO\".to_string()\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp0zdentp8.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (x1, y1) = interval1;\n\
    \    let (x2, y2) = interval2;\n    if (x1 <= x2 && x2 <= y1) || (x2 <= x1 &&\
    \ x1 <= y2) {\n        let max_x = isize::max(x1, x2);\n        let min_y = isize::min(y1,\
    \ y2);\n        if min_y - max_x == 1 {\n            return \"NO\".to_string();\n\
    \        }\n        let sieve = prime_sieve(min_y - max_x);\n        if sieve[(min_y\
    \ - max_x) as usize] {\n            return \"YES\".to_string();\n        }\n \
    \   }\n    \"NO\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `prime_sieve` in this scope\n  --> /tmp/tmpv1zrst0x.rs:23:21\n\
    \   |\n23 |         let sieve = prime_sieve(min_y - max_x);\n   |            \
    \         ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let start = interval1.0.max(interval2.0);\n\
    \    let end = interval1.1.min(interval2.1);\n    if start > end {\n        return\
    \ \"NO\".to_string();\n    }\n    if is_prime(end - start + 1) {\n        return\
    \ \"YES\".to_string();\n    }\n    \"NO\".to_string()\n}\n\nfn main() {\n    let\
    \ candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n \
    \   assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2,\
    \ 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1,\
    \ -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpazf_lhw9.rs:20:8\n\
    \   |\n20 |     if is_prime(end - start + 1) {\n   |        ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let start = std::cmp::max(interval1.0,\
    \ interval2.0);\n    let end = std::cmp::min(interval1.1, interval2.1);\n    if\
    \ start <= end {\n        let mut flag = true;\n        let end_tmp = if end ==\
    \ 1 { 2 } else { end };\n        for i in 2..end_tmp {\n            if end % i\
    \ == 0 {\n                flag = false;\n                break;\n            }\n\
    \        }\n        if flag {\n            \"YES\".to_string()\n        } else\
    \ {\n            \"NO\".to_string()\n        }\n    } else {\n        \"NO\".to_string()\n\
    \    }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp1oir57ix.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    let (mut start, mut end) = (0, 0);\n    if a\
    \ <= c && c <= b {\n        start = c;\n    } else if c <= a && a <= d {\n   \
    \     start = a;\n    }\n    if a <= d && d <= b {\n        end = d;\n    } else\
    \ if c <= b && b <= d {\n        end = b;\n    }\n    if start == 0 || end ==\
    \ 0 {\n        return \"NO\".to_string();\n    }\n    if is_prime(end - start)\
    \ {\n        return \"YES\".to_string();\n    }\n    \"NO\".to_string()\n}\n\n\
    fn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2),\
    \ (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp4uvgs83d.rs:31:8\n\
    \   |\n31 |     if is_prime(end - start) {\n   |        ^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let mut min_intersection\
    \ = interval1.0.max(interval2.0);\n    let mut max_intersection = interval1.1.min(interval2.1);\n\
    \    if max_intersection < min_intersection {\n        return \"NO\".to_string();\n\
    \    }\n    let length = max_intersection - min_intersection + 1;\n    if length\
    \ == 1 {\n        return \"NO\".to_string();\n    }\n    if length == 2 {\n  \
    \      return \"YES\".to_string();\n    }\n    for i in 2..length {\n        if\
    \ length % i == 0 {\n            return \"NO\".to_string();\n        }\n    }\n\
    \    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpgvtgo2c9.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (i1_start, i1_end)\
    \ = interval1;\n    let (i2_start, i2_end) = interval2;\n    if (i1_start < i2_start\
    \ && i1_end < i2_start) || (i2_start < i1_start && i2_end < i1_start) {\n    \
    \    return \"NO\".to_string();\n    }\n    let max_start = cmp::max(i1_start,\
    \ i2_start);\n    let min_end = cmp::min(i1_end, i2_end);\n    let len = min_end\
    \ - max_start + 1;\n    if prime_numbers::is_prime(len) {\n        return \"YES\"\
    .to_string();\n    }\n    \"NO\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmpas_z91d4.rs:20:21\n   |\n20 |     let max_start = cmp::max(i1_start,\
    \ i2_start);\n   |                     ^^^ use of undeclared crate or module `cmp`\n\
    \nerror[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n \
    \ --> /tmp/tmpas_z91d4.rs:21:19\n   |\n21 |     let min_end = cmp::min(i1_end,\
    \ i2_end);\n   |                   ^^^ use of undeclared crate or module `cmp`\n\
    \nerror[E0433]: failed to resolve: use of undeclared crate or module `prime_numbers`\n\
    \  --> /tmp/tmpas_z91d4.rs:23:8\n   |\n23 |     if prime_numbers::is_prime(len)\
    \ {\n   |        ^^^^^^^^^^^^^ use of undeclared crate or module `prime_numbers`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let mut x = interval1.0;\n\
    \    let mut y = interval1.1;\n    let (a, b) = interval2;\n    if interval1.0\
    \ > interval2.0 {\n        x = interval2.0;\n    }\n    if interval1.1 < interval2.1\
    \ {\n        y = interval2.1;\n    }\n    if x > y {\n        return \"NO\".to_string();\n\
    \    }\n    let mut primes = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut val = x;\n\
    \    let mut vec = Vec::new();\n    while val <= y {\n        vec.push(val);\n\
    \        val += 1;\n    }\n    for prime in primes {\n        if vec.contains(&prime)\
    \ {\n            return \"YES\".to_string();\n        }\n    }\n    \"NO\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp_hvtscw3.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    if interval1.0 >\
    \ interval2.1 || interval2.0 > interval1.1 {\n        \"NO\".to_string()\n   \
    \ } else {\n        let min_start = interval1.0.max(interval2.0);\n        let\
    \ max_end = interval1.1.min(interval2.1);\n        let diff = (max_end - min_start)\
    \ + 1;\n        if diff > 2 && (diff as f64).sqrt().fract() == 0.0 {\n       \
    \     \"NO\".to_string()\n        } else {\n            \"YES\".to_string()\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmph4_9t_mp.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (i1_min, i1_max)\
    \ = interval1;\n    let (i2_min, i2_max) = interval2;\n    if i1_max < i2_min\
    \ || i2_max < i1_min {\n        return \"NO\".to_string();\n    }\n    let min\
    \ = if i1_min < i2_min { i2_min } else { i1_min };\n    let max = if i1_max <\
    \ i2_max { i1_max } else { i2_max };\n    let inter = (min, max);\n    let len\
    \ = inter.1 - inter.0;\n    if len <= 1 {\n        return \"NO\".to_string();\n\
    \    }\n    if is_prime(len) {\n        return \"YES\".to_string();\n    }\n \
    \   \"NO\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp7kusg00s.rs:27:8\n\
    \   |\n27 |     if is_prime(len) {\n   |        ^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let start = if interval1.0\
    \ > interval2.0 {\n        interval1.0\n    } else {\n        interval2.0\n  \
    \  };\n    let end = if interval1.1 < interval2.1 {\n        interval1.1\n   \
    \ } else {\n        interval2.1\n    };\n    if start > end {\n        return\
    \ \"NO\".to_string();\n    }\n    for i in 2..start {\n        if start % i ==\
    \ 0 {\n            return \"NO\".to_string();\n        }\n    }\n    for i in\
    \ 2..end {\n        if end % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpefs9xj56.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let start_value\
    \ = interval1.0.max(interval2.0);\n    let end_value = interval1.1.min(interval2.1);\n\
    \    let diff = end_value - start_value;\n    if diff < 0 {\n        return \"\
    NO\".to_string();\n    }\n    let n = (2..=(diff as f64).sqrt() as isize).filter(|x|\
    \ diff % x == 0).count();\n    if n == 0 {\n        \"YES\".to_string()\n    }\
    \ else {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpqbvenlyk.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start, end)\
    \ = if interval1.0 < interval2.0 {\n        (interval2.0, interval1.1)\n    }\
    \ else {\n        (interval1.0, interval2.1)\n    };\n    if start > end {\n \
    \       return \"NO\".to_string();\n    }\n    let diff = end - start + 1;\n \
    \   if diff <= 1 {\n        return \"NO\".to_string();\n    }\n    if is_prime(diff)\
    \ {\n        return \"YES\".to_string();\n    }\n    \"NO\".to_string()\n}\n\n\
    fn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2),\
    \ (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp3j3swdwy.rs:27:8\n\
    \   |\n27 |     if is_prime(diff) {\n   |        ^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n  let mut result = (isize::max(interval1.0,\
    \ interval2.0), isize::min(interval1.1, interval2.1));\n  if result.0 > result.1\
    \ {\n    return \"NO\".to_string();\n  }\n  if result.1 - result.0 == 1 {\n  \
    \  return \"YES\".to_string();\n  }\n  if result.1 - result.0 == 2 {\n    return\
    \ \"NO\".to_string();\n  }\n  let mut i = 2;\n  while i <= result.1 {\n    if\
    \ result.1 % i == 0 {\n      return \"NO\".to_string();\n    }\n    i += 1;\n\
    \  }\n  \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmplqupdzgp.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (interval1_start,\
    \ interval1_end) = interval1;\n    let (interval2_start, interval2_end) = interval2;\n\
    \    if interval1_end < interval2_start || interval2_end < interval1_start {\n\
    \        return \"NO\".to_string();\n    }\n    let new_start = std::cmp::max(interval1_start,\
    \ interval2_start);\n    let new_end = std::cmp::min(interval1_end, interval2_end);\n\
    \    let len = new_end - new_start + 1;\n    if len == 1 {\n        return \"\
    NO\".to_string();\n    }\n    if len == 2 {\n        return \"YES\".to_string();\n\
    \    }\n    let mut is_prime = true;\n    for i in 3..len {\n        if len %\
    \ i == 0 {\n            is_prime = false;\n            break;\n        }\n   \
    \ }\n    if is_prime {\n        return \"YES\".to_string();\n    }\n    return\
    \ \"NO\".to_string();\n}\n\nfn main() {\n    let candidate = intersection;\n \
    \   assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpoudgbe8k.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (x1, x2) = interval1;\n\
    \    let (y1, y2) = interval2;\n    let left = x1.max(y1);\n    let right = x2.min(y2);\n\
    \    if left <= right {\n        if right - left == 0 {\n            return \"\
    NO\".to_string();\n        }\n        if right - left == 1 {\n            return\
    \ \"YES\".to_string();\n        }\n        let range = (2..(right - left)).collect::<Vec<isize>>();\n\
    \        let primes = range.iter().filter(|&x| {\n            let range = 2..((*x\
    \ as f64).sqrt() as isize);\n            range.all(|i| {\n                (*x\
    \ % i) != 0\n            })\n        }).collect::<Vec<&isize>>();\n        if\
    \ primes.contains(&(&(right - left))) {\n            return \"YES\".to_string();\n\
    \        }\n    }\n    \"NO\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `range` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp_5aidubi.rs:29:13\n   |\n28 |             let range =\
    \ 2..((*x as f64).sqrt() as isize);\n   |                 ----- help: consider\
    \ changing this to be mutable: `mut range`\n29 |             range.all(|i| {\n\
    \   |             ^^^^^ cannot borrow as mutable\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let start = std::cmp::max(interval1.0,\
    \ interval2.0);\n    let end = std::cmp::min(interval1.1, interval2.1);\n    if\
    \ start > end {\n        return \"NO\".to_string();\n    }\n    let diff = end\
    \ - start + 1;\n    match &*(2..(diff - 1)).filter(|x| diff % x == 0).collect::<Vec<_>>()\
    \ {\n        [] => \"YES\".to_string(),\n        _ => \"NO\".to_string(),\n  \
    \  }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpy6oao885.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let start = interval1.0.max(interval2.0);\n\
    \    let end = interval1.1.min(interval2.1);\n    if start <= end {\n        if\
    \ end == start || end == start + 1 {\n            \"NO\".to_string()\n       \
    \ } else {\n            if is_prime(end - start + 1) {\n                \"YES\"\
    .to_string()\n            } else {\n                \"NO\".to_string()\n     \
    \       }\n        }\n    } else {\n        \"NO\".to_string()\n    }\n}\n\nfn\
    \ main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2),\
    \ (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp__h3vy9t.rs:21:16\n\
    \   |\n21 |             if is_prime(end - start + 1) {\n   |                ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let start1 = interval1.0;\n\
    \    let end1 = interval1.1;\n    let start2 = interval2.0;\n    let end2 = interval2.1;\n\
    \    if start1 > end2 || start2 > end1 {\n        return \"NO\".to_string();\n\
    \    }\n    let start_intersection = start1.max(start2);\n    let end_intersection\
    \ = end1.min(end2);\n    let mut is_prime = true;\n    for i in 2..(end_intersection\
    \ - start_intersection + 1) {\n        if (end_intersection - start_intersection\
    \ + 1) % i == 0 {\n            is_prime = false;\n            break;\n       \
    \ }\n    }\n    if is_prime {\n        return \"YES\".to_string();\n    }\n  \
    \  \"NO\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n \
    \   assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpuqngdhok.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    if interval1.0 >\
    \ interval2.1 || interval2.0 > interval1.1 {\n        return \"NO\".to_string();\n\
    \    }\n    let length =\n        if interval1.0 > interval2.0 {\n           \
    \ interval1.0 - interval2.1\n        } else {\n            interval2.0 - interval1.1\n\
    \        };\n    if is_prime(length) {\n        \"YES\".to_string()\n    } else\
    \ {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate =\
    \ intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmps_yfu8du.rs:24:8\n\
    \   |\n24 |     if is_prime(length) {\n   |        ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821494
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let intersection\
    \ = (interval1.0.max(interval2.0), interval1.1.min(interval2.1));\n    let result\
    \ =\n        if intersection.0 <= intersection.1 {\n            is_prime(intersection.1\
    \ - intersection.0 + 1)\n        } else {\n            false\n        };\n   \
    \ if result {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n\
    \    }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp5cw8gfel.rs:18:13\n\
    \   |\n18 |             is_prime(intersection.1 - intersection.0 + 1)\n   |  \
    \           ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let interval = (\n\
    \        interval1.0.max(interval2.0),\n        interval1.1.min(interval2.1),\n\
    \    );\n    if interval.0 >= interval.1 {\n        return \"NO\".to_string();\n\
    \    }\n    let range = (interval.0 + 1..interval.1).collect::<Vec<isize>>();\n\
    \    if range.len() < 2 {\n        return \"YES\".to_string();\n    }\n    if\
    \ range.iter().all(|&x| x % 2 != 0) {\n        return \"YES\".to_string();\n \
    \   }\n    if range.iter().any(|&x| x == 3) {\n        return \"YES\".to_string();\n\
    \    }\n    for i in (3..=range.len() / 2).step_by(2) {\n        if range.iter().all(|&x|\
    \ x % i != 0) {\n            return \"YES\".to_string();\n        }\n    }\n \
    \   \"NO\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxpjriqjw.rs:33:38\n   |\n\
    33 |         if range.iter().all(|&x| x % i != 0) {\n   |                    \
    \                  ^ expected `isize`, found `usize`\n\nerror[E0277]: cannot mod\
    \ `isize` by `usize`\n  --> /tmp/tmpxpjriqjw.rs:33:36\n   |\n33 |         if range.iter().all(|&x|\
    \ x % i != 0) {\n   |                                    ^ no implementation for\
    \ `isize % usize`\n   |\n   = help: the trait `Rem<usize>` is not implemented\
    \ for `isize`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 <= start2 &&\
    \ start2 <= end1 {\n        if start1 <= end2 && end2 <= end1 {\n            if\
    \ end2 - start2 == 1 {\n                return \"YES\".to_string();\n        \
    \    }\n            if is_prime(end2 - start2) {\n                return \"YES\"\
    .to_string();\n            }\n        } else {\n            if end1 - start2 ==\
    \ 1 {\n                return \"YES\".to_string();\n            }\n          \
    \  if is_prime(end1 - start2) {\n                return \"YES\".to_string();\n\
    \            }\n        }\n    } else if start2 <= start1 && start1 <= end2 {\n\
    \        if start2 <= end1 && end1 <= end2 {\n            if end1 - start1 ==\
    \ 1 {\n                return \"YES\".to_string();\n            }\n          \
    \  if is_prime(end1 - start1) {\n                return \"YES\".to_string();\n\
    \            }\n        } else {\n            if end2 - start1 == 1 {\n      \
    \          return \"YES\".to_string();\n            }\n            if is_prime(end2\
    \ - start1) {\n                return \"YES\".to_string();\n            }\n  \
    \      }\n    }\n    \"NO\".to_string()\n}\n\nfn main() {\n    let candidate =\
    \ intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmppr_8xa8m.rs:22:16\n\
    \   |\n22 |             if is_prime(end2 - start2) {\n   |                ^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `is_prime` in\
    \ this scope\n  --> /tmp/tmppr_8xa8m.rs:29:16\n   |\n29 |             if is_prime(end1\
    \ - start2) {\n   |                ^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_prime` in this scope\n  --> /tmp/tmppr_8xa8m.rs:38:16\n\
    \   |\n38 |             if is_prime(end1 - start1) {\n   |                ^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `is_prime` in\
    \ this scope\n  --> /tmp/tmppr_8xa8m.rs:45:16\n   |\n45 |             if is_prime(end2\
    \ - start1) {\n   |                ^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    if interval1.0 >\
    \ interval2.1 || interval2.0 > interval1.1 {\n        return \"NO\".to_string();\n\
    \    }\n    let start = std::cmp::max(interval1.0, interval2.0);\n    let end\
    \ = std::cmp::min(interval1.1, interval2.1);\n    if start > end {\n        return\
    \ \"NO\".to_string();\n    }\n    if is_prime(end - start + 1) {\n        return\
    \ \"YES\".to_string();\n    }\n    return \"NO\".to_string();\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpyin4juye.rs:23:8\n\
    \   |\n23 |     if is_prime(end - start + 1) {\n   |        ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821493
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    if interval1.0 >\
    \ interval2.1 || interval2.0 > interval1.1 {\n        return \"NO\".to_string();\n\
    \    }\n    let mut v = vec![];\n    if interval1.0 < interval2.0 {\n        v.push(interval2.0);\n\
    \    } else {\n        v.push(interval1.0);\n    }\n    if interval1.1 < interval2.1\
    \ {\n        v.push(interval1.1);\n    } else {\n        v.push(interval2.1);\n\
    \    }\n    let length = v[1] - v[0] + 1;\n    if length == 1 {\n        return\
    \ \"NO\".to_string();\n    }\n    if length == 2 {\n        return \"YES\".to_string();\n\
    \    }\n    for i in 2..length / 2 + 1 {\n        if length % i == 0 {\n     \
    \       return \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp8mxzk5py.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    // This function\
    \ takes two intervals and returns the intersection,\n    // if it exists, of these\
    \ two intervals\n    let (x1, y1) = interval1;\n    let (x2, y2) = interval2;\n\
    \    // if (x1, y1) and (x2, y2) are disjoint, return false\n    if x1 > y2 ||\
    \ x2 > y1 {\n        return \"NO\".to_string();\n    }\n    // (a, b) is the intersection\
    \ of (x1, y1) and (x2, y2)\n    let (a, b) = (cmp::max(x1, x2), cmp::min(y1, y2));\n\
    \    // if (a, b) is a prime, return \"YES\"\n    if is_prime(b - a + 1) {\n \
    \       return \"YES\".to_string();\n    }\n    // if (a, b) is not a prime, return\
    \ \"NO\"\n    return \"NO\".to_string();\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmpbvp7je3y.rs:24:19\n   |\n24 |     let (a, b) = (cmp::max(x1, x2),\
    \ cmp::min(y1, y2));\n   |                   ^^^ use of undeclared crate or module\
    \ `cmp`\n\nerror[E0433]: failed to resolve: use of undeclared crate or module\
    \ `cmp`\n  --> /tmp/tmpbvp7je3y.rs:24:37\n   |\n24 |     let (a, b) = (cmp::max(x1,\
    \ x2), cmp::min(y1, y2));\n   |                                     ^^^ use of\
    \ undeclared crate or module `cmp`\n\nerror[E0425]: cannot find function `is_prime`\
    \ in this scope\n  --> /tmp/tmpbvp7je3y.rs:26:8\n   |\n26 |     if is_prime(b\
    \ - a + 1) {\n   |        ^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let max_start = std::cmp::max(start1,\
    \ start2);\n    let min_end = std::cmp::min(end1, end2);\n    if max_start > min_end\
    \ {\n        return \"NO\".to_string();\n    }\n    let length = min_end - max_start\
    \ + 1;\n    if length == 1 {\n        return \"NO\".to_string();\n    }\n    let\
    \ mut result = false;\n    let mut counter = 3;\n    while counter * counter <=\
    \ length {\n        if length % counter == 0 {\n            result = true;\n \
    \           break;\n        }\n        counter += 2;\n    }\n    if result {\n\
    \        \"NO\".to_string()\n    } else {\n        \"YES\".to_string()\n    }\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp1t08ih99.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let mut result =\
    \ \"NO\";\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n    let mut\
    \ x: isize = 0;\n    let mut y: isize = 0;\n    if c <= b && a <= d {\n      \
    \  x = c;\n        y = b;\n        if a > c {\n            x = a;\n        }\n\
    \        if b < d {\n            y = b;\n        }\n        if y - x >= 0 {\n\
    \            if is_prime(y - x) {\n                result = \"YES\";\n       \
    \     }\n        }\n    }\n    result.to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp_5wq7o87.rs:30:16\n\
    \   |\n30 |             if is_prime(y - x) {\n   |                ^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (x1, y1) = interval1;\n\
    \    let (x2, y2) = interval2;\n    if (x1 > y2) || (x2 > y1) {\n        return\
    \ \"NO\".to_string();\n    }\n    let range = if x1 > x2 { x1..y2 } else { x2..y1\
    \ };\n    let range_len = range.len() as isize;\n    if range_len == 0 {\n   \
    \     return \"NO\".to_string();\n    }\n    let mut is_prime = true;\n    for\
    \ i in 2..range_len {\n        if range_len % i == 0 {\n            is_prime =\
    \ false;\n            break;\n        }\n    }\n    if is_prime {\n        return\
    \ \"YES\".to_string();\n    }\n    \"NO\".to_string()\n}\n\nfn main() {\n    let\
    \ candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n \
    \   assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2,\
    \ 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1,\
    \ -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpngfdpeen.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let start = interval1.0.max(interval2.0);\n\
    \    let end = interval1.1.min(interval2.1);\n    if start > end {\n        \"\
    NO\".to_string()\n    } else {\n        let length = end - start + 1;\n      \
    \  if length == 2 {\n            \"YES\".to_string()\n        } else {\n     \
    \       let mut is_prime = true;\n            for i in 3..length {\n         \
    \       if length % i == 0 {\n                    is_prime = false;\n        \
    \            break;\n                }\n            }\n            if is_prime\
    \ {\n                \"YES\".to_string()\n            } else {\n             \
    \   \"NO\".to_string()\n            }\n        }\n    }\n}\n\nfn main() {\n  \
    \  let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n \
    \   assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2,\
    \ 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1,\
    \ -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpsnl_l0u5.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (mut start,\
    \ mut end) = (interval1.0, interval1.1);\n    if start > end {\n        start\
    \ = interval1.1;\n        end = interval1.0;\n    }\n    let (mut i1_start, mut\
    \ i1_end) = (interval2.0, interval2.1);\n    if i1_start > i1_end {\n        i1_start\
    \ = interval2.1;\n        i1_end = interval2.0;\n    }\n    if end < i1_start\
    \ || start > i1_end {\n        return \"NO\".to_string();\n    }\n    let s =\
    \ std::cmp::max(start, i1_start);\n    let e = std::cmp::min(end, i1_end);\n \
    \   if s >= e {\n        return \"NO\".to_string();\n    }\n    let s = s as usize;\n\
    \    let e = e as usize;\n    let diff = e - s;\n    let result =\n        if\
    \ diff == 1 || diff == 2 || diff == 3 || diff == 5 || diff == 7 || diff == 11\
    \ {\n            \"YES\"\n        } else {\n            \"NO\"\n        };\n \
    \   result.to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp_zwvedjz.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (interval1_left,\
    \ interval1_right) = interval1;\n    let (interval2_left, interval2_right) = interval2;\n\
    \    let mut left = interval1_left;\n    let mut right = interval1_right;\n  \
    \  if interval2_left > interval1_left {\n        left = interval2_left;\n    }\n\
    \    if interval2_right < interval1_right {\n        right = interval2_right;\n\
    \    }\n    if left > right {\n        return \"NO\".to_string();\n    }\n   \
    \ if left == right {\n        return \"YES\".to_string();\n    }\n    let s =\
    \ right - left + 1;\n    if s == 2 {\n        return \"YES\".to_string();\n  \
    \  }\n    for i in 2..(s as f64).sqrt() as isize + 1 {\n        if s % i == 0\
    \ {\n            return \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpmt6qusn_.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    if interval1.0 <=\
    \ interval2.1 && interval2.0 <= interval1.1 {\n        let low = std::cmp::max(interval1.0,\
    \ interval2.0);\n        let high = std::cmp::min(interval1.1, interval2.1);\n\
    \        if is_prime(high - low + 1) {\n            return \"YES\".to_string();\n\
    \        }\n    }\n    \"NO\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpdzbt62z8.rs:18:12\n\
    \   |\n18 |         if is_prime(high - low + 1) {\n   |            ^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let x = interval1.0.max(interval2.0);\n\
    \    let y = interval1.1.min(interval2.1);\n    let interval = x..=y;\n    if\
    \ interval.len() > 0 {\n        if interval.len() == 1 {\n            \"YES\"\
    .to_string()\n        } else {\n            match interval.len() {\n         \
    \       2 | 3 | 5 | 7 | 11 | 13 | 17 | 19 | 23 | 29 | 31 | 37 | 41 | 43 | 47 |\
    \ 53 | 59 | 61 | 67 | 71 | 73 | 79 | 83 | 89 | 97 => \"YES\".to_string(),\n  \
    \              _ => \"NO\".to_string()\n            }\n        }\n    } else {\n\
    \        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `RangeInclusive` in\
    \ the current scope\n  --> /tmp/tmpxcj5ka08.rs:18:17\n   |\n18 |     if interval.len()\
    \ > 0 {\n   |                 ^^^ method not found in `RangeInclusive<isize>`\n\
    \nerror[E0599]: no method named `len` found for struct `RangeInclusive` in the\
    \ current scope\n  --> /tmp/tmpxcj5ka08.rs:19:21\n   |\n19 |         if interval.len()\
    \ == 1 {\n   |                     ^^^ method not found in `RangeInclusive<isize>`\n\
    \nerror[E0599]: no method named `len` found for struct `RangeInclusive` in the\
    \ current scope\n  --> /tmp/tmpxcj5ka08.rs:22:28\n   |\n22 |             match\
    \ interval.len() {\n   |                            ^^^ method not found in `RangeInclusive<isize>`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    // (1,1) (1,1)\n\
    \    // (1,2) (2,4)\n    // (2,4) (1,2)\n    // (3,3) (3,3)\n    // (1,3) (2,4)\n\
    \    // (2,4) (1,3)\n    // (5,5) (5,5)\n    // (1,10) (5,5)\n    // (5,5) (1,10)\n\
    \    // (1,10) (2,4)\n    // (2,4) (1,10)\n    // (1,1) (1,10)\n    // (1,10)\
    \ (1,1)\n    // (1,10) (1,20)\n    // (1,20) (1,10)\n    // (9,9) (9,9)\n    //\
    \ (5,5) (10,10)\n    // (10,10) (5,5)\n    // (5,5) (11,11)\n    // (11,11) (5,5)\n\
    \    // (2,2) (2,2)\n    // (1,20) (5,15)\n    // (5,15) (1,20)\n    // (10,100)\
    \ (20,50)\n    // (20,50) (10,100)\n    // (1,100) (50,100)\n    // (50,100) (1,100)\n\
    \    // (10,100) (50,100)\n    // (50,100) (10,100)\n    // (15,15) (15,15)\n\
    \    // (10,15) (20,25)\n    // (20,25) (10,15)\n    // (1,1) (3,3)\n    // (3,3)\
    \ (1,1)\n    // (1,1) (5,5)\n    // (5,5) (1,1)\n    // (1,2) (1,2)\n    // (1,3)\
    \ (3,3)\n    // (3,3) (1,3)\n    // (1\n}\n\nfn main() {\n    let candidate =\
    \ intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwvdt710x.rs:14:74\n   |\n\
    14 | fn intersection(interval1: (isize, isize), interval2: (isize, isize)) ->\
    \ String {\n   |    ------------                                             \
    \             ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let interval1 =\
    \ interval1.0..interval1.1;\n    let interval2 = interval2.0..interval2.1;\n \
    \   if let Some(intersection) = interval1.intersection(&interval2) {\n       \
    \ // let intersection = intersection.0..intersection.1;\n        if intersection.end\
    \ - intersection.start < 2 {\n            \"NO\".to_string()\n        } else {\n\
    \            for i in 2..(intersection.end - intersection.start) {\n         \
    \       if (intersection.end - intersection.start) % i == 0 {\n              \
    \      return \"NO\".to_string();\n                }\n            }\n        \
    \    \"YES\".to_string()\n        }\n    } else {\n        \"NO\".to_string()\n\
    \    }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `intersection` found for struct `std::ops::Range`\
    \ in the current scope\n  --> /tmp/tmpcu12c1zw.rs:17:43\n   |\n17 |     if let\
    \ Some(intersection) = interval1.intersection(&interval2) {\n   |            \
    \                               ^^^^^^^^^^^^ method not found in `std::ops::Range<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (l1, r1) = interval1;\n\
    \    let (l2, r2) = interval2;\n    if l1 > r2 || l2 > r1 {\n        return \"\
    NO\".to_string();\n    }\n    let (l, r) = (l1.max(l2), r1.min(r2));\n    if (l..r).count()\
    \ == 1 {\n        return \"YES\".to_string();\n    }\n    return \"NO\".to_string();\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmps3gn_p23.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    if (c >= a && c <= b) || (d >= a && d <= b)\
    \ {\n        let max = isize::max(isize::max(a, b), isize::max(c, d));\n     \
    \   let min = isize::min(isize::min(a, b), isize::min(c, d));\n        let range\
    \ = (min..max).collect::<Vec<isize>>();\n        if range.len() > 1 {\n      \
    \      if range.len() == 2 {\n                return \"YES\".to_string();\n  \
    \          }\n            if range.iter().all(|&n| n % 2 != 0) {\n           \
    \     return \"YES\".to_string();\n            }\n        }\n    }\n    \"NO\"\
    .to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp8wq24sa6.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let _interval1 =\
    \ interval1;\n    let _interval2 = interval2;\n    unimplemented!()\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpfhk9vr9g.rs:17:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821495
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let isize_max =\
    \ std::isize::MAX;\n    let isize_min = std::isize::MIN;\n    let (mut start,\
    \ mut end) = (isize_max, isize_min);\n    let (mut start1, mut end1) = interval1;\n\
    \    let (mut start2, mut end2) = interval2;\n    // start and end of intersection\n\
    \    if start1 < start2 {\n        start = start2;\n    } else {\n        start\
    \ = start1;\n    }\n    if end1 > end2 {\n        end = end2;\n    } else {\n\
    \        end = end1;\n    }\n    if start > end {\n        return \"NO\".to_string();\n\
    \    }\n    if is_prime(end - start + 1) {\n        return \"YES\".to_string();\n\
    \    }\n    \"NO\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpxivr7iq1.rs:34:8\n\
    \   |\n34 |     if is_prime(end - start + 1) {\n   |        ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    if interval1.0 >\
    \ interval2.1 || interval2.0 > interval1.1 {\n        \"NO\".to_string()\n   \
    \ } else {\n        let (start, end) = \n            if interval1.0 > interval2.0\
    \ { (interval1.0, interval2.1) }\n            else { (interval2.0, interval1.1)\
    \ };\n        match (start..end).len() {\n            1 => \"YES\".to_string(),\n\
    \            2 => \"YES\".to_string(),\n            3 => \"YES\".to_string(),\n\
    \            5 => \"YES\".to_string(),\n            7 => \"YES\".to_string(),\n\
    \            _ => \"NO\".to_string(),\n        }\n    }\n}\n\nfn main() {\n  \
    \  let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n \
    \   assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2,\
    \ 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1,\
    \ -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp83v5zjbh.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let max_start =\
    \ interval1.0.max(interval2.0);\n    let min_end = interval1.1.min(interval2.1);\n\
    \    let res = min_end - max_start;\n    if res < 0 {\n        \"NO\".to_string()\n\
    \    } else if res == 0 {\n        \"YES\".to_string()\n    } else {\n       \
    \ match primes::is_prime(res as u64) {\n            true => \"YES\".to_string(),\n\
    \            false => \"NO\".to_string(),\n        }\n    }\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `primes`\n\
    \  --> /tmp/tmp5gehtpcc.rs:23:15\n   |\n23 |         match primes::is_prime(res\
    \ as u64) {\n   |               ^^^^^^ use of undeclared crate or module `primes`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (i1s, i1e) =\
    \ interval1;\n    let (i2s, i2e) = interval2;\n    let i1 = (i1s..=i1e).collect::<Vec<isize>>();\n\
    \    let i2 = (i2s..=i2e).collect::<Vec<isize>>();\n    let inter: Vec<_> = i1.iter().filter(|x|\
    \ i2.contains(x)).collect();\n    match inter.len() {\n        0 => \"NO\".to_string(),\n\
    \        1 => \"YES\".to_string(),\n        _ => inter.iter().any(|&x| prime(x))\
    \ ? \"YES\".to_string() : \"NO\".to_string(),\n    }\n}\n\nfn main() {\n    let\
    \ candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n \
    \   assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2,\
    \ 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1,\
    \ -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `,`, `.`, `?`, `}`, or an operator, found `\"YES\"\
    `\n  --> /tmp/tmpzui5dn54.rs:23:48\n   |\n23 |         _ => inter.iter().any(|&x|\
    \ prime(x)) ? \"YES\".to_string() : \"NO\".to_string(),\n   |           --   \
    \                                ^^^^^ expected one of `,`, `.`, `?`, `}`, or\
    \ an operator\n   |           |\n   |           while parsing the `match` arm\
    \ starting here\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let (mut start, mut end)\
    \ = (0, 0);\n    if start1 >= start2 && start1 <= end2 {\n        start = start1;\n\
    \    } else if start2 >= start1 && start2 <= end1 {\n        start = start2;\n\
    \    }\n    if end1 >= start2 && end1 <= end2 {\n        end = end1;\n    } else\
    \ if end2 >= start1 && end2 <= end1 {\n        end = end2;\n    }\n    if start\
    \ > end {\n        return \"NO\".to_string();\n    }\n    let len = end - start\
    \ + 1;\n    for i in 2..(len as f64).sqrt() as isize + 1 {\n        if len % i\
    \ == 0 {\n            return \"NO\".to_string();\n        }\n    }\n    \"YES\"\
    .to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp40e19t4k.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (s1, e1) = interval1;\n\
    \    let (s2, e2) = interval2;\n    if (s1 > e2) || (s2 > e1) {\n        return\
    \ \"NO\".to_string();\n    }\n    let (start, end) = if s1 > s2 {\n        (s1,\
    \ e2)\n    } else {\n        (s2, e1)\n    };\n    let mut count = end - start;\n\
    \    if count == 1 {\n        return \"NO\".to_string();\n    }\n    while count\
    \ > 1 {\n        if (end - start + 1) % count == 0 {\n            return \"NO\"\
    .to_string();\n        }\n        count -= 1;\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmplwzohpwf.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let mut start =\
    \ interval1.0;\n    let mut end = interval1.1;\n    if interval2.0 > start {\n\
    \        start = interval2.0;\n    }\n    if interval2.1 < end {\n        end\
    \ = interval2.1;\n    }\n    if start > end {\n        return \"NO\".to_string();\n\
    \    }\n    let mut length = end - start + 1;\n    while length > 1 {\n      \
    \  if start % length == 0 && end % length == 0 {\n            return \"NO\".to_string();\n\
    \        }\n        length -= 1;\n    }\n    \"YES\".to_string()\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp63oubse1.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    use num::Signed;\n\
    \    let min = |a: isize, b: isize| -> isize { if a < b { a } else { b } };\n\
    \    let max = |a: isize, b: isize| -> isize { if a > b { a } else { b } };\n\
    \    let (start1, end1) = interval1;\n    let (start2, end2) = interval2;\n  \
    \  let start = max(start1, start2);\n    let end = min(end1, end2);\n    if start\
    \ > end {\n        return \"NO\".to_string();\n    }\n    let len = end - start\
    \ + 1;\n    let is_prime = primes::is_prime(len as u64);\n    if is_prime {\n\
    \        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n    }\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0432]: unresolved import `num`\n  --> /tmp/tmpaqygh7sg.rs:15:9\n\
    \   |\n15 |     use num::Signed;\n   |         ^^^\n   |         |\n   |     \
    \    unresolved import\n   |         help: a similar path exists: `std::num`\n\
    \nerror[E0433]: failed to resolve: use of undeclared crate or module `primes`\n\
    \  --> /tmp/tmpaqygh7sg.rs:26:20\n   |\n26 |     let is_prime = primes::is_prime(len\
    \ as u64);\n   |                    ^^^^^^ use of undeclared crate or module `primes`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    if interval1.0 >\
    \ interval2.1 || interval2.0 > interval1.1 {\n        \"NO\".to_string()\n   \
    \ } else {\n        let start = interval1.0.max(interval2.0);\n        let end\
    \ = interval1.1.min(interval2.1);\n        let len = end - start + 1;\n      \
    \  if len < 2 {\n            \"NO\".to_string()\n        } else {\n          \
    \  let mut is_prime = true;\n            for i in 2..len {\n                if\
    \ len % i == 0 {\n                    is_prime = false;\n                    break;\n\
    \                }\n            }\n            if is_prime {\n               \
    \ \"YES\".to_string()\n            } else {\n                \"NO\".to_string()\n\
    \            }\n        }\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpifa8n290.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    match get_intersection(interval1,\
    \ interval2) {\n        None => \"NO\".to_string(),\n        Some((_, _)) => {\n\
    \            let (start, end) = get_intersection(interval1, interval2).unwrap();\n\
    \            match is_prime((end - start + 1) as usize) {\n                true\
    \ => \"YES\".to_string(),\n                false => \"NO\".to_string(),\n    \
    \        }\n        }\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_intersection` in this scope\n \
    \ --> /tmp/tmp5ijpd45s.rs:15:11\n   |\n15 |     match get_intersection(interval1,\
    \ interval2) {\n   |           ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `get_intersection` in this scope\n  --> /tmp/tmp5ijpd45s.rs:18:32\n\
    \   |\n18 |             let (start, end) = get_intersection(interval1, interval2).unwrap();\n\
    \   |                                ^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp5ijpd45s.rs:19:19\n\
    \   |\n19 |             match is_prime((end - start + 1) as usize) {\n   |   \
    \                ^^^^^^^^ not found in this scope\n\nerror: aborting due to 3\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 0
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2 || start2\
    \ > end1 {\n        return \"NO\".to_string();\n    }\n    let start = start1.max(start2);\n\
    \    let end = end1.min(end2);\n    if start <= end {\n        if (start..end).count()\
    \ == 2 {\n            return \"YES\".to_string();\n        }\n    }\n    \"NO\"\
    .to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821495
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    if a <= c && c <= b && b <= d {\n        if\
    \ is_prime(b - c + 1) { \"YES\".to_string() } else { \"NO\".to_string() }\n  \
    \  } else if a <= c && c <= d && d <= b {\n        if is_prime(d - c + 1) { \"\
    YES\".to_string() } else { \"NO\".to_string() }\n    } else if c <= a && a <=\
    \ d && d <= b {\n        if is_prime(d - a + 1) { \"YES\".to_string() } else {\
    \ \"NO\".to_string() }\n    } else if c <= a && a <= b && b <= d {\n        if\
    \ is_prime(b - a + 1) { \"YES\".to_string() } else { \"NO\".to_string() }\n  \
    \  } else {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp5filam_m.rs:18:12\n\
    \   |\n18 |         if is_prime(b - c + 1) { \"YES\".to_string() } else { \"NO\"\
    .to_string() }\n   |            ^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_prime` in this scope\n  --> /tmp/tmp5filam_m.rs:20:12\n\
    \   |\n20 |         if is_prime(d - c + 1) { \"YES\".to_string() } else { \"NO\"\
    .to_string() }\n   |            ^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_prime` in this scope\n  --> /tmp/tmp5filam_m.rs:22:12\n\
    \   |\n22 |         if is_prime(d - a + 1) { \"YES\".to_string() } else { \"NO\"\
    .to_string() }\n   |            ^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_prime` in this scope\n  --> /tmp/tmp5filam_m.rs:24:12\n\
    \   |\n24 |         if is_prime(b - a + 1) { \"YES\".to_string() } else { \"NO\"\
    .to_string() }\n   |            ^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let x_start = interval1.0;\n\
    \    let x_end = interval1.1;\n    let y_start = interval2.0;\n    let y_end =\
    \ interval2.1;\n    let (start, end) = if x_start <= y_start {\n        if x_end\
    \ >= y_start {\n            (y_start, if x_end <= y_end { x_end } else { y_end\
    \ })\n        } else {\n            return \"NO\".to_string();\n        }\n  \
    \  } else {\n        if y_end >= x_start {\n            (x_start, if y_end <=\
    \ x_end { y_end } else { x_end })\n        } else {\n            return \"NO\"\
    .to_string();\n        }\n    };\n    let len = end - start + 1;\n    if len ==\
    \ 1 {\n        return \"NO\".to_string();\n    }\n    match len {\n        2 |\
    \ 3 | 5 | 7 => \"YES\".to_string(),\n        _ => \"NO\".to_string(),\n    }\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp_xkwsbuz.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (i, j) = (interval1.0,\
    \ interval1.1);\n    let (a, b) = (interval2.0, interval2.1);\n    let mut flag\
    \ = true;\n    let mut count = 0;\n    let mut result = \"NO\";\n    while flag\
    \ {\n        if i > j {\n            break;\n        }\n        if (i >= a &&\
    \ i <= b) || (j >= a && j <= b) {\n            count += 1;\n        }\n      \
    \  if count == 0 {\n            break;\n        }\n        if count != 2 {\n \
    \           i += 1;\n            j -= 1;\n        } else {\n            if (i\
    \ == a && j == b) || (i == b && j == a) {\n                flag = false;\n   \
    \             result = \"YES\";\n            } else {\n                flag =\
    \ false;\n            }\n        }\n    }\n    result.to_string()\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign twice to immutable variable `i`\n  --> /tmp/tmpzcxpbg57.rs:31:13\n\
    \   |\n15 |     let (i, j) = (interval1.0, interval1.1);\n   |          -\n  \
    \ |          |\n   |          first assignment to `i`\n   |          help: consider\
    \ making this binding mutable: `mut i`\n...\n31 |             i += 1;\n   |  \
    \           ^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]:\
    \ cannot assign twice to immutable variable `j`\n  --> /tmp/tmpzcxpbg57.rs:32:13\n\
    \   |\n15 |     let (i, j) = (interval1.0, interval1.1);\n   |             -\n\
    \   |             |\n   |             first assignment to `j`\n   |          \
    \   help: consider making this binding mutable: `mut j`\n...\n32 |           \
    \  j -= 1;\n   |             ^^^^^^ cannot assign twice to immutable variable\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    let mut e = 0;\n    let mut f = 0;\n    if c\
    \ < a {\n        e = c;\n        f = a;\n    } else {\n        e = a;\n      \
    \  f = c;\n    }\n    if b < d {\n        if b < f || e > d {\n            return\
    \ \"NO\".to_string();\n        }\n    } else {\n        if d < f || e > b {\n\
    \            return \"NO\".to_string();\n        }\n    }\n    let mut length\
    \ = b - a;\n    if length < 0 {\n        length = length * -1;\n    }\n    let\
    \ mut i = 2;\n    while i < length {\n        if length % i == 0 {\n         \
    \   return \"NO\".to_string();\n        }\n        i += 1;\n    }\n    \"YES\"\
    .to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpcabh3k0r.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let start = interval1.0.max(interval2.0);\n\
    \    let end = interval1.1.min(interval2.1);\n    if start > end {\n        return\
    \ \"NO\".to_string();\n    }\n    let length = end - start + 1;\n    match length\
    \ {\n        0 => \"NO\".to_string(),\n        1 => \"YES\".to_string(),\n   \
    \     2 => \"YES\".to_string(),\n        4 => \"NO\".to_string(),\n        _ =>\
    \ {\n            for x in 2..(length / 2 + 1) {\n                if length % x\
    \ == 0 {\n                    return \"NO\".to_string();\n                }\n\
    \            }\n            \"YES\".to_string()\n        }\n    }\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpu480xnlg.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let mut i1_start\
    \ = interval1.0;\n    let mut i1_end = interval1.1;\n    let mut i2_start = interval2.0;\n\
    \    let mut i2_end = interval2.1;\n    if i1_start > i1_end {\n        std::mem::swap(&mut\
    \ i1_start, &mut i1_end);\n    }\n    if i2_start > i2_end {\n        std::mem::swap(&mut\
    \ i2_start, &mut i2_end);\n    }\n    if i1_end < i2_start || i2_end < i1_start\
    \ {\n        return \"NO\".to_string();\n    }\n    let len = match (i1_start\
    \ <= i2_start, i1_end <= i2_end) {\n        (true, true) => i1_end - i2_start,\n\
    \        (true, false) => i2_end - i2_start,\n        (false, true) => i1_end\
    \ - i1_start,\n        (false, false) => i1_start - i2_start,\n    };\n    if\
    \ is_prime(len) {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n\
    \    }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpg4ztwd59.rs:34:8\n\
    \   |\n34 |     if is_prime(len) {\n   |        ^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (mut start,\
    \ mut end) = {\n        let (start1, end1) = interval1;\n        let (start2,\
    \ end2) = interval2;\n        let new_start = start1.max(start2);\n        let\
    \ new_end = end1.min(end2);\n        if new_start > new_end {\n            return\
    \ \"NO\".to_string();\n        }\n        (new_start, new_end)\n    };\n    start\
    \ -= 1;\n    if start == 0 {\n        return \"NO\".to_string();\n    }\n    for\
    \ i in 2..(end as f64).sqrt() as isize + 1 {\n        if start % i == 0 || end\
    \ % i == 0 {\n            return \"NO\".to_string();\n        }\n    }\n    \"\
    YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpqk6ah0_g.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n  let mut new_interval\
    \ = (0, 0);\n  if interval1.0 <= interval2.0 && interval2.0 <= interval1.1 {\n\
    \    new_interval.0 = interval2.0;\n  } else if interval2.0 <= interval1.0 &&\
    \ interval1.0 <= interval2.1 {\n    new_interval.0 = interval1.0;\n  }\n  if interval1.0\
    \ <= interval2.1 && interval2.1 <= interval1.1 {\n    new_interval.1 = interval2.1;\n\
    \  } else if interval2.0 <= interval1.1 && interval1.1 <= interval2.1 {\n    new_interval.1\
    \ = interval1.1;\n  }\n  if new_interval.0 == 0 || new_interval.1 == 0 {\n   \
    \ \"NO\".to_string()\n  } else {\n    let len = new_interval.1 - new_interval.0\
    \ + 1;\n    for i in 2..len {\n      if len % i == 0 {\n        return \"NO\"\
    .to_string();\n      }\n    }\n    \"YES\".to_string()\n  }\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpf63zj2ye.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let intersection\
    \ = match (interval1, interval2) {\n        ((a, b), (c, d)) if c <= b && a <=\
    \ d => (std::cmp::max(a, c), std::cmp::min(b, d)),\n        _ => return \"NO\"\
    .to_string(),\n    };\n    if intersection.0 == intersection.1 {\n        \"NO\"\
    .to_string()\n    } else {\n        let length = intersection.1 - intersection.0\
    \ - 1;\n        if is_prime(length) {\n            \"YES\".to_string()\n     \
    \   } else {\n            \"NO\".to_string()\n        }\n    }\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp58v7zrwf.rs:23:12\n\
    \   |\n23 |         if is_prime(length) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    // Check if intervals\
    \ intersect\n    if interval1.0 > interval2.1 || interval2.0 > interval1.1 {\n\
    \        return \"NO\".to_string();\n    }\n    // Find the intersection of the\
    \ intervals\n    let start = if interval1.0 < interval2.0 {\n        interval2.0\n\
    \    } else {\n        interval1.0\n    };\n    let end = if interval1.1 < interval2.1\
    \ {\n        interval1.1\n    } else {\n        interval2.1\n    };\n    let len\
    \ = end - start + 1;\n    // Check if the length of the intersection is a prime\
    \ number\n    if !primes::is_prime(len) {\n        return \"NO\".to_string();\n\
    \    }\n    return \"YES\".to_string();\n}\n\nfn main() {\n    let candidate =\
    \ intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `primes`\n\
    \  --> /tmp/tmp4ru9_8ph.rs:32:9\n   |\n32 |     if !primes::is_prime(len) {\n\
    \   |         ^^^^^^ use of undeclared crate or module `primes`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let mut interval\
    \ = (0, 0);\n    let mut min1 = interval1.0;\n    let mut max1 = interval1.1;\n\
    \    let mut min2 = interval2.0;\n    let mut max2 = interval2.1;\n    if min1\
    \ > max1 {\n        let temp = min1;\n        min1 = max1;\n        max1 = temp;\n\
    \    }\n    if min2 > max2 {\n        let temp = min2;\n        min2 = max2;\n\
    \        max2 = temp;\n    }\n    if max1 < min2 || max2 < min1 {\n        return\
    \ \"NO\".to_string();\n    }\n    if min1 <= min2 && max1 <= max2 {\n        interval\
    \ = (min2, max1);\n    } else if min1 <= min2 && max1 >= max2 {\n        interval\
    \ = (min2, max2);\n    } else if min1 >= min2 && max1 <= max2 {\n        interval\
    \ = (min1, max1);\n    } else if min1 >= min2 && max1 >= max2 {\n        interval\
    \ = (min1, max2);\n    }\n    let mut prime_number = true;\n    for i in 2..(interval.1\
    \ - interval.0 + 1) {\n        if interval.1 - interval.0 + 1 != i && (interval.1\
    \ - interval.0 + 1) % i == 0 {\n            prime_number = false;\n          \
    \  break;\n        }\n    }\n    if prime_number {\n        return \"YES\".to_string();\n\
    \    } else {\n        return \"NO\".to_string();\n    }\n}\n\nfn main() {\n \
    \   let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n \
    \   assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2,\
    \ 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1,\
    \ -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpxfty9_pz.rs:58:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let mut list = Vec::new();\n\
    \    for i in interval1.0..=interval1.1 {\n        if i >= interval2.0 && i <=\
    \ interval2.1 {\n            list.push(i);\n        }\n    }\n    let size = list.len();\n\
    \    if size < 2 {\n        return \"NO\".to_string();\n    }\n    let res = is_prime(&size);\n\
    \    if res {\n        return \"YES\".to_string();\n    }\n    \"NO\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpvk0fz54v.rs:25:15\n\
    \   |\n25 |     let res = is_prime(&size);\n   |               ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 >= end2 ||\
    \ start2 >= end1 {\n        \"NO\".to_string()\n    } else {\n        let intersection\
    \ = if start1 < start2 {\n            (start2, if end1 < end2 { end1 } else {\
    \ end2 })\n        } else {\n            (start1, if end1 < end2 { end1 } else\
    \ { end2 })\n        };\n        let length = (intersection.1 - intersection.0)\
    \ + 1;\n        if (length == 2) || (length % 2 != 0 && !(2..length).any(|v| length\
    \ % v == 0)) {\n            \"YES\".to_string()\n        } else {\n          \
    \  \"NO\".to_string()\n        }\n    }\n}\n\nfn main() {\n    let candidate =\
    \ intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp0om5i_iv.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let start = std::cmp::max(interval1.0,\
    \ interval2.0);\n    let end = std::cmp::min(interval1.1, interval2.1);\n    if\
    \ start > end {\n        \"NO\".to_string()\n    } else {\n        let l = end\
    \ - start + 1;\n        if (l == 2) || (l == 3) || (l == 5) || (l == 7) {\n  \
    \          \"YES\".to_string()\n        } else {\n            \"NO\".to_string()\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpjxs7zad3.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    // let inter = intersection(interval1,\
    \ interval2);\n    // println!(\"{:?}\", inter);\n    if interval1.0 > interval2.1\
    \ || interval2.0 > interval1.1 {\n        return \"NO\".to_string();\n    }\n\
    \    let mut inter: (isize, isize) = (0, 0);\n    if interval1.0 > interval2.0\
    \ {\n        inter.0 = interval1.0;\n    } else {\n        inter.0 = interval2.0;\n\
    \    }\n    if interval1.1 < interval2.1 {\n        inter.1 = interval1.1;\n \
    \   } else {\n        inter.1 = interval2.1;\n    }\n    let l = inter.1 - inter.0;\n\
    \    for i in 2..l + 1 {\n        if l % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpz2429vrm.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (low, high)\
    \ = (interval1.0.max(interval2.0), interval1.1.min(interval2.1));\n    if low\
    \ > high {\n        return \"NO\".to_string();\n    }\n    let len = high - low\
    \ + 1;\n    if is_prime(len) {\n        return \"YES\".to_string();\n    }\n \
    \   \"NO\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpybbvdb3m.rs:20:8\n\
    \   |\n20 |     if is_prime(len) {\n   |        ^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    // code here\n \
    \   let (a, b) = interval1;\n    let (c, d) = interval2;\n    if a > d || b <\
    \ c { return \"NO\".to_string(); }\n    let (e, f) = if a < c { (c, d) } else\
    \ { (a, b) };\n    let primes = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    primes.contains(&(f\
    \ - e + 1))\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp959n_y0d.rs:21:5\n   |\n\
    14 | fn intersection(interval1: (isize, isize), interval2: (isize, isize)) ->\
    \ String {\n   |                                                             \
    \             ------ expected `String` because of return type\n...\n21 |     primes.contains(&(f\
    \ - e + 1))\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |     |\n   |     expected struct `String`, found\
    \ `bool`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 0
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let interval_intersection\
    \ = (\n        std::cmp::max(interval1.0, interval2.0),\n        std::cmp::min(interval1.1,\
    \ interval2.1),\n    );\n    if interval_intersection.0 >= interval_intersection.1\
    \ {\n        \"NO\".to_string()\n    } else {\n        let interval_length = interval_intersection.1\
    \ - interval_intersection.0;\n        if interval_length <= 1 {\n            \"\
    NO\".to_string()\n        } else {\n            let mut prime = true;\n      \
    \      for i in 2..interval_length {\n                if interval_length % i ==\
    \ 0 {\n                    prime = false;\n                    break;\n      \
    \          }\n            }\n            if prime {\n                \"YES\".to_string()\n\
    \            } else {\n                \"NO\".to_string()\n            }\n   \
    \     }\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821495
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let length = std::cmp::max(interval1.0,\
    \ interval2.0) - std::cmp::min(interval1.1, interval2.1);\n    if length <= 0\
    \ { return \"NO\".to_string(); }\n    if primes::is_prime(length as usize) { \"\
    YES\".to_string() } else { \"NO\".to_string() }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `primes`\n\
    \  --> /tmp/tmpdm9xgsgg.rs:17:8\n   |\n17 |     if primes::is_prime(length as\
    \ usize) { \"YES\".to_string() } else { \"NO\".to_string() }\n   |        ^^^^^^\
    \ use of undeclared crate or module `primes`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let intv1 = ((interval1.0).min(interval1.1),\
    \ (interval1.0).max(interval1.1));\n    let intv2 = ((interval2.0).min(interval2.1),\
    \ (interval2.0).max(interval2.1));\n    if intv1.1 < intv2.0 || intv2.1 < intv1.0\
    \ {\n        \"NO\".to_string()\n    } else {\n        let length = ((intv1.0).max(intv2.0)\
    \ - (intv1.1).min(intv2.1)).abs() + 1;\n        if length == 1 {\n           \
    \ \"NO\".to_string()\n        } else {\n            let result = (2..length/2\
    \ + 1).filter(|&x| length % x == 0).collect::<Vec<_>>();\n            if result.len()\
    \ == 0 {\n                \"YES\".to_string()\n            } else {\n        \
    \        \"NO\".to_string()\n            }\n        }\n    }\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmphjfdmt1b.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let a = interval1.0.max(interval2.0);\n\
    \    let b = interval1.1.min(interval2.1);\n    if a <= b {\n        if is_prime(b\
    \ - a + 1) {\n            return \"YES\".to_string();\n        }\n    }\n    \"\
    NO\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpfq72617i.rs:18:12\n\
    \   |\n18 |         if is_prime(b - a + 1) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    if interval1.0 <=\
    \ interval2.1 && interval2.0 <= interval1.1 {\n        let intersection = (interval1.0.max(interval2.0),\
    \ interval1.1.min(interval2.1));\n        if intersection.1 - intersection.0 ==\
    \ 1 { return \"NO\".to_string(); }\n        for i in 2..(intersection.1 - intersection.0)\
    \ {\n            if (intersection.1 - intersection.0) % i == 0 { return \"NO\"\
    .to_string(); }\n        }\n        \"YES\".to_string()\n    } else {\n      \
    \  \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpods44gav.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let (lower, upper) =\
    \ if start1 > start2 {\n        (start1, end2)\n    } else {\n        (start2,\
    \ end1)\n    };\n    let length = if lower > upper {\n        0\n    } else {\n\
    \        upper - lower + 1\n    };\n    if length == 0 {\n        \"NO\".to_string()\n\
    \    } else {\n        match length {\n            1 | 2 | 3 | 5 | 7 | 11 | 13\
    \ | 17 | 19 | 23 | 29 | 31 | 37 | 41 | 43 | 47 | 53 | 59 | 61 | 67 | 71 | 73 |\
    \ 79 | 83 | 89 | 97 => \"YES\".to_string(),\n            _ => \"NO\".to_string(),\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpwsaipdo7.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let mut intersection\
    \ = (0, 0);\n    let left = if interval1.0 < interval2.0 { interval1.0 } else\
    \ { interval2.0 };\n    let right = if interval1.1 < interval2.1 { interval1.1\
    \ } else { interval2.1 };\n    if right > left {\n        intersection = (left,\
    \ right);\n    }\n    if is_prime(intersection.1 - intersection.0) {\n       \
    \ return \"YES\".to_string();\n    }\n    \"NO\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp7ezz1zxb.rs:21:8\n\
    \   |\n21 |     if is_prime(intersection.1 - intersection.0) {\n   |        ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    let (left, right) = (max(a, c), min(b, d));\n\
    \    if left >= right {\n        return \"NO\".to_string();\n    }\n    let length\
    \ = right - left + 1;\n    if length == 2 {\n        return \"YES\".to_string();\n\
    \    }\n    for i in 2..length {\n        if length % i == 0 {\n            return\
    \ \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpm9kzjyzs.rs:17:26\n\
    \   |\n17 |     let (left, right) = (max(a, c), min(b, d));\n   |            \
    \              ^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ function\n   |\n1  | use std::cmp::max;\n   |\n\nerror[E0425]: cannot find function\
    \ `min` in this scope\n  --> /tmp/tmpm9kzjyzs.rs:17:37\n   |\n17 |     let (left,\
    \ right) = (max(a, c), min(b, d));\n   |                                     ^^^\n\
    ...\n33 | fn main() {\n   | --------- similarly named function `main` defined\
    \ here\n   |\nhelp: a function with a similar name exists\n   |\n17 |     let\
    \ (left, right) = (max(a, c), main(b, d));\n   |                             \
    \        ~~~~\nhelp: consider importing this function\n   |\n1  | use std::cmp::min;\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    // Write your code\
    \ here\n    let (begin1, end1) = interval1;\n    let (begin2, end2) = interval2;\n\
    \    let begin = std::cmp::max(begin1, begin2);\n    let end = std::cmp::min(end1,\
    \ end2);\n    if begin > end {\n        return \"NO\".to_string();\n    }\n  \
    \  for i in 2..begin {\n        if end % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    return \"YES\".to_string();\n}\n\nfn main() {\n    let\
    \ candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n \
    \   assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2,\
    \ 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1,\
    \ -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpr0kt9lgw.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    //let (min, max)\
    \ = if interval1.0 < interval2.0 {\n    //    (interval1.0, interval2.1)\n   \
    \ //} else {\n    //    (interval2.0, interval1.1)\n    //};\n    let min = interval1.0.max(interval2.0);\n\
    \    let max = interval1.1.min(interval2.1);\n    let v = if min <= max { max\
    \ - min + 1 } else { 0 };\n    if v < 2 {\n        return \"NO\".to_string();\n\
    \    }\n    if is_prime(v) {\n        \"YES\".to_string()\n    } else {\n    \
    \    \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp9dzprtlt.rs:26:8\n\
    \   |\n26 |     if is_prime(v) {\n   |        ^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 101
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n  let (start1, end1)\
    \ = interval1;\n  let (start2, end2) = interval2;\n  if start1 > end2 || start2\
    \ > end1 {\n    return \"NO\".to_string();\n  }\n  let mut max_start = start1;\n\
    \  let mut min_end = end1;\n  if start2 > max_start {\n    max_start = start2;\n\
    \  }\n  if end2 < min_end {\n    min_end = end2;\n  }\n  if max_start > min_end\
    \ {\n    return \"NO\".to_string();\n  }\n  let length = min_end - max_start +\
    \ 1;\n  if length <= 1 {\n    return \"NO\".to_string();\n  }\n  for i in 2..length\
    \ {\n    if length % i == 0 {\n      return \"NO\".to_string();\n    }\n  }\n\
    \  \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpds56m2sg.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821495
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\nfn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    if start1 >= end2 ||\
    \ start2 >= end1 {\n        return \"NO\".to_string();\n    }\n    let start =\
    \ std::cmp::max(start1, start2);\n    let end = std::cmp::min(end1, end2);\n \
    \   if is_prime(end - start) {\n        \"YES\".to_string()\n    } else {\n  \
    \      \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpz8sm3b_u.rs:22:8\n\
    \   |\n22 |     if is_prime(end - start) {\n   |        ^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821495
