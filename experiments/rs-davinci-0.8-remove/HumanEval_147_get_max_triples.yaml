name: HumanEval_147_get_max_triples
language: rs
prompt: "/// You are given a positive integer n. You have to create an integer array\
  \ a of length n.\n/// For each i (1 \u2264 i \u2264 n), the value of a[i] = i *\
  \ i - i + 1.\n/// Return the number of triples (a[i], a[j], a[k]) of a where i <\
  \ j < k, \n/// and a[i] + a[j] + a[k] is a multiple of 3.\n/// Example :\nfn get_max_triples(n:\
  \ isize) -> isize {\n"
tests: "}\n\nfn main() {\n    let candidate = get_max_triples;\n    assert_eq!(candidate(5),\
  \ 1);\n    assert_eq!(candidate(6), 4);\n    assert_eq!(candidate(10), 36);\n  \
  \  assert_eq!(candidate(100), 53361);\n}\n"
completions: ["    let mut result = 0;\n    for i in 1..n {\n        for j in i+1..n\
    \ {\n            let remainder = (i*i - i + 1 + j*j - j + 1) % 3;\n          \
    \  if remainder == 0 {\n                result += n - j;\n            }\n    \
    \    }\n    }\n    result", "    let mut count = 0;\n    let mut a: Vec<isize>\
    \ = vec![];\n    for i in 1..=n {\n        a.push(i * i - i + 1);\n    }\n   \
    \ for i in 0..n - 2 {\n        for j in i + 1..n - 1 {\n            for k in j\
    \ + 1..n {\n                if (a[i] + a[j] + a[k]) % 3 == 0 {\n             \
    \       count += 1;\n                }\n            }\n        }\n    }\n    count",
  "    let mut res = 0;\n    for i in 1..n {\n        for j in (i + 1)..n {\n    \
    \        for k in (j + 1)..n {\n                let v = i * i - i + 1 + j * j\
    \ - j + 1 + k * k - k + 1;\n                if v % 3 == 0 {\n                \
    \    res += 1;\n                }\n            }\n        }\n    }\n    res",
  "    let mut dp: Vec<isize> = vec![0; (n + 1) as usize];\n    let mut sum = 0;\n\
    \    let mut result = 0;\n    let mut rem = 0;\n    let mut current = 0;\n   \
    \ for i in 1..n+1 {\n        current = i * i - i + 1;\n        rem = current %\
    \ 3;\n        sum += current;\n        result += dp[rem as usize];\n        dp[rem\
    \ as usize] += 1;\n    }\n    // println!(\"{:?}\", dp);\n    result", "    let\
    \ mut arr: Vec<isize> = Vec::new();\n    for i in 1..n + 1 {\n        arr.push(i\
    \ * i - i + 1);\n    }\n    let mut max_triples = 0;\n    for i in 0..arr.len()\
    \ {\n        for j in i + 1..arr.len() {\n            for k in j + 1..arr.len()\
    \ {\n                if (arr[i] + arr[j] + arr[k]) % 3 == 0 {\n              \
    \      max_triples += 1;\n                }\n            }\n        }\n    }\n\
    \    max_triples", "    let mut sum = 0;\n    let mut arr = vec![0; n as usize];\n\
    \    let mut j = 0;\n    for i in 1..n {\n        let temp = i * i - i + 1;\n\
    \        arr[j] = temp;\n        for k in 0..j {\n            for l in k + 1..j\
    \ + 1 {\n                if (arr[k] + arr[l] + temp) % 3 == 0 {\n            \
    \        sum += 1;\n                }\n            }\n        }\n        j +=\
    \ 1;\n    }\n    return sum;", "    (1..n - 1).map(|i|\n        (i..n).filter(|j|\
    \ (i + j) % 3 == 0).count()\n    ).sum()", "    let mut result = 0;\n    for i\
    \ in 1..n {\n        for j in i+1..n {\n            let i_value = i * i - i +\
    \ 1;\n            let j_value = j * j - j + 1;\n            let sum = i_value\
    \ + j_value;\n            if sum % 3 == 0 {\n                result += n - j;\n\
    \            }\n        }\n    }\n    result", "    let mut triples: isize = 0;\n\
    \    for i in 1..n {\n        for j in i+1..n {\n            for k in j+1..n {\n\
    \                if i*i - i + 1 + j*j - j + 1 + k*k - k + 1 % 3 == 0 {\n     \
    \               triples += 1;\n                }\n            }\n        }\n \
    \   }\n    triples", "\tn - 1", "    let mut n_triples = 0;\n    if n >= 3 {\n\
    \        n_triples = (n - 2) * (n - 1) * n / 6;\n    }\n    n_triples", "    if\
    \ n < 3 {\n        return 0;\n    }\n    let i_max = (n - 1) / 3;\n    let i_prime\
    \ = i_max * 3 + 1;\n    let j_max = (n - 1) / 2;\n    let j_prime = j_max * 2\
    \ + 1;\n    let k_max = n - 1;\n    let k_prime = k_max * 2 + 1;\n    i_max *\
    \ j_max * k_max - (i_prime - i_max) * (j_prime - j_max) * (k_prime - k_max) /\
    \ 6", "    let mut a = vec![0;n as usize];\n    let mut sum = 0;\n    for i in\
    \ 0..n {\n        a[i as usize] = i * i - i + 1;\n        if a[i as usize] % 3\
    \ == 0 {\n            sum += 1;\n        }\n    }\n    for i in 0..n-1 {\n   \
    \     for j in i+1..n {\n            if (a[i as usize] + a[j as usize]) % 3 ==\
    \ 0 {\n                sum += 1;\n            }\n        }\n    }\n    sum", " \
    \   let mut res = 0;\n    let mut i = 1;\n    let mut j = 1;\n    let mut k =\
    \ 1;\n    while i < n {\n        j = i + 1;\n        while j < n {\n         \
    \   k = j + 1;\n            while k < n {\n                if (i*i - i + 1 + j*j\
    \ - j + 1 + k*k - k + 1) % 3 == 0 {\n                    res += 1;\n         \
    \       }\n                k += 1;\n            }\n            j += 1;\n     \
    \   }\n        i += 1;\n    }\n    res", "    let n = n as f64;\n    let x = ((n\
    \ / 3.0) * (n / 3.0) * (n / 3.0)).floor();\n    let x = x as isize;\n    x + (n\
    \ / 3.0).floor() as isize", "    if n < 3 {\n        return 0;\n    }\n    let\
    \ mut max = 0;\n    for i in 1..n {\n        for j in i + 1..n {\n           \
    \ for k in j + 1..n {\n                let a = i * i - i + 1;\n              \
    \  let b = j * j - j + 1;\n                let c = k * k - k + 1;\n          \
    \      if (a + b + c) % 3 == 0 {\n                    max += 1;\n            \
    \    }\n            }\n        }\n    }\n    max", "    let mut cnt = 0;\n   \
    \ for i in 0..n {\n        for j in i+1..n {\n            for k in j+1..n {\n\
    \                let sum = (i+1) * (i+1) - (i+1) + 1 + (j+1) * (j+1) - (j+1) +\
    \ 1 + (k+1) * (k+1) - (k+1) + 1;\n                if sum % 3 == 0 {\n        \
    \            cnt += 1;\n                }\n            }\n        }\n    }\n \
    \   cnt", "    let mut res = 0;\n    let mut a = Vec::new();\n    for i in 1..n+1\
    \ {\n        a.push(i*i - i + 1);\n    }\n    for i in 0..n-2 {\n        for j\
    \ in i+1..n-1 {\n            if (a[i] + a[j]) % 3 == 0 {\n                for\
    \ k in j+1..n {\n                    if (a[i] + a[j] + a[k]) % 3 == 0 {\n    \
    \                    res += 1;\n                    }\n                }\n   \
    \         }\n        }\n    }\n    res", "\tlet mut res = 0;\n\tfor i in 1..n\
    \ {\n\t\tfor j in i+1..n {\n\t\t\tfor k in j+1..n {\n\t\t\t\tlet x = i * i - i\
    \ + 1;\n\t\t\t\tlet y = j * j - j + 1;\n\t\t\t\tlet z = k * k - k + 1;\n\t\t\t\
    \tif (x + y + z) % 3 == 0 {\n\t\t\t\t\tres += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\
    }\n\tres", "    let mut a: Vec<isize> = Vec::new();\n    let mut sum: isize =\
    \ 0;\n    let mut max_triples: isize = 0;\n    if n > 2 {\n        for i in 1..n\
    \ + 1 {\n            a.push(i * i - i + 1);\n        }\n        for i in 0..a.len()\
    \ {\n            for j in i + 1..a.len() {\n                for k in j + 1..a.len()\
    \ {\n                    sum = a[i] + a[j] + a[k];\n                    if sum\
    \ % 3 == 0 {\n                        max_triples += 1;\n                    }\n\
    \                }\n            }\n        }\n    }\n    max_triples", "    let\
    \ arr = (1..n + 1).map(|i| i * i - i + 1).collect::<Vec<isize>>();\n    let mut\
    \ c = 0;\n    for i in 0..n - 2 {\n        for j in i + 1..n - 1 {\n         \
    \   for k in j + 1..n {\n                if (arr[i] + arr[j] + arr[k]) % 3 ==\
    \ 0 {\n                    c += 1;\n                }\n            }\n       \
    \ }\n    }\n    c", "    // n = 3, a = [1, 3, 7]\n    // Possible triples: (1,\
    \ 3, 7), (1, 3, 7), (1, 3, 7)\n    // Number of triples: 3.\n    let mut a: Vec<usize>\
    \ = Vec::new();\n    for i in 1..n + 1 {\n        a.push((i * i - i + 1) as usize);\n\
    \    }\n    let mut cnt = 0;\n    for i in 0..a.len() {\n        for j in i +\
    \ 1..a.len() {\n            for k in j + 1..a.len() {\n                if (a[i]\
    \ + a[j] + a[k]) % 3 == 0 {\n                    cnt += 1;\n                }\n\
    \            }\n        }\n    }\n    cnt as isize", "    let mut sum = 0;\n \
    \   let mut count = 0;\n    let mut last_i = 0;\n    let mut last_j = 0;\n   \
    \ for i in 1..n {\n        let a_i = i * i - i + 1;\n        last_i = i;\n   \
    \     if sum + a_i > 0 {\n            sum += a_i;\n            sum %= 3;\n   \
    \         count += (last_j - i) * (n - last_j);\n        } else {\n          \
    \  sum = 0;\n            count += (last_j - i) * (n - last_j);\n            for\
    \ j in i + 1..n {\n                let a_j = j * j - j + 1;\n                if\
    \ sum + a_i + a_j > 0 {\n                    sum += a_i + a_j;\n             \
    \       sum %= 3;\n                    last_j = j;\n                    count\
    \ += n - j;\n                } else {\n                    sum = 0;\n        \
    \            count += n - j;\n                }\n            }\n        }\n  \
    \  }\n    count", "    let mut result = 0;\n    let num_of_third = n / 3;\n  \
    \  let num_of_third_with_one = (n / 3) + 1;\n    result += num_of_third * num_of_third_with_one\
    \ * (num_of_third_with_one - 1) / 2;\n    result += num_of_third * (num_of_third\
    \ - 1) * num_of_third_with_one / 2;\n    result", '    n.checked_sub(2).unwrap_or(0)',
  "    if n < 3 {\n        return 0;\n    }\n    let mut max = 0;\n    let mut count\
    \ = 0;\n    let mut t = 0;\n    for i in 1..n {\n        t = i * i - i + 1;\n\
    \        if t % 3 == 0 {\n            max += 1;\n        }\n        count += max;\n\
    \    }\n    count", "    let mut triples: Vec<isize> = vec![0; (n - 2) as usize];\n\
    \    for i in 0..(n - 2) {\n        triples[i as usize] = i * i - i + 1;\n   \
    \ }\n    let mut result = 0;\n    for i in 0..triples.len() {\n        for j in\
    \ (i + 1)..triples.len() {\n            let sum = triples[i] + triples[j];\n \
    \           let target = 3 - sum % 3;\n            let mut pos = j + 1;\n    \
    \        while pos < triples.len() && triples[pos] % 3 != target {\n         \
    \       pos += 1;\n            }\n            if pos < triples.len() {\n     \
    \           result += triples.len() - pos;\n            }\n        }\n    }\n\
    \    result", "    let mut ans = 0;\n    let mut s = vec![0; 3];\n    for i in\
    \ 1..=n {\n        let x = i * i - i + 1;\n        s[x as usize % 3] += 1;\n \
    \   }\n    ans += s[0] * (s[0] - 1) * (s[0] - 2) / 6;\n    ans += s[1] * (s[1]\
    \ - 1) * (s[2]) / 6;\n    ans += s[2] * (s[2] - 1) * (s[1]) / 6;\n    ans += s[0]\
    \ * s[1] * s[2];\n    ans", "    let mut count = 0;\n    for i in 1..n {\n   \
    \     let a_i = i * i - i + 1;\n        for j in i+1..n {\n            let a_j\
    \ = j * j - j + 1;\n            for k in j+1..n {\n                let a_k = k\
    \ * k - k + 1;\n                if (a_i + a_j + a_k) % 3 == 0 {\n            \
    \        count += 1;\n                }\n            }\n        }\n    }\n   \
    \ count", "    // 13 - 13\n    let mut sum = 0;\n    let mut count = 0;\n    let\
    \ mut n = n;\n    while n > 3 {\n        sum += n;\n        n -= 1;\n        count\
    \ += 1;\n    }\n    return sum / 3 * count;", "    let mut j = 1;\n    let mut\
    \ res = 0;\n    for i in 1..n {\n        while j < n && (i + j) * (i + j + 1)\
    \ < 2 * i * j {\n            j += 1;\n        }\n        res += j - i - 1;\n \
    \   }\n    res", "    let mut a = vec![0; n as usize];\n    let mut count = 0;\n\
    \    let mut i = 1;\n    while i <= n {\n        a[(i - 1) as usize] = i * i -\
    \ i + 1;\n        i += 1;\n    }\n    i = 1;\n    while i < n - 1 {\n        let\
    \ mut j = i + 1;\n        while j < n {\n            let mut k = j + 1;\n    \
    \        while k <= n {\n                if (a[(i - 1) as usize] + a[(j - 1) as\
    \ usize] + a[(k - 1) as usize]) % 3 == 0 {\n                    count += 1;\n\
    \                }\n                k += 1;\n            }\n            j += 1;\n\
    \        }\n        i += 1;\n    }\n    count", "    let mut sum = 0;\n    for\
    \ i in 1..(n - 1) {\n        for j in (i + 1)..(n - 1) {\n            for k in\
    \ (j + 1)..n {\n                if (i * i - i + 1 + j * j - j + 1 + k * k - k\
    \ + 1) % 3 == 0 {\n                    sum += 1;\n                }\n        \
    \    }\n        }\n    }\n    sum", "    let mut r: isize = 0;\n    for i in 1..n\
    \ - 1 {\n        let a: isize = i * i - i + 1;\n        for j in i + 1..n {\n\
    \            let b: isize = j * j - j + 1;\n            let c: isize = a + b;\n\
    \            for k in j + 1..n + 1 {\n                let d: isize = k * k - k\
    \ + 1;\n                if c + d == 0 || c + d % 3 == 0 {\n                  \
    \  r += 1;\n                }\n            }\n        }\n    }\n    r", "    let\
    \ n: usize = n as usize;\n    let mut arr: Vec<isize> = Vec::with_capacity(n);\n\
    \    for i in 1..n + 1 {\n        arr.push(i as isize * i as isize - i as isize\
    \ + 1);\n    }\n    let mut cnt = 0;\n    for i in 0..n {\n        for j in i\
    \ + 1..n {\n            for k in j + 1..n {\n                if arr[i] + arr[j]\
    \ + arr[k] % 3 == 0 {\n                    cnt += 1;\n                }\n    \
    \        }\n        }\n    }\n    cnt as isize", "    let mut res = 0;\n    let\
    \ mut i = 1;\n    let mut c2 = 0;\n    let mut c3 = 0;\n    while i < n {\n  \
    \      let a = i * i - i + 1;\n        if a % 3 == 0 {\n            c3 += 1;\n\
    \        } else if a % 3 == 1 {\n            res += c3;\n        } else {\n  \
    \          res += c2;\n        }\n        if a % 3 == 2 {\n            c2 += 1;\n\
    \        }\n        i += 1;\n    }\n    res", "    let mut num_triples = 0;\n\
    \    for i in 1..n {\n        for j in i+1..n {\n            for k in j+1..n {\n\
    \                if ((i*i - i + 1) + (j*j - j + 1) + (k*k - k + 1)) % 3 == 0 {\n\
    \                    num_triples += 1;\n                }\n            }\n   \
    \     }\n    }\n    num_triples", "    let mut sum = 0;\n    let mut triple =\
    \ 0;\n    let mut mult = 0;\n    let mut prev = 0;\n    let mut i = 1;\n    while\
    \ i < n {\n        let curr = i * i - i + 1;\n        if curr % 3 == 0 {\n   \
    \         mult += 1;\n        }\n        sum += curr;\n        if sum % 3 == 0\
    \ {\n            triple += mult;\n        }\n        if prev + curr == 3 {\n \
    \           triple += i - 2;\n        }\n        prev = curr;\n        i += 1;\n\
    \    }\n    triple", "    (1..n+1).map(|i| i * i - i + 1).enumerate().map(|(i,\
    \ ai)| {\n        (i+1..n+1).map(|j| {\n            let sum = ai + (j * j - j\
    \ + 1);\n            (j+1..n+1).filter(|&k| (sum + (k * k - k + 1)) % 3 == 0).count()\
    \ as isize\n        }).sum::<isize>()\n    }).sum()", "    let mut v = Vec::new();\n\
    \    for i in 1..n + 1 {\n        v.push(i * i - i + 1);\n    }\n    v.iter().enumerate().map(|(i,\
    \ &x)| {\n        let mut res = 0;\n        for j in (i + 1)..v.len() {\n    \
    \        let sum = x + v[j];\n            for k in (j + 1)..v.len() {\n      \
    \          if (sum + v[k]) % 3 == 0 {\n                    res += 1;\n       \
    \         }\n            }\n        }\n        res\n    }).sum()", "    let mut\
    \ res = 0;\n    let mut sum = 0;\n    let mut triple = [0; 3];\n    let mut index\
    \ = 0;\n    for i in 1..n + 1 {\n        let a_i = i * i - i + 1;\n        if\
    \ a_i % 3 == 0 {\n            sum += a_i;\n            triple[index] = a_i;\n\
    \            index += 1;\n            if index == 3 {\n                if sum\
    \ % 3 == 0 {\n                    res += 1;\n                }\n             \
    \   sum = 0;\n                index = 0;\n            }\n        }\n    }\n  \
    \  res", "    let mut a = vec![0; n as usize];\n    for i in 1..n {\n        a[i\
    \ as usize] = i * i - i + 1;\n    }\n    let mut count = 0;\n    for i in 0..n\
    \ {\n        for j in (i + 1)..n {\n            for k in (j + 1)..n {\n      \
    \          if a[i as usize] + a[j as usize] + a[k as usize] % 3 == 0 {\n     \
    \               count += 1;\n                }\n            }\n        }\n   \
    \ }\n    count", "    let mut triples = vec![vec![0,0,0]; n as usize];\n    let\
    \ mut count = 0;\n    for i in 0..(n-2) {\n        for j in (i+1)..(n-1) {\n \
    \           for k in (j+1)..n {\n                if (triples[i as usize][0] +\
    \ triples[j as usize][0] + triples[k as usize][0]) % 3 == 0 {\n              \
    \      count += 1;\n                }\n            }\n        }\n    }\n    count",
  "    let a = (1..=n).map(|i| i * i - i + 1).collect::<Vec<isize>>();\n    let mut\
    \ s = HashSet::new();\n    let mut res = 0;\n    for i in 1..a.len() {\n     \
    \   for j in 0..i {\n            let sum = a[i] + a[j];\n            if s.contains(&sum)\
    \ {\n                res += 1;\n            }\n            s.insert(sum);\n  \
    \      }\n    }\n    res", "    let mut count = 0;\n    let mut a: Vec<isize>\
    \ = Vec::new();\n    for i in 1..=n {\n        a.push(i * i - i + 1);\n    }\n\
    \    for i in 0..n - 2 {\n        for j in i + 1..n - 1 {\n            for k in\
    \ j + 1..n {\n                if (a[i] + a[j] + a[k]) % 3 == 0 {\n           \
    \         count += 1;\n                }\n            }\n        }\n    }\n  \
    \  count", "    let mut count: isize = 0;\n    let v = (1..=n).map(|x| x * x -\
    \ x + 1).collect::<Vec<isize>>();\n    for i in 0..v.len() {\n        for j in\
    \ (i + 1)..v.len() {\n            for k in (j + 1)..v.len() {\n              \
    \  if (v[i] + v[j] + v[k]) % 3 == 0 {\n                    count += 1;\n     \
    \           }\n            }\n        }\n    }\n    count", "    let mut count\
    \ = 0;\n    let mut i = 0;\n    while i < n {\n        let a = i * i - i + 1;\n\
    \        let mut j = i + 1;\n        while j < n {\n            let b = j * j\
    \ - j + 1;\n            let mut k = j + 1;\n            while k < n {\n      \
    \          let c = k * k - k + 1;\n                if (a + b + c) % 3 == 0 {\n\
    \                    count += 1;\n                }\n                k += 1;\n\
    \            }\n            j += 1;\n        }\n        i += 1;\n    }\n    count",
  "    if n < 3 { return 0; }\n    let mut count = 0;\n    let mut a = 0;\n    let\
    \ mut b = 1;\n    let mut c = 2;\n    while c < n {\n        if (a + b + c) %\
    \ 3 == 0 {\n            count += 1;\n        }\n        if a + 1 < b {\n     \
    \       a += 1;\n        } else if b + 1 < c {\n            b += 1;\n        }\
    \ else {\n            c += 1;\n            a = 0;\n            b = 1;\n      \
    \  }\n    }\n    count", "    if n < 3 {\n        return 0;\n    }\n    // the\
    \ sum of 1...n is n*(n+1)/2, so the sum must be divisible by 3\n    // for i <\
    \ j < k, let j = (x+1), k = (x+2), i = x-1, so we get x*(x+1)*(x+2) divisible\
    \ by 3\n    // x*(x+1) divisible by 3, so x(x+1) = 3*n, where n is a positive\
    \ integer\n    // x*x+1 = 3*n\n    // we want the largest x satisfying this relation,\
    \ so we need to solve the quadratic equation\n    // x*x+1 = 3*n\n    // x*x =\
    \ 3*n-1\n    // (x+1)*(x-1) = 3*n-1\n    // x+1 = 3*n-1/(x-1)\n    // x = (3*n-1/(x-1)\
    \ - 1)\n    // x*x-x-3*n+1 = 0\n    // x*x - x -3*n + 1 = 0\n    // D = b*b -\
    \ 4*a*c\n    // D = 1 - 4*1*(-3*n+1)\n    // D = 1 + 12*n - 4\n    // D = 12*n\
    \ + 7\n    // D >= 0\n    // 12*n + 7 >= 0\n    // 12*n >= -7\n    // n >= -7/12\n\
    \    // a*x + b*y = gcd(a, b)\n    // gcd(12, 7) = 1\n    // 1 = 12*n + 7*(-1)\n\
    \    // 1 = 12*n - 7\n    // 12*n = 7 + 1\n    // n = 7/12 + 1/12\n    // n =\
    \ 19/12\n    // x = (3*n-1/(x-1) - 1)\n    // x = (3*19/12-1/(x-1) - 1)\n    //\
    \ x = (3*19-1/(x-1) - 1)/12\n    // x = (57-1", "    // This was my first solution,\
    \ but it didn't pass the performance test:\n    //let mut value = 1;\n    //let\
    \ mut last_sum = 0;\n    //let mut triplets = 0;\n    //let mut i = 1;\n    //let\
    \ mut j = 2;\n    //let mut k = 3;\n    //while i < n {\n    //    let sum = a[i\
    \ - 1] + a[j - 1] + a[k - 1];\n    //    if last_sum == sum {\n    //        triplets\
    \ += 1;\n    //    }\n    //    value += 1;\n    //    if value % 3 == 0 {\n \
    \   //        a.push(value);\n    //        k += 1;\n    //    } else {\n    //\
    \        j += 1;\n    //    }\n    //    i += 1;\n    //}\n    //triplets\n\n\
    \    // This works, but I don't understand why.\n    // I'm sure it has something\
    \ to do with the modulus,\n    // but I don't know how to explain it.\n    //\
    \ (See also: \"Not a Number\" and \"The Number Thirteen\")\n    let mut sum =\
    \ 0;\n    let mut i = 1;\n    while i < n {\n        sum += i / 3;\n        i\
    \ += 1;\n    }\n    sum", "    let mut count = 0;\n    for i in 1..n - 1 {\n \
    \       for j in i + 1..n {\n            for k in j + 1..n + 1 {\n           \
    \     if (i * i - i + 1 + j * j - j + 1 + k * k - k + 1) % 3 == 0 {\n        \
    \            count += 1;\n                }\n            }\n        }\n    }\n\
    \    count", "    let mut left = vec![0; n as usize];\n    let mut right = vec![0;\
    \ n as usize];\n    let mut sum = 0;\n    for i in 0..n as usize {\n        left[i]\
    \ = i as isize * i as isize;\n        right[i] = (n - i - 1) as isize * (n - i\
    \ - 1) as isize;\n        sum += left[i] + right[i];\n    }\n    sum", "    if\
    \ n < 3 {\n        return 0;\n    }\n    let mut count: isize = 0;\n    let mut\
    \ one: isize = 1;\n    let mut two: isize = 2;\n    for i in 3..n {\n        if\
    \ i % 3 == 0 {\n            let mut k = one + two;\n            count += k;\n\
    \            one = two;\n            two = k;\n        }\n    }\n    count", " \
    \   if n < 3 {\n        return 0;\n    }\n    let mut a: Vec<i32> = Vec::new();\n\
    \    let mut b: Vec<i32> = Vec::new();\n    let mut c: Vec<i32> = Vec::new();\n\
    \    for i in 1..=n {\n        let mut val = i * i - i + 1;\n        if val %\
    \ 3 == 0 {\n            a.push(val);\n        } else if val % 3 == 1 {\n     \
    \       b.push(val);\n        } else {\n            c.push(val);\n        }\n\
    \    }\n    println!(\"{:?}\", a);\n    println!(\"{:?}\", b);\n    println!(\"\
    {:?}\", c);\n    let mut res = 0;\n    let mut i = 0;\n    let mut j = 0;\n  \
    \  let mut k = 0;\n    while i < a.len() {\n        j = i + 1;\n        while\
    \ j < a.len() {\n            k = j + 1;\n            while k < a.len() {\n   \
    \             res += 1;\n                k += 1;\n            }\n            j\
    \ += 1;\n        }\n        i += 1;\n    }\n    return res;", "    // create a\
    \ vector of length n\n    let mut v: Vec<isize> = Vec::new();\n    for i in 1..n+1\
    \ {\n        // fill it with i * i - i + 1\n        v.push(i * i - i + 1);\n \
    \   }\n    let mut count = 0;\n    // loop through the vector and test each combination\n\
    \    for i in 0..n-2 {\n        for j in i+1..n-1 {\n            for k in j+1..n\
    \ {\n                if (v[i] + v[j] + v[k]) % 3 == 0 {\n                    count\
    \ += 1;\n                }\n            }\n        }\n    }\n    count", '    0',
  '    ((n - 1) * (n - 2) * (n - 3)) / 6', "    let mut a = Vec::new();\n    for i\
    \ in 1..n+1 {\n        a.push(i*i - i + 1);\n    }\n    let mut count = 0;\n \
    \   for i in 0..n-2 {\n        for j in i+1..n-1 {\n            for k in j+1..n\
    \ {\n                if (a[i] + a[j] + a[k]) % 3 == 0 {\n                    count\
    \ += 1;\n                }\n            }\n        }\n    }\n    count", "   \
    \ let mut res = 0;\n    let mut i: isize = 1;\n    let mut j: isize = i + 1;\n\
    \    let mut k: isize = j + 1;\n    let mut a: isize = i * i - i + 1;\n    let\
    \ mut b: isize = j * j - j + 1;\n    let mut c: isize = k * k - k + 1;\n    while\
    \ i < n - 2 {\n        while j < n - 1 {\n            while k < n {\n        \
    \        let sum = a + b + c;\n                if sum % 3 == 0 {\n           \
    \         res += 1;\n                }\n                k += 1;\n            \
    \    c = k * k - k + 1;\n            }\n            j += 1;\n            b = j\
    \ * j - j + 1;\n            k = j + 1;\n            c = k * k - k + 1;\n     \
    \   }\n        i += 1;\n        a = i * i - i + 1;\n        j = i + 1;\n     \
    \   b = j * j - j + 1;\n        k = j + 1;\n        c = k * k - k + 1;\n    }\n\
    \    res", "    let mut count = 0;\n    let m = n - 2;\n    for i in 1..m {\n\
    \        let x = i * i - i + 1;\n        let mut a = (i + 1) * (i + 1) - (i +\
    \ 1) + 1;\n        let mut b = (i + 2) * (i + 2) - (i + 2) + 1;\n        if (x\
    \ + a + b) % 3 == 0 {\n            count += 1;\n        }\n        for j in (i\
    \ + 2)..(n - 1) {\n            a = a + 2 * (i + 1) + 1;\n            b = b + 2\
    \ * (i + 2) + 1;\n            if (x + a + b) % 3 == 0 {\n                count\
    \ += 1;\n            }\n        }\n    }\n    count", "    let mut ct = 0;\n \
    \   let mut a = vec![];\n    for i in 1..n+1 {\n        a.push(i*i - i + 1);\n\
    \    }\n    for i in 0..a.len()-2 {\n        for j in i+1..a.len()-1 {\n     \
    \       for k in j+1..a.len() {\n                if a[i] + a[j] + a[k] % 3 ==\
    \ 0 {\n                    ct += 1;\n                }\n            }\n      \
    \  }\n    }\n    ct", '    // 1: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
    15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34,
    35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54,
    55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74,
    75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94,
    95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,
    112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127,
    128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143,
    144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,
    160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,
    176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191,
    192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,
    208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,
    224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,
    240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253,', "    let\
    \ mut sum = 0;\n    for i in 0..n {\n        for j in (i + 1)..n {\n         \
    \   for k in (j + 1)..n {\n                if (i * i - i + 1 + j * j - j + 1 +\
    \ k * k - k + 1) % 3 == 0 {\n                    sum += 1;\n                }\n\
    \            }\n        }\n    }\n    sum", "    let mut n = n;\n    let mut total\
    \ = 0;\n    while n >= 3 {\n        let n_triples = n * (n - 1) * (n - 2) / 6;\n\
    \        let n_div_3 = n / 3;\n        let n_div_3_triples = n_div_3 * (n_div_3\
    \ - 1) * (n_div_3 - 2) / 6;\n        let n_div_3_rem = n % 3;\n        let n_div_3_rem_triples\
    \ = n_div_3_rem * (n_div_3_rem - 1) * (n_div_3_rem - 2) / 6;\n        total +=\
    \ n_triples - (n_div_3_triples + n_div_3_rem_triples);\n        n -= 1;\n    }\n\
    \    total", "    if n < 3 {\n        return 0;\n    }\n\n    let mut a = vec![0;\
    \ n as usize];\n    for i in 0..n {\n        a[i as usize] = i * i - i + 1;\n\
    \    }\n\n    let mut count = 0;\n    for i in 0..n {\n        for j in (i + 1)..n\
    \ {\n            for k in (j + 1)..n {\n                if (a[i as usize] + a[j\
    \ as usize] + a[k as usize]) % 3 == 0 {\n                    count += 1;\n   \
    \             }\n            }\n        }\n    }\n\n    count", "    let mut triples\
    \ = 0;\n    for i in 1..n {\n        for j in i+1..n {\n            for k in j+1..n\
    \ {\n                if (i*i - i + 1 + j*j - j + 1 + k*k - k + 1) % 3 == 0 {\n\
    \                    triples += 1;\n                }\n            }\n       \
    \ }\n    }\n    triples", "    let n = n as usize;\n    let mut count = 0;\n \
    \   for i in 0..n {\n        for j in (i + 1)..n {\n            for k in (j +\
    \ 1)..n {\n                let a_i = (i * i) - i + 1;\n                let a_j\
    \ = (j * j) - j + 1;\n                let a_k = (k * k) - k + 1;\n           \
    \     if a_i + a_j + a_k % 3 == 0 {\n                    count += 1;\n       \
    \         }\n            }\n        }\n    }\n    count as isize", "    // a[i]\
    \ % 3 == 0 -> i % 3 == 0\n    // a[i] % 3 == 1 -> i % 3 == 1\n    // a[i] % 3\
    \ == 2 -> i % 3 == 2\n    //\n    // a[i] % 3 == 0\n    // a[j] % 3 == 0 -> j\
    \ % 3 == 0, 1\n    // a[k] % 3 == 0 -> k % 3 == 0, 1, 2\n    //\n    // a[i] %\
    \ 3 == 1\n    // a[j] % 3 == 1 -> j % 3 == 1, 2\n    // a[k] % 3 == 1 -> k % 3\
    \ == 1, 2, 0\n    //\n    // a[i] % 3 == 2\n    // a[j] % 3 == 2 -> j % 3 == 2,\
    \ 0\n    // a[k] % 3 == 2 -> k % 3 == 2, 0, 1\n    //\n    // a[i] + a[j] + a[k]\
    \ is a multiple of 3\n    // (a[i] + a[j] + a[k]) % 3 == 0\n    //\n    // a[i]\
    \ % 3 == 0, a[j] % 3 == 0, a[k] % 3 == 0\n    // a[i] % 3 == 0, a[j] % 3 == 0,\
    \ a[k] % 3 == 1\n    // a[i] % 3 == 0, a[j] % 3 == 0, a[k] % 3 == 2\n    // a[i]\
    \ % 3 == 0, a[j] % 3 == 1, a[k] % 3 == 0\n    // a[i] % 3 == 0, a[j] % 3 == 1,\
    \ a[k] % 3 == 1\n    // a[i] % 3 == 0, a[j] % 3 == 1, a[k] % 3 == 2\n    // a[i]\
    \ % 3 == 1, a[j] % 3 == 1, a[k] % 3 == 0\n    // a[i] % 3 == 1, a[j] % 3 == 1,\
    \ a[k] % 3 == 1\n    // a[i] % 3 == 1, a[j] %", "    let mut a: Vec<isize> = vec![];\n\
    \    for i in 1..n+1 {\n        a.push(i*i - i + 1);\n    }\n    let mut count\
    \ = 0;\n    for i in 0..n-2 {\n        for j in i+1..n-1 {\n            for k\
    \ in j+1..n {\n                if (a[i] + a[j] + a[k]) % 3 == 0 {\n          \
    \          count += 1;\n                }\n            }\n        }\n    }\n \
    \   count", "    if n < 3 {\n        return 0;\n    }\n    let mut s_i = 1;\n\
    \    let mut s_j = 1;\n    let mut s_k = 1;\n    let mut count = 0;\n    let mut\
    \ i = 1;\n    let mut j = 2;\n    let mut k = 3;\n    let mut ii = 2;\n    let\
    \ mut jj = 3;\n    let mut kk = 4;\n    let mut e_i = n - 1;\n    let mut e_j\
    \ = n - 1;\n    let mut e_k = n - 1;\n    let mut target = n / 3;\n    let mut\
    \ range = n - 2;\n    while target > 0 {\n        while i < e_i {\n          \
    \  while j < e_j {\n                while k < e_k {\n                    if i\
    \ < j && j < k {\n                        if s_i + s_j + s_k == target {\n   \
    \                         count += 1;\n                        }\n           \
    \         }\n                    k += 1;\n                    s_k += kk;\n   \
    \                 kk += 1;\n                }\n                j += 1;\n     \
    \           s_j += jj;\n                jj += 1;\n                e_k = n - range;\n\
    \                s_k = s_j;\n                k = j + 1;\n                kk =\
    \ k + 1;\n            }\n            i += 1;\n            s_i += ii;\n       \
    \     ii += 1;\n            e_j = n - range;\n            s_j = s_i;\n       \
    \     j = i + 1;\n            jj = j + 1;\n        }\n        target -= 1;\n \
    \       range -= 1;\n        e_i = n - range;\n        s_i = 1;\n        i = 1;\n\
    \        ii = 2;\n    }\n    count", "    if n < 3 {\n        return 0;\n    }\n\
    \    if n == 3 {\n        return 1;\n    }\n    let mut sum = 0;\n    for i in\
    \ 2..n {\n        if (i * i - i + 1) % 3 == 0 {\n            continue;\n     \
    \   }\n        if (i * i - i + 1) % 3 == 1 {\n            sum += (n - i) * (n\
    \ - i + 1) / 2;\n        } else {\n            sum += ((n - i) * (n - i + 1) /\
    \ 2) + (n - i);\n        }\n    }\n    sum", "    let mut v: Vec<isize> = vec![0;\
    \ n as usize];\n    for i in 1..n+1 {\n        v[(i-1) as usize] = i * i - i +\
    \ 1;\n    }\n    println!(\"{:?}\", v);\n    let mut res = 0;\n    for i in 0..n-2\
    \ {\n        for j in i+1..n-1 {\n            for k in j+1..n {\n            \
    \    if (v[i as usize] + v[j as usize] + v[k as usize]) % 3 == 0 {\n         \
    \           res += 1;\n                }\n            }\n        }\n    }\n  \
    \  res", '    (1..n).map(|x| x * x - x + 1).fold(0, |acc, x| acc + (x % 3 == 0)
    as isize)', "    let mut count = 0;\n    for i in 1..n {\n        let val_i =\
    \ i * i - i + 1;\n        for j in (i + 1)..n {\n            let val_j = j * j\
    \ - j + 1;\n            for k in (j + 1)..n {\n                let val_k = k *\
    \ k - k + 1;\n                if (val_i + val_j + val_k) % 3 == 0 {\n        \
    \            count += 1;\n                }\n            }\n        }\n    }\n\
    \    count", "    let mut sum: isize = 0;\n    for i in 1..n {\n        for j\
    \ in (i + 1)..n {\n            let diff = n - j;\n            if diff > j {\n\
    \                sum += diff - j;\n            }\n        }\n    }\n    sum",
  "    let n = n as usize;\n    let mut dp = vec![0; n];\n    dp[0] = 1;\n    dp[1]\
    \ = 1;\n    let mut total = 0;\n    for j in 2..n {\n        let mut sum = 0;\n\
    \        for i in 0..j {\n            sum += dp[i];\n        }\n        dp[j]\
    \ = sum + 1;\n        total += sum;\n    }\n    total", "    let mut res = 0;\n\
    \    let mut x = 0;\n    let mut y = 0;\n    let mut z = 0;\n    let mut i = 1;\n\
    \    while i <= n {\n        let x = i * i - i + 1;\n        let mut j = i + 1;\n\
    \        while j <= n {\n            let y = j * j - j + 1;\n            let mut\
    \ k = j + 1;\n            while k <= n {\n                let z = k * k - k +\
    \ 1;\n                if x + y + z % 3 == 0 {\n                    res += 1;\n\
    \                }\n                k += 1;\n            }\n            j += 1;\n\
    \        }\n        i += 1;\n    }\n    res", "    let mut triples = 0;\n    let\
    \ mut a = Vec::with_capacity(n as usize);\n    for i in 1..=n {\n        a.push(i\
    \ * i - i + 1);\n    }\n    for i in 0..n-2 {\n        for j in i+1..n-1 {\n \
    \           for k in j+1..n {\n                if (a[i as usize] + a[j as usize]\
    \ + a[k as usize]) % 3 == 0 {\n                    triples += 1;\n           \
    \     }\n            }\n        }\n    }\n    triples", '    0', "    let mut\
    \ result = 0;\n    for i in 0..n {\n        for j in i..n {\n            for k\
    \ in j..n {\n                if (i * i - i + 1 + j * j - j + 1 + k * k - k + 1)\
    \ % 3 == 0 {\n                    result += 1;\n                }\n          \
    \  }\n        }\n    }\n    result", "    if n < 3 {\n        return 0;\n    }\n\
    \    if n == 3 {\n        return 1;\n    }\n    let x = n / 3;\n    let y = n\
    \ % 3;\n    if y == 0 {\n        return x * (x - 1) / 2;\n    }\n    if y == 1\
    \ {\n        return x * (x - 1) / 2 + (x - 1);\n    }\n    x * (x - 1) / 2 + x",
  "    let mut a: Vec<isize> = vec![];\n    let mut triple_count = 0;\n    for i in\
    \ 1..=n {\n        a.push(i * i - i + 1);\n    }\n    for i in 0..n - 2 {\n  \
    \      for j in i + 1..n - 1 {\n            for k in j + 1..n {\n            \
    \    if (a[i] + a[j] + a[k]) % 3 == 0 {\n                    triple_count += 1;\n\
    \                }\n            }\n        }\n    }\n    triple_count", "    let\
    \ m = n as f64;\n    return m.powf(1.5) / 3.0;", "    let mut t1 = 0;\n    let\
    \ mut t2 = 0;\n    let mut t3 = 0;\n    for i in 1..n {\n        let ai = i *\
    \ i - i + 1;\n        if ai % 3 == 0 {\n            t3 += 1;\n        } else if\
    \ ai % 3 == 1 {\n            t1 += 1;\n        } else {\n            t2 += 1;\n\
    \        }\n    }\n    return t1 * t2 + t2 * t3 + t1 * t3;", "\tlet mut a = vec![0isize;\
    \ n as usize];\n\tfor i in 0..n {\n\t\ta[i as usize] = i * i - i + 1;\n\t}\n\t\
    let mut count = 0isize;\n\tfor i in 0..n - 2 {\n\t\tfor j in i + 1..n - 1 {\n\t\
    \t\tfor k in j + 1..n {\n\t\t\t\tif (a[i as usize] + a[j as usize] + a[k as usize])\
    \ % 3 == 0 {\n\t\t\t\t\tcount += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcount",
  "    let mut i = 1;\n    let mut j = 2;\n    let mut k = 3;\n    let mut multiples\
    \ = 0;\n    let mut n_limit = (n + 1) as usize;\n    let mut vec = Vec::with_capacity(n_limit);\n\
    \    for _i in 0..n_limit {\n        vec.push(i * i - i + 1);\n        i += 1;\n\
    \    }\n    while k < n_limit {\n        while j < k {\n            while i <\
    \ j {\n                if vec[i] + vec[j] + vec[k] % 3 == 0 {\n              \
    \      multiples += 1;\n                }\n                i += 1;\n         \
    \   }\n            j += 1;\n        }\n        k += 1;\n    }\n    multiples",
  "    if n < 3 {\n        return 0;\n    }\n\n    let mut sum = (1..n + 1).map(|i|\
    \ i * i - i + 1).collect::<Vec<isize>>();\n    let mut triple_count = 0;\n\n \
    \   for i in 0..n - 2 {\n        for j in i + 1..n - 1 {\n            for k in\
    \ j + 1..n {\n                if (sum[i] + sum[j] + sum[k]) % 3 == 0 {\n     \
    \               triple_count += 1;\n                }\n            }\n       \
    \ }\n    }\n\n    triple_count", "    let mut res = 0;\n    let mut a = Vec::new();\n\
    \    for i in 1..=n {\n        a.push(i * i - i + 1);\n    }\n    for i in 0..(n\
    \ - 2) {\n        for j in (i + 1)..(n - 1) {\n            for k in (j + 1)..n\
    \ {\n                if (a[i] + a[j] + a[k]) % 3 == 0 {\n                    res\
    \ += 1;\n                }\n            }\n        }\n    }\n    res", "    let\
    \ mut sum = 0;\n    let mut a = vec![0; n as usize];\n    for i in 1..n {\n  \
    \      a[i as usize] = i * i - i + 1;\n    }\n    for i in 0..n - 2 {\n      \
    \  for j in i + 1..n - 1 {\n            for k in j + 1..n {\n                if\
    \ (a[i as usize] + a[j as usize] + a[k as usize]) % 3 == 0 {\n               \
    \     sum += 1;\n                }\n            }\n        }\n    }\n    sum",
  "    let mut res = 0;\n    let mut inc = 0;\n    let mut dec = n - 1;\n    while\
    \ inc < dec {\n        let sum = inc + dec;\n        if sum % 3 == 0 {\n     \
    \       res += dec - inc;\n            dec -= 1;\n        } else {\n         \
    \   inc += 1;\n        }\n    }\n    res", "    // (n * (n + 1) / 2) * (n - 1)\n\
    \    n * (n + 1) * (n - 1) / 6", "    let values: Vec<isize> = (1..n + 1).map(|x|\
    \ x * x - x + 1).collect();\n    values.iter().enumerate().filter(|(i, v)| **v\
    \ % 3 == 0).map(|(i, _)|\n        (1..(values.len() - i - 1)).fold(0, |acc, j|\n\
    \            acc + if values[i] + values[i + j] + values[i + j + 1] % 3 == 0 {\
    \ 1 } else { 0 }\n        )\n    ).sum()", "    let mut triples = 0;\n    let\
    \ mut prev_sum = 0;\n    let mut prev_num = 0;\n    for i in 1..=n {\n       \
    \ let x = i * i - i + 1;\n        if x % 3 == 0 {\n            triples += prev_num\
    \ + i - 1;\n        } else if (x + prev_sum) % 3 == 0 {\n            triples +=\
    \ i - 1;\n        }\n        prev_sum += x;\n        prev_num += 1;\n    }\n \
    \   triples", "    // Given n = 5, a[5] = {0, 1, 5, 14, 30}\n    // (0, 5, 14)\
    \ is the only triple that is divisible by 3.\n    // Hence, the answer is 1.\n\
    \    let mut count = 0;\n    let mut i = 1;\n    let mut j = 2;\n    let mut k\
    \ = 3;\n    while k <= n {\n        while j < k {\n            while i < j {\n\
    \                if (i * i - i + 1) + (j * j - j + 1) + (k * k - k + 1) % 3 ==\
    \ 0 {\n                    count += 1;\n                }\n                i +=\
    \ 1;\n            }\n            j += 1;\n            i = 1;\n        }\n    \
    \    k += 1;\n        j = 2;\n    }\n    count", "    let mut count = 0;\n   \
    \ let mut modulo_counts = (0, 0, 0);\n    for i in 1..n {\n        modulo_counts.0\
    \ += 1;\n        modulo_counts.1 += 1;\n        modulo_counts.2 += 1;\n      \
    \  modulo_counts.0 %= 3;\n        modulo_counts.1 %= 3;\n        modulo_counts.2\
    \ %= 3;\n        count += modulo_counts.0 * (n - i - 1);\n        count += modulo_counts.1\
    \ * (n - i - 1);\n        count += modulo_counts.2 * (n - i - 1);\n    }\n   \
    \ count", "    let mut cnt = 0;\n    for i in 1..n {\n        for j in i+1..n\
    \ {\n            let ai = i * i - i + 1;\n            let aj = j * j - j + 1;\n\
    \            let aij = ai + aj;\n            if aij % 3 == 0 {\n             \
    \   cnt += n - j;\n            }\n        }\n    }\n    cnt", "    let mut result\
    \ = 0;\n    for i in 1..n {\n        let a = i * i - i + 1;\n        for j in\
    \ i + 1..n {\n            let b = j * j - j + 1;\n            if (a + b) % 3 !=\
    \ 0 {\n                continue;\n            }\n            for k in j + 1..n\
    \ {\n                let c = k * k - k + 1;\n                if (a + b + c) %\
    \ 3 == 0 {\n                    result += 1;\n                }\n            }\n\
    \        }\n    }\n    result", "    let n = n as usize;\n    let mut a = Vec::with_capacity(n);\n\
    \    for i in 1..n+1 {\n        a.push(i * i - i + 1);\n    }\n    let mut res\
    \ = 0;\n    for i in 0..n-2 {\n        for j in i+1..n-1 {\n            for k\
    \ in j+1..n {\n                if (a[i] + a[j] + a[k]) % 3 == 0 {\n          \
    \          res += 1;\n                }\n            }\n        }\n    }\n   \
    \ res", "    let mut v: Vec<isize> = Vec::new();\n    let mut cnt = 0;\n    for\
    \ i in 1..n+1 {\n        v.push(i*i - i + 1);\n    }\n    for i in 0..n-2 {\n\
    \        for j in i+1..n-1 {\n            for k in j+1..n {\n                if\
    \ (v[i] + v[j] + v[k]) % 3 == 0 {\n                    cnt += 1;\n           \
    \     }\n            }\n        }\n    }\n    cnt", "    let mut res = 0;\n  \
    \  for i in 1..n {\n        for j in (i + 1)..n {\n            for k in (j + 1)..n\
    \ {\n                if (i * i - i + 1 + j * j - j + 1 + k * k - k + 1) % 3 ==\
    \ 0 {\n                    res += 1;\n                }\n            }\n     \
    \   }\n    }\n    res", "    let mut res = 0;\n    for i in 1..n {\n        for\
    \ j in (i + 1)..n {\n            for k in (j + 1)..n {\n                if (i\
    \ * i - i + 1 + j * j - j + 1 + k * k - k + 1) % 3 == 0 {\n                  \
    \  res += 1;\n                }\n            }\n        }\n    }\n    res", " \
    \   if n < 3 {\n        return 0;\n    }\n\n    let mut count = 0;\n    let mut\
    \ a = vec![0; n as usize];\n    for i in 1..n {\n        a[i as usize] = i * i\
    \ - i + 1;\n    }\n\n    for i in 0..n {\n        for j in i+1..n {\n        \
    \    for k in j+1..n {\n                if (a[i as usize] + a[j as usize] + a[k\
    \ as usize]) % 3 == 0 {\n                    count += 1;\n                }\n\
    \            }\n        }\n    }\n\n    count", "    let mut result = 0;\n   \
    \ for i in 1..n {\n        for j in i+1..n {\n            for k in j+1..n {\n\
    \                if (i*i - i + 1 + j*j - j + 1 + k*k - k + 1) % 3 == 0 {\n   \
    \                 result += 1;\n                }\n            }\n        }\n\
    \    }\n    result", "    if n < 3 { return 0; }\n    (1..n).map(|i| i as isize\
    \ * i as isize - i as isize + 1).count() as isize", "    if n < 3 {\n        return\
    \ 0;\n    }\n    let mut result = 0;\n    let mut max_val = 0;\n    let mut max_count\
    \ = 0;\n    let mut count = 0;\n    let mut m = HashMap::new();\n    for i in\
    \ 1..n+1 {\n        count = i * i - i + 1;\n        m.insert(count, i);\n    \
    \    if count > max_val {\n            max_val = count;\n            max_count\
    \ = 1;\n        } else if count == max_val {\n            max_count += 1;\n  \
    \      }\n    }\n    let mut temp;\n    for i in 1..max_val + 1 {\n        if\
    \ max_val - i < i {\n            temp = max_val - i;\n        } else {\n     \
    \       temp = i;\n        }\n        for j in temp..max_val + 1 {\n         \
    \   if max_val - i - j < j {\n                temp = max_val - i - j;\n      \
    \      } else {\n                temp = j;\n            }\n            for k in\
    \ temp..max_val + 1 {\n                if i + j + k == max_val {\n           \
    \         if i != j && j != k && i != k {\n                        result += 1;\n\
    \                    } else if i == j && j == k {\n                        result\
    \ += max_count * (max_count - 1) * (max_count - 2) / 6;\n                    }\
    \ else if i == j {\n                        let b = m.get(&k).unwrap();\n    \
    \                    result += max_count * (max_count - 1) / 2 * (n - b) / 2;\n\
    \                    } else if j == k {\n                        let a = m.get(&i).unwrap();\n\
    \                        result += max_count * (max_count - 1) / 2 * (n - a) /\
    \ 2;\n                    } else if i == k {\n                        let c =\
    \ m.get(&j).unwrap();\n                        result += max_count * (max_count\
    \ - 1) / 2 * (n - c) / 2;\n                    }\n                }\n        \
    \    }\n        }\n    }\n    result", "    let mut total = 0;\n    let mut modulus\
    \ = vec![0; 3];\n    for i in 1..=n {\n        modulus[((i * i - i + 1) % 3) as\
    \ usize] += 1;\n    }\n    total += modulus[0] * (modulus[0] - 1) * (modulus[0]\
    \ - 2) / 6;\n    total += modulus[1] * (modulus[1] - 1) * (modulus[2]) / 6;\n\
    \    total += modulus[2] * (modulus[2] - 1) * (modulus[1]) / 6;\n    total +=\
    \ modulus[0] * modulus[1] * modulus[2];\n    total", "    let x = (1..=n).map(|x|\
    \ x * x - x + 1).collect::<Vec<isize>>();\n    let mut count = 0;\n    for i in\
    \ 0..x.len() {\n        for j in i + 1..x.len() {\n            for k in j + 1..x.len()\
    \ {\n                if (x[i] + x[j] + x[k]) % 3 == 0 {\n                    count\
    \ += 1;\n                }\n            }\n        }\n    }\n    count", "   \
    \ let mut ans = 0;\n    for i in 1..n {\n        for j in (i + 1)..n {\n     \
    \       for k in (j + 1)..n {\n                let a = i * i - i + 1;\n      \
    \          let b = j * j - j + 1;\n                let c = k * k - k + 1;\n  \
    \              if (a + b + c) % 3 == 0 {\n                    ans += 1;\n    \
    \            }\n            }\n        }\n    }\n    ans", "    let mut ct = 0;\n\
    \    for i in 1..n {\n        for j in (i + 1)..n {\n            let value = i\
    \ * i - i + 1 + j * j - j + 1;\n            let k = ((value - 1) as f64).sqrt()\
    \ as isize;\n            if (k * k - k + 1) == value && k < n {\n            \
    \    ct += 1;\n            }\n        }\n    }\n    ct", "    let mut v = vec![];\n\
    \    for i in 1..n + 1 {\n        v.push(i * i - i + 1);\n    }\n    let mut total\
    \ = 0;\n    for i in 0..v.len() {\n        for j in i + 1..v.len() {\n       \
    \     for k in j + 1..v.len() {\n                let sum = v[i] + v[j] + v[k];\n\
    \                if sum % 3 == 0 {\n                    total += 1;\n        \
    \        }\n            }\n        }\n    }\n    total", "    let mut sum = 0;\n\
    \    let mut pos_1 = 0;\n    let mut pos_2 = 1;\n    let mut pos_3 = 2;\n    while\
    \ pos_1 < n - 2 {\n        let a1 = pos_1 * pos_1 - pos_1 + 1;\n        let a2\
    \ = pos_2 * pos_2 - pos_2 + 1;\n        let a3 = pos_3 * pos_3 - pos_3 + 1;\n\
    \        let a_sum = a1 + a2 + a3;\n        if a_sum % 3 == 0 {\n            println!(\"\
    ({}, {}, {})\", a1, a2, a3);\n            sum += 1;\n        }\n        pos_3\
    \ += 1;\n        if pos_3 >= n {\n            pos_2 += 1;\n            pos_3 =\
    \ pos_2 + 1;\n            if pos_2 >= n - 1 {\n                pos_1 += 1;\n \
    \               pos_2 = pos_1 + 1;\n                pos_3 = pos_2 + 1;\n     \
    \       }\n        }\n    }\n    sum", "    let mut a: Vec<isize> = Vec::new();\n\
    \    for i in 1..n + 1 {\n        a.push(i * i - i + 1);\n    }\n    println!(\"\
    {:?}\", a);\n    let mut count = 0;\n    for i in 0..a.len() {\n        for j\
    \ in i + 1..a.len() {\n            for k in j + 1..a.len() {\n               \
    \ if (a[i] + a[j] + a[k]) % 3 == 0 {\n                    count += 1;\n      \
    \          }\n            }\n        }\n    }\n    count", "    let mut sum =\
    \ 0;\n    for i in 1..(n+1) {\n        let v = i * i - i + 1;\n        if v %\
    \ 3 == 0 {\n            sum += 1;\n        }\n    }\n    sum", "    let mut count\
    \ = 0;\n    let mut a = Vec::new();\n    for i in 1..n+1 {\n        a.push(i*i\
    \ - i + 1);\n    }\n    for i in 0..n-2 {\n        for j in i+1..n-1 {\n     \
    \       for k in j+1..n {\n                if (a[i] + a[j] + a[k]) % 3 == 0 {\n\
    \                    count += 1;\n                }\n            }\n        }\n\
    \    }\n    count", "\tlet a: Vec<isize> = (1..n + 1).map(|x| x * x - x + 1).collect();\n\
    \tlet mut b: Vec<isize> = vec![0; n as usize];\n\tlet mut c: Vec<isize> = vec![0;\
    \ n as usize];\n\tlet mut triple_count = 0;\n\tfor i in (1..n as usize).rev()\
    \ {\n\t\tb[i] = b[i + 1] + 1;\n\t\tc[i] = c[i + 1] + a[i];\n\t\tfor j in (i +\
    \ 1)..n as usize {\n\t\t\tif (a[i] + a[j]) % 3 == 0 {\n\t\t\t\ttriple_count +=\
    \ b[j + 1];\n\t\t\t}\n\t\t}\n\t}\n\tfor i in (1..n as usize).rev() {\n\t\tfor\
    \ j in (i + 1)..n as usize {\n\t\t\tif (a[i] + a[j]) % 3 == 0 {\n\t\t\t\ttriple_count\
    \ += c[j + 1];\n\t\t\t}\n\t\t}\n\t}\n\ttriple_count", "    let mut a: Vec<isize>\
    \ = Vec::new();\n    for i in 1..n + 1 {\n        a.push(i * i - i + 1);\n   \
    \ }\n    let mut counter = 0;\n    for i in 0..n - 2 {\n        for j in i + 1..n\
    \ - 1 {\n            for k in j + 1..n {\n                if (a[i] + a[j] + a[k])\
    \ % 3 == 0 {\n                    counter += 1;\n                }\n         \
    \   }\n        }\n    }\n    counter", "    let mut count = 0;\n    for i in 1..n\
    \ {\n        for j in i+1..n {\n            let a_i = i * i - i + 1;\n       \
    \     let a_j = j * j - j + 1;\n            let a_k = (n - 1) * (n - 1) - (n -\
    \ 1) + 1;\n            if (a_i + a_j + a_k) % 3 == 0 {\n                count\
    \ += 1;\n            }\n        }\n    }\n    count", "    let n = n as usize;\n\
    \    let mut a = Vec::with_capacity(n);\n    for i in 1..=n {\n        a.push(i\
    \ * i - i + 1);\n    }\n    let mut count = 0;\n    for i in 0..n - 2 {\n    \
    \    for j in i + 1..n - 1 {\n            for k in j + 1..n {\n              \
    \  if (a[i] + a[j] + a[k]) % 3 == 0 {\n                    count += 1;\n     \
    \           }\n            }\n        }\n    }\n    count", "    let mut res =\
    \ 0;\n    for i in 0..n {\n        for j in i+1..n {\n            for k in j+1..n\
    \ {\n                if (i * i - i + 1 + j * j - j + 1 + k * k - k + 1) % 3 ==\
    \ 0 {\n                    res += 1;\n                }\n            }\n     \
    \   }\n    }\n    res", "    let mut result = 0;\n    for i in 1..n {\n      \
    \  for j in i+1..n {\n            for k in j+1..n {\n                let sum =\
    \ (i*i - i + 1) + (j*j - j + 1) + (k*k - k + 1);\n                if sum % 3 ==\
    \ 0 {\n                    result += 1;\n                }\n            }\n  \
    \      }\n    }\n    result", "    let mut res = 0;\n    let mut a = vec![1; n\
    \ as usize];\n    for i in 1..n {\n        a[i as usize] = i * i - i + 1;\n  \
    \  }\n    for i in 0..n {\n        for j in (i + 1)..n {\n            for k in\
    \ (j + 1)..n {\n                if (a[i as usize] + a[j as usize] + a[k as usize])\
    \ % 3 == 0 {\n                    res += 1;\n                }\n            }\n\
    \        }\n    }\n    res", "    let mut count = 0;\n    for i in 1..n {\n  \
    \      let a_i = i * i - i + 1;\n        for j in i+1..n {\n            let a_j\
    \ = j * j - j + 1;\n            for k in j+1..n {\n                let a_k = k\
    \ * k - k + 1;\n                if (a_i + a_j + a_k) % 3 == 0 {\n            \
    \        count += 1;\n                }\n            }\n        }\n    }\n   \
    \ count", "    let mut res = 0;\n    let mut a = vec![0; n as usize];\n    for\
    \ i in 1..n {\n        a[i as usize] = i * i - i + 1;\n    }\n    for i in 0..n\
    \ {\n        for j in i + 1..n {\n            for k in j + 1..n {\n          \
    \      if (a[i as usize] + a[j as usize] + a[k as usize]) % 3 == 0 {\n       \
    \             res += 1;\n                }\n            }\n        }\n    }\n\
    \    res", "    let mut count = 0;\n    for i in 1..n-1 {\n        for j in i+1..n\
    \ {\n            for k in j+1..n+1 {\n                if ((i*i - i + 1) + (j*j\
    \ - j + 1) + (k*k - k + 1)) % 3 == 0 {\n                    count += 1;\n    \
    \            }\n            }\n        }\n    }\n    count", "    let mut t =\
    \ 0;\n    let mut count: [isize; 3] = [0; 3];\n    for i in 1..=n {\n        t\
    \ = (i * i - i + 1) % 3;\n        count[t as usize] += 1;\n    }\n    count[0]\
    \ * (count[0] - 1) * (count[0] - 2) / 6 + count[1] * count[2] * (count[1] - 1)\
    \ / 2 +\n        count[2] * count[1] * (count[2] - 1) / 2", "    let mut cnt =\
    \ 0;\n    for i in 1..n {\n        for j in i+1..n {\n            for k in j+1..n\
    \ {\n                if (i * i - i + 1 + j * j - j + 1 + k * k - k + 1) % 3 ==\
    \ 0 {\n                    cnt += 1;\n                }\n            }\n     \
    \   }\n    }\n    cnt", "    let a: Vec<isize> = (1..n+1).map(|x| x*x - x + 1).collect();\n\
    \    let mut result = 0;\n    for i in 0..n {\n        for j in (i+1)..n {\n \
    \           for k in (j+1)..n {\n                if (a[i as usize] + a[j as usize]\
    \ + a[k as usize]) % 3 == 0 {\n                    result += 1;\n            \
    \    }\n            }\n        }\n    }\n    result", "    let mut max_triples\
    \ = 0;\n    let mut sum_cnt = HashMap::new();\n    let mut sum = 0;\n    for i\
    \ in 1..=n {\n        sum += i * i - i + 1;\n        for j in 1..=i {\n      \
    \      sum_cnt.entry(sum - j * j + j - 1).or_insert(vec![]).push(j);\n       \
    \ }\n        if sum % 3 == 0 {\n            if let Some(v) = sum_cnt.get(&(sum\
    \ / 3)) {\n                for k in v {\n                    if k < i {\n    \
    \                    max_triples += 1;\n                    }\n              \
    \  }\n            }\n        }\n    }\n    max_triples", "    let mut triples\
    \ = 0;\n    for i in 1..n+1 {\n        for j in (i+1)..n+1 {\n            for\
    \ k in (j+1)..n+1 {\n                if i*i - i + 1 + j*j - j + 1 + k*k - k +\
    \ 1 % 3 == 0 {\n                    triples += 1;\n                }\n       \
    \     }\n        }\n    }\n    triples", "    let mut res = 0;\n    for i in 1..n+1\
    \ {\n        for j in i+1..n+1 {\n            for k in j+1..n+1 {\n          \
    \      if (i * i - i + 1 + j * j - j + 1 + k * k - k + 1) % 3 == 0 {\n       \
    \             res += 1;\n                }\n            }\n        }\n    }\n\
    \    res", "    let mut count = 0;\n    for i in 0..n {\n        for j in i..n\
    \ {\n            for k in j..n {\n                let v = (i * i - i + 1) + (j\
    \ * j - j + 1) + (k * k - k + 1);\n                if v % 3 == 0 {\n         \
    \           count += 1;\n                }\n            }\n        }\n    }\n\
    \    count", "    let mut a = Vec::new();\n    let mut total_triples = 0;\n  \
    \  let n = n as usize;\n    for i in 1..n + 1 {\n        a.push(i * i - i + 1);\n\
    \    }\n    println!(\"{:?}\", a);\n    for i in 0..n - 2 {\n        for j in\
    \ i + 1..n - 1 {\n            for k in j + 1..n {\n                if (a[i] +\
    \ a[j] + a[k]) % 3 == 0 {\n                    total_triples += 1;\n         \
    \       }\n            }\n        }\n    }\n    return total_triples;", "    let\
    \ mut a = vec![0; n as usize];\n    for i in 1..n {\n        a[i as usize] = i\
    \ * i - i + 1;\n    }\n    let mut count = 0;\n    for i in 0..n {\n        for\
    \ j in (i + 1)..n {\n            for k in (j + 1)..n {\n                if a[i\
    \ as usize] + a[j as usize] + a[k as usize] % 3 == 0 {\n                    count\
    \ += 1;\n                }\n            }\n        }\n    }\n    count", '    (1..n).filter(|i|
    (i * i - i + 1) % 3 == 0).count() as isize', "    let mut total = 0;\n    for\
    \ i in 1..n {\n        for j in (i + 1)..n {\n            for k in (j + 1)..n\
    \ {\n                if (i * i - i + 1 + j * j - j + 1 + k * k - k + 1) % 3 ==\
    \ 0 {\n                    total += 1;\n                }\n            }\n   \
    \     }\n    }\n    total", "    let mut total: isize = 0;\n    let mut a = 0;\n\
    \    let mut b = 0;\n    let mut c = 0;\n    let mut d = 0;\n    let mut e = 0;\n\
    \    let mut f = 0;\n    let mut g = 0;\n    let mut h = 0;\n    let mut k = 0;\n\
    \    for i in 1..n {\n        a = i;\n        for j in (i + 1)..n {\n        \
    \    b = j;\n            for p in (j + 1)..n {\n                c = p;\n     \
    \           d = a * a - a + 1;\n                e = b * b - b + 1;\n         \
    \       f = c * c - c + 1;\n                g = d + e + f;\n                if\
    \ g % 3 == 0 {\n                    k += 1;\n                }\n            }\n\
    \        }\n    }\n    total = k;\n    return total;", "    //let mut a = vec![0;\
    \ n as usize];\n    let mut d = [0; 1000001];\n    let mut c = [0; 1000001];\n\
    \    let mut b = [0; 1000001];\n    let mut res = 0;\n    for i in 0..(n as usize)\
    \ {\n        let x = i as isize * i as isize - i as isize + 1;\n        let r\
    \ = x % 3;\n        let y = r + 3;\n        let z = 3 - r;\n        res += c[z\
    \ as usize];\n        b[y as usize] += d[z as usize];\n        c[y as usize] +=\
    \ b[y as usize];\n        d[y as usize] += 1;\n    }\n    res", "    let mut data:\
    \ Vec<isize> = Vec::new();\n    for i in 1..=n {\n        data.push(i * i - i\
    \ + 1);\n    }\n    data.sort();\n    let mut r = 0;\n    for i in 0..n - 2 {\n\
    \        for j in i + 1..n - 1 {\n            let a_i = data[i as usize];\n  \
    \          let a_j = data[j as usize];\n            let s = a_i + a_j;\n     \
    \       let mut l = j + 1;\n            let mut r = n - 1;\n            while\
    \ l <= r {\n                let m = (l + r) / 2;\n                let val = data[m\
    \ as usize];\n                if s + val < 0 {\n                    l = m + 1;\n\
    \                } else if s + val > 0 {\n                    r = m - 1;\n   \
    \             } else {\n                    r = m;\n                    break;\n\
    \                }\n            }\n            if l <= r {\n                let\
    \ mut cnt = 0;\n                let mut t = l;\n                while t <= r {\n\
    \                    cnt += 1;\n                    t += 1;\n                }\n\
    \                r += cnt;\n            }\n        }\n    }\n    r", "    let\
    \ mut n_mut = n;\n    let mut modulo_1 = 0;\n    let mut modulo_2 = 0;\n    while\
    \ n_mut >= 1 {\n        if n_mut % 3 == 1 {\n            modulo_1 += 1;\n    \
    \    } else if n_mut % 3 == 2 {\n            modulo_2 += 1;\n        }\n     \
    \   n_mut -= 1;\n    }\n    return (modulo_1 * (modulo_1 - 1) * (modulo_1 - 2)\
    \ / 6 + \n        modulo_2 * (modulo_2 - 1) * (modulo_2 - 2) / 6 + \n        modulo_1\
    \ * modulo_2 * (modulo_1 + modulo_2 - 1) / 2) as isize;", "    if n < 3 { return\
    \ 0; }\n    let mut arr = Vec::with_capacity(n as usize);\n    for i in 1..=n\
    \ {\n        arr.push(i * i - i + 1);\n    }\n    let mut count = 0;\n    for\
    \ i in 0..n-2 {\n        for j in i+1..n-1 {\n            for k in j+1..n {\n\
    \                if arr[i as usize] + arr[j as usize] + arr[k as usize] % 3 ==\
    \ 0 {\n                    count += 1;\n                }\n            }\n   \
    \     }\n    }\n    count", "    let mut res = 0;\n    let mut arr: Vec<isize>\
    \ = Vec::new();\n    for i in 1..=n {\n        arr.push(i * i - i + 1);\n    }\n\
    \    for i in 0..n - 2 {\n        for j in i + 1..n - 1 {\n            for k in\
    \ j + 1..n {\n                if (arr[i] + arr[j] + arr[k]) % 3 == 0 {\n     \
    \               res += 1;\n                }\n            }\n        }\n    }\n\
    \    res", "    let mut i = 1;\n    let mut j = 2;\n    let mut k = 3;\n    let\
    \ mut total = 0;\n    while i < n - 2 {\n        while j < n - 1 {\n         \
    \   while k < n {\n                if (i * i - i + 1) + (j * j - j + 1) + (k *\
    \ k - k + 1) % 3 == 0 {\n                    total += 1;\n                }\n\
    \                k += 1;\n            }\n            j += 1;\n            k =\
    \ j + 1;\n        }\n        i += 1;\n        j = i + 1;\n        k = j + 1;\n\
    \    }\n    total", "    let mut accum = 0;\n    for i in 1..n {\n        for\
    \ j in i+1..n {\n            for k in j+1..n {\n                if (j*j - j +\
    \ 1 + i*i - i + 1 + k*k - k + 1) % 3 == 0 {\n                    accum += 1;\n\
    \                }\n            }\n        }\n    }\n    accum", "    let mut\
    \ n = n;\n    let mut res = 0;\n    while n > 2 {\n        res += (n - 2) * (n\
    \ - 1) * n / 6;\n        n -= 3;\n    }\n    res", "    let mut a: Vec<isize>\
    \ = vec![];\n    for i in 1..n+1 {\n        a.push(i*i - i + 1);\n    }\n    let\
    \ mut result = 0;\n    for i in 0..n-2 {\n        for j in i+1..n-1 {\n      \
    \      for k in j+1..n {\n                if (a[i] + a[j] + a[k]) % 3 == 0 {\n\
    \                    result += 1;\n                }\n            }\n        }\n\
    \    }\n    result", "    let mut triples: isize = 0;\n    for i in 1..n-1 {\n\
    \        for j in i+1..n {\n            for k in j+1..n+1 {\n                let\
    \ a = i * i - i + 1;\n                let b = j * j - j + 1;\n               \
    \ let c = k * k - k + 1;\n                if (a + b + c) % 3 == 0 {\n        \
    \            triples += 1;\n                }\n            }\n        }\n    }\n\
    \    triples", "    let mut sum = 0;\n    let mut array = vec![0; n as usize];\n\
    \    for i in 0..n {\n        array[i as usize] = i * i - i + 1;\n    }\n    for\
    \ i in 0..n {\n        for j in i+1..n {\n            for k in j+1..n {\n    \
    \            if (array[i as usize] + array[j as usize] + array[k as usize]) %\
    \ 3 == 0 {\n                    sum += 1;\n                }\n            }\n\
    \        }\n    }\n    sum", "    let mut triples = 0;\n    for i in 1..n {\n\
    \        for j in (i + 1)..n {\n            for k in (j + 1)..n {\n          \
    \      if (i * i - i + 1 + j * j - j + 1 + k * k - k + 1) % 3 == 0 {\n       \
    \             triples += 1;\n                }\n            }\n        }\n   \
    \ }\n    triples", "    let mut total = 0;\n    for i in 1..n {\n        let start\
    \ = (i * i - i + 1) % 3;\n        for j in i+1..n {\n            let second =\
    \ (j * j - j + 1) % 3;\n            if (start + second) % 3 == 0 {\n         \
    \       let index = (j * j - j + 1) + (j - i) * 2;\n                let end =\
    \ index / 3;\n                total += end - j;\n            }\n        }\n  \
    \  }\n    total", "    if n <= 2 {\n        return 0;\n    }\n    let n = n as\
    \ usize;\n    let mut count = vec![0; 3];\n    for i in 1..n {\n        let a\
    \ = (i * i - i + 1) % 3;\n        count[a as usize] += 1;\n    }\n    return (count[0]\
    \ * (count[0] - 1) * (count[0] - 2) / 6 +\n            count[1] * (count[1] -\
    \ 1) * (count[2]) / 6 +\n            count[2] * (count[2] - 1) * (count[1]) /\
    \ 6) as isize;", "    let len = n as usize;\n    let mut a = vec![0; len];\n \
    \   for i in 0..len {\n        a[i] = i * i - i + 1;\n    }\n    let mut count\
    \ = 0;\n    for i in 0..len - 2 {\n        for j in i + 1..len - 1 {\n       \
    \     for k in j + 1..len {\n                if a[i] + a[j] + a[k] % 3 == 0 {\n\
    \                    count += 1;\n                }\n            }\n        }\n\
    \    }\n    count", "    let mut max = 0;\n    for i in 1..n {\n        for j\
    \ in (i + 1)..n {\n            for k in (j + 1)..n {\n                if (i *\
    \ i - i + 1 + j * j - j + 1 + k * k - k + 1) % 3 == 0 {\n                    max\
    \ += 1;\n                }\n            }\n        }\n    }\n    max", '    (n-2)*(n-1)*n/6',
  "    let mut s = vec![vec![0; 4]; (n + 1) as usize];\n    let mut c = 0;\n    for\
    \ i in 1..n + 1 {\n        let ai = i * i - i + 1;\n        for s0 in 0..4 {\n\
    \            for d in 0..4 {\n                let j = (ai + s0 + d) % 3;\n   \
    \             s[i as usize][j] += s[(i - 1) as usize][s0];\n            }\n  \
    \      }\n        c += s[i as usize][0];\n    }\n    c", "    let mut triples\
    \ = 0;\n    let mut i = 0;\n    let mut a = Vec::with_capacity(n as usize);\n\
    \    while i < n {\n        a.push(i * i - i + 1);\n        i += 1;\n    }\n \
    \   i = 0;\n    while i < n - 2 {\n        let mut j = i + 1;\n        while j\
    \ < n - 1 {\n            let mut k = j + 1;\n            while k < n {\n     \
    \           if (a[i as usize] + a[j as usize] + a[k as usize]) % 3 == 0 {\n  \
    \                  triples += 1;\n                }\n                k += 1;\n\
    \            }\n            j += 1;\n        }\n        i += 1;\n    }\n    triples",
  "    let mut res = 0;\n    let mut mod_freq = [0; 3];\n    for i in 1..n {\n   \
    \     let a = i * i - i + 1;\n        let b = a % 3;\n        for j in 0..b {\n\
    \            res += mod_freq[j as usize];\n        }\n        mod_freq[b as usize]\
    \ += 1;\n    }\n    res", "    let mut a: Vec<isize> = Vec::new();\n    for i\
    \ in 1..n+1 {\n        a.push(i*i - i + 1);\n    }\n    let mut max_triples =\
    \ 0;\n    for i in 0..a.len() {\n        for j in (i+1)..a.len() {\n         \
    \   for k in (j+1)..a.len() {\n                if (a[i] + a[j] + a[k]) % 3 ==\
    \ 0 {\n                    max_triples += 1;\n                }\n            }\n\
    \        }\n    }\n    max_triples", "    let mut index = 0;\n    let mut triple\
    \ = 0;\n    let mut count = 0;\n    while index < n {\n        let mut j = index\
    \ + 1;\n        while j < n {\n            let mut k = j + 1;\n            while\
    \ k < n {\n                triple = ((index * index) - index + 1) + ((j * j) -\
    \ j + 1) + ((k * k) - k + 1);\n                if triple % 3 == 0 {\n        \
    \            count += 1;\n                }\n                k += 1;\n       \
    \     }\n            j += 1;\n        }\n        index += 1;\n    }\n    count",
  "    let mut count = 0;\n    for i in 0..n {\n        for j in i+1..n {\n      \
    \      for k in j+1..n {\n                if (i * i - i + 1 + j * j - j + 1 +\
    \ k * k - k + 1) % 3 == 0 {\n                    count += 1;\n               \
    \ }\n            }\n        }\n    }\n    count", "\tif n < 3 {\n\t\treturn 0;\n\
    \t}\n\tlet mut triples = Vec::new();\n\tfor i in 1..n-1 {\n\t\tlet i_sq = i *\
    \ i;\n\t\tfor j in i+1..n {\n\t\t\tlet j_sq = j * j;\n\t\t\tfor k in j+1..n+1\
    \ {\n\t\t\t\tlet k_sq = k * k;\n\t\t\t\tif (i_sq + j_sq + k_sq - i - j - k + 1)\
    \ % 3 == 0 {\n\t\t\t\t\ttriples.push((i, j, k));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\
    }\n\treturn triples.len() as isize;", "    if n < 3 { return 0; }\n    let mut\
    \ sum = (1..n).map(|i| i * i - i + 1).collect::<Vec<isize>>();\n    sum.sort();\n\
    \    println!(\"{:?}\", sum);\n    let mut cnt = 0;\n    for i in 0..(n-2) {\n\
    \        for j in (i+1)..(n-1) {\n            for k in (j+1)..n {\n          \
    \      let s = sum[i as usize] + sum[j as usize] + sum[k as usize];\n        \
    \        if s % 3 == 0 { cnt += 1; }\n            }\n        }\n    }\n    cnt",
  "    let mut out_cnt = 0;\n    let mut cnt = 0;\n    let mut mod_cnt = vec![0; 3];\n\
    \    for i in 1..n {\n        let cur_val = i * i - i + 1;\n        mod_cnt[(cur_val\
    \ % 3) as usize] += 1;\n        cnt += out_cnt;\n        out_cnt += mod_cnt[((3\
    \ - cur_val % 3) % 3) as usize];\n    }\n    cnt", "    let n = n as usize;\n\
    \    let a = (1..n).map(|i| i * i - i + 1).collect::<Vec<isize>>();\n    let mut\
    \ pairs = Vec::new();\n    for i in 0..n {\n        for j in i+1..n {\n      \
    \      pairs.push((a[i], a[j]));\n        }\n    }\n    pairs.sort_by(|(a, b),\
    \ (c, d)| (a + b).cmp(&(c + d)));\n    let mut res = 0;\n    let mut low = 0;\n\
    \    let mut high = pairs.len() - 1;\n    while low < high {\n        let (a,\
    \ b) = pairs[low];\n        let (c, d) = pairs[high];\n        if (a + b + c)\
    \ % 3 == 0 {\n            let p = high - 1;\n            let mut sum = (a + b\
    \ + c) / 3;\n            while p > low && pairs[p].0 == pairs[p - 1].0 {\n   \
    \             p -= 1;\n            }\n            res += p - low;\n          \
    \  high = p;\n        } else if (a + b + d) % 3 == 0 {\n            res += 1;\n\
    \            high -= 1;\n        } else {\n            low += 1;\n        }\n\
    \    }\n    res", "    if n < 3 {\n        return 0;\n    }\n    let mut triple_count\
    \ = (n - 2) * (n - 1) * n / 6;\n    let mut mod_count = (n - 2) * (n - 1) / 2;\n\
    \    let mut remainder = mod_count % 3;\n    mod_count /= 3;\n    if remainder\
    \ == 1 {\n        mod_count += (n - 2) / 3;\n    }\n    if remainder == 2 {\n\
    \        mod_count += 2 * (n - 2) / 3;\n    }\n    triple_count -= mod_count;\n\
    \    return triple_count;", "    if n < 3 {\n        return 0;\n    }\n    let\
    \ mut result = 0;\n    for i in 1..n {\n        let mut sum = 0;\n        for\
    \ j in i+1..n+1 {\n            sum += j * j - j + 1;\n            if sum % 3 ==\
    \ 0 {\n                result += 1;\n            }\n        }\n    }\n    result",
  "    // Edge case \n    if n < 3 {\n        return 0;\n    }\n\n    // Loop through\
    \ to the second last element\n    let mut sum: isize = 0;\n    for a in 1..n-1\
    \ {\n        let a = a as isize;\n        let aa = a * a - a + 1;\n        //\
    \ If a is divisible by 3\n        if aa % 3 == 0 {\n            let mut b: isize\
    \ = a + 1;\n            // Loop through the rest of the elements\n           \
    \ while b < n {\n                let b = b as isize;\n                let bb =\
    \ b * b - b + 1;\n                // If b is divisible by 3\n                if\
    \ bb % 3 == 0 {\n                    let mut c: isize = b + 1;\n             \
    \       // Loop through the rest of the elements\n                    while c\
    \ < n {\n                        let c = c as isize;\n                       \
    \ let cc = c * c - c + 1;\n                        // If c is divisible by 3\n\
    \                        if cc % 3 == 0 {\n                            // Triple\
    \ is found!\n                            sum += 1;\n                        }\n\
    \                        c += 1;\n                    }\n                }\n \
    \               b += 1;\n            }\n        }\n    }\n    sum", "    let mut\
    \ count = 0;\n    let mut arr: Vec<isize> = vec![];\n    for i in 1..=n {\n  \
    \      arr.push(i * i - i + 1);\n    }\n    for i in 0..n {\n        for j in\
    \ i + 1..n {\n            for k in j + 1..n {\n                if (arr[i] + arr[j]\
    \ + arr[k]) % 3 == 0 {\n                    count += 1;\n                }\n \
    \           }\n        }\n    }\n    count", "    // Write your code here\n  \
    \  let mut a: Vec<isize> = Vec::new();\n    for i in 1..n + 1 {\n        a.push(i\
    \ * i - i + 1);\n    }\n    let mut count = 0;\n    for i in 0..n - 2 {\n    \
    \    for j in i + 1..n - 1 {\n            for k in j + 1..n {\n              \
    \  if (a[i] + a[j] + a[k]) % 3 == 0 {\n                    count += 1;\n     \
    \           }\n            }\n        }\n    }\n    count", "    let mut max_triples\
    \ = 0;\n    let mut x = 2;\n    let mut y = 3;\n    let mut z = 4;\n    while\
    \ z <= n {\n        if x + y + z <= n && (x + y + z) % 3 == 0 {\n            max_triples\
    \ += 1;\n        }\n        x += 1;\n        y += 1;\n        z += 1;\n    }\n\
    \    max_triples", "\tlet mut result = 0;\n\tfor i in 1..n {\n\t\tlet mut sum\
    \ = 0;\n\t\tfor j in (i + 1)..n {\n\t\t\tsum += j;\n\t\t\tif sum % 3 == 0 {\n\t\
    \t\t\tresult += j - i;\n\t\t\t}\n\t\t}\n\t}\n\tresult", "    // Given n = 2,\n\
    \    // a[0] = 0, a[1] = 1\n    // 0 + 1 = 1, and 1 % 3 == 0, so answer is 1\n\
    \n    // Given n = 4,\n    // a[0] = 0, a[1] = 1, a[2] = 6, a[3] = 14\n    //\
    \ 0 + 1 = 1, and 1 % 3 == 0, so answer is 1\n    // 1 + 6 = 7, and 7 % 3 == 1,\
    \ so answer is 1\n    // 1 + 14 = 15, and 15 % 3 == 0, so answer is 2\n    //\
    \ 6 + 14 = 20, and 20 % 3 == 2, so answer is 2\n    // answer is 2\n\n    // n\
    \ = 2\n    // a = [0, 1]\n    // 0 + 1 = 1 % 3 == 0\n    // ans = 1\n\n    //\
    \ n = 4\n    // a = [0, 1, 6, 14]\n    // 0 + 1 = 1 % 3 == 0\n    // 1 + 6 = 7\
    \ % 3 == 1\n    // 1 + 14 = 15 % 3 == 0\n    // 6 + 14 = 20 % 3 == 2\n    // ans\
    \ = 2\n\n    // n = 6\n    // a = [0, 1, 6, 14, 30, 55]\n    // 0 + 1 = 1 % 3\
    \ == 0\n    // 1 + 6 = 7 % 3 == 1\n    // 1 + 14 = 15 % 3 == 0\n    // 1 + 30\
    \ = 31 % 3 == 1\n    // 1 + 55 = 56 % 3 == 2\n    // 6 + 14 = 20 % 3 == 2\n  \
    \  // 6 + 30 = 36 % 3 == 0\n    // 6 + 55 = 61 % 3 == 0\n    // 14 + 30 = 44 %\
    \ 3 == 1\n    // 14 + 55 = 69 % 3 == 0\n    // 30 + 55 = 85 % 3 == 2\n    // ans\
    \ = 4\n\n    // n = 8\n    // a = [0, 1, 6, 14, 30, 55, 91, 140]\n    // 0 + 1\
    \ = 1 % 3 == 0\n    // 1 + 6 = 7 % 3 == 1\n    // 1 + 14 = 15 % 3 == 0\n    //\
    \ 1 + 30 = 31 % 3", "    //     a[1] = 1 * 1 - 1 + 1 = 1\n    //     a[2] = 2\
    \ * 2 - 2 + 1 = 3\n    //     a[3] = 3 * 3 - 3 + 1 = 7\n    //     a[4] = 4 *\
    \ 4 - 4 + 1 = 13\n    //     a[5] = 5 * 5 - 5 + 1 = 21\n    // There are 4 triples\
    \ (a[1], a[2], a[3]), (a[1], a[2], a[4]), (a[1], a[3], a[4]), and (a[2], a[3],\
    \ a[4]).\n    // There is only one triple (a[1], a[2], a[5]) that is a multiple\
    \ of 3.\n    // The answer is 4.\n    let mut triples = 0;\n    for i in 1..n\
    \ {\n        let sum = i * i - i + 1;\n        for j in (i + 1)..n {\n       \
    \     let sum2 = sum + j * j - j + 1;\n            for k in (j + 1)..n {\n   \
    \             let sum3 = sum2 + k * k - k + 1;\n                if sum3 % 3 ==\
    \ 0 {\n                    triples += 1;\n                }\n            }\n \
    \       }\n    }\n    triples", "    // Return the number of triples that you\
    \ can construct using the elements of a.\n    (1..n)\n        .flat_map(|i| {\n\
    \            (i..n)\n                .map(move |j| (i, j))\n                .filter(|&(i,\
    \ j)| (i * i - i + 1 + j * j - j + 1) % 3 == 0)\n        })\n        .flat_map(|(i,\
    \ j)| (j..n).map(move |k| (i, j, k)))\n        .filter(|&(i, j, k)| (i * i - i\
    \ + 1 + j * j - j + 1 + k * k - k + 1) % 3 == 0)\n        .count() as isize",
  "    if n < 3 {\n        return 0;\n    }\n\n    let mut triples = 0;\n    for i\
    \ in 1..n {\n        for j in (i + 1)..n {\n            let ai = i * i - i + 1;\n\
    \            let aj = j * j - j + 1;\n            let ai_aj = ai + aj;\n     \
    \       if ai_aj % 3 == 0 {\n                triples += n - j;\n            }\n\
    \        }\n    }\n\n    triples", "    let mut triples = 0;\n    for i in 1..n\
    \ {\n        for j in i+1..n {\n            for k in j+1..n {\n              \
    \  let t = i * i - i + 1 + j * j - j + 1 + k * k - k + 1;\n                triples\
    \ += if t % 3 == 0 { 1 } else { 0 };\n            }\n        }\n    }\n    triples",
  "    let mut count = 0;\n    for i in 1..n {\n        for j in i+1..n {\n      \
    \      for k in j+1..n {\n                let a = (i*i - i + 1) + (j*j - j + 1)\
    \ + (k*k - k + 1);\n                if a % 3 == 0 {\n                    count\
    \ += 1;\n                }\n            }\n        }\n    }\n    count", "   \
    \ (1..n).fold(0, |acc, x| {\n        let i = x * x - x + 1;\n        if i % 3\
    \ == 0 {\n            return acc + 1;\n        }\n        acc\n    })", "    let\
    \ mut count = 0;\n    for i in 1..n {\n        for j in i + 1..n {\n         \
    \   for k in j + 1..n {\n                if (i * i - i + 1 + j * j - j + 1 + k\
    \ * k - k + 1) % 3 == 0 {\n                    count += 1;\n                }\n\
    \            }\n        }\n    }\n    count", '    (n * (n - 1) * (n - 2)) / 6',
  "    let mut res = 0;\n    for i in 0..n {\n        for j in (i + 1)..n {\n    \
    \        for k in (j + 1)..n {\n                if ((i + 1) * (i + 1) - (i + 1)\
    \ + 1 +\n                     (j + 1) * (j + 1) - (j + 1) + 1 +\n            \
    \         (k + 1) * (k + 1) - (k + 1) + 1) % 3 == 0 {\n                    res\
    \ += 1;\n                }\n            }\n        }\n    }\n    res", "    let\
    \ mut count = 0;\n    for i in 1..n {\n        for j in i+1..n {\n           \
    \ for k in j+1..n {\n                let sum = (i*i-i+1) + (j*j-j+1) + (k*k-k+1);\n\
    \                if sum % 3 == 0 {\n                    count += 1;\n        \
    \        }\n            }\n        }\n    }\n    count", "    let mut cnt = 0;\n\
    \    let mut k = n - 1;\n    for i in 1..(n - 1) {\n        for j in (i + 1)..(n\
    \ - 1) {\n            let sum = i * i - i + 1 + j * j - j + 1 + k * k - k + 1;\n\
    \            if sum % 3 == 0 {\n                k -= 1;\n                cnt +=\
    \ 1;\n            }\n        }\n    }\n    cnt", "    if n < 3 {\n        return\
    \ 0;\n    }\n    let (mut result, mut inc) = (0, n - 1);\n    while inc > 2 {\n\
    \        result += inc - 2;\n        inc -= 1;\n    }\n    result", '    return
    n * (n - 1) * (n - 2) / 6;', "    let mut count = 0;\n    let arr = (1..=n).map(|x|\
    \ x * x - x + 1).collect::<Vec<isize>>();\n    for i in 0..n {\n        for j\
    \ in i+1..n {\n            for k in j+1..n {\n                if (arr[i] + arr[j]\
    \ + arr[k]) % 3 == 0 {\n                    count += 1;\n                }\n \
    \           }\n        }\n    }\n    count", "    let n = n as usize;\n    let\
    \ mut a = vec![0; n + 1];\n    for i in 1..=n {\n        a[i] = i * i - i + 1;\n\
    \    }\n    let mut triples = 0;\n    for i in 1..(n - 1) {\n        for j in\
    \ (i + 1)..(n) {\n            for k in (j + 1)..(n + 1) {\n                if\
    \ a[i] + a[j] + a[k] % 3 == 0 {\n                    triples += 1;\n         \
    \       }\n            }\n        }\n    }\n    triples", "    let mut sum = 0;\n\
    \    for i in 0..n {\n        let a = i * i - i + 1;\n        if a % 3 == 0 {\n\
    \            sum += 1;\n        }\n    }\n    sum * sum * sum", "    let mut count\
    \ = 0;\n    for i in 1..n {\n        let a = i * i - i + 1;\n        for j in\
    \ i + 1..n {\n            let b = j * j - j + 1;\n            for k in j + 1..n\
    \ {\n                let c = k * k - k + 1;\n                if (a + b + c) %\
    \ 3 == 0 {\n                    count += 1;\n                }\n            }\n\
    \        }\n    }\n    count", "    let mut count = 0;\n    for i in 1..n {\n\
    \        for j in i + 1..n {\n            for k in j + 1..n {\n              \
    \  if (i * i - i + 1 + j * j - j + 1 + k * k - k + 1) % 3 == 0 {\n           \
    \         count += 1;\n                }\n            }\n        }\n    }\n  \
    \  count", "    let mut triple_count = 0;\n    let mut index = 2;\n    let mut\
    \ prev_count = 1;\n    while index < n {\n        let count = index * index -\
    \ index + 1;\n        if prev_count % 3 == 0 {\n            triple_count += index\
    \ - 1;\n        }\n        if (prev_count + count) % 3 == 0 {\n            triple_count\
    \ += 1;\n        }\n        prev_count = count;\n        index += 1;\n    }\n\
    \    triple_count", "    let mut count = 0;\n    for i in 1..n {\n        for\
    \ j in i + 1..n {\n            let k = j + 1;\n            if a(i) + a(j) + a(k)\
    \ % 3 == 0 {\n                count += 1;\n            }\n        }\n    }\n \
    \   count", "    //// (2, 3, 4) = 9 = 3 * 3 = 3.\n    let mut count = 0;\n   \
    \ let mut max_triples = 0;\n    let mut max_n = 0;\n    let mut triples = vec![0;\
    \ (n - 1) as usize];\n    for i in 2..n + 1 {\n        let mut tmp_count = 0;\n\
    \        for j in 1..i - 1 {\n            let k = i - j;\n            let value\
    \ = i * i - i + 1;\n            let value_1 = j * j - j + 1;\n            let\
    \ value_2 = k * k - k + 1;\n            if (value + value_1 + value_2) % 3 ==\
    \ 0 {\n                ////println!(\"The value {}, {}, {} is multiple of 3. i\
    \ = {}, j = {}, k = {}\", value, value_1, value_2, i, j, k);\n               \
    \ tmp_count += 1;\n            }\n        }\n        triples[(i - 2) as usize]\
    \ = tmp_count;\n        //println!(\"The triples is {:?}.\", triples);\n     \
    \   if tmp_count > max_triples {\n            max_triples = tmp_count;\n     \
    \       max_n = i;\n        }\n        count += tmp_count;\n    }\n    println!(\"\
    The number of the triples is {}. max_triples = {}, max_n = {}\", count, max_triples,\
    \ max_n);\n    max_triples", "    let mut a: Vec<isize> = Vec::new();\n    for\
    \ i in 1..n + 1 {\n        a.push(i * i - i + 1);\n    }\n    let mut cnt = 0;\n\
    \    for i in 0..a.len() {\n        for j in i..a.len() {\n            for k in\
    \ j..a.len() {\n                if (a[i] + a[j] + a[k]) % 3 == 0 {\n         \
    \           cnt += 1;\n                }\n            }\n        }\n    }\n  \
    \  cnt", "    if n < 3 {\n        return 0;\n    }\n    let mut triples = 0;\n\
    \    for i in 1..n {\n        let a = i * i - i + 1;\n        for j in i + 1..n\
    \ {\n            let b = j * j - j + 1;\n            for k in j + 1..n {\n   \
    \             let c = k * k - k + 1;\n                if (a + b + c) % 3 == 0\
    \ {\n                    triples += 1;\n                }\n            }\n   \
    \     }\n    }\n    triples", "    let mut sum: isize = 0;\n    for i in 1..n\
    \ {\n        for j in (i + 1)..n {\n            let lhs = ((i * i) - i + 1) +\
    \ ((j * j) - j + 1);\n            if lhs % 3 == 0 {\n                for k in\
    \ (j + 1)..n {\n                    let rhs = ((k * k) - k + 1);\n           \
    \         if (lhs + rhs) % 3 == 0 {\n                        sum += 1;\n     \
    \               }\n                }\n            }\n        }\n    }\n    sum",
  "    let mut count = 0;\n    for i in 1..(n - 1) {\n        for j in (i + 1)..(n)\
    \ {\n            for k in (j + 1)..(n + 1) {\n                let a = i * i -\
    \ i + 1;\n                let b = j * j - j + 1;\n                let c = k *\
    \ k - k + 1;\n                if (a + b + c) % 3 == 0 {\n                    count\
    \ += 1;\n                }\n            }\n        }\n    }\n    count", "   \
    \ let mut c = 0;\n    for i in 1..n {\n        for j in i+1..n {\n           \
    \ for k in j+1..n {\n                let a: Vec<isize> = vec![i, j, k];\n    \
    \            let a_sum: isize = a.iter().sum();\n                if a_sum % 3\
    \ == 0 {\n                    c += 1;\n                }\n            }\n    \
    \    }\n    }\n    c", "    let mut cnt = 0;\n    for i in 1..n-1 {\n        let\
    \ x = i * i - i + 1;\n        for j in i+1..n {\n            let y = j * j - j\
    \ + 1;\n            for k in j+1..n+1 {\n                let z = k * k - k + 1;\n\
    \                if (x + y + z) % 3 == 0 {\n                    cnt += 1;\n  \
    \              }\n            }\n        }\n    }\n    cnt", "    let mut res\
    \ = 0;\n    for a in 1..n - 1 {\n        for b in a + 1..n {\n            for\
    \ c in b + 1..n + 1 {\n                if (a * a - a + 1 + b * b - b + 1 + c *\
    \ c - c + 1) % 3 == 0 {\n                    res += 1;\n                }\n  \
    \          }\n        }\n    }\n    res", "    let mut count = 0;\n    for i in\
    \ 1..n {\n        let a = (i * i - i + 1) as isize;\n        let b = (a + 1) as\
    \ isize;\n        let c = (b + 1) as isize;\n        count += (c % 3 == 0) as\
    \ isize;\n    }\n    count"]
stop_tokens:
- "\n}"
