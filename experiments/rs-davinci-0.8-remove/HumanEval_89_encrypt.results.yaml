language: rs
name: HumanEval_89_encrypt
results:
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut v = Vec::new();\n    for c in s.chars() {\n        if let Some(x)\
    \ = c.to_digit(36) {\n            let x = x + 2;\n            if x > 35 {\n  \
    \              v.push(x - 34);\n            } else {\n                v.push(x);\n\
    \            }\n        }\n    }\n    String::from_utf8(v.iter().map(|x| x.to_string().into_bytes()[0]).collect()).unwrap()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"12\"`,\n right: `\"lm\"`', /tmp/tmp90v227u_.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822739
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    // create string containing lowercase letters\n    let lowercase = \"\
    abcdefghijklmnopqrstuvwxyz\";\n    // create string containing uppercase letters\n\
    \    let uppercase = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    // iterate over each\
    \ character in the passed string,\n    // match the character to the string containing\
    \ lowercase\n    // and uppercase letters, return the index of the character\n\
    \    // in the string, add two to the index and return the letter\n    // at that\
    \ index in the string. If the index is larger than\n    // the lenght of the string,\
    \ subtract 26 from the index.\n    s.chars().map(|x| {\n        let c = match\
    \ lowercase.find(x) {\n            Some(i) => (i + 2) % 26,\n            None\
    \ => lowercase.find(x).unwrap()\n        };\n        lowercase.chars().nth(c).unwrap()\n\
    \    }).collect()\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpoylml07m.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822739
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n\tlet mut res = String::new();\n\tfor c in s.chars() {\n\t\tlet orig = c\
    \ as u8;\n\t\tlet moved = if orig >= 97 && orig <= 122 { \n\t\t\t((orig - 97 +\
    \ 5) % 26) + 97 \n\t\t} else if orig >= 65 && orig <= 90 { \n\t\t\t((orig - 65\
    \ + 5) % 26) + 65 \n\t\t} else { orig };\n\t\tres.push(moved as char);\n\t}\n\t\
    res\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"mn\"`,\n right: `\"lm\"`', /tmp/tmpeaby6els.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822739
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    s.chars().map(|c| match c {\n            'A'...'M' | 'a'...'m' => ((c\
    \ as u8) + 2) as char,\n            'N'...'Z' | 'n'...'z' => ((c as u8) - 10)\
    \ as char,\n            _ => c\n        }).collect()\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpepcz8cfe.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822739
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut encrypted = String::new();\n    let mut alphabet = String::from(\"\
    abcdefghijklmnopqrstuvwxyz\");\n    alphabet.push_str(\"abcdefghijklmnopqrstuvwxyz\"\
    );\n    for c in s.chars() {\n        if c.is_lowercase() {\n            let index\
    \ = alphabet.find(c).unwrap();\n            encrypted.push(alphabet.chars().nth(index\
    \ + 2).unwrap());\n        } else {\n            encrypted.push(c);\n        }\n\
    \    }\n    encrypted\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpc6kqkfvf.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822739
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut enc = String::new();\n    let chars: Vec<char> = s.chars().collect();\n\
    \    for c in chars {\n        let b = ((c as u8) + 2) as char;\n        enc.push(b);\n\
    \    }\n    enc\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpznqt8i9f.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822739
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    const ALPHABET_OFFSET: usize = 2;\n    let mut s = s.chars().map(|c|\
    \ {\n        match c {\n            'a' ..= 'z' => ((c as u8 - 'a' as u8 + ALPHABET_OFFSET\
    \ as u8) % 26 + 'a' as u8) as char,\n            'A' ..= 'Z' => ((c as u8 - 'A'\
    \ as u8 + ALPHABET_OFFSET as u8) % 26 + 'A' as u8) as char,\n            _ =>\
    \ c\n        }\n    }).collect::<String>();\n    s\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpefqbioqq.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822739
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n  let mut ans = \"\".to_string();\n  for c in s.chars() {\n    let num: u8\
    \ = (c as u8) + 2 * 2;\n    if num > 122 {\n      ans.push((num - 26) as char);\n\
    \    } else {\n      ans.push(num as char);\n    }\n  }\n  ans\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822739
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n\tlet mut output = String::new();\n\tfor c in s.chars() {\n\t\tlet new_letter\
    \ = match c {\n\t\t\t'a' => 'c',\n\t\t\t'b' => 'd',\n\t\t\t'c' => 'e',\n\t\t\t\
    'd' => 'f',\n\t\t\t'e' => 'g',\n\t\t\t'f' => 'h',\n\t\t\t'g' => 'i',\n\t\t\t'h'\
    \ => 'j',\n\t\t\t'i' => 'k',\n\t\t\t'j' => 'l',\n\t\t\t'k' => 'm',\n\t\t\t'l'\
    \ => 'n',\n\t\t\t'm' => 'o',\n\t\t\t'n' => 'p',\n\t\t\t'o' => 'q',\n\t\t\t'p'\
    \ => 'r',\n\t\t\t'q' => 's',\n\t\t\t'r' => 't',\n\t\t\t's' => 'u',\n\t\t\t't'\
    \ => 'v',\n\t\t\t'u' => 'w',\n\t\t\t'v' => 'x',\n\t\t\t'w' => 'y',\n\t\t\t'x'\
    \ => 'z',\n\t\t\t'y' => 'a',\n\t\t\t'z' => 'b',\n\t\t\t_ => c,\n\t\t};\n\t\toutput.push(new_letter);\n\
    \t}\n\treturn output;\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmplbejm5qx.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822739
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut result = \"\".to_string();\n    for ch in s.chars() {\n     \
    \   let mut chr: char = ch;\n        if let Some(chr) = chr.to_digit(10) {\n \
    \           let ord = ((chr as i32) - 48 + 2 * 2) % 10;\n            let chr =\
    \ (ord + 48) as u8 as char;\n            result.push(chr);\n        } else {\n\
    \            result.push(chr);\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmp7f7hwmk_.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822739
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\".to_string();\n    let mut\
    \ new_alphabet = \"\".to_string();\n    let mut temp = \"\".to_string();\n   \
    \ let mut final_string = \"\".to_string();\n    let mut count = 0;\n    for i\
    \ in 0..26 {\n        if i < 24 {\n            new_alphabet.push_str(&alphabet[(i\
    \ + 2)..(i + 3)]);\n        } else {\n            temp.push_str(&alphabet[(i +\
    \ 2)..(i + 3)]);\n        }\n    }\n    new_alphabet.push_str(&temp);\n    for\
    \ i in 0..s.len() {\n        for j in 0..26 {\n            if s[i..(i + 1)] ==\
    \ alphabet[j..(j + 1)] {\n                final_string.push_str(&new_alphabet[j..(j\
    \ + 1)]);\n                count += 1;\n            }\n        }\n    }\n    final_string\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 27 is out of bounds of `abcdefghijklmnopqrstuvwxyz`'',
    /tmp/tmp8chlr4ii.rs:16:28

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822739
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let letters = b'a'..=b'z';\n    let shift = s.bytes().map(|c| (c - b'a'\
    \ + 2) % 26);\n    let cipher = shift.zip(letters).map(|(sh, le)| le + sh);\n\
    \    String::from_utf8(cipher.collect()).unwrap()\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jl\"`,\n right: `\"lm\"`', /tmp/tmpw_a4q90e.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822739
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\".chars().collect::<Vec<char>>();\n\
    \    let (new_alphabet, _) = alphabet.split_at(alphabet.len() - 2);\n    let e_alphabet\
    \ = [&vec!['a', 'b'], new_alphabet].concat();\n    let mut e_string = String::new();\n\
    \    for ch in s.chars() {\n        if ch.is_whitespace() {\n            e_string.push('\
    \ ');\n        } else {\n            let index = alphabet.iter().position(|c|\
    \ c == &ch).unwrap();\n            e_string.push(e_alphabet[index]);\n       \
    \ }\n    }\n    e_string\n}\n\nfn main() {\n    let candidate = encrypt;\n   \
    \ assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"fg\"`,\n right: `\"lm\"`', /tmp/tmplrag0j8y.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822739
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut t = String::new();\n    let alphabets: Vec<char> = \"abcdefghijklmnopqrstuvwxyz\"\
    .chars().collect();\n    for c in s.chars() {\n        let mut matched = false;\n\
    \        for i in 0..26 {\n            if c == alphabets[i] {\n              \
    \  let index = i+2*2;\n                t.push(alphabets[index%26]);\n        \
    \        matched = true;\n                break;\n            }\n        }\n \
    \       if !matched {\n            t.push(c);\n        }\n    }\n    t\n}\n\n\
    fn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822739
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut string = s.to_string();\n    string.chars().map(|x| if x.is_alphabetic()\
    \ { (((x as u8) - ('a' as u8) + 2) % 26 + ('a' as u8)) as char } else { x }).collect()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmph4lnh8fv.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822739
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut result = String::new();\n    for c in s.chars() {\n        let\
    \ alphabet = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\
    \ 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n        let\
    \ new_char = alphabet[((((c as i8 - 'a' as i8) + 2) * 2) % 26) as usize];\n  \
    \      result.push(new_char);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"su\"`,\n right: `\"lm\"`', /tmp/tmp8o329756.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822739
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut result = String::new();\n    for c in s.chars() {\n        result.push((c\
    \ as u8 + 2*2) as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpjapp1dfc.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822739
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut result = String::new();\n    for _ in s.bytes() {\n        result.push_str(\"\
    a\");\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n   \
    \ assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"aa\"`,\n right: `\"lm\"`', /tmp/tmpluax34l0.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822739
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let v: Vec<char> = s.chars().collect();\n    let mut alpha: Vec<char>\
    \ = \"abcdefghijklmnopqrstuvwxyz\".chars().collect();\n    let mut new_alpha:\
    \ Vec<char> = \"cdefghijklmnopqrstuvwxyzab\".chars().collect();\n    let mut message:\
    \ Vec<char> = vec![' '; v.len()];\n    for i in 0..v.len() {\n        for j in\
    \ 0..alpha.len() {\n            if v[i] == alpha[j] {\n                message[i]\
    \ = new_alpha[j];\n            }\n        }\n    }\n    let s: String = message.into_iter().collect();\n\
    \    s\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpvj7o3h0m.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822739
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut str = s.clone();\n    str.chars().map(|c| {\n        if c.is_alphabetic()\
    \ {\n            let base = if c.is_uppercase() { 65 } else { 97 };\n        \
    \    let char = c as i32;\n            char + (char - base + 2) * 2\n        }\
    \ else {\n            c as i32\n        } as u8 as char\n    }).collect()\n}\n\
    \nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `as`\n  --> /tmp/tmpjljwrvht.rs:15:11\n\
    \   |\n15 |         } as u8 as char\n   |           ^^ expected expression\n \
    \  |\nhelp: parentheses are required to parse this as an expression\n   |\n9 \
    \ ~         (if c.is_alphabetic() {\n10 |             let base = if c.is_uppercase()\
    \ { 65 } else { 97 };\n11 |             let char = c as i32;\n12 |           \
    \  char + (char - base + 2) * 2\n13 |         } else {\n14 |             c as\
    \ i32\n ...\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659822739
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    return s.chars().map(|c| {\n        if c == ' ' {\n            return\
    \ c;\n        }\n        let index = (c as u8) - 65;\n        let index = (index\
    \ + 2 * 2) % 26;\n        (index + 65) as char\n    }).collect();\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"RS\"`,\n right: `\"lm\"`', /tmp/tmp9jg6fy0s.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822739
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    s.chars().map(|x| if x >= 'a' && x <= 'z' {\n        ((x as u8 - b'a'\
    \ + 2 * 2) % 26 + b'a') as char\n    } else if x >= 'A' && x <= 'Z' {\n      \
    \  ((x as u8 - b'A' + 2 * 2) % 26 + b'A') as char\n    } else {\n        x\n \
    \   }).collect()\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822739
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut encrypted_str = String::new();\n    for c in s.chars() {\n  \
    \      encrypted_str.push(if c.is_lowercase() {\n            (((c as u8) - 97\
    \ + 4) % 26 + 97) as char\n        } else {\n            (((c as u8) - 65 + 4)\
    \ % 26 + 65) as char\n        });\n    }\n    encrypted_str\n}\n\nfn main() {\n\
    \    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822739
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    s.chars().map(|c| {\n        // gets the ascii index of the character\n\
    \        let idx = c as u8;\n\n        // check if it's an alphabet and return\
    \ the encrypted char\n        if (idx >= 65 && idx <= 90) || (idx >= 97 && idx\
    \ <= 122) {\n            (((idx - 2) % 26) + 2) as char\n        } else {\n  \
    \          c\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\u{1a}\\u{1b}\"`,\n right: `\"lm\"`', /tmp/tmp2gmsc8il.rs:22:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822739
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n    s.chars().map(|x|\
    \ {\n        let mut cur_index = alphabet.find(x).unwrap();\n        cur_index\
    \ += cur_index * 2;\n        alphabet.chars().nth(cur_index).unwrap()\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"vy\"`,\n right: `\"lm\"`', /tmp/tmpivr1m5en.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822740
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n\t//..\n\tlet mut res: String = String::new();\n\tfor c in s.chars() {\n\t\
    \tlet n = (c as u8) + 3;\n\t\tres.push(n as char);\n\t}\n\tres\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"kl\"`,\n right: `\"lm\"`', /tmp/tmp30btacxu.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822740
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let alphabet: Vec<char> = \"abcdefghijklmnopqrstuvwxyz\".chars().collect();\n\
    \    let mut rotated_alphabet: Vec<char> = alphabet.clone();\n    rotated_alphabet.rotate_right(2\
    \ * 2);\n    s.chars().map(|c| match alphabet.iter().position(|x| x == &c) {\n\
    \        Some(x) => rotated_alphabet[x],\n        None => c\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"de\"`,\n right: `\"lm\"`', /tmp/tmp2_kc02yu.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822740
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    for x in s.chars(){\n        let i = x as u8;\n        println!(\"{}\"\
    , i)\n    }\n    \"abcd\".to_string()\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"abcd\"`,\n right: `\"lm\"`', /tmp/tmp_j5wjx33.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: '104

    105

    '
  timestamp: 1659822740
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut out = String::new();\n    for ch in s.chars() {\n        out.push(\n\
    \            match ch {\n                'a'...'w' => ch.clone() + 2,\n      \
    \          'x' | 'y' | 'z' => (ch.clone() - 24) + 2,\n                _ => ch.clone(),\n\
    \            }\n        );\n    }\n    out\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "warning: `...` range patterns are deprecated\n  --> /tmp/tmp5n1gx6i2.rs:11:20\n\
    \   |\n11 |                 'a'...'w' => ch.clone() + 2,\n   |               \
    \     ^^^ help: use `..=` for an inclusive range\n   |\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]`\
    \ on by default\n   = warning: this is accepted in the current edition (Rust 2015)\
    \ but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nerror[E0369]: cannot add `{integer}` to `char`\n  --> /tmp/tmp5n1gx6i2.rs:11:41\n\
    \   |\n11 |                 'a'...'w' => ch.clone() + 2,\n   |               \
    \               ---------- ^ - {integer}\n   |                              |\n\
    \   |                              char\n\nerror[E0369]: cannot subtract `{integer}`\
    \ from `char`\n  --> /tmp/tmp5n1gx6i2.rs:12:48\n   |\n12 |                 'x'\
    \ | 'y' | 'z' => (ch.clone() - 24) + 2,\n   |                                \
    \     ---------- ^ -- {integer}\n   |                                     |\n\
    \   |                                     char\n\nerror: aborting due to 2 previous\
    \ errors; 1 warning emitted\n\nFor more information about this error, try `rustc\
    \ --explain E0369`.\n"
  stdout: ''
  timestamp: 1659822739
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut encrypted_string = String::new();\n    for letter in s.chars()\
    \ {\n        let mut encrypted_letter = letter as u8;\n        if encrypted_letter\
    \ >= 65 && encrypted_letter <= 90 {\n            encrypted_letter = encrypted_letter\
    \ + 2 * 2;\n            if encrypted_letter > 90 {\n                encrypted_letter\
    \ = encrypted_letter - 90 + 64;\n            }\n        } else if encrypted_letter\
    \ >= 97 && encrypted_letter <= 122 {\n            encrypted_letter = encrypted_letter\
    \ + 2 * 2;\n            if encrypted_letter > 122 {\n                encrypted_letter\
    \ = encrypted_letter - 122 + 96;\n            }\n        }\n        encrypted_string.push(encrypted_letter\
    \ as char);\n    }\n    encrypted_string\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822740
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut result = String::new();\n    for c in s.chars() {\n        result.push((c\
    \ as u8 + 4) as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpjr8echrq.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822740
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let alphabet = vec!['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',\
    \ 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n\
    \    let shifted_alphabet = vec!['c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',\
    \ 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'a',\
    \ 'b'];\n    let mut new_string = String::new();\n    for c in s.chars() {\n \
    \       for i in 0..alphabet.len() {\n            if c == alphabet[i] {\n    \
    \            new_string.push(shifted_alphabet[i]);\n            }\n        }\n\
    \    }\n    new_string\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpbc1c4iio.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822740
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let map = rotate(ALPHABET.to_string(), 2 * 2);\n    s.chars().map(|c|\
    \ map[&c]).collect()\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `rotate` in this scope\n --> /tmp/tmpq8bfce8j.rs:7:15\n\
    \  |\n7 |     let map = rotate(ALPHABET.to_string(), 2 * 2);\n  |            \
    \   ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `ALPHABET`\
    \ in this scope\n --> /tmp/tmpq8bfce8j.rs:7:22\n  |\n7 |     let map = rotate(ALPHABET.to_string(),\
    \ 2 * 2);\n  |                      ^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822739
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n\tlet mut encrypted = String::new();\n\tlet mut i = 1;\n\tlet mut alphabet\
    \ = vec!['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',\
    \ 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n\tlet mut alphabet2\
    \ = vec!['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',\
    \ 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n\tfor ch in s.chars()\
    \ {\n\t\tif ch == ' ' {\n\t\t\tencrypted.push(ch);\n\t\t} else {\n\t\t\tlet index\
    \ = alphabet.iter().position(|&r| r == ch).unwrap();\n\t\t\tencrypted.push(alphabet2[index]);\n\
    \t\t\talphabet2.rotate_left(2*i);\n\t\t\ti += 1;\n\t\t}\n\t}\n\tencrypted\n}\n\
    \nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hk\"`,\n right: `\"lm\"`', /tmp/tmp1k7byj5v.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822740
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut letters = s.chars();\n    let mut alphabet: Vec<char> = (97..123).map(|x|\
    \ x as u8 as char).collect();\n    let mut new_string = String::new();\n    loop\
    \ {\n        let letter = letters.next();\n        if letter == None {\n     \
    \       break;\n        } else {\n            let mut index = 0;\n           \
    \ for (i, &c) in alphabet.iter().enumerate() {\n                if c == letter.unwrap()\
    \ {\n                    index = i;\n                    break;\n            \
    \    }\n            }\n            let new_char = match index {\n            \
    \    0 => 100,\n                1 => 101,\n                2...25 => index + 2,\n\
    \                _ => -1,\n            };\n            new_string.push(alphabet[new_char\
    \ as usize]);\n        }\n    }\n    new_string\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "warning: `...` range patterns are deprecated\n  --> /tmp/tmpz26le6np.rs:25:18\n\
    \   |\n25 |                 2...25 => index + 2,\n   |                  ^^^ help:\
    \ use `..=` for an inclusive range\n   |\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]`\
    \ on by default\n   = warning: this is accepted in the current edition (Rust 2015)\
    \ but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpz26le6np.rs:26:22\n\
    \   |\n26 |                 _ => -1,\n   |                      ^^ the trait `Neg`\
    \ is not implemented for `usize`\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822739
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    s.chars().map(|c| {\n        if c.is_alphabetic() {\n            let\
    \ n = (c as u8) + 2;\n            (((n as i32) - 97) % 26 + 97) as u8 as char\n\
    \        } else {\n            c\n        }\n    }).collect()\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpb4pb7ibp.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822740
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut v: Vec<char> = s.chars().collect();\n    let new_v: Vec<String>\
    \ = v.iter().map(|c| get_cipher(*c)).collect();\n    new_v.join(\"\")\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_cipher` in this scope\n --> /tmp/tmp3l_4y7mi.rs:8:47\n\
    \  |\n8 |     let new_v: Vec<String> = v.iter().map(|c| get_cipher(*c)).collect();\n\
    \  |                                               ^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822739
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    s.chars().map(|c| {\n        // Calculate the shift\n        let shift\
    \ = (((c as u8 - 97) + 2) * 2) % 26;\n        // Add the shift to the character\n\
    \        (c as u8 + shift) as char\n    }).collect()\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"z}\"`,\n right: `\"lm\"`', /tmp/tmp0kuk8v83.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822740
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut r: Vec<char> = s.chars().collect();\n    for i in 0..r.len()\
    \ {\n        r[i] = (r[i] as u8 + 2*2) as char;\n    }\n    r.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpgw3_gjp9.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822740
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    // Encrypt the string.\n    let vec: Vec<char> = s.chars().collect();\n\
    \    let mut result = String::new();\n    for i in 0..vec.len() {\n        let\
    \ mut new_char = vec[i] as u8;\n        let is_lowercase = new_char >= 97 && new_char\
    \ <= 122;\n        let is_uppercase = new_char >= 65 && new_char <= 90;\n    \
    \    if is_lowercase {\n            new_char += 2;\n            if new_char >\
    \ 122 {\n                new_char -= 26;\n            }\n        } else if is_uppercase\
    \ {\n            new_char += 2;\n            if new_char > 90 {\n            \
    \    new_char -= 26;\n            }\n        }\n        result.push(new_char as\
    \ char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpcfsvkxp_.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822740
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut string = s.clone();\n    // Create a vector of the string with\
    \ chars\n    let mut new_string: Vec<char> = string.chars().collect();\n    for\
    \ c in new_string.iter_mut() {\n        // ASCII 65-90 is capital letters\n  \
    \      if *c as u8 >= 65 && *c as u8 <= 90 {\n            *c = (((*c as u8 - 65)\
    \ + 2) % 26 + 65) as char;\n        }\n        // ASCII 97-122 is lowercase letters\n\
    \        else if *c as u8 >= 97 && *c as u8 <= 122 {\n            *c = (((*c as\
    \ u8 - 97) + 2) % 26 + 97) as char;\n        }\n    }\n    // Now we have a vector\
    \ of chars, so lets concatenate it\n    string = new_string.into_iter().collect();\n\
    \    string\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpok3i81to.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822740
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut result = String::new();\n    for letter in s.chars() {\n    \
    \    if !letter.is_alphabetic() {\n            result.push(letter);\n        \
    \    continue;\n        }\n        let alpha_offset = match letter.is_uppercase()\
    \ {\n            true => 65,\n            false => 97,\n        };\n        let\
    \ new_val = letter as u8 + 4;\n        if new_val > alpha_offset + 25 {\n    \
    \        result.push((new_val - 26) as char);\n        } else {\n            result.push(new_val\
    \ as char);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822740
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    // map over the string and get an iterator of chars\n    // find the\
    \ position of those chars in the alphabet and add 2\n    // then map the resulting\
    \ positions to a new iterator of chars\n    s.chars().map(|x| ((x as u8 - 97 +\
    \ 2 * 2) % 26 + 97) as char).collect()\n}\n\nfn main() {\n    let candidate =\
    \ encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"\
    ));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"ewhjklnop\"\
    ));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"kj\"));\n\
    \    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"\
    faewfawefaewg\")), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822740
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut result = String::new();\n    let mut counter = 0;\n    for i\
    \ in s.chars() {\n        if i == ' ' {\n            result.push(' ');\n     \
    \   } else {\n            let mut number = (i as u8) + 2 * counter as u8;\n  \
    \          while number > 122 {\n                number -= 26;\n            }\n\
    \            result.push(std::char::from_u32(number as u32).unwrap());\n     \
    \       counter += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hk\"`,\n right: `\"lm\"`', /tmp/tmpy2sre1mr.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822740
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    const ALPHABET: &str = \"abcdefghijklmnopqrstuvwxyz\";\n    let mut encrypted_string\
    \ = String::new();\n    for c in s.chars() {\n        let encrypted_char = match\
    \ c {\n            'a'...'z' => {\n                let index = match ALPHABET.find(c)\
    \ {\n                    Some(i) => i,\n                    None => panic!(\"\
    Did not find c in alphabet\"),\n                };\n                let new_index\
    \ = index + 2 * 2;\n                if new_index < ALPHABET.len() {\n        \
    \            ALPHABET.chars().nth(new_index).unwrap()\n                } else\
    \ {\n                    ALPHABET.chars().nth(new_index - ALPHABET.len()).unwrap()\n\
    \                }\n            },\n            'A'...'Z' => {\n             \
    \   let index = match ALPHABET.find(c.to_ascii_lowercase()) {\n              \
    \      Some(i) => i,\n                    None => panic!(\"Did not find c in alphabet\"\
    ),\n                };\n                let new_index = index + 2 * 2;\n     \
    \           if new_index < ALPHABET.len() {\n                    ALPHABET.chars().nth(new_index).unwrap().to_ascii_uppercase()\n\
    \                } else {\n                    ALPHABET.chars().nth(new_index\
    \ - ALPHABET.len()).unwrap().to_ascii_uppercase()\n                }\n       \
    \     },\n            _ => c,\n        };\n        encrypted_string.push(encrypted_char);\n\
    \    }\n    encrypted_string\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822740
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n  s.into_bytes().iter().map(|&c| (c as u8 + 2) as char).collect()\n}\n\n\
    fn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmplv67vdfo.rs:12:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822740
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let chars: Vec<char> = s.chars().collect();\n    let mut result = String::new();\n\
    \    for ch in chars {\n        if ch.is_alphabetic() {\n            let i = ((ch\
    \ as u8) - ('a' as u8)) as i32;\n            let n = (i + 2) % 26;\n         \
    \   result.push((n as u8 + ('a' as u8)) as char);\n        } else {\n        \
    \    result.push(ch);\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpg4bjbc8i.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822740
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    /// for loop to iterate over the input string\n    for c in s.chars()\
    \ {\n        /// if the character is an alphabet\n        if c.is_alphabetic()\
    \ {\n            /// return the character shifted by 2\n            return c.shift_forward(2);\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "warning: unused doc comment\n  --> /tmp/tmpaau7zcl7.rs:7:5\n   |\n7  |\
    \       /// for loop to iterate over the input string\n   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    8  | /     for c in s.chars() {\n9  | |         /// if the character is an alphabet\n\
    10 | |         if c.is_alphabetic() {\n11 | |             /// return the character\
    \ shifted by 2\n12 | |             return c.shift_forward(2);\n13 | |        \
    \ }\n14 | |     }\n   | |_____- rustdoc does not generate documentation for expressions\n\
    \   |\n   = note: `#[warn(unused_doc_comments)]` on by default\n   = help: use\
    \ `//` for a plain comment\n\nwarning: unused doc comment\n  --> /tmp/tmpaau7zcl7.rs:9:9\n\
    \   |\n9  |           /// if the character is an alphabet\n   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    10 | /         if c.is_alphabetic() {\n11 | |             /// return the character\
    \ shifted by 2\n12 | |             return c.shift_forward(2);\n13 | |        \
    \ }\n   | |_________- rustdoc does not generate documentation for expressions\n\
    \   |\n   = help: use `//` for a plain comment\n\nwarning: unused doc comment\n\
    \  --> /tmp/tmpaau7zcl7.rs:11:13\n   |\n11 |             /// return the character\
    \ shifted by 2\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n12 | \
    \            return c.shift_forward(2);\n   |             -------------------------\
    \ rustdoc does not generate documentation for expressions\n   |\n   = help: use\
    \ `//` for a plain comment\n\nerror[E0599]: no method named `shift_forward` found\
    \ for type `char` in the current scope\n  --> /tmp/tmpaau7zcl7.rs:12:22\n   |\n\
    12 |             return c.shift_forward(2);\n   |                      ^^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpaau7zcl7.rs:8:5\n\
    \   |\n6  |   fn encrypt(s: String) -> String {\n   |                        \
    \    ------ expected `String` because of return type\n7  |       /// for loop\
    \ to iterate over the input string\n8  | /     for c in s.chars() {\n9  | |  \
    \       /// if the character is an alphabet\n10 | |         if c.is_alphabetic()\
    \ {\n11 | |             /// return the cha"
  stdout: ''
  timestamp: 1659822740
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut new_string = String::new();\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    ;\n    for i in s.chars() {\n        if alphabet.contains(i) {\n            let\
    \ mut new_index = alphabet.find(i).unwrap() + 4;\n            if new_index > 25\
    \ {\n                new_index -= 26;\n            }\n            new_string.push(alphabet.chars().nth(new_index).unwrap());\n\
    \        } else {\n            new_string.push(i);\n        }\n    }\n    new_string\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822740
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    s.chars().map(|c| {\n        match c {\n            'a' | 'A' => 'C',\n\
    \            'b' | 'B' => 'D',\n            'c' | 'C' => 'E',\n            'd'\
    \ | 'D' => 'F',\n            'e' | 'E' => 'G',\n            'f' | 'F' => 'H',\n\
    \            'g' | 'G' => 'I',\n            'h' | 'H' => 'J',\n            'i'\
    \ | 'I' => 'K',\n            'j' | 'J' => 'L',\n            'k' | 'K' => 'M',\n\
    \            'l' | 'L' => 'N',\n            'm' | 'M' => 'O',\n            'n'\
    \ | 'N' => 'P',\n            'o' | 'O' => 'Q',\n            'p' | 'P' => 'R',\n\
    \            'q' | 'Q' => 'S',\n            'r' | 'R' => 'T',\n            's'\
    \ | 'S' => 'U',\n            't' | 'T' => 'V',\n            'u' | 'U' => 'W',\n\
    \            'v' | 'V' => 'X',\n            'w' | 'W' => 'Y',\n            'x'\
    \ | 'X' => 'Z',\n            'y' | 'Y' => 'A',\n            'z' | 'Z' => 'B',\n\
    \            _ => c,\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"JK\"`,\n right: `\"lm\"`', /tmp/tmpq9scas85.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822740
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut new_string = String::new();\n    for c in s.chars() {\n     \
    \   let c = if c.is_ascii_lowercase() {\n            (((c as u8 - b'a' + 2) %\
    \ 26) + b'a') as char\n        } else if c.is_ascii_uppercase() {\n          \
    \  (((c as u8 - b'A' + 2) % 26) + b'A') as char\n        } else {\n          \
    \  c\n        };\n        new_string.push(c);\n    }\n    new_string\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpc_ty7n93.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822740
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    return s.chars().map(|c| (if c.is_alphabetic() {\n        match c {\n\
    \            'A' | 'a' => 'C',\n            'B' | 'b' => 'D',\n            'C'\
    \ | 'c' => 'E',\n            'D' | 'd' => 'F',\n            'E' | 'e' => 'G',\n\
    \            'F' | 'f' => 'H',\n            'G' | 'g' => 'I',\n            'H'\
    \ | 'h' => 'J',\n            'I' | 'i' => 'K',\n            'J' | 'j' => 'L',\n\
    \            'K' | 'k' => 'M',\n            'L' | 'l' => 'N',\n            'M'\
    \ | 'm' => 'O',\n            'N' | 'n' => 'P',\n            'O' | 'o' => 'Q',\n\
    \            'P' | 'p' => 'R',\n            'Q' | 'q' => 'S',\n            'R'\
    \ | 'r' => 'T',\n            'S' | 's' => 'U',\n            'T' | 't' => 'V',\n\
    \            'U' | 'u' => 'W',\n            'V' | 'v' => 'X',\n            'W'\
    \ | 'w' => 'Y',\n            'X' | 'x' => 'Z',\n            'Y' | 'y' => 'A',\n\
    \            'Z' | 'z' => 'B',\n            _ => panic!(\"It isn't alphabetic!\"\
    ),\n        }\n    } else {\n        c\n    }).to_string()).collect::<String>();\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"JK\"`,\n right: `\"lm\"`', /tmp/tmp2issvm9r.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822740
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    s.chars().map(|x| match x {\n            'a' => 'c',\n            'b'\
    \ => 'd',\n            'c' => 'e',\n            'd' => 'f',\n            'e' =>\
    \ 'g',\n            'f' => 'h',\n            'g' => 'i',\n            'h' => 'j',\n\
    \            'i' => 'k',\n            'j' => 'l',\n            'k' => 'm',\n \
    \           'l' => 'n',\n            'm' => 'o',\n            'n' => 'p',\n  \
    \          'o' => 'q',\n            'p' => 'r',\n            'q' => 's',\n   \
    \         'r' => 't',\n            's' => 'u',\n            't' => 'v',\n    \
    \        'u' => 'w',\n            'v' => 'x',\n            'w' => 'y',\n     \
    \       'x' => 'z',\n            'y' => 'a',\n            'z' => 'b',\n      \
    \      _ => x,\n        }).collect()\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpqe5aicd2.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822740
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let alphabet = vec!['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',\
    \ 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n\
    \    let mut e = vec![];\n    for c in s.chars() {\n        let index = alphabet.iter().position(|&r|\
    \ r == c).unwrap();\n        if index > 22 {\n            e.push(alphabet[index-22]);\n\
    \        } else {\n            e.push(alphabet[index+4]);\n        }\n    }\n\
    \    e.into_iter().collect()\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 26 but the
    index is 26'', /tmp/tmp6k4fd4nw.rs:14:20

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822740
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let rot = |c: char| match c {\n        'a'...'y' => ((c as u8) + 2) as\
    \ char,\n        'z' => 'a',\n        ' ' => ' ',\n        _ => ((c as u8) + 1)\
    \ as char,\n    };\n    s.chars().map(rot).collect()\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpyxb91lo4.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822740
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    s.chars().map(|c| {\n        let offset = \n            if (c as u8)\
    \ < 97 + 2 { 26 } else { 0 };\n        ((c as u8) + (4 as u8) - (97 as u8) + offset)\
    \ as char\n    }).collect()\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\u{b}\\u{c}\"`,\n right: `\"lm\"`', /tmp/tmp1z_4zci9.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822740
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut ret: Vec<u8> = vec![];\n    let a = b'a';\n    let mut l = s.to_lowercase().into_bytes();\n\
    \    for i in 0..l.len() {\n        ret.push(a + (((l[i] - a) * 2 + 2) % 26));\n\
    \    }\n    String::from_utf8(ret).unwrap()\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"qs\"`,\n right: `\"lm\"`', /tmp/tmp_wge6pd0.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822740
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut res = String::new();\n    for c in s.chars() {\n        if c.is_ascii_alphabetic()\
    \ {\n            let c_ = match c {\n                'A'..='M' | 'a'..='m' =>\
    \ (c as u8 + 2) as char,\n                'N'..='Z' | 'n'..='z' => (c as u8 -\
    \ 24) as char,\n                _ => c,\n            };\n            res.push(c_);\n\
    \        } else {\n            res.push(c);\n        }\n    }\n    res\n}\n\n\
    fn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpyzzocb3a.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822740
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut res = String::new();\n    for c in s.chars() {\n        if c.is_uppercase()\
    \ {\n            res.push(((((c as u8) - b'A') + 2) % 26 + b'A') as char);\n \
    \       } else if c.is_lowercase() {\n            res.push(((((c as u8) - b'a')\
    \ + 2) % 26 + b'a') as char);\n        } else {\n            res.push(c);\n  \
    \      }\n    }\n    res\n}\n\nfn main() {\n    let candidate = encrypt;\n   \
    \ assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpr5df7vv4.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822740
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut result = String::new();\n    for c in s.chars() {\n        let\
    \ c_num = c as u8;\n        let c_char = ((c_num - 97) * 2 + 97) as char;\n  \
    \      result.push(c_char);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"oq\"`,\n right: `\"lm\"`', /tmp/tmpdl90bc1o.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822740
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let alphabet = vec!['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',\
    \ 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n\
    \    let mut encr = \"\".to_string();\n    let mut index: usize = 0;\n    for\
    \ c in s.chars() {\n        for (i, a) in alphabet.iter().enumerate() {\n    \
    \        if c == *a {\n                index = i;\n                break;\n  \
    \          }\n        }\n        let l = alphabet[(index+2)%26];\n        encr.push(l);\n\
    \    }\n    encr\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpi4yoqzwe.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822740
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    s.chars().map(|c| {\n        if c.is_alphabetic() {\n            let\
    \ mut c = c.to_ascii_lowercase();\n            c = (c as u8 + 4) as char;\n  \
    \          if c > 'z' {\n                c = (c as u8 - 'z' as u8 + 'a' as u8\
    \ - 1) as char;\n            }\n            c\n        } else {\n            c\n\
    \        }\n    }).collect()\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822740
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut res = String::new();\n    for x in s.chars() {\n        if x\
    \ == 'y' {\n            res.push('a');\n        } else if x == 'z' {\n       \
    \     res.push('b');\n        } else {\n            res.push((x as u8 + 2) as\
    \ char);\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpeb0u2pqo.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822740
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let letters: Vec<_> = s.chars().collect();\n    let mut res = Vec::new();\n\
    \    for c in letters {\n        res.push(rotate_char(c));\n    }\n    res.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `rotate_char` in this scope\n  --> /tmp/tmpqc_jsu92.rs:10:18\n\
    \   |\n10 |         res.push(rotate_char(c));\n   |                  ^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822740
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let len = s.len();\n    let mut ret_str = String::new();\n    for c in\
    \ s.chars() {\n        let ascii = c as u8;\n        if ascii >= 97 && ascii <=\
    \ 122 {\n            let ascii_ret = ascii + (2 * 2);\n            if ascii_ret\
    \ > 122 {\n                let mut new_ascii = ascii_ret - 122;\n            \
    \    new_ascii += 96;\n                ret_str.push(new_ascii as char);\n    \
    \        } else {\n                ret_str.push(ascii_ret as char);\n        \
    \    }\n        } else if ascii >= 65 && ascii <= 90 {\n            let ascii_ret\
    \ = ascii + (2 * 2);\n            if ascii_ret > 90 {\n                let mut\
    \ new_ascii = ascii_ret - 90;\n                new_ascii += 64;\n            \
    \    ret_str.push(new_ascii as char);\n            } else {\n                ret_str.push(ascii_ret\
    \ as char);\n            }\n        } else {\n            ret_str.push(c);\n \
    \       }\n    }\n    ret_str\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822740
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut ret: Vec<char> = Vec::new();\n    for c in s.chars() {\n    \
    \    ret.push(get_char_rotated(c));\n    }\n    ret.into_iter().collect()\n}\n\
    \nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_char_rotated` in this scope\n -->\
    \ /tmp/tmphcrw4o4v.rs:9:18\n  |\n9 |         ret.push(get_char_rotated(c));\n\
    \  |                  ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659822740
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut result = String::new();\n    let alphabet: Vec<char> = (b'a'..b'z'\
    \ + 1).map(|c| c as char).collect();\n    for c in s.chars() {\n        if c.is_alphabetic()\
    \ {\n            let index = alphabet.iter().position(|&x| x == c.to_lowercase().next().unwrap()).unwrap();\n\
    \            let new_index = if index + 13 < alphabet.len() { index + 13 } else\
    \ { index - 13 };\n            let new_char = alphabet[new_index];\n         \
    \   result.push(new_char);\n        } else {\n            result.push(c);\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"uv\"`,\n right: `\"lm\"`', /tmp/tmp4l99yea1.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822740
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    return s.chars().map(|c| {\n        if c.is_lowercase() {\n         \
    \   let mut sc = c as u8 + 2;\n            if sc > 122 {\n                sc =\
    \ 96 + (sc - 122);\n            }\n            return sc as char;\n        } else\
    \ if c.is_uppercase() {\n            let mut sc = c as u8 + 2;\n            if\
    \ sc > 90 {\n                sc = 64 + (sc - 90);\n            }\n           \
    \ return sc as char;\n        } else {\n            return c;\n        }\n   \
    \ }).collect();\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmp2me1c89a.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822740
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut cs = s.into_bytes();\n    for c in cs.iter_mut() {\n        *c\
    \ = c.wrapping_add(2).wrapping_mul(2);\n    }\n    String::from_utf8(cs).unwrap()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Result::unwrap()` on an `Err` value:
    FromUtf8Error { bytes: [212, 214], error: Utf8Error { valid_up_to: 0, error_len:
    Some(1) } }'', /tmp/tmp57v4emmt.rs:11:27

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822740
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n\t// create a vector of the alphabet\n\tlet alphabet: Vec<char> = vec!['a',\
    \ 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q',\
    \ 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n\t// create a vector of the string\n\
    \tlet v: Vec<char> = s.chars().collect();\n\t// create a new string to copy the\
    \ encrypted string into\n\tlet mut e = String::new();\n\t// iterate through the\
    \ string vector\n\tfor i in 0..v.len() {\n\t\t// if the character is in the alphabet\n\
    \t\tif alphabet.contains(&v[i]) {\n\t\t\t// find the index of the letter in the\
    \ alphabet\n\t\t\tlet index = alphabet.iter().position(|&r| r == v[i]).unwrap();\n\
    \t\t\t// shift the letter down by 2, store it in a variable\n\t\t\tlet letter\
    \ = match index + 2 {\n\t\t\t\t26 | 27 => 'a',\n\t\t\t\t28 | 29 => 'b',\n\t\t\t\
    \t30 | 31 => 'c',\n\t\t\t\t32 | 33 => 'd',\n\t\t\t\t34 | 35 => 'e',\n\t\t\t\t\
    36 | 37 => 'f',\n\t\t\t\t38 | 39 => 'g',\n\t\t\t\t40 | 41 => 'h',\n\t\t\t\t42\
    \ | 43 => 'i',\n\t\t\t\t44 | 45 => 'j',\n\t\t\t\t46 | 47 => 'k',\n\t\t\t\t48 |\
    \ 49 => 'l',\n\t\t\t\t50 | 51 => 'm',\n\t\t\t\t52 | 53 => 'n',\n\t\t\t\t54 | 55\
    \ => 'o',\n\t\t\t\t56 | 57 => 'p',\n\t\t\t\t58 | 59 => 'q',\n\t\t\t\t60 | 61 =>\
    \ 'r',\n\t\t\t\t62 | 63 => 's',\n\t\t\t\t64 | 65 => 't',\n\t\t\t\t66 | 67\n}\n\
    \nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmptrq03ep0.rs:54:3\n\
    \   |\n6  | fn encrypt(s: String) -> String {\n   |                          \
    \       - unclosed delimiter\n...\n14 |     for i in 0..v.len() {\n   |      \
    \                   - unclosed delimiter\n15 |         // if the character is\
    \ in the alphabet\n16 |         if alphabet.contains(&v[i]) {\n   |          \
    \                           - unclosed delimiter\n...\n20 |             let letter\
    \ = match index + 2 {\n   |                                          - this delimiter\
    \ might not be properly closed...\n...\n42 | }\n   | - ...as it matches this but\
    \ it has different indentation\n...\n54 | }\n   |   ^\n\nerror: expected one of\
    \ `...`, `..=`, `..`, `=>`, `if`, or `|`, found `}`\n  --> /tmp/tmptrq03ep0.rs:42:1\n\
    \   |\n41 |                 66 | 67\n   |                        - expected one\
    \ of `...`, `..=`, `..`, `=>`, `if`, or `|`\n42 | }\n   | ^ unexpected token\n\
    \nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found keyword\
    \ `fn`\n  --> /tmp/tmptrq03ep0.rs:44:1\n   |\n42 | }\n   |  - expected one of\
    \ `.`, `;`, `?`, `else`, or an operator\n43 | \n44 | fn main() {\n   | ^^ unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptrq03ep0.rs:14:2\n  \
    \ |\n6  |   fn encrypt(s: String) -> String {\n   |                          \
    \  ------ expected `String` because of return type\n...\n14 | /     for i in 0..v.len()\
    \ {\n15 | |         // if the character is in the alphabet\n16 | |         if\
    \ alphabet.contains(&v[i]) {\n17 | |             // find the index of the letter\
    \ in the alphabet\n...  |\n53 | |     assert_eq!(candidate(String::from(\"a\"\
    )), String::from(\"e\"));\n54 | | }\n   | |__^ expected struct `String`, found\
    \ `()`\n\nerror: aborting due to 4 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659822740
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut new_string = String::new();\n    for ch in s.chars() {\n    \
    \    let i = match ch {\n            'a' => 'c',\n            'b' => 'd',\n  \
    \          'c' => 'e',\n            'd' => 'f',\n            'e' => 'g',\n   \
    \         'f' => 'h',\n            'g' => 'i',\n            'h' => 'j',\n    \
    \        'i' => 'k',\n            'j' => 'l',\n            'k' => 'm',\n     \
    \       'l' => 'n',\n            'm' => 'o',\n            'n' => 'p',\n      \
    \      'o' => 'q',\n            'p' => 'r',\n            'q' => 's',\n       \
    \     'r' => 't',\n            's' => 'u',\n            't' => 'v',\n        \
    \    'u' => 'w',\n            'v' => 'x',\n            'w' => 'y',\n         \
    \   'x' => 'z',\n            'y' => 'a',\n            'z' => 'b',\n          \
    \  _ => ch,\n        };\n        new_string.push(i);\n    }\n    new_string\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpnj4nr3o9.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822740
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let v: Vec<char> = s.chars().collect();\n    let mut res = String::new();\n\
    \    for i in 0..v.len() {\n        if v[i] as u8 >= 65 && v[i] as u8 <= 90 {\n\
    \            let n: u8 = v[i] as u8 + (65 - 65 - 2) * 2;\n            let c: char\
    \ = n as char;\n            res.push(c);\n        } else if v[i] as u8 >= 97 &&\
    \ v[i] as u8 <= 122 {\n            let n: u8 = v[i] as u8 + (97 - 97 - 2) * 2;\n\
    \            let c: char = n as char;\n            res.push(c);\n        } else\
    \ {\n            res.push(v[i]);\n        }\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: this arithmetic operation will overflow\n  --> /tmp/tmpvkdbesip.rs:11:38\n\
    \   |\n11 |             let n: u8 = v[i] as u8 + (65 - 65 - 2) * 2;\n   |    \
    \                                  ^^^^^^^^^^^^^ attempt to compute `0_u8 - 2_u8`,\
    \ which would overflow\n   |\n   = note: `#[deny(arithmetic_overflow)]` on by\
    \ default\n\nerror: this arithmetic operation will overflow\n  --> /tmp/tmpvkdbesip.rs:15:38\n\
    \   |\n15 |             let n: u8 = v[i] as u8 + (97 - 97 - 2) * 2;\n   |    \
    \                                  ^^^^^^^^^^^^^ attempt to compute `0_u8 - 2_u8`,\
    \ which would overflow\n\nerror: aborting due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1659822740
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let lower_alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n    let mut lower_alphabet_index\
    \ = 0;\n    let mut rotated_lower_alphabet = \"cdefghijklmnopqrstuvwxyzab\";\n\
    \    let mut rotated_lower_alphabet_index = 0;\n    let mut encrypted_string =\
    \ String::new();\n    for ch in s.chars() {\n        if (ch.is_alphabetic()) {\n\
    \            if (ch.is_lowercase()) {\n                while lower_alphabet.chars().nth(lower_alphabet_index)\
    \ != Some(ch) {\n                    lower_alphabet_index += 1;\n            \
    \    }\n                encrypted_string.push(rotated_lower_alphabet.chars().nth(rotated_lower_alphabet_index).unwrap());\n\
    \                rotated_lower_alphabet_index += 1;\n                lower_alphabet_index\
    \ += 1;\n            } else {\n                encrypted_string.push(ch);\n  \
    \          }\n        } else {\n            encrypted_string.push(ch);\n     \
    \   }\n    }\n    encrypted_string\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"cd\"`,\n right: `\"lm\"`', /tmp/tmpns_1342w.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822740
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n\tlet mut res = String::new();\n\tfor ch in s.chars() {\n\t\tlet ch = ch\
    \ as u8;\n\t\tlet new_ch = if ch >= 'a' as u8 && ch <= 'y' as u8 {\n\t\t\tch +\
    \ 2\n\t\t} else if ch == 'z' as u8 {\n\t\t\t'a' as u8\n\t\t} else if ch == 'Z'\
    \ as u8 {\n\t\t\t'A' as u8\n\t\t} else if ch >= 'A' as u8 && ch <= 'Y' as u8 {\n\
    \t\t\tch + 2\n\t\t} else {\n\t\t\tch\n\t\t};\n\t\tres.push(new_ch as char);\n\t\
    }\n\tres\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpfrn84iho.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822740
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n\tlet mut v: Vec<u8> = s.into_bytes();\n\tfor i in 0..v.len() {\n\t\tmatch\
    \ v[i] {\n\t\t\tb'A'...b'Y' => v[i] += 2,\n\t\t\tb'Z' => v[i] = b'A',\n\t\t\t\
    b'a'...b'y' => v[i] += 2,\n\t\t\tb'z' => v[i] = b'a',\n\t\t\t_ => {},\n\t\t}\n\
    \t}\n\tString::from_utf8(v).unwrap()\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpl3idndx2.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822740
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    s.chars().map(|c| match c {\n        'A'...'Z' => {\n            let\
    \ d = 'Z' as u8 - c as u8;\n            if d < 2 {\n                char::from(b'A'\
    \ + 2 - d)\n            } else {\n                char::from(c as u8 + 2)\n  \
    \          }\n        },\n        'a'...'z' => {\n            let d = 'z' as u8\
    \ - c as u8;\n            if d < 2 {\n                char::from(b'a' + 2 - d)\n\
    \            } else {\n                char::from(c as u8 + 2)\n            }\n\
    \        },\n        _ => c\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpy85w56gf.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822740
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n  let alphabet = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',\
    \ 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n\
    \  let mut v = Vec::new();\n  for i in s.chars() {\n    let mut x = i as u8;\n\
    \    x = (x + 4) as u8;\n    if x == 'z' as u8 + 1 {\n      x = x - 25;\n    }\
    \ else if x == 'z' as u8 + 2 {\n      x = x - 25;\n    } else if x == 'z' as u8\
    \ + 3 {\n      x = x - 25;\n    } else if x == 'z' as u8 + 4 {\n      x = x -\
    \ 25;\n    }\n    if x == 'y' as u8 + 1 {\n      x = x - 25;\n    } else if x\
    \ == 'y' as u8 + 2 {\n      x = x - 25;\n    } else if x == 'y' as u8 + 3 {\n\
    \      x = x - 25;\n    } else if x == 'y' as u8 + 4 {\n      x = x - 25;\n  \
    \  }\n    if x == 'x' as u8 + 1 {\n      x = x - 25;\n    } else if x == 'x' as\
    \ u8 + 2 {\n      x = x - 25;\n    } else if x == 'x' as u8 + 3 {\n      x = x\
    \ - 25;\n    } else if x == 'x' as u8 + 4 {\n      x = x - 25;\n    }\n    v.push(x\
    \ as char);\n  }\n  v.into_iter().collect()\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jeibjebijeibk\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmphvmhzohf.rs:50:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822740
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    // convert String to Vec<char>\n    let ch_vec: Vec<char> = s.chars().collect();\n\
    \    // create new Vec<char>\n    let mut new_ch_vec: Vec<char> = Vec::new();\n\
    \    // create a Vec<char> of the alphabet\n    let alphabet: Vec<char> = \"abcdefghijklmnopqrstuvwxyz\"\
    .chars().collect();\n    // iterate over each char in the Vec<char> input\n  \
    \  for ch in ch_vec {\n        // check if the char is uppercase\n        if ch.is_uppercase()\
    \ {\n            // get the index of the char in the alphabet\n            let\
    \ char_index = alphabet.iter().position(|&r| r == ch.to_lowercase().nth(0).unwrap()).unwrap();\n\
    \            // shift down the index by two multiplied to two places\n       \
    \     let new_char_index = (char_index + (2 * 2)) % 26;\n            // get the\
    \ new char, and push it to the new Vec<char>\n            new_ch_vec.push(alphabet[new_char_index].to_uppercase().nth(0).unwrap());\n\
    \        }\n        // check if the char is lowercase\n        else if ch.is_lowercase()\
    \ {\n            // get the index of the char in the alphabet\n            let\
    \ char_index = alphabet.iter().position(|&r| r == ch).unwrap();\n            //\
    \ shift down the index by two multiplied to two places\n            let new_char_index\
    \ = (char_index + (2 * 2)) % 26;\n            // get the new char, and push it\
    \ to the new Vec<char>\n            new_ch_vec.push(alphabet[new_char_index]);\n\
    \        }\n        // if not uppercase or lowercase push the char as is\n   \
    \     else {\n            new_ch_vec.push(ch);\n        }\n    }\n    // convert\
    \ the Vec<char> back to a String\n    let new_string: String = new_ch_vec.into_iter().collect();\n\
    \    // return the new string\n    new_string\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822740
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    // code here!\n    let mut result = String::new();\n    let alpha = ['a',\
    \ 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q',\
    \ 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n    for c in s.chars() {\n  \
    \      let mut ind = 0;\n        for i in 0..alpha.len() {\n            if c ==\
    \ alpha[i] {\n                ind = i;\n                break;\n            }\n\
    \        }\n        let diff = ind - 2;\n        if diff >= 0 {\n            result.push(alpha[diff])\n\
    \        } else {\n            result.push(alpha[alpha.len() + diff])\n      \
    \  }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"fg\"`,\n right: `\"lm\"`', /tmp/tmp8g5jq1fn.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822740
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut result = String::new();\n    for c in s.chars() {\n        result.push(rot_letter(c));\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `rot_letter` in this scope\n --> /tmp/tmp7p1bcwwi.rs:9:21\n\
    \  |\n9 |         result.push(rot_letter(c));\n  |                     ^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822740
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut new_string = String::new();\n    for letter in s.chars() {\n\
    \        if letter == ' ' {\n            new_string.push(letter);\n        } else\
    \ {\n            new_string.push(((letter as u8 + 2) as char));\n        }\n \
    \   }\n    new_string\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmp65jztpsx.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822740
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n  s.chars().map(|c| {\n    if c.is_alphabetic() {\n      let mut base = if\
    \ c.is_lowercase() { 'a' as u8 } else { 'A' as u8 };\n      base += (c as u8 -\
    \ base + 8) % 26;\n      base as char\n    } else {\n      c\n    }\n  }).collect()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"pq\"`,\n right: `\"lm\"`', /tmp/tmpqddconbg.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822741
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    // split the string into a vector and map each character to\n    // it's\
    \ rotation\n    s.chars().map(rotate).collect()\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `rotate` in this scope\n --> /tmp/tmphiqwjgjr.rs:9:19\n\
    \  |\n9 |     s.chars().map(rotate).collect()\n  |                   ^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822740
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut cipher = s.clone();\n    for i in 0..cipher.len() {\n       \
    \ let c = cipher.chars().nth(i).unwrap();\n        let idx = c as u8 - 97;\n \
    \       let mut new_idx = idx + 2 * 2;\n        if new_idx > 26 {\n          \
    \  new_idx = new_idx - 26;\n        }\n        let new_char = (new_idx + 97) as\
    \ char;\n        cipher.replace_range(i..i+1, &new_char.to_string());\n    }\n\
    \    return cipher;\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpvqawvx8c.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822741
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut encrypted_string = String::new();\n    let mut chars = s.chars();\n\
    \    while let Some(c) = chars.next() {\n        encrypted_string.push(encrypt_char(c))\n\
    \    }\n    encrypted_string\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `encrypt_char` in this scope\n  -->\
    \ /tmp/tmpobg4yc1c.rs:10:31\n   |\n10 |         encrypted_string.push(encrypt_char(c))\n\
    \   |                               ^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822740
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut new_str = String::new();\n    for c in s.chars() {\n        let\
    \ mut new_c = c as u8;\n        new_c += 2;\n        let char_c = std::char::from_u32(new_c\
    \ as u32).unwrap();\n        new_str.push(char_c);\n    }\n    new_str\n}\n\n\
    fn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmplcmlyngr.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822741
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let s = s.to_lowercase();\n    let mut output: String = String::new();\n\
    \    for c in s.chars() {\n        let mut c_num = c as u8;\n        if c_num\
    \ >= 97 && c_num <= 122 {\n            c_num = ((c_num - 97 + 2 * 2) % 26) + 97;\n\
    \        }\n        output.push(c_num as char);\n    }\n    output\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822741
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut new_str = String::new();\n    let a = \"abcdefghijklmnopqrstuvwxyz\"\
    ;\n    let shift = 2 * 2;\n    for c in s.chars() {\n        new_str.push(rotate_char(c,\
    \ shift, a));\n    }\n    new_str\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `rotate_char` in this scope\n  --> /tmp/tmp_e6kx7mx.rs:11:22\n\
    \   |\n11 |         new_str.push(rotate_char(c, shift, a));\n   |            \
    \          ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822740
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let alpha = \"abcdefghijklmnopqrstuvwxyz\";\n    let shift_alpha = \"\
    cdefghijklmnopqrstuvwxyzab\";\n    let shift_alpha_2 = \"efghijklmnopqrstuvwxyzabcde\"\
    ;\n    let shift_alpha_3 = \"ghijklmnopqrstuvwxyzabcdefg\";\n    let shift_alpha_4\
    \ = \"ijklmnopqrstuvwxyzabcdefghi\";\n    let shift_alpha_5 = \"klmnopqrstuvwxyzabcdefghijk\"\
    ;\n    let shift_alpha_6 = \"mnopqrstuvwxyzabcdefghijklm\";\n    let shift_alpha_7\
    \ = \"opqrstuvwxyzabcdefghijklmnop\";\n    let shift_alpha_8 = \"qrstuvwxyzabcdefghijklmnopqr\"\
    ;\n    let shift_alpha_9 = \"stuvwxyzabcdefghijklmnopqrst\";\n    let shift_alpha_10\
    \ = \"uvwxyzabcdefghijklmnopqrstuv\";\n    let shift_alpha_11 = \"wxyzabcdefghijklmnopqrstuvwx\"\
    ;\n    let shift_alpha_12 = \"yzabcdefghijklmnopqrstuvwxyz\";\n    let shift_alpha_13\
    \ = \"abcdefghijklmnopqrstuvwxyz\";\n    let mut s_to_vec: Vec<char> = s.chars().collect();\n\
    \    let mut encrypted_vec: Vec<char> = Vec::new();\n    for i in 0..s_to_vec.len()\
    \ {\n        match s_to_vec[i] {\n            'a' => encrypted_vec.push(shift_alpha.chars().nth(alpha.find(s_to_vec[i]).unwrap()).unwrap()),\n\
    \            'b' => encrypted_vec.push(shift_alpha_2.chars().nth(alpha.find(s_to_vec[i]).unwrap()).unwrap()),\n\
    \            '\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmp0wd99nlt.rs:27:13\n\
    \   |\n27 |             '\n   |             ^\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0762`.\n"
  stdout: ''
  timestamp: 1659822740
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut output = String::new();\n    for letter in s.chars() {\n    \
    \    let ascii_value = letter as u8;\n        let encrypted_value = ascii_value\
    \ + 2;\n        output.push(encrypted_value as char);\n    }\n    output\n}\n\n\
    fn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmprblv6xn0.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822741
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut result = String::new();\n    for c in s.chars() {\n        if\
    \ let Some(idx) = ALPHABET.find(c) {\n            let new_idx = (idx + 2 * 2)\
    \ % ALPHABET.len();\n            result.push(ALPHABET.chars().nth(new_idx).unwrap());\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `ALPHABET` in this scope\n --> /tmp/tmpgn4xyp2n.rs:9:28\n\
    \  |\n9 |         if let Some(idx) = ALPHABET.find(c) {\n  |                 \
    \           ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `ALPHABET` in this scope\n  --> /tmp/tmpgn4xyp2n.rs:10:43\n   |\n10 |      \
    \       let new_idx = (idx + 2 * 2) % ALPHABET.len();\n   |                  \
    \                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `ALPHABET` in this scope\n  --> /tmp/tmpgn4xyp2n.rs:11:25\n   |\n\
    11 |             result.push(ALPHABET.chars().nth(new_idx).unwrap());\n   |  \
    \                       ^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659822740
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    // TODO\n    let mut ret = String::new();\n    for i in s.chars() {\n\
    \        let a = i as u8;\n        let new_char = match a {\n            x if\
    \ x >= 97 && x <= 122 => {\n                if x < 120 {\n                   \
    \ x + 2\n                } else {\n                    x - 24\n              \
    \  }\n            },\n            x if x >= 65 && x <= 90 => {\n             \
    \   if x < 88 {\n                    x + 2\n                } else {\n       \
    \             x - 24\n                }\n            },\n            _ => a\n\
    \        };\n        ret.push(new_char as char);\n    }\n    ret\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpvdiqzgpt.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822741
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let base_alphabet = \"abcdefghijklmnopqrstuvwxyz\".to_string();\n   \
    \ let shift_alphabet = \"cdefghijklmnopqrstuvwxyzab\".to_string();\n    let mut\
    \ encrypted_string = String::new();\n    for (i, c) in s.chars().enumerate() {\n\
    \        if base_alphabet.contains(c) {\n            let letter_index = base_alphabet.find(c).unwrap();\n\
    \            let new_letter = shift_alphabet.chars().nth(letter_index).unwrap();\n\
    \            encrypted_string.push(new_letter);\n        } else {\n          \
    \  encrypted_string.push(c);\n        }\n    }\n    encrypted_string\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmp6cnqcky5.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822741
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let alphabet = vec![\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\",\
    \ \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\"\
    , \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut s_array:\
    \ Vec<char> = s.chars().collect();\n    let mut k = 0;\n    while k < s_array.len()\
    \ {\n        if (s_array[k] as u8 >= 97) && (s_array[k] as u8 <= 122) {\n    \
    \        let mut i = 0;\n            while i < alphabet.len() {\n            \
    \    if alphabet[i] == &s_array[k].to_string() {\n                    s_array[k]\
    \ = alphabet[(i + 2) % alphabet.len()].chars().nth(0).unwrap();\n            \
    \        break;\n                }\n                i += 1;\n            }\n \
    \       }\n        k += 1;\n    }\n    s_array.into_iter().collect()\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmp9ima3t4l.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822741
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let alphabet = String::from(\"abcdefghijklmnopqrstuvwxyz\");\n    let\
    \ mut encrypted = String::new();\n    for c in s.chars() {\n        if c.is_lowercase()\
    \ {\n            encrypted.push(alphabet.chars().nth((c as u8 - 97 + 4) % 26).unwrap());\n\
    \        } else {\n            encrypted.push(c);\n        }\n    }\n    encrypted\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk0i3ubq5.rs:11:49\n   |\n\
    11 |             encrypted.push(alphabet.chars().nth((c as u8 - 97 + 4) % 26).unwrap());\n\
    \   |                                                 ^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                                                 |\n   |                \
    \                                 expected `usize`, found `u8`\n   |         \
    \                                        help: you can convert a `u8` to a `usize`:\
    \ `((c as u8 - 97 + 4) % 26).into()`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659822740
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    s.chars().map(|c| {\n        if let Some(x) = c.to_digit(36) {\n    \
    \        if x < 10 {\n                format!(\"{}\", (x + 20) % 10)\n       \
    \     } else {\n                format!(\"{}\", std::char::from_digit((x + 20)\
    \ % 26 + 10, 36).unwrap())\n            }\n        } else {\n            c.to_string()\n\
    \        }\n    }).collect()\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822741
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut encrypted = String::new();\n    for mut c in s.chars() {\n  \
    \      c = match c {\n            'a' => 'c',\n            'b' => 'd',\n     \
    \       'c' => 'e',\n            'd' => 'f',\n            'e' => 'g',\n      \
    \      'f' => 'h',\n            'g' => 'i',\n            'h' => 'j',\n       \
    \     'i' => 'k',\n            'j' => 'l',\n            'k' => 'm',\n        \
    \    'l' => 'n',\n            'm' => 'o',\n            'n' => 'p',\n         \
    \   'o' => 'q',\n            'p' => 'r',\n            'q' => 's',\n          \
    \  'r' => 't',\n            's' => 'u',\n            't' => 'v',\n           \
    \ 'u' => 'w',\n            'v' => 'x',\n            'w' => 'y',\n            'x'\
    \ => 'z',\n            'y' => 'a',\n            'z' => 'b',\n            _ =>\
    \ c,\n        };\n        encrypted.push(c);\n    }\n    encrypted\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmp0c1nan3u.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822741
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut cipher = String::new();\n    for c in s.chars() {\n        if\
    \ c.is_alphabetic() {\n            cipher.push(((c as u8 - b'a' + 2) % 26 + b'a')\
    \ as char);\n        } else {\n            cipher.push(c);\n        }\n    }\n\
    \    cipher\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmptbgir3bz.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822741
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut encrypt_string = String::new();\n    let alphabet = vec!['a',\
    \ 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q',\
    \ 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n    let mut index = 0;\n    let\
    \ mut current_alphabet_position = 0;\n    let ascii_lowercase_char_int = 97;\n\
    \    let ascii_uppercase_char_int = 65;\n    let a: Vec<char> = s.chars().collect();\n\
    \    for character in a {\n        if character.is_ascii_alphabetic() {\n    \
    \        let ascii_letter = character as u8;\n            if ascii_letter < ascii_uppercase_char_int\
    \ {\n                let mut letter_lowercase = String::new();\n             \
    \   let mut letter_lowercase_char: char = char::from(ascii_letter);\n        \
    \        let mut alphabet_position = alphabet.iter().position(|&r| r == letter_lowercase_char).unwrap();\n\
    \                alphabet_position += 2 * index;\n                if alphabet_position\
    \ > 25 {\n                    alphabet_position -= 26;\n                }\n  \
    \              letter_lowercase_char = alphabet[alphabet_position];\n        \
    \        letter_lowercase.push(letter_lowercase_char);\n                encrypt_string.push_str(&letter_lowercase);\n\
    \                index += 1;\n            } else {\n                let mut letter_uppercase\
    \ = String::new();\n                let mut letter_uppercase_char: char = char::from(ascii_letter);\n\
    \                let mut alphabet_position = alphabet.iter().position(|&r| r ==\
    \ letter_uppercase_char.to_ascii_lowercase()).unwrap();\n                alphabet_position\
    \ += 2 * index;\n                if alphabet_position > 25 {\n               \
    \     alphabet_position -= 26;\n                }\n                letter_uppercase_char\
    \ = alphabet[alphabet_position].to_ascii_\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpr9j0vnp5.rs:50:3\n\
    \   |\n6  | fn encrypt(s: String) -> String {\n   |                          \
    \       - unclosed delimiter\n...\n14 |     for character in a {\n   |       \
    \                 - unclosed delimiter\n15 |         if character.is_ascii_alphabetic()\
    \ {\n   |                                            - unclosed delimiter\n...\n\
    29 |             } else {\n   |                    - this delimiter might not\
    \ be properly closed...\n...\n38 | }\n   | - ...as it matches this but it has\
    \ different indentation\n...\n50 | }\n   |   ^\n\nerror[E0610]: `char` is a primitive\
    \ type and therefore doesn't have fields\n  --> /tmp/tmpr9j0vnp5.rs:37:69\n  \
    \ |\n37 |                 letter_uppercase_char = alphabet[alphabet_position].to_ascii_\n\
    \   |                                                                     ^^^^^^^^^\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpr9j0vnp5.rs:14:5\n   |\n6  | \
    \  fn encrypt(s: String) -> String {\n   |                            ------ expected\
    \ `String` because of return type\n...\n14 | /     for character in a {\n15 |\
    \ |         if character.is_ascii_alphabetic() {\n16 | |             let ascii_letter\
    \ = character as u8;\n17 | |             if ascii_letter < ascii_uppercase_char_int\
    \ {\n...  |\n49 | |     assert_eq!(candidate(String::from(\"a\")), String::from(\"\
    e\"));\n50 | | }\n   | |__^ expected struct `String`, found `()`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0610.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659822741
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut str: Vec<char> = s.chars().collect();\n    for x in str.iter_mut()\
    \ {\n        if let Some(i) = ASCII_ALPHABET.iter().position(|x| *x == *x) {\n\
    \            let index = (i + 4) % 26;\n            *x = ASCII_ALPHABET[index];\n\
    \        }\n    }\n    str.into_iter().collect()\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `ASCII_ALPHABET` in this scope\n --> /tmp/tmp2at5ejzi.rs:9:26\n\
    \  |\n9 |         if let Some(i) = ASCII_ALPHABET.iter().position(|x| *x == *x)\
    \ {\n  |                          ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `ASCII_ALPHABET` in this scope\n  --> /tmp/tmp2at5ejzi.rs:11:18\n\
    \   |\n11 |             *x = ASCII_ALPHABET[index];\n   |                  ^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822741
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut ret_string = String::new();\n    let a_in_ascii = 'a' as u8;\n\
    \    let z_in_ascii = 'z' as u8;\n    let max_rotate = z_in_ascii - a_in_ascii;\n\
    \    let rotate_amount = 2 * 2;\n\n    let mut str_iter = s.chars();\n    while\
    \ let Some(c) = str_iter.next() {\n        let mut char_to_insert = c;\n     \
    \   if c.is_alphabetic() {\n            if c.is_uppercase() {\n              \
    \  char_to_insert = (((c as u8 - a_in_ascii + rotate_amount) % max_rotate) + a_in_ascii)\
    \ as char;\n            } else {\n                char_to_insert = (((c as u8\
    \ - a_in_ascii + rotate_amount) % max_rotate) + a_in_ascii) as char;\n       \
    \     }\n        }\n        ret_string.push(char_to_insert);\n    }\n    ret_string\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jeibjebijeibk\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpuwr39q_e.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822741
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n\ts.chars().map(|c| match c {\n\t\t'A'...'C' => ((c as u8) + 26 - 2).into(),\n\
    \t\t'D'...'Z' => ((c as u8) - 2).into(),\n\t\t_ => c\n\t}).collect()\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmp19u5pr3z.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822741
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let v: Vec<char> = s.chars().collect();\n    let mut encrypt_v: Vec<char>\
    \ = vec![' '; v.len()];\n    for (i, l) in v.iter().enumerate() {\n        encrypt_v[i]\
    \ = (*l as u8 + 2 * 2) as char;\n    }\n    encrypt_v.iter().collect()\n}\n\n\
    fn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmppgqo_til.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822741
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let base: Vec<char> = \"abcdefghijklmnopqrstuvwxyz\".chars().collect();\n\
    \    let result: Vec<char> = s.chars().map(|x| {\n        let base_index = base.iter().position(|&y|\
    \ y == x).unwrap();\n        base[(base_index + 2 * 2) % base.len()]\n    }).collect();\n\
    \    result.iter().cloned().collect()\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822741
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut result = String::new();\n    let mut chars = s.chars();\n   \
    \ while let Some(ch) = chars.next() {\n        if ch.is_alphabetic() {\n     \
    \       let code = ch as u8 + 2 * 2;\n            if code <= 'z' as u8 {\n   \
    \             result.push(code as char);\n            } else {\n             \
    \   result.push((code - 26) as char);\n            }\n        } else {\n     \
    \       result.push(ch);\n        }\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822741
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    use std::iter::Iterator;\n    let mut result = String::new();\n    let\
    \ mut temp = 0;\n    for x in s.chars() {\n        if x >= 'a' && x <= 'z' {\n\
    \            temp = x as u8 - 'a' as u8;\n            temp = ((temp + 2) * 2)\
    \ % 26;\n            result.push((temp + 'a' as u8) as char);\n        } else\
    \ if x >= 'A' && x <= 'Z' {\n            temp = x as u8 - 'A' as u8;\n       \
    \     temp = ((temp + 2) * 2) % 26;\n            result.push((temp + 'A' as u8)\
    \ as char);\n        } else {\n            result.push(x);\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"su\"`,\n right: `\"lm\"`', /tmp/tmpz7z17frm.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822741
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut s_crypt = String::new();\n    let alphabet = ['a', 'b', 'c',\
    \ 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's',\
    \ 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n    for c in s.chars() {\n        if c\
    \ == ' ' {\n            s_crypt.push(c);\n        } else {\n            if c ==\
    \ 'y' {\n                s_crypt.push('a');\n            } else if c == 'z' {\n\
    \                s_crypt.push('b');\n            } else {\n                let\
    \ mut idx = 0;\n                for i in 0..alphabet.len() {\n               \
    \     if c == alphabet[i] {\n                        idx = i;\n              \
    \          break;\n                    }\n                }\n                s_crypt.push(alphabet[idx\
    \ + 2]);\n            }\n        }\n    }\n    s_crypt\n}\n\nfn main() {\n   \
    \ let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpyp7l4fls.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822741
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let chars = s.chars().map(|c| {\n        match c {\n            'A' ...\
    \ 'Z' => (((c as u8) - 65 + 2 * 2) % 26 + 65) as char,\n            'a' ... 'z'\
    \ => (((c as u8) - 97 + 2 * 2) % 26 + 97) as char,\n            _ => c\n     \
    \   }\n    });\n    chars.collect()\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822741
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut out = String::new();\n    for x in s.chars() {\n        if x.is_numeric()\
    \ {\n            out.push(x);\n        } else {\n            let next = x as u8\
    \ + 2;\n            out.push(next as char);\n        }\n    }\n    out\n}\n\n\
    fn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpwo6z2s73.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822741
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut result = \"\".to_string();\n    for i in s.chars() {\n      \
    \  result.push(shift_char(i, 2));\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `shift_char` in this scope\n --> /tmp/tmpodvis65g.rs:9:21\n\
    \  |\n9 |         result.push(shift_char(i, 2));\n  |                     ^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822741
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut result = String::new();\n    for ch in s.chars() {\n        if\
    \ ch == 'z' {\n            result.push('b');\n        } else if ch == 'y' {\n\
    \            result.push('a');\n        } else {\n            let mut ch_int =\
    \ ch as u8;\n            ch_int += 2;\n            result.push(ch_int as char);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmp2nuluw7t.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822741
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let alphabet: Vec<char> = \"abcdefghijklmnopqrstuvwxyz\".chars().collect();\n\
    \    let mut encrypted_message = String::new();\n    for c in s.chars() {\n  \
    \      let mut index = (alphabet.iter().position(|&r| r == c).unwrap() + 1) *\
    \ 2;\n        if index > 26 {\n            index = index - 26;\n        }\n  \
    \      encrypted_message.push(alphabet[index - 1]);\n    }\n    encrypted_message\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"pr\"`,\n right: `\"lm\"`', /tmp/tmphjx2ynx8.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822741
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let bytes = s.as_bytes();\n    let mut result = Vec::new();\n    for\
    \ &byte in bytes {\n        result.push(encrypt_by_2(byte));\n    }\n    String::from_utf8(result).unwrap()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `encrypt_by_2` in this scope\n  -->\
    \ /tmp/tmprc0b_l2t.rs:10:21\n   |\n10 |         result.push(encrypt_by_2(byte));\n\
    \   |                     ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659822741
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut result = String::new();\n    let mut i = 0;\n    let mut alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\".chars();\n    for\
    \ ch in s.chars() {\n        if ch == ' ' {\n            result.push(ch);\n  \
    \      } else {\n            let mut next_char = alphabet.nth(i).unwrap();\n \
    \           while next_char != ch {\n                i += 1;\n               \
    \ next_char = alphabet.nth(i).unwrap();\n            }\n            if i >= 50\
    \ {\n                i = i - 51;\n            } else if i >= 24 {\n          \
    \      i = i - 25;\n            }\n            i += 2;\n            let encrypted_char\
    \ = alphabet.nth(i).unwrap();\n            result.push(encrypted_char);\n    \
    \        i += 2;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmp0z28x4nv.rs:17:45

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822741
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut encrypted = String::new();\n    for c in s.chars() {\n      \
    \  encrypted.push(if c == 'z' { 'b' } else if c == 'y' { 'a' } else { (((c as\
    \ u8) + 2) as char) });\n    }\n    encrypted\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmp1_urayrh.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822741
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut enc = String::new();\n    for c in s.chars() {\n        let x\
    \ = c as u8;\n        let e = ((x as u16) - (b'a' as u16) + 26) % 26;\n      \
    \  let c2 = ((e * e * e * e * e * e * e * e * e * e * e * e * e * e) % 26) as\
    \ u8;\n        let c3 = ((b'a' as u16) + c2 as u16) as u8;\n        enc.push(c3\
    \ as char);\n    }\n    enc\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to multiply with overflow'', /tmp/tmpjstnd8d9.rs:11:20

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822741
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut chars = s.chars();\n    let mut res = String::new();\n    for\
    \ c in chars {\n        if let Some(a) = c.to_lowercase().next() {\n         \
    \   res.push(match a {\n                'a' | 'b' => 'c',\n                'c'\
    \ | 'd' => 'e',\n                'e' | 'f' => 'g',\n                'g' | 'h'\
    \ => 'i',\n                'i' | 'j' => 'k',\n                'k' | 'l' => 'm',\n\
    \                'm' | 'n' => 'o',\n                'o' | 'p' => 'q',\n      \
    \          'q' | 'r' => 's',\n                's' | 't' => 'u',\n            \
    \    'u' | 'v' => 'w',\n                'w' | 'x' => 'y',\n                'y'\
    \ | 'z' => 'a',\n                _ => a,\n            });\n        }\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ik\"`,\n right: `\"lm\"`', /tmp/tmpn6ebherd.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822741
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut result = String::new();\n    for c in s.chars() {\n        result.push((c\
    \ as u8 + 2 * 2) as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpig8oyw95.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822741
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    for c in s.chars() {\n        if c == 'z' {\n            print!(\"a\"\
    );\n        } else if c == 'Z' {\n            print!(\"A\");\n        } else {\n\
    \            print!(\"{}\", c as u8 + 2);\n        }\n    }\n    return s;\n}\n\
    \nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmpd86mernc.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: '106107'
  timestamp: 1659822741
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut alphabet: Vec<char> = \"abcdefghijklmnopqrstuvwxyz\".chars().collect();\n\
    \    let mut encrypted: Vec<char> = vec![];\n    for c in s.chars() {\n      \
    \  if alphabet.contains(&c) {\n            encrypted.push(alphabet[alphabet.iter().position(|&x|\
    \ x == c).unwrap() + 1]);\n        } else {\n            encrypted.push(c);\n\
    \        }\n    }\n    encrypted.into_iter().collect()\n}\n\nfn main() {\n   \
    \ let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ij\"`,\n right: `\"lm\"`', /tmp/tmpaksqipy_.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822741
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    s.chars().map(|c| {\n        if c.is_ascii_lowercase() {\n          \
    \  (b'a' + ((c as u8 - b'a' + 2) % 26)) as char\n        } else if c.is_ascii_uppercase()\
    \ {\n            (b'A' + ((c as u8 - b'A' + 2) % 26)) as char\n        } else\
    \ {\n            c\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpt17dojmf.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822741
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut r = String::new();\n    for c in s.chars() {\n        r.push(match\
    \ c {\n            'a' => 'c',\n            'b' => 'd',\n            'c' => 'e',\n\
    \            'd' => 'f',\n            'e' => 'g',\n            'f' => 'h',\n \
    \           'g' => 'i',\n            'h' => 'j',\n            'i' => 'k',\n  \
    \          'j' => 'l',\n            'k' => 'm',\n            'l' => 'n',\n   \
    \         'm' => 'o',\n            'n' => 'p',\n            'o' => 'q',\n    \
    \        'p' => 'r',\n            'q' => 's',\n            'r' => 't',\n     \
    \       's' => 'u',\n            't' => 'v',\n            'u' => 'w',\n      \
    \      'v' => 'x',\n            'w' => 'y',\n            'x' => 'z',\n       \
    \     'y' => 'a',\n            'z' => 'b',\n            _ => c,\n        });\n\
    \    }\n    r\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpubstc5go.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822741
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut result = String::new();\n    for c in s.chars() {\n        let\
    \ encrypted_c = match c {\n            'a' | 'A' => 'C',\n            'b' | 'B'\
    \ => 'D',\n            'c' | 'C' => 'E',\n            'd' | 'D' => 'F',\n    \
    \        'e' | 'E' => 'G',\n            'f' | 'F' => 'H',\n            'g' | 'G'\
    \ => 'I',\n            'h' | 'H' => 'J',\n            'i' | 'I' => 'K',\n    \
    \        'j' | 'J' => 'L',\n            'k' | 'K' => 'M',\n            'l' | 'L'\
    \ => 'N',\n            'm' | 'M' => 'O',\n            'n' | 'N' => 'P',\n    \
    \        'o' | 'O' => 'Q',\n            'p' | 'P' => 'R',\n            'q' | 'Q'\
    \ => 'S',\n            'r' | 'R' => 'T',\n            's' | 'S' => 'U',\n    \
    \        't' | 'T' => 'V',\n            'u' | 'U' => 'W',\n            'v' | 'V'\
    \ => 'X',\n            'w' | 'W' => 'Y',\n            'x' | 'X' => 'Z',\n    \
    \        'y' | 'Y' => 'A',\n            'z' | 'Z' => 'B',\n            _ => c,\n\
    \        };\n        result.push(encrypted_c);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"JK\"`,\n right: `\"lm\"`', /tmp/tmpa4q4_z0t.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822741
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    s.chars().map(|x| {\n        if x.is_alphabetic() {\n            if x.is_lowercase()\
    \ {\n                (((x as u8 - 'a' as u8) + 2 * 2) % 26 + 'a' as u8) as char\n\
    \            } else {\n                (((x as u8 - 'A' as u8) + 2 * 2) % 26 +\
    \ 'A' as u8) as char\n            }\n        } else {\n            x\n       \
    \ }\n    }).collect()\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822741
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut chars = s.chars();\n    let mut encrypt_string = String::new();\n\
    \    let mut flag = 0;\n    for i in 0..s.len() {\n        let mut c = chars.next().unwrap();\n\
    \        let mut temp = 0;\n        if c as u8 >= 65 && c as u8 <= 90 {\n    \
    \        flag = 1;\n            temp = c as u8 - 65;\n            temp = temp\
    \ * 2;\n            temp = temp + 65;\n            c = temp as u8 as char;\n \
    \       }\n        else if c as u8 >= 97 && c as u8 <= 122 {\n            flag\
    \ = 1;\n            temp = c as u8 - 97;\n            temp = temp * 2;\n     \
    \       temp = temp + 97;\n            c = temp as u8 as char;\n        }\n  \
    \      encrypt_string.push(c);\n    }\n    if flag == 0 {\n        encrypt_string\
    \ = String::from(\"\");\n    }\n    encrypt_string\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"oq\"`,\n right: `\"lm\"`', /tmp/tmpaapx7glh.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822741
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n    let mut secret =\
    \ String::new();\n    for c in s.chars() {\n        if c.is_alphabetic() {\n \
    \           let index = alphabet.find(c).unwrap();\n            let new_index\
    \ = index * 2 + 2;\n            let result = alphabet.chars().nth(new_index).unwrap();\n\
    \            secret.push(result);\n        } else {\n            secret.push(c);\n\
    \        }\n    }\n    secret\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"qs\"`,\n right: `\"lm\"`', /tmp/tmp4p4wzplv.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822741
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = encrypt;\n  \
    \  assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpgfnmb2m8.rs:7:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822741
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = encrypt;\n \
    \   assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpo8narrt0.rs:7:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822741
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    // if string is empty, return as is\n    if s.is_empty() {\n        return\
    \ s;\n    }\n    // convert string to chars, and iterate over it\n    let mut\
    \ encrypted_string = String::new();\n    for i in s.chars() {\n        if i.is_alphabetic()\
    \ {\n            // lower case\n            if i.is_lowercase() {\n          \
    \      encrypted_string.push(\n                    ((i as u8 - 97 + 4) % 26 +\
    \ 97) as char\n                );\n            } else {\n                // upper\
    \ case\n                encrypted_string.push(\n                    ((i as u8\
    \ - 65 + 4) % 26 + 65) as char\n                );\n            }\n        } else\
    \ {\n            // it is a number, add it as is\n            encrypted_string.push(i);\n\
    \        }\n    }\n    return encrypted_string;\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822741
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut c = String::new();\n    for l in s.to_lowercase().chars() {\n\
    \        let l_num = l as u8;\n        match l_num {\n            97...120 =>\
    \ c.push((l_num + 2) as char),\n            121 => c.push('a'),\n            122\
    \ => c.push('b'),\n            _ => c.push(l),\n        }\n    }\n    c\n}\n\n\
    fn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpwil63hpl.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822741
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n\tlet to_lowercase = s.to_lowercase();\n\tlet mut encrypted_string = String::new();\n\
    \tfor i in to_lowercase.chars() {\n\t\tif i == 'z' {\n\t\t\tencrypted_string.push('b');\n\
    \t\t} else if i == 'y' {\n\t\t\tencrypted_string.push('a');\n\t\t} else {\n\t\t\
    \tencrypted_string.push(((i as u8 + 2) as char))\n\t\t}\n\t}\n\tencrypted_string\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpgzmchlja.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822741
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let alph = \"abcdefghijklmnopqrstuvwxyz\";\n    let mut enc = String::new();\n\
    \    for c in s.chars() {\n        let mut index = alph.find(c).unwrap();\n  \
    \      if index > 23 {\n            index -= 24;\n        } else {\n         \
    \   index += 2;\n        }\n        enc.push(alph.chars().nth(index).unwrap());\n\
    \    }\n    enc\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmp6_vtg6ku.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822741
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    // TODO: Implement me\n    String::new()\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"lm\"`', /tmp/tmpwb49btvs.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822741
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n\tlet mut new_string = String::new();\n\tlet length = s.len();\n\tlet mut\
    \ i = 0;\n\tlet mut str_vec: Vec<char> = s.chars().collect();\n\twhile i < length\
    \ {\n\t\tmatch str_vec[i] {\n\t\t\t'a' => new_string.push('c'),\n\t\t\t'b' =>\
    \ new_string.push('d'),\n\t\t\t'c' => new_string.push('e'),\n\t\t\t'd' => new_string.push('f'),\n\
    \t\t\t'e' => new_string.push('g'),\n\t\t\t'f' => new_string.push('h'),\n\t\t\t\
    'g' => new_string.push('i'),\n\t\t\t'h' => new_string.push('j'),\n\t\t\t'i' =>\
    \ new_string.push('k'),\n\t\t\t'j' => new_string.push('l'),\n\t\t\t'k' => new_string.push('m'),\n\
    \t\t\t'l' => new_string.push('n'),\n\t\t\t'm' => new_string.push('o'),\n\t\t\t\
    'n' => new_string.push('p'),\n\t\t\t'o' => new_string.push('q'),\n\t\t\t'p' =>\
    \ new_string.push('r'),\n\t\t\t'q' => new_string.push('s'),\n\t\t\t'r' => new_string.push('t'),\n\
    \t\t\t's' => new_string.push('u'),\n\t\t\t't' => new_string.push('v'),\n\t\t\t\
    'u' => new_string.push('w'),\n\t\t\t'v' => new_string.push('x'),\n\t\t\t'w' =>\
    \ new_string.push('y'),\n\t\t\t'x' => new_string.push('z'),\n\t\t\t'y' => new_string.push('a'),\n\
    \t\t\t'z' => new_string.push('b'),\n\t\t\t_ => new_string.push(str_vec[i]),\n\t\
    \t}\n\t\ti += 1;\n\t}\n\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa5v3usv6.rs:11:2\n   |\n\
    6  |   fn encrypt(s: String) -> String {\n   |                            ------\
    \ expected `String` because of return type\n...\n11 | /     while i < length {\n\
    12 | |         match str_vec[i] {\n13 | |             'a' => new_string.push('c'),\n\
    14 | |             'b' => new_string.push('d'),\n...  |\n41 | |         i += 1;\n\
    42 | |     }\n   | |_____^ expected struct `String`, found `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659822741
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    // your code here\n    let alphabets: Vec<char> = \"abcdefghijklmnopqrstuvwxyz\"\
    .chars().collect();\n    let mut encrypted_string = String::new();\n    for c\
    \ in s.chars() {\n        if c.is_alphabetic() {\n            let mut c_index\
    \ = alphabets.iter().position(|&x| x == c).unwrap();\n            c_index = (c_index\
    \ + (2 * 2)) % 26;\n            encrypted_string.push(alphabets[c_index]);\n \
    \       } else {\n            encrypted_string.push(c);\n        }\n    }\n  \
    \  encrypted_string\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822741
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    s.chars().map(|c| match c {\n        'a' => 'c',\n        'b' => 'd',\n\
    \        'c' => 'e',\n        'd' => 'f',\n        'e' => 'g',\n        'f' =>\
    \ 'h',\n        'g' => 'i',\n        'h' => 'j',\n        'i' => 'k',\n      \
    \  'j' => 'l',\n        'k' => 'm',\n        'l' => 'n',\n        'm' => 'o',\n\
    \        'n' => 'p',\n        'o' => 'q',\n        'p' => 'r',\n        'q' =>\
    \ 's',\n        'r' => 't',\n        's' => 'u',\n        't' => 'v',\n      \
    \  'u' => 'w',\n        'v' => 'x',\n        'w' => 'y',\n        'x' => 'z',\n\
    \        'y' => 'a',\n        'z' => 'b',\n        _ => c,\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmp0i1cah3s.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822741
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    String::from(\"\")\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"lm\"`', /tmp/tmpu645cfo1.rs:12:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822741
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut res = String::new();\n    for c in s.chars() {\n        if c\
    \ >= 'a' && c <= 'z' {\n            let val = (c as u8 - 'a' as u8 + 2 * 2) %\
    \ 26;\n            res.push(char::from(val + 'a' as u8));\n        } else if c\
    \ >= 'A' && c <= 'Z' {\n            let val = (c as u8 - 'A' as u8 + 2 * 2) %\
    \ 26;\n            res.push(char::from(val + 'A' as u8));\n        } else {\n\
    \            res.push(c);\n        }\n    }\n    res\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822742
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut encrypted_string = String::new();\n    for c in s.chars() {\n\
    \        if c == ' ' {\n            encrypted_string.push(c);\n        } else\
    \ {\n            let a = match c {\n                'x' => 'a',\n            \
    \    'y' => 'b',\n                'z' => 'c',\n                _ => {\n      \
    \              let prev_char = (c as u8 - 1) as char;\n                    let\
    \ next_char = (c as u8 + 1) as char;\n                    prev_char.to_string()\
    \ + &next_char.to_string()\n                }\n            };\n            encrypted_string.push_str(&a);\n\
    \        }\n    }\n    encrypted_string\n}\n\nfn main() {\n    let candidate =\
    \ encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"\
    ));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"ewhjklnop\"\
    ));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"kj\"));\n\
    \    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"\
    faewfawefaewg\")), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: `match` arms have incompatible types\n  --> /tmp/tmpo5ewy8ax.rs:19:21\n\
    \   |\n12 |               let a = match c {\n   |  _____________________-\n13\
    \ | |                 'x' => 'a',\n   | |                        --- this is found\
    \ to be of type `char`\n14 | |                 'y' => 'b',\n   | |           \
    \             --- this is found to be of type `char`\n15 | |                 'z'\
    \ => 'c',\n   | |                        --- this is found to be of type `char`\n\
    ...  |\n19 | |                     prev_char.to_string() + &next_char.to_string()\n\
    \   | |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n20 | |                 }\n21 | |            \
    \ };\n   | |_____________- `match` arms have incompatible types\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659822741
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut \n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n --> /tmp/tmpp2lz3oml.rs:8:1\n \
    \ |\n8 | }\n  | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659822741
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\".to_string();\n    let mut\
    \ encrypted_string = String::new();\n    for c in s.chars() {\n        let shifted_index\
    \ = (alphabet.find(c).unwrap() + 4) % 26;\n        encrypted_string.push(alphabet.chars().nth(shifted_index).unwrap());\n\
    \    }\n    encrypted_string\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822742
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut chars = Vec::new();\n    for c in s.chars() {\n        chars.push(c);\n\
    \    }\n    //let mut chars = s.chars().collect::<Vec<char>>();\n    let len =\
    \ chars.len();\n    for i in 0..len {\n        match chars[i] {\n            'a'\
    \ | 'A' => chars[i] = 'C',\n            'b' | 'B' => chars[i] = 'D',\n       \
    \     'c' | 'C' => chars[i] = 'E',\n            'd' | 'D' => chars[i] = 'F',\n\
    \            'e' | 'E' => chars[i] = 'G',\n            'f' | 'F' => chars[i] =\
    \ 'H',\n            'g' | 'G' => chars[i] = 'I',\n            'h' | 'H' => chars[i]\
    \ = 'J',\n            'i' | 'I' => chars[i] = 'K',\n            'j' | 'J' => chars[i]\
    \ = 'L',\n            'k' | 'K' => chars[i] = 'M',\n            'l' | 'L' => chars[i]\
    \ = 'N',\n            'm' | 'M' => chars[i] = 'O',\n            'n' | 'N' => chars[i]\
    \ = 'P',\n            'o' | 'O' => chars[i] = 'Q',\n            'p' | 'P' => chars[i]\
    \ = 'R',\n            'q' | 'Q' => chars[i] = 'S',\n            'r' | 'R' => chars[i]\
    \ = 'T',\n            's' | 'S' => chars[i] = 'U',\n            't' | 'T' => chars[i]\
    \ = 'V',\n            'u' | 'U' => chars[i] = 'W',\n            'v' | 'V' => chars[i]\
    \ = 'X',\n            'w' | 'W' => chars[i] = 'Y',\n            'x' | 'X' => chars[i]\
    \ = 'Z',\n\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpsdlz48k3.rs:52:3\n\
    \   |\n6  | fn encrypt(s: String) -> String {\n   |                          \
    \       - unclosed delimiter\n...\n13 |     for i in 0..len {\n   |          \
    \           - unclosed delimiter\n14 |         match chars[i] {\n   |        \
    \                - this delimiter might not be properly closed...\n...\n40 | }\n\
    \   | - ...as it matches this but it has different indentation\n...\n52 | }\n\
    \   |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsdlz48k3.rs:13:5\n\
    \   |\n6  |   fn encrypt(s: String) -> String {\n   |                        \
    \    ------ expected `String` because of return type\n...\n13 | /     for i in\
    \ 0..len {\n14 | |         match chars[i] {\n15 | |             'a' | 'A' => chars[i]\
    \ = 'C',\n16 | |             'b' | 'B' => chars[i] = 'D',\n...  |\n51 | |    \
    \ assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n52 | | }\n\
    \   | |__^ expected struct `String`, found `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659822741
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    // Convert the string to lowercase, then convert it to chars\n    s.to_lowercase().chars().map(|c|\
    \ {\n        // Match each char to a number, +13 and mod 26. If the \n       \
    \ // character is a space, or if the character is not\n        // alphabetic then\
    \ return the character.\n        // Otherwise, return the character converted\
    \ to its\n        // unicode representation.\n        match c {\n            'a'\
    \ ... 'z' => (((c as u8 - b'a' + 13) % 26) + b'a') as char,\n            _ =>\
    \ c\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"uv\"`,\n right: `\"lm\"`', /tmp/tmpmeexqz17.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822742
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    for x in s.chars() {\n        if x.is_alphabetic() {\n            println!(\"\
    {}\", ((x as u8 + 5) % 122) as char);\n        }\n    }\n    String::from(\"\"\
    )\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"lm\"`', /tmp/tmp60xrrq7o.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: 'm

    n

    '
  timestamp: 1659822742
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut res = String::new();\n    for i in s.chars() {\n        res.push(((i\
    \ as u8) + 2).to_ascii_lowercase() as char);\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpsptew1pf.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822742
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n    s.chars().map(|c|\
    \ {\n        match alphabet.find(c) {\n            Some(i) => {\n            \
    \    let n = alphabet.len();\n                let rotated = (i + (n / 2) * 2)\
    \ % n;\n                return alphabet.chars().nth(rotated).unwrap();\n     \
    \       },\n            None => c\n        }\n    }).collect()\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmpbm541867.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822742
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut v = s.as_bytes().to_vec();\n    for i in 0..v.len() {\n     \
    \   if v[i] > 96 && v[i] < 123 {\n            v[i] = (v[i] - 96 + 2 * 2) % 26\
    \ + 96;\n        }\n    }\n    String::from_utf8(v).unwrap()\n}\n\nfn main() {\n\
    \    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822742
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut newstr = String::new();\n    let alphabet = vec![\"a\", \"b\"\
    , \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\"\
    , \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\"\
    , \"y\", \"z\"];\n    let mut s = s.to_lowercase();\n    let mut i = 0;\n    let\
    \ mut x: char;\n    while i < s.len() {\n        x = s.chars().nth(i).unwrap();\n\
    \        if x == ' ' || x == ',' || x == '.' || x == '!' || x == '?' {\n     \
    \       newstr.push(x);\n        } else {\n            let index = alphabet.iter().position(|&r|\
    \ r == &x.to_string()).unwrap();\n            newstr.push_str(alphabet[(index\
    \ + 1) % alphabet.len()]);\n            newstr.push_str(alphabet[(index + 2) %\
    \ alphabet.len()]);\n        }\n        i += 1;\n    }\n    newstr\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ijjk\"`,\n right: `\"lm\"`', /tmp/tmphuagfv8l.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822742
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut new_string = String::new();\n    for i in s.chars() {\n     \
    \   if i == ' ' {\n            new_string.push(' ');\n        } else {\n     \
    \       new_string.push(((i as u8) + 2) as char);\n        }\n    }\n    new_string\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmps00cp_n9.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822742
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut s2 = s.clone();\n    let alphabets = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    ;\n    for (i, ch) in s.chars().enumerate() {\n        match alphabets.find(ch)\
    \ {\n            Some(j) => {\n                let index = (j + (2 * 2)) % alphabets.len();\n\
    \                s2.replace_range(i..i+1, &alphabets[index..index+1]);\n     \
    \       },\n            None => {},\n        }\n    }\n    s2\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jeiAjeAijeiAk\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpvrauug0z.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822742
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut new_string = String::new();\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    ;\n    for x in s.chars() {\n        for y in alphabet.chars() {\n           \
    \ if x == y {\n                let count = alphabet.chars().count();\n       \
    \         let index = alphabet.chars().position(|x| x == y).unwrap();\n      \
    \          let encrypted_index = if index + 4 < count {\n                    index\
    \ + 4\n                } else {\n                    index + 4 - count\n     \
    \           };\n                new_string.push(alphabet.chars().nth(encrypted_index).unwrap());\n\
    \            }\n        }\n    }\n    new_string\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822742
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let cipher = \n        ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i',\
    \ 'j', 'k', 'l', 'm',\n         'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z'];\n    let mut value = String::new();\n    for c in s.chars()\
    \ {\n        let n = c as usize - 'a' as usize;\n        value.push(cipher[(n+2*2)%26]);\n\
    \    }\n    value\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822742
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    // TODO\n    unimplemented!()\n}\n\nfn main() {\n    let candidate =\
    \ encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"\
    ));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"ewhjklnop\"\
    ));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"kj\"));\n\
    \    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"\
    faewfawefaewg\")), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp4n104oc5.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822742
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut result = String::new();\n    for c in s.chars() {\n        if\
    \ c.is_alphabetic() {\n            result.push(if c.is_uppercase() {\n       \
    \         (((c as u8 - b'A') + 2 * 2) % 26 + b'A') as char\n            } else\
    \ {\n                (((c as u8 - b'a') + 2 * 2) % 26 + b'a') as char\n      \
    \      });\n        } else {\n            result.push(c);\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822742
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let n = s.len();\n    let mut alpha = vec!['a'; 26];\n    for i in 0..26\
    \ {\n        alpha[i] = (b'a' as u8 + (i * 2) as u8) as char;\n    }\n    let\
    \ mut d = HashMap::new();\n    for i in 0..26 {\n        d.insert(alpha[i], i);\n\
    \    }\n    let mut result = vec!['a'; n];\n    for i in 0..n {\n        let c\
    \ = s.chars().nth(i).unwrap();\n        result[i] = match d.get(&c) {\n      \
    \      Some(x) => alpha[(*x + 2) % 26],\n            None => c,\n        };\n\
    \    }\n    result.iter().collect()\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpp5auh9ht.rs:12:17\n   |\n12 |     let mut d = HashMap::new();\n   |\
    \                 ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659822742
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut output = String::new();\n    let mut alphabet = vec!['a', 'b',\
    \ 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r',\
    \ 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n    for c in s.chars() {\n       \
    \ let index = alphabet.iter().position(|&x| x == c).unwrap();\n        if index\
    \ == 24 {\n            output.push(alphabet[0]);\n            output.push(alphabet[1]);\n\
    \        } else if index == 25 {\n            output.push(alphabet[0]);\n    \
    \        output.push(alphabet[2]);\n        } else {\n            output.push(alphabet[index\
    \ + 2]);\n        }\n    }\n    output\n}\n\nfn main() {\n    let candidate =\
    \ encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"\
    ));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"ewhjklnop\"\
    ));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"kj\"));\n\
    \    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"\
    faewfawefaewg\")), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpiqkhnpjk.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822742
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let t: String = s.chars().map(|c| {\n        match c {\n            '\
    \ ' => ' ',\n            _ => (((c as u8) - 'a' as u8 + 2 * 2) % 26 + 'a' as u8)\
    \ as char\n        }\n    }).collect();\n    t\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822742
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    // Write code here\n    let mut result = String::new();\n    let mut\
    \ vec: Vec<char> = s.chars().collect();\n    for c in vec {\n        result.push(if\
    \ c == 'z' {\n            'b'\n        } else if c == 'y' {\n            'a'\n\
    \        } else {\n            ((c as u8) + 2) as char\n        });\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmp_jzrhdey.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822742
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    s.chars().map(|c| match c {\n        'a'...'y' => c as u8 + 2,\n    \
    \    'z' => 'a' as u8,\n        'A'...'Y' => c as u8 + 2,\n        'Z' => 'A'\
    \ as u8,\n        _ => c as u8,\n    } as char).collect()\n}\n\nfn main() {\n\
    \    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpu9o6hzdy.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822742
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    //alphabet key\n    let mut alphabet = HashMap::new();\n    alphabet.insert('a',\
    \ 'c');\n    alphabet.insert('b', 'd');\n    alphabet.insert('c', 'e');\n    alphabet.insert('d',\
    \ 'f');\n    alphabet.insert('e', 'g');\n    alphabet.insert('f', 'h');\n    alphabet.insert('g',\
    \ 'i');\n    alphabet.insert('h', 'j');\n    alphabet.insert('i', 'k');\n    alphabet.insert('j',\
    \ 'l');\n    alphabet.insert('k', 'm');\n    alphabet.insert('l', 'n');\n    alphabet.insert('m',\
    \ 'o');\n    alphabet.insert('n', 'p');\n    alphabet.insert('o', 'q');\n    alphabet.insert('p',\
    \ 'r');\n    alphabet.insert('q', 's');\n    alphabet.insert('r', 't');\n    alphabet.insert('s',\
    \ 'u');\n    alphabet.insert('t', 'v');\n    alphabet.insert('u', 'w');\n    alphabet.insert('v',\
    \ 'x');\n    alphabet.insert('w', 'y');\n    alphabet.insert('x', 'z');\n    alphabet.insert('y',\
    \ 'a');\n    alphabet.insert('z', 'b');\n\n    //split string into an array\n\
    \    let mut split_s = s.split(\"\");\n    let mut new_string = String::new();\n\
    \n    //loop through array and encrypt letters\n    for letter in split_s {\n\
    \        match alphabet.get(&letter.to_string()) {\n            Some(x) => new_string.push_str(x),\n\
    \            None => new_string.push_str(&letter),\n        }\n    }\n    return\
    \ new_string;\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n -->\
    \ /tmp/tmpkg0o0hd5.rs:8:24\n  |\n8 |     let mut alphabet = HashMap::new();\n\
    \  |                        ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659822742
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    // TODO\n    unimplemented!()\n}\n\nfn main() {\n    let candidate =\
    \ encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"\
    ));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"ewhjklnop\"\
    ));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"kj\"));\n\
    \    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"\
    faewfawefaewg\")), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp4n104oc5.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822742
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\".to_string();\n    let mut\
    \ encrypted = \"\".to_string();\n    let mut counter = 0;\n    let count = s.len();\n\
    \    let mut rotated_alphabet = alphabet.split_off(2);\n    let rotated_alphabet\
    \ = rotated_alphabet + &alphabet[..2];\n    while counter < count {\n        let\
    \ ref c = s[counter..counter+1];\n        let ref index = alphabet.find(c).unwrap();\n\
    \        let ref encrypted_char = rotated_alphabet[*index..*index+1];\n      \
    \  encrypted = encrypted + encrypted_char;\n        counter += 1;\n    }\n   \
    \ encrypted\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpbsnsrbxq.rs:11:9\n\
    \   |\n11 |     let mut rotated_alphabet = alphabet.split_off(2);\n   |      \
    \   ----^^^^^^^^^^^^^^^^\n   |         |\n   |         help: remove this `mut`\n\
    \   |\n   = note: `#[warn(unused_mut)]` on by default\n\nerror[E0596]: cannot\
    \ borrow `alphabet` as mutable, as it is not declared as mutable\n  --> /tmp/tmpbsnsrbxq.rs:11:32\n\
    \   |\n7  |     let alphabet = \"abcdefghijklmnopqrstuvwxyz\".to_string();\n \
    \  |         -------- help: consider changing this to be mutable: `mut alphabet`\n\
    ...\n11 |     let mut rotated_alphabet = alphabet.split_off(2);\n   |        \
    \                        ^^^^^^^^ cannot borrow as mutable\n\nerror: aborting\
    \ due to previous error; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659822742
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut encrypted_string = String::new();\n    for letter in s.chars()\
    \ {\n        encrypted_string.push(match letter {\n            'A' => 'Y',\n \
    \           'B' => 'Z',\n            'C' => 'A',\n            'D' => 'B',\n  \
    \          'E' => 'C',\n            'F' => 'D',\n            'G' => 'E',\n   \
    \         'H' => 'F',\n            'I' => 'G',\n            'J' => 'H',\n    \
    \        'K' => 'I',\n            'L' => 'J',\n            'M' => 'K',\n     \
    \       'N' => 'L',\n            'O' => 'M',\n            'P' => 'N',\n      \
    \      'Q' => 'O',\n            'R' => 'P',\n            'S' => 'Q',\n       \
    \     'T' => 'R',\n            'U' => 'S',\n            'V' => 'T',\n        \
    \    'W' => 'U',\n            'X' => 'V',\n            'Y' => 'W',\n         \
    \   'Z' => 'X',\n            _ => letter,\n        });\n    }\n    encrypted_string\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmpc5y3c5jm.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822742
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut crypted_string = \"\".to_string();\n    for c in s.chars() {\n\
    \        crypted_string.push(\n            if c >= 'a' && c <= 'z' {\n       \
    \         ((c as u8 - 97 + 2*2) % 26 + 97) as char\n            } else if c >=\
    \ 'A' && c <= 'Z' {\n                ((c as u8 - 65 + 2*2) % 26 + 65) as char\n\
    \            } else {\n                c\n            }\n        );\n    }\n \
    \   crypted_string\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822742
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = encrypt;\n  \
    \  assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpgfnmb2m8.rs:7:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822741
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut res = String::new();\n    for c in s.chars() {\n        let n\
    \ = (c as u8 - b'a' + 1) * 2;\n        let n = n as u8;\n        let n = (n +\
    \ b'a' - 1) % 26 + b'a';\n        res.push(n as char);\n    }\n    res\n}\n\n\
    fn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ik\"`,\n right: `\"lm\"`', /tmp/tmp1hgvpj8w.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822742
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let bytes = s.into_bytes();\n    let mut encrypted = Vec::new();\n  \
    \  for byte in bytes {\n        encrypted.push(byte + 2 * 2);\n    }\n    String::from_utf8(encrypted).unwrap()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmplwupm38f.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822742
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut new_string = String::new();\n    for c in s.chars() {\n     \
    \   new_string.push(match c {\n            'a' => 'c',\n            'b' => 'd',\n\
    \            'c' => 'e',\n            'd' => 'f',\n            'e' => 'g',\n \
    \           'f' => 'h',\n            'g' => 'i',\n            'h' => 'j',\n  \
    \          'i' => 'k',\n            'j' => 'l',\n            'k' => 'm',\n   \
    \         'l' => 'n',\n            'm' => 'o',\n            'n' => 'p',\n    \
    \        'o' => 'q',\n            'p' => 'r',\n            'q' => 's',\n     \
    \       'r' => 't',\n            's' => 'u',\n            't' => 'v',\n      \
    \      'u' => 'w',\n            'v' => 'x',\n            'w' => 'y',\n       \
    \     'x' => 'z',\n            'y' => 'a',\n            'z' => 'b',\n        \
    \    _ => c,\n        });\n    }\n    new_string\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmp7c60068i.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822742
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let alphabets = \"abcdefghijklmnopqrstuvwxyz\".chars().collect::<Vec<char>>();\n\
    \    let mut new_string = String::new();\n    for i in s.chars() {\n        let\
    \ val = alphabets.iter().position(|x| *x == i).unwrap();\n        let encrypted_val\
    \ = (val + 2 * 2) % 26;\n        new_string.push_str(&String::from(alphabets[encrypted_val].to_string()));\n\
    \    }\n    new_string\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822742
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    s.chars().map(|c| {\n        match c {\n            ' ' => ' ',\n   \
    \         _ => {\n                let offset = (((c as u8) - b'a') + 2) % 26;\n\
    \                (b'a' + offset) as char\n            }\n        }\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpk4p1nm_3.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822742
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut result = \"\".to_string();\n    for letter in s.chars() {\n \
    \       let mut new_letter = letter as u8;\n        if new_letter >= 65 && new_letter\
    \ <= 90 {\n            new_letter = new_letter + 2;\n            if new_letter\
    \ > 90 {\n                new_letter = new_letter - 26;\n            }\n     \
    \   }\n        if new_letter >= 97 && new_letter <= 122 {\n            new_letter\
    \ = new_letter + 2;\n            if new_letter > 122 {\n                new_letter\
    \ = new_letter - 26;\n            }\n        }\n        result.push(new_letter\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmp4kc57d22.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822742
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let alphabet = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',\
    \ 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n\
    \    let mut encrypted = String::new();\n    for character in s.chars() {\n  \
    \      for i in 0..alphabet.len() {\n            if character == alphabet[i] {\n\
    \                let index = (i + (2 * 2)) % alphabet.len();\n               \
    \ encrypted.push(alphabet[index]);\n            }\n        }\n    }\n    encrypted\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822742
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut res = String::new();\n    for c in s.chars() {\n        res.push(((c\
    \ as u8) + 2*2) as char);\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpsa5bfq9s.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822742
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    s.bytes().map(|b| if b == b'z' {\n        b'a'\n    } else if b == b'Z'\
    \ {\n        b'A'\n    } else if b > b'Z' && b < b'z' {\n        b + 2\n    }\
    \ else if b == b'Y' {\n        b'A'\n    } else if b == b'y' {\n        b'a'\n\
    \    } else {\n        b + 4\n    } as char).collect()\n}\n\nfn main() {\n   \
    \ let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpt4hd23su.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822742
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut ret = String::new();\n    for c in s.chars() {\n        if c.is_ascii_alphabetic()\
    \ {\n            let c = match c {\n                'a'..='z' => c as u8 + 2,\n\
    \                'A'..='Z' => c as u8 + 2,\n                _ => c as u8,\n  \
    \          };\n            ret.push(if c > 'z' as u8 {\n                (c - 26)\
    \ as char\n            } else {\n                c as char\n            })\n \
    \       } else {\n            ret.push(c);\n        }\n    }\n    ret\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmplo55nt5f.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822742
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut res = String::new();\n    for c in s.chars() {\n        if c\
    \ == ' ' {\n            res.push(' ');\n        } else {\n            let c_new\
    \ = c as u8 + 2;\n            let c_new = if c_new > 122 {\n                ((c_new\
    \ - 122) + 96) as char\n            } else {\n                c_new as char\n\
    \            };\n            res.push(c_new);\n        }\n    }\n    res\n}\n\n\
    fn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmplesbvnbf.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822742
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n  let alphabets = \"abcdefghijklmnopqrstuvwxyz\".to_string();\n  let encrypted_alphabets\
    \ = \"cdefghijklmnopqrstuvwxyzab\".to_string();\n  let mut encrypted_string =\
    \ \"\".to_string();\n  for c in s.chars() {\n    let index = alphabets.find(c).unwrap();\n\
    \    encrypted_string.push(encrypted_alphabets.chars().nth(index).unwrap());\n\
    \  }\n  encrypted_string\n}\n\nfn main() {\n    let candidate = encrypt;\n   \
    \ assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmp5_xho3l2.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822742
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    /// encrypt(\"Hello World!\") => \"Jgnnq Yqtnf!\"\n    s.chars().map(|c|{\n\
    \        (c as u8 + 2*2) as char\n    }).collect()\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmprq_i3u8c.rs:19:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822742
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    s.chars().map(|ch| {\n        let ascii = (ch as u8) + 4;\n        ascii\
    \ as char\n    }).collect()\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpkamfv80e.rs:19:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822742
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let encrypted = String::new();\n    for c in s.chars() {\n        let\
    \ upper = c.is_uppercase();\n        let c = c.to_ascii_lowercase();\n       \
    \ if c == 'z' {\n            encrypted.push('b');\n        } else if c == 'y'\
    \ {\n            encrypted.push('a');\n        } else {\n            encrypted.push((c\
    \ as u8 + 2) as char);\n        }\n        if upper {\n            encrypted.push(encrypted.pop().unwrap().to_ascii_uppercase());\n\
    \        }\n    }\n    encrypted\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `encrypted` as mutable, as it is not declared\
    \ as mutable\n  --> /tmp/tmpgz_tl0ph.rs:12:13\n   |\n7  |     let encrypted =\
    \ String::new();\n   |         --------- help: consider changing this to be mutable:\
    \ `mut encrypted`\n...\n12 |             encrypted.push('b');\n   |          \
    \   ^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `encrypted`\
    \ as mutable, as it is not declared as mutable\n  --> /tmp/tmpgz_tl0ph.rs:14:13\n\
    \   |\n7  |     let encrypted = String::new();\n   |         --------- help: consider\
    \ changing this to be mutable: `mut encrypted`\n...\n14 |             encrypted.push('a');\n\
    \   |             ^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow\
    \ `encrypted` as mutable, as it is not declared as mutable\n  --> /tmp/tmpgz_tl0ph.rs:16:13\n\
    \   |\n7  |     let encrypted = String::new();\n   |         --------- help: consider\
    \ changing this to be mutable: `mut encrypted`\n...\n16 |             encrypted.push((c\
    \ as u8 + 2) as char);\n   |             ^^^^^^^^^ cannot borrow as mutable\n\n\
    error[E0596]: cannot borrow `encrypted` as mutable, as it is not declared as mutable\n\
    \  --> /tmp/tmpgz_tl0ph.rs:19:13\n   |\n7  |     let encrypted = String::new();\n\
    \   |         --------- help: consider changing this to be mutable: `mut encrypted`\n\
    ...\n19 |             encrypted.push(encrypted.pop().unwrap().to_ascii_uppercase());\n\
    \   |             ^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow\
    \ `encrypted` as mutable, as it is not declared as mutable\n  --> /tmp/tmpgz_tl0ph.rs:19:28\n\
    \   |\n7  |     let encrypted = String::new();\n   |         --------- help: consider\
    \ changing this to be mutable: `mut encrypted`\n...\n19 |             encrypted.push(encrypted.pop().unwrap().to_ascii_uppercase());\n\
    \   |                            ^^^^^^^^^ cannot borrow as mutable\n\nerror[E0499]:\
    \ cannot borrow `encrypted` as mutable more than once at a time\n  --> /tmp/tmpgz_tl0ph.rs:19:28\n\
    \   |\n19 |             encrypted.push(encrypted.pop().unwrap().to_ascii_uppercase());\n\
    \   |             --------- ---- ^^^^^^"
  stdout: ''
  timestamp: 1659822742
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let a = b'a';\n    let z = b'z';\n    let A = b'A';\n    let Z = b'Z';\n\
    \    let offset = 2 * 2;\n    let mut out = String::new();\n    for b in s.as_bytes()\
    \ {\n        let ret = match *b {\n            i if (i >= a && i < a + offset)\
    \ => {\n                let x = i + (26 - offset);\n                x as char\n\
    \            },\n            i if (i >= a + offset && i <= z) => {\n         \
    \       let x = i - offset;\n                x as char\n            },\n     \
    \       i if (i >= A && i < A + offset) => {\n                let x = i + (26\
    \ - offset);\n                x as char\n            },\n            i if (i >=\
    \ A + offset && i <= Z) => {\n                let x = i - offset;\n          \
    \      x as char\n            },\n            _ => {\n                *b as char\n\
    \            }\n        };\n        out.push(ret);\n    }\n    out\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"de\"`,\n right: `\"lm\"`', /tmp/tmpb65jj_uo.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822742
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n  let alphabet = String::from(\"abcdefghijklmnopqrstuvwxyz\");\n  let mut\
    \ e_message = String::new();\n  let sl = s.to_lowercase();\n  for i in sl.chars()\
    \ {\n    let mut index = alphabet.find(i).unwrap();\n    index += 4;\n    if index\
    \ > 25 {\n      index = index - 26;\n    }\n    e_message.push(alphabet.chars().nth(index).unwrap());\n\
    \  }\n  e_message\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822742
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n    let mut coded = String::new();\n\
    \    for c in s.chars() {\n        let key = alphabet.chars().position(|x| x ==\
    \ c).unwrap();\n        let real_key = (key + 2) * 2;\n        coded.push(alphabet.chars().nth(real_key).unwrap());\n\
    \    }\n    coded\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"su\"`,\n right: `\"lm\"`', /tmp/tmpzvzqcrvj.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822742
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    s.chars().map(|c| {\n        // LETTERS_IN_ALPHABET is 26, to wrap around\
    \ add it to the position\n        // in the alphabet.\n        match c {\n   \
    \         'A' ... 'Z' => ((c as u8 - 'A' as u8 + 4) % LETTERS_IN_ALPHABET as u8\
    \ + 'A' as u8) as char,\n            'a' ... 'z' => ((c as u8 - 'a' as u8 + 4)\
    \ % LETTERS_IN_ALPHABET as u8 + 'a' as u8) as char,\n            _ => c\n    \
    \    }\n    }).collect()\n}\n\nfn main() {\n    let candidate = encrypt;\n   \
    \ assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `LETTERS_IN_ALPHABET` in this scope\n \
    \ --> /tmp/tmpt6bmx1iy.rs:11:57\n   |\n11 |             'A' ... 'Z' => ((c as\
    \ u8 - 'A' as u8 + 4) % LETTERS_IN_ALPHABET as u8 + 'A' as u8) as char,\n   |\
    \                                                         ^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `LETTERS_IN_ALPHABET`\
    \ in this scope\n  --> /tmp/tmpt6bmx1iy.rs:12:57\n   |\n12 |             'a' ...\
    \ 'z' => ((c as u8 - 'a' as u8 + 4) % LETTERS_IN_ALPHABET as u8 + 'a' as u8) as\
    \ char,\n   |                                                         ^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nwarning: `...` range patterns are deprecated\n  -->\
    \ /tmp/tmpt6bmx1iy.rs:11:17\n   |\n11 |             'A' ... 'Z' => ((c as u8 -\
    \ 'A' as u8 + 4) % LETTERS_IN_ALPHABET as u8 + 'A' as u8) as char,\n   |     \
    \            ^^^ help: use `..=` for an inclusive range\n   |\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]`\
    \ on by default\n   = warning: this is accepted in the current edition (Rust 2015)\
    \ but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nwarning: `...` range patterns are deprecated\n  --> /tmp/tmpt6bmx1iy.rs:12:17\n\
    \   |\n12 |             'a' ... 'z' => ((c as u8 - 'a' as u8 + 4) % LETTERS_IN_ALPHABET\
    \ as u8 + 'a' as u8) as char,\n   |                 ^^^ help: use `..=` for an\
    \ inclusive range\n   |\n   = warning: this is accepted in the current edition\
    \ (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information,\
    \ see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822742
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    s.chars().map(|c| {\n        (c as u8 + 2*2) as char\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpv28v2r7q.rs:18:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822742
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    s.chars().map(|c| {\n        if c.is_ascii_alphabetic() {\n         \
    \   let base = if c.is_ascii_lowercase() {\n                b'a'\n           \
    \ } else {\n                b'A'\n            };\n            let index = (c as\
    \ u8 - base + (2*2)) % 26;\n            (index + base) as char\n        } else\
    \ {\n            c\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822742
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let alpha = \"abcdefghijklmnopqrstuvwxyz\".chars().collect::<Vec<char>>();\n\
    \    let alpha2 = alpha.clone();\n    let mut count = 0;\n    let mut ans = String::new();\n\
    \    for i in s.chars() {\n        let index = alpha.iter().position(|&x| x ==\
    \ i).unwrap();\n        ans.push(alpha2[(index + (4 * count)) % 26]);\n      \
    \  count += 1;\n    }\n    ans\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hm\"`,\n right: `\"lm\"`', /tmp/tmp6gm92mkk.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822742
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut result = String::new();\n    for c in s.chars() {\n        if\
    \ c.is_alphabetic() {\n            if c.is_uppercase() {\n                result.push(((c\
    \ as u8 - 65 + 2) % 26 + 65) as char);\n            } else {\n               \
    \ result.push(((c as u8 - 97 + 2) % 26 + 97) as char);\n            }\n      \
    \  } else {\n            result.push(c);\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmp00dmovqi.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822742
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = encrypt;\n \
    \   assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpo8narrt0.rs:7:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822741
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut res = String::new();\n    for c in s.chars() {\n        if c.is_alphabetic()\
    \ {\n            let shifted = c as u8 + (2 * 2);\n            let letter = \n\
    \                if shifted > 122 {\n                    shifted - 26\n      \
    \          } else {\n                    shifted\n                };\n       \
    \     res.push(letter as char);\n        } else {\n            res.push(c);\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = encrypt;\n \
    \   assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822742
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut result = String::new();\n    for c in s.chars() {\n        result.push(match\
    \ c {\n            'a' => 'c',\n            'A' => 'C',\n            'b' => 'd',\n\
    \            'B' => 'D',\n            'c' => 'e',\n            'C' => 'E',\n \
    \           'd' => 'f',\n            'D' => 'F',\n            'e' => 'g',\n  \
    \          'E' => 'G',\n            'f' => 'h',\n            'F' => 'H',\n   \
    \         'g' => 'i',\n            'G' => 'I',\n            'h' => 'j',\n    \
    \        'H' => 'J',\n            'i' => 'k',\n            'I' => 'K',\n     \
    \       'j' => 'l',\n            'J' => 'L',\n            'k' => 'm',\n      \
    \      'K' => 'M',\n            'l' => 'n',\n            'L' => 'N',\n       \
    \     'm' => 'o',\n            'M' => 'O',\n            'n' => 'p',\n        \
    \    'N' => 'P',\n            'o' => 'q',\n            'O' => 'Q',\n         \
    \   'p' => 'r',\n            'P' => 'R',\n            'q' => 's',\n          \
    \  'Q' => 'S',\n            'r' => 't',\n            'R' => 'T',\n           \
    \ 's' => 'u',\n            'S' => 'U',\n            't' => 'v',\n            'T'\
    \ => 'V',\n            'u' => 'w',\n            'U' => 'W',\n            'v' =>\
    \ 'x',\n            'V' => 'X',\n            'w' => 'y',\n            'W' => 'Y',\n\
    \            'x' => 'z',\n            'X' => 'Z',\n            'y' => 'a',\n \
    \           'Y' => 'A',\n            'z' => 'b',\n            'Z' => 'B',\n  \
    \          _ => c,\n        });\n    }\n   \n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw9zmynun.rs:8:5\n   |\n6\
    \  |   fn encrypt(s: String) -> String {\n   |                            ------\
    \ expected `String` because of return type\n7  |       let mut result = String::new();\n\
    8  | /     for c in s.chars() {\n9  | |         result.push(match c {\n10 | |\
    \             'a' => 'c',\n11 | |             'A' => 'C',\n...  |\n63 | |    \
    \     });\n64 | |     }\n   | |_____^ expected struct `String`, found `()`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659822742
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    \"\".to_string()\n}\n\nfn main() {\n    let candidate = encrypt;\n  \
    \  assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"lm\"`', /tmp/tmp24l3446k.rs:12:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822742
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = encrypt;\n  \
    \  assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpgfnmb2m8.rs:7:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822741
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    for c in s.chars() {\n        let x = c as u8;\n        if x >= 65 &&\
    \ x <= 77 {\n            //println!(\"{}\", x + 23);\n        }\n        else\
    \ if x >= 78 && x <= 90 {\n            //println!(\"{}\", x - 23);\n        }\n\
    \        else if x >= 97 && x <= 109 {\n            //println!(\"{}\", x + 23);\n\
    \        }\n        else if x >= 110 && x <= 122 {\n            //println!(\"\
    {}\", x - 23);\n        }\n        else {\n            //println!(\"{}\", x);\n\
    \        }\n    }\n    s\n}\n\nfn main() {\n    let candidate = encrypt;\n   \
    \ assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmpnz57llcj.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822742
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    s.chars().map(|c| {\n        let mut c_int = c as u8;\n        if c_int\
    \ >= 65 && c_int <= 90 {\n            c_int += 4;\n            if c_int > 90 {\n\
    \                c_int -= 26;\n            }\n        } else if c_int >= 97 &&\
    \ c_int <= 122 {\n            c_int += 4;\n            if c_int > 122 {\n    \
    \            c_int -= 26;\n            }\n        }\n        c_int as char\n \
    \   }).collect()\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822742
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = encrypt;\n  \
    \  assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpgfnmb2m8.rs:7:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822741
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut encrypted_string = String::new();\n    for i in s.chars() {\n\
    \        let mut char_num = i as u8;\n        if char_num >= 65 && char_num <=\
    \ 90 {\n            char_num = ((char_num - 65 + 65) % 26) + 65;\n        } else\
    \ if char_num >= 97 && char_num <= 122 {\n            char_num = ((char_num -\
    \ 97 + 65) % 26) + 97;\n        }\n        encrypted_string.push(char_num as char);\n\
    \    }\n    encrypted_string\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"uv\"`,\n right: `\"lm\"`', /tmp/tmpkdkgsk8j.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822742
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    s.chars().map(|c| {\n        let new_c = ((c as u8 - 'a' as u8) + 2)\
    \ % 26 + 'a' as u8;\n        new_c as char\n    }).collect()\n}\n\nfn main() {\n\
    \    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpck0wy8l3.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822743
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let letters = alphabet();\n    let mut encrypted_string = String::new();\n\
    \    for c in s.chars() {\n        let idx = letters.iter().position(|&letter|\
    \ letter == c).unwrap();\n        let new_idx = (idx + (2 * 2)) % 26;\n      \
    \  encrypted_string.push(letters[new_idx]);\n    }\n    encrypted_string\n}\n\n\
    fn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `alphabet` in this scope\n --> /tmp/tmp2t0fvhwx.rs:7:19\n\
    \  |\n7 |     let letters = alphabet();\n  |                   ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822742
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\nfn encrypt(s: String) -> String\
    \ {\n    let mut encr = String::new();\n    for c in s.chars() {\n        let\
    \ n = (c as u8 + 2 * 2) as char;\n        encr.push(n);\n    }\n    encr\n}\n\n\
    fn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp__ku7bcj.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822743
