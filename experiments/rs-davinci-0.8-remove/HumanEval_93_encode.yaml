name: HumanEval_93_encode
language: rs
prompt: "/// Write a function that takes a message, and encodes in such a \n/// way\
  \ that it swaps case of all letters, replaces all vowels in \n/// the message with\
  \ the letter that appears 2 places ahead of that \n/// vowel in the english alphabet.\
  \ \n/// Assume only letters. \n/// Examples:\nfn encode(message: String) -> String\
  \ {\n"
tests: "}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
  TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
  )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")),\
  \ String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\"\
  )), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
  I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
completions: ["    let mut res = String::new();\n    for c in message.chars() {\n\
    \        if ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') {\n            if\
    \ c.is_lowercase() {\n                res.push(c.to_uppercase().next().unwrap());\n\
    \            } else {\n                res.push(c.to_lowercase().next().unwrap());\n\
    \            }\n        } else {\n            res.push(c);\n        }\n    }\n\
    \    res", "    let mut result = message.chars().map(|c| {\n        match c {\n\
    \            'a' => 'c',\n            'e' => 'g',\n            'i' => 'k',\n \
    \           'o' => 'q',\n            'u' => 'y',\n            c if c.is_ascii_uppercase()\
    \ => c.to_ascii_lowercase(),\n            c if c.is_ascii_lowercase() => c.to_ascii_uppercase(),\n\
    \            _ => c,\n        }\n    }).collect::<String>();\n    result", " \
    \   let mut encoded_message = String::new();\n    for character in message.chars()\
    \ {\n        if is_vowel(character) {\n            encoded_message.push(get_next_vowel(character));\n\
    \        } else if is_uppercase(character) {\n            encoded_message.push(character.to_lowercase().next().unwrap());\n\
    \        } else {\n            encoded_message.push(character.to_uppercase().next().unwrap());\n\
    \        }\n    }\n    encoded_message", "    let encoded_message = message.chars().map(|c|\
    \ {\n        let new_c = match c {\n            'a' => 'c',\n            'e' =>\
    \ 'g',\n            'i' => 'k',\n            'o' => 'q',\n            'u' => 'w',\n\
    \            'A' => 'C',\n            'E' => 'G',\n            'I' => 'K',\n \
    \           'O' => 'Q',\n            'U' => 'W',\n            _ => c,\n      \
    \  };\n        new_c\n    }).collect::<String>();\n    encoded_message", "   \
    \ let mut code = String::new();\n    let vowels = [\n        'a', 'e', 'i', 'o',\
    \ 'u', 'A', 'E', 'I', 'O', 'U'\n    ];\n    for c in message.chars() {\n     \
    \   if c == 'z' {\n            code.push('a');\n        } else if c == 'Z' {\n\
    \            code.push('A');\n        } else if vowels.contains(&c) {\n      \
    \      code.push((c as u8 + 2) as char);\n        } else if c.is_uppercase() {\n\
    \            code.push(c.to_lowercase().next().unwrap());\n        } else if c.is_lowercase()\
    \ {\n            code.push(c.to_uppercase().next().unwrap());\n        } else\
    \ {\n            code.push(c);\n        }\n    }\n    code", "    let chars: Vec<char>\
    \ = message.chars().collect();\n    let mut output = String::new();\n    for c\
    \ in chars {\n        let mut temp = c;\n        if c.is_alphabetic() {\n    \
    \        if c.is_lowercase() {\n                temp = c.to_uppercase().nth(0).unwrap();\n\
    \            } else {\n                temp = c.to_lowercase().nth(0).unwrap();\n\
    \            }\n            if temp == 'A' {\n                temp = 'C';\n  \
    \          } else if temp == 'B' {\n                temp = 'D';\n            }\
    \ else if temp == 'C' {\n                temp = 'E';\n            } else if temp\
    \ == 'D' {\n                temp = 'F';\n            } else if temp == 'E' {\n\
    \                temp = 'G';\n            } else if temp == 'F' {\n          \
    \      temp = 'H';\n            } else if temp == 'G' {\n                temp\
    \ = 'I';\n            } else if temp == 'H' {\n                temp = 'J';\n \
    \           } else if temp == 'I' {\n                temp = 'K';\n           \
    \ } else if temp == 'J' {\n                temp = 'L';\n            } else if\
    \ temp == 'K' {\n                temp = 'M';\n            } else if temp == 'L'\
    \ {\n                temp = 'N';\n            } else if temp == 'M' {\n      \
    \          temp = 'O';\n            } else if temp == 'N' {\n                temp\
    \ = 'P';\n            } else if temp == 'O' {\n                temp = 'Q';\n \
    \           } else if temp == 'P' {\n                temp = 'R';\n           \
    \ } else if temp == 'Q' {\n                temp = 'S';\n            } else if\
    \ temp == 'R' {\n                temp = 'T';\n            } else if temp == 'S'\
    \ {\n                temp = 'U';\n            } else if temp == 'T' {\n      \
    \          temp = 'V';\n            } else if temp == 'U' {\n                temp\
    \ = 'W';\n            } else if temp == 'V' {\n                temp = 'X';\n \
    \           } else if temp ==", "    let n = message.len();\n    let mut encoded\
    \ = String::with_capacity(n);\n    for ch in message.chars() {\n        if ch.is_lowercase()\
    \ {\n            encoded.push(ch.to_uppercase().next().unwrap());\n        } else\
    \ if ch.is_uppercase() {\n            encoded.push(ch.to_lowercase().next().unwrap());\n\
    \        } else {\n            encoded.push(ch);\n        }\n    }\n    let mut\
    \ vowels = [false; 5];\n    vowels[0] = true; //a\n    vowels[2] = true; //e\n\
    \    vowels[4] = true; //i\n    vowels[1] = true; //o\n    vowels[3] = true; //u\n\
    \    for (i, ch) in encoded.chars().enumerate() {\n        if ch == 'a' {\n  \
    \          encoded.replace_range(i..i+1, \"c\");\n        } else if ch == 'e'\
    \ {\n            encoded.replace_range(i..i+1, \"g\");\n        } else if ch ==\
    \ 'i' {\n            encoded.replace_range(i..i+1, \"k\");\n        } else if\
    \ ch == 'o' {\n            encoded.replace_range(i..i+1, \"q\");\n        } else\
    \ if ch == 'u' {\n            encoded.replace_range(i..i+1, \"s\");\n        }\n\
    \    }\n    encoded", "    let mut encoded_message = String::new();\n    let vowels\
    \ = String::from(\"aeiou\");\n    let mut alphabet = String::from(\"abcdefghijklmnopqrstuvwxyz\"\
    );\n    alphabet.push_str(\"abcdefghijklmnopqrstuvwxyz\");\n    for c in message.chars()\
    \ {\n        let idx = vowels.find(c);\n        if idx.is_some() {\n         \
    \   let idx = idx.unwrap();\n            encoded_message.push(alphabet.chars().nth(idx\
    \ + 2).unwrap());\n        } else {\n            encoded_message.push(c);\n  \
    \      }\n    }\n    encoded_message", "    if message.is_empty() {\n        return\
    \ message;\n    }\n\n    let mut encoded = String::new();\n    for c in message.chars()\
    \ {\n        encoded.push(match c {\n            'a' => 'c',\n            'e'\
    \ => 'g',\n            'i' => 'k',\n            'o' => 'q',\n            'u' =>\
    \ 'y',\n            _ if c.is_ascii_uppercase() => c.to_ascii_lowercase(),\n \
    \           _ if c.is_ascii_lowercase() => c.to_ascii_uppercase(),\n         \
    \   _ => c,\n        });\n    }\n    encoded", "    let mut result = String::new();\n\
    \    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    for i in message.chars()\
    \ {\n        if vowels.contains(&i) {\n            result.push(((i as u8) + 2)\
    \ as char);\n        } else {\n            result.push(i);\n        }\n    }\n\
    \    result", "    message.chars().map(|c| {\n        let n = match c {\n    \
    \        'a' | 'e' | 'i' | 'o' | 'u' => 2,\n            'A' | 'E' | 'I' | 'O'\
    \ | 'U' => 2,\n            _ => 0,\n        };\n        match c {\n          \
    \  'a'...'z' => ('a' as u8 + ((c as u8 - 'a' as u8 + n) % 26)) as char,\n    \
    \        'A'...'Z' => ('A' as u8 + ((c as u8 - 'A' as u8 + n) % 26)) as char,\n\
    \            _ => c,\n        }\n    }).collect()", "    // message.\n    // let\
    \ v = vec!['a', 'e', 'i', 'o', 'u'];\n    // let letters = b'a'..=b'z';\n    //\
    \ let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let v = \"aeiou\".to_string();\n\
    \    let mut result = String::new();\n    for c in message.chars() {\n       \
    \ if v.contains(c) {\n            // let t = c as u8;\n            // let mut\
    \ t = c;\n            let mut t = c as u8;\n            t += 2;\n            //\
    \ if t > b'u' {\n            //     t -= 4;\n            // }\n            if\
    \ t > 117 {\n                t -= 4;\n            }\n            let t = char::from(t);\n\
    \            result.push(t);\n        } else {\n            if c >= 'a' && c <=\
    \ 'z' {\n                // let t = c as u8;\n                // t += 32;\n  \
    \              // let t = char::from(t);\n                // result.push(t);\n\
    \                result.push(c.to_ascii_uppercase());\n            } else {\n\
    \                result.push(c);\n            }\n        }\n    }\n    result",
  "    // YOUR CODE HERE\n    unimplemented!();", "    let mut result = String::new();\n\
    \    let message_chars: Vec<char> = message.chars().collect();\n    for c in message_chars\
    \ {\n        match c {\n            'a' => result.push('c'),\n            'e'\
    \ => result.push('g'),\n            'i' => result.push('k'),\n            'o'\
    \ => result.push('q'),\n            'u' => result.push('s'),\n            'A'\
    \ => result.push('C'),\n            'E' => result.push('G'),\n            'I'\
    \ => result.push('K'),\n            'O' => result.push('Q'),\n            'U'\
    \ => result.push('S'),\n            _ => result.push(c),\n        }\n    }\n \
    \   result", "    let mut out: String = String::new();\n    let vowels = \"aeiou\"\
    ;\n    let mut characters = message.chars();\n    while let Some(character) =\
    \ characters.next() {\n        if character.is_ascii_uppercase() {\n         \
    \   let lower = character.to_ascii_lowercase();\n            if vowels.contains(lower)\
    \ {\n                let vowels = \"aeiou\".chars();\n                let mut\
    \ offset = 0;\n                while let Some(vowel) = vowels.next() {\n     \
    \               if vowel == lower {\n                        break;\n        \
    \            }\n                    offset += 1;\n                }\n        \
    \        offset += 2;\n                let vowels = \"aeiou\".chars();\n     \
    \           let mut new_char = 'a';\n                for vowel in vowels {\n \
    \                   if offset == 0 {\n                        new_char = vowel;\n\
    \                        break;\n                    }\n                    offset\
    \ -= 1;\n                }\n                out.push(new_char.to_ascii_uppercase());\n\
    \            } else {\n                out.push(character);\n            }\n \
    \       } else if character.is_ascii_lowercase() {\n            let upper = character.to_ascii_uppercase();\n\
    \            if vowels.contains(upper) {\n                let vowels = \"aeiou\"\
    .chars();\n                let mut offset = 0;\n                while let Some(vowel)\
    \ = vowels.next() {\n                    if vowel == upper {\n               \
    \         break;\n                    }\n                    offset += 1;\n  \
    \              }\n                offset += 2;\n                let vowels = \"\
    aeiou\".chars();\n                let mut new_char = 'a';\n                for\
    \ vowel in vowels {\n                    if offset == 0 {\n                  \
    \      new_char = vowel;\n                        break;\n                   \
    \ }\n                    offset -= 1;\n                }\n                out.push(new_char);\n\
    \            } else {\n                out.push(character);\n            }\n \
    \       } else {\n            out.push(character);\n        }\n    }\n    out",
  "    let mut result = String::new();\n    for c in message.chars() {\n        let\
    \ c = if c.is_lowercase() {\n            c.to_uppercase().next().unwrap()\n  \
    \      } else {\n            c.to_lowercase().next().unwrap()\n        };\n  \
    \      result.push(match c {\n            'A' => 'C',\n            'E' => 'G',\n\
    \            'I' => 'K',\n            'O' => 'Q',\n            'U' => 'Y',\n \
    \           _ => c,\n        });\n    }\n    result", "    let code = message.as_bytes();\n\
    \    let mut encoded = String::new();\n    let mut pos:usize = 0;\n    while pos\
    \ < code.len() {\n        let i = code[pos];\n        if i >= b'a' && i <= b'z'\
    \ {\n            encoded.push((i - b'a' + b'A') as char);\n        } else if i\
    \ >= b'A' && i <= b'Z' {\n            encoded.push((i - b'A' + b'a') as char);\n\
    \        } else if i == b' ' {\n            encoded.push(' ');\n        } else\
    \ if i == b'Z' {\n            encoded.push('A');\n        } else if i == b'z'\
    \ {\n            encoded.push('a');\n        } else {\n            let c = (i\
    \ + 2) as char;\n            encoded.push(c);\n        }\n        pos += 1;\n\
    \    }\n    encoded", "    let mut result = String::new();\n    for c in message.chars()\
    \ {\n        let c_lowercase = c.to_lowercase().to_string();\n        if \"aeiou\"\
    .contains(c_lowercase.as_str()) {\n            let next_two = c_lowercase.chars().nth(2).unwrap().to_string();\n\
    \            if c.is_lowercase() {\n                result.push_str(next_two.as_str());\n\
    \            } else {\n                result.push_str(next_two.to_uppercase().as_str());\n\
    \            }\n        } else {\n            result.push(c);\n        }\n   \
    \ }\n    result", '    unimplemented!()', "    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    .chars().collect::<Vec<char>>();\n    let vowels = \"aeiou\".chars().collect::<Vec<char>>();\n\
    \    let mut encoded_message = String::new();\n    for letter in message.chars()\
    \ {\n        let letter_lower = letter.to_lowercase().collect::<Vec<char>>()[0];\n\
    \        if let Some(idx) = alphabet.iter().position(|&r| r == letter_lower) {\n\
    \            if vowels.contains(&letter_lower) {\n                let mut new_letter\
    \ = alphabet[(idx + 2) % alphabet.len()];\n                if letter.is_uppercase()\
    \ {\n                    new_letter = new_letter.to_uppercase().collect::<Vec<char>>()[0];\n\
    \                }\n                encoded_message.push(new_letter);\n      \
    \      } else {\n                let new_letter = if letter.is_uppercase() {\n\
    \                    alphabet[idx].to_uppercase().collect::<Vec<char>>()[0]\n\
    \                } else {\n                    alphabet[idx]\n               \
    \ };\n                encoded_message.push(new_letter);\n            }\n     \
    \   }\n    }\n    encoded_message", "    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    .chars().collect::<Vec<char>>();\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n\
    \    let mut encoded = String::new();\n    let lowercase_message = message.to_lowercase();\n\
    \    for c in lowercase_message.chars() {\n        if alphabet.contains(&c) {\n\
    \            let i = alphabet.iter().position(|x| *x == c).unwrap();\n       \
    \     let new_c = if vowels.contains(&c) {\n                if i + 2 > alphabet.len()\
    \ - 1 {\n                    alphabet[(i + 2) - alphabet.len()]\n            \
    \    } else {\n                    alphabet[i + 2]\n                }\n      \
    \      } else {\n                alphabet[i]\n            };\n            encoded.push(new_c);\n\
    \        } else {\n            encoded.push(c);\n        }\n    }\n    encoded",
  "    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    message.chars().map(|c| {\n  \
    \      if c.is_alphabetic() {\n            let offset = if c.is_lowercase() {\
    \ 'a' } else { 'A' };\n            let mut char_offset = (c as u8 - offset as\
    \ u8 + 2) % 26;\n            if char_offset == 0 {\n                char_offset\
    \ = 26;\n            }\n            if vowels.contains(&(offset as char + char_offset\
    \ as char)) {\n                char_offset += 1;\n            }\n            (offset\
    \ as u8 + char_offset) as char\n        } else {\n            c\n        }\n \
    \   }).collect()", "    let message_bytes = message.as_bytes();\n    let mut result:\
    \ Vec<u8> = Vec::new();\n    for &byte in message_bytes {\n        match byte\
    \ {\n            x if x >= 97 && x <= 122 => {\n                result.push(x\
    \ - 32);\n            },\n            x if x >= 65 && x <= 90 => {\n         \
    \       result.push(x + 32);\n            },\n            x => {\n           \
    \     result.push(x);\n            }\n        }\n    }\n    let result_message\
    \ = String::from_utf8(result).unwrap();\n    let mut encoded: Vec<u8> = Vec::new();\n\
    \    for character in result_message.chars() {\n        match character {\n  \
    \          'a' => {\n                encoded.push(b'c');\n            },\n   \
    \         'e' => {\n                encoded.push(b'g');\n            },\n    \
    \        'i' => {\n                encoded.push(b'k');\n            },\n     \
    \       'o' => {\n                encoded.push(b'm');\n            },\n      \
    \      'u' => {\n                encoded.push(b'w');\n            },\n       \
    \     x => {\n                encoded.push(x as u8);\n            }\n        }\n\
    \    }\n    String::from_utf8(encoded).unwrap()", "    let mut result = String::new();\n\
    \    for ch in message.chars() {\n        if ch.is_ascii_uppercase() {\n     \
    \       result.push(ch.to_ascii_lowercase());\n        } else if ch.is_ascii_lowercase()\
    \ {\n            result.push(ch.to_ascii_uppercase());\n        } else {\n   \
    \         result.push(ch);\n        }\n    }\n    result", "    let mut res =\
    \ String::new();\n    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    for c in message.chars()\
    \ {\n        match c {\n            c if c.is_lowercase() => res.push(c.to_uppercase().next().unwrap()),\n\
    \            c if c.is_uppercase() => res.push(c.to_lowercase().next().unwrap()),\n\
    \            c if vowels.contains(&c) => {\n                let index = vowels.iter().position(|x|\
    \ *x == c).unwrap();\n                res.push(vowels[(index + 2) % vowels.len()]);\n\
    \            },\n            _ => res.push(c),\n        }\n    }\n    res", " \
    \   let mut encoded = String::new();\n    let mut in_vowel = false;\n    for letter\
    \ in message.chars() {\n        if !letter.is_alphabetic() {\n            encoded.push(letter);\n\
    \            continue;\n        }\n        if !in_vowel {\n            encoded.push(letter.to_uppercase().to_string());\n\
    \        } else {\n            encoded.push(letter.to_lowercase().to_string());\n\
    \        }\n        match letter {\n            'a' => encoded.push_str(\"c\"\
    ),\n            'e' => encoded.push_str(\"g\"),\n            'i' => encoded.push_str(\"\
    k\"),\n            'o' => encoded.push_str(\"q\"),\n            'u' => encoded.push_str(\"\
    s\"),\n            _ => {}\n        }\n        in_vowel = !in_vowel;\n    }\n\
    \    encoded", "    let mut encoded_message = String::from(\"\");\n    let vowels\
    \ = ['a', 'e', 'i', 'o', 'u'];\n    for character in message.chars() {\n     \
    \   if character.is_alphabetic() {\n            if vowels.contains(&character)\
    \ {\n                encoded_message.push(find_next_vowel(character));\n     \
    \       } else {\n                encoded_message.push(character.to_lowercase().next().unwrap());\n\
    \            }\n        } else {\n            encoded_message.push(character);\n\
    \        }\n    }\n    encoded_message", '    String::from("Encoded message")',
  "\tlet mut res: String = String::new();\n\tlet vowels = vec!['a', 'e', 'i', 'o',\
    \ 'u'];\n\tlet mut count = 0;\n\tfor letter in message.chars() {\n\t\tlet mut\
    \ l = letter;\n\t\tif l.is_ascii_uppercase() {\n\t\t\tl = l.to_ascii_lowercase();\n\
    \t\t}\n\t\tif vowels.contains(&l) {\n\t\t\tlet mut i = 0;\n\t\t\tfor v in vowels.iter()\
    \ {\n\t\t\t\tif l == *v {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ti += 1;\n\t\t\t\
    }\n\t\t\tif i == 4 {\n\t\t\t\tl = vowels[0];\n\t\t\t} else {\n\t\t\t\tl = vowels[i\
    \ + 1];\n\t\t\t}\n\t\t}\n\t\tif count % 2 == 0 {\n\t\t\tl = l.to_ascii_uppercase();\n\
    \t\t}\n\t\tres.push(l);\n\t\tcount += 1;\n\t}\n\tres", "  let mut encoded = String::new();\n\
    \  for c in message.chars() {\n    if c.is_ascii_lowercase() {\n      encoded.push(c.to_ascii_uppercase());\n\
    \    } else if c.is_ascii_uppercase() {\n      encoded.push(c.to_ascii_lowercase());\n\
    \    } else {\n      encoded.push(c);\n    }\n  }\n  encoded", "    let mut result\
    \ = message.to_owned();\n    result.make_ascii_lowercase();\n    result.chars().map(|c|\
    \ {\n        match c {\n            'a' => 'c',\n            'e' => 'g',\n   \
    \         'i' => 'k',\n            'o' => 'q',\n            'u' => 'y',\n    \
    \        _ => c,\n        }\n    }).collect()", '    unimplemented!()', "    //1.\
    \ Split the string into individual characters\n    //2. Iterate through the chars\
    \ using enumerate\n    //3. Check if it is a letter, else ignore\n    //4. If\
    \ a vowel, replace it with the char 2 places ahead of it\n    //5. Check if is\
    \ a capital letter and if so, make it lowercase\n    //6. Check if is a lowercase\
    \ letter and if so, make it uppercase\n    //7. Collect the chars and return them\
    \ as a string\n    message.chars().enumerate().map(|(i, c)| {\n        if c.is_alphabetic()\
    \ {\n            match c {\n                'a' | 'e' | 'i' | 'o' | 'u' => match\
    \ c.to_lowercase().next().unwrap() {\n                    'a' => 'c',\n      \
    \              'e' => 'g',\n                    'i' => 'k',\n                \
    \    'o' => 'q',\n                    'u' => 'y',\n                    _ => c\n\
    \                },\n                _ => c\n            }\n        } else {\n\
    \            c\n        }\n    }).map(|c| {\n        if c.is_uppercase() {\n \
    \           c.to_lowercase().next().unwrap()\n        } else {\n            c.to_uppercase().next().unwrap()\n\
    \        }\n    }).collect()", "    let normal_vowels = \"aeiou\";\n    let mut\
    \ encoded = message.clone();\n    for ch in encoded.chars_mut() {\n        let\
    \ lower = ch.to_lowercase().to_string();\n        if lower == ch {\n         \
    \   ch.make_ascii_uppercase();\n        } else {\n            ch.make_ascii_lowercase();\n\
    \        }\n        if normal_vowels.contains(ch) {\n            let mut split\
    \ = lower.chars();\n            let _a = split.next().unwrap();\n            let\
    \ b = split.next().unwrap();\n            if let Some(c) = split.next() {\n  \
    \              *ch = c;\n            } else {\n                *ch = b;\n    \
    \        }\n        }\n    }\n    encoded", "  let mut answer = String::new();\n\
    \  let mut skip_next = false;\n  for c in message.chars() {\n    if skip_next\
    \ {\n      skip_next = false;\n      continue;\n    }\n    let mut curr_char =\
    \ c;\n    if c.is_ascii_lowercase() {\n      curr_char = c.to_ascii_uppercase();\n\
    \    } else if c.is_ascii_uppercase() {\n      curr_char = c.to_ascii_lowercase();\n\
    \    } else if c == '\\'' {\n      answer.push(c);\n      continue;\n    }\n \
    \   match curr_char {\n      'A' => {\n        answer.push('C');\n        skip_next\
    \ = true;\n      },\n      'E' => {\n        answer.push('G');\n        skip_next\
    \ = true;\n      },\n      'I' => {\n        answer.push('K');\n        skip_next\
    \ = true;\n      },\n      'O' => {\n        answer.push('Q');\n        skip_next\
    \ = true;\n      },\n      'U' => {\n        answer.push('W');\n        skip_next\
    \ = true;\n      },\n      'Y' => {\n        answer.push('A');\n        skip_next\
    \ = true;\n      },\n      _ => answer.push(curr_char),\n    }\n  }\n  answer",
  "    let mut result = \"\".to_string();\n    let vowels = [\"a\", \"e\", \"i\",\
    \ \"o\", \"u\"];\n    for c in message.chars() {\n        if vowels.contains(&c.to_string().as_str())\
    \ {\n            result.push_str(next_vowel(c.to_string()).as_str());\n      \
    \  } else {\n            result.push_str(c.to_string().as_str());\n        }\n\
    \    }\n    result", "    message.chars().map(|l| {\n        if l.is_ascii_uppercase()\
    \ {\n            l.to_ascii_lowercase()\n        } else if l.is_ascii_lowercase()\
    \ {\n            l.to_ascii_uppercase()\n        } else {\n            l\n   \
    \     }\n    }).map(|l| {\n        if l == 'a' {\n            'c'\n        } else\
    \ if l == 'e' {\n            'g'\n        } else if l == 'i' {\n            'k'\n\
    \        } else if l == 'o' {\n            'q'\n        } else if l == 'u' {\n\
    \            'w'\n        } else {\n            l\n        }\n    }).collect()",
  "    let mut result = String::new();\n    for c in message.chars() {\n        match\
    \ c {\n            'a' => result.push('c'),\n            'e' => result.push('g'),\n\
    \            'i' => result.push('k'),\n            'o' => result.push('q'),\n\
    \            'u' => result.push('s'),\n            'y' => result.push('a'),\n\
    \            'A' => result.push('C'),\n            'E' => result.push('G'),\n\
    \            'I' => result.push('K'),\n            'O' => result.push('Q'),\n\
    \            'U' => result.push('S'),\n            'Y' => result.push('A'),\n\
    \            _ => result.push(c),\n        }\n    }\n    result", "    let mut\
    \ output = message.clone();\n    for (i, c) in message.chars().enumerate() {\n\
    \        if c.is_ascii_lowercase() {\n            output.as_mut_str().replace_range(i..i+1,\
    \ &c.to_ascii_uppercase().to_string());\n        } else if c.is_ascii_uppercase()\
    \ {\n            output.as_mut_str().replace_range(i..i+1, &c.to_ascii_lowercase().to_string());\n\
    \        } else if c == 'a' {\n            output.as_mut_str().replace_range(i..i+1,\
    \ \"c\");\n        } else if c == 'e' {\n            output.as_mut_str().replace_range(i..i+1,\
    \ \"g\");\n        } else if c == 'i' {\n            output.as_mut_str().replace_range(i..i+1,\
    \ \"k\");\n        } else if c == 'o' {\n            output.as_mut_str().replace_range(i..i+1,\
    \ \"q\");\n        } else if c == 'u' {\n            output.as_mut_str().replace_range(i..i+1,\
    \ \"s\");\n        } else if c == 'A' {\n            output.as_mut_str().replace_range(i..i+1,\
    \ \"C\");\n        } else if c == 'E' {\n            output.as_mut_str().replace_range(i..i+1,\
    \ \"G\");\n        } else if c == 'I' {\n            output.as_mut_str().replace_range(i..i+1,\
    \ \"K\");\n        } else if c == 'O' {\n            output.as_mut_str().replace_range(i..i+1,\
    \ \"Q\");\n        } else if c == 'U' {\n            output.as_mut_str().replace_range(i..i+1,\
    \ \"S\");\n        }\n    }\n    output", "    let mut encoded = String::new();\n\
    \    for c in message.chars() {\n        let mut is_upper = false;\n        let\
    \ c = if c.is_uppercase() {\n            is_upper = true;\n            c.to_lowercase().collect::<Vec<char>>()[0]\n\
    \        } else {\n            c\n        };\n        let encoded_c = match c\
    \ {\n            'a' => 'c',\n            'e' => 'g',\n            'i' => 'k',\n\
    \            'o' => 'q',\n            'u' => 'y',\n            _ => c,\n     \
    \   };\n        if is_upper {\n            encoded.push(encoded_c.to_uppercase().collect::<Vec<char>>()[0]);\n\
    \        } else {\n            encoded.push(encoded_c);\n        }\n    }\n  \
    \  encoded", '    unimplemented!()', "    message.chars().map(|x| match x {\n\
    \        'a' => 'c',\n        'e' => 'g',\n        'i' => 'k',\n        'o' =>\
    \ 'q',\n        'u' => 'w',\n        'A' => 'C',\n        'E' => 'G',\n      \
    \  'I' => 'K',\n        'O' => 'Q',\n        'U' => 'W',\n        _ => x,\n  \
    \  }).collect()", '    unimplemented!()', '    String::from("")', '    String::from("")',
  "  let mut encoded = String::new();\n  let  alphabet_bytes = String::from(\"abcdefghijklmnopqrstuvwxyz\"\
    ).into_bytes();\n  let vowels = String::from(\"aeiou\").into_bytes();\n  let diff_vowels\
    \ = 2;\n  let mut vowels_iter = vowels.iter();\n  let mut vowels_ptr = vowels_iter.next();\n\
    \  for c in message.into_bytes() {\n    let encode_char = match c {\n      65\
    \ ... 90 => if c > 65 + diff_vowels {\n        c + diff_vowels\n      } else {\n\
    \        90 - 65 + diff_vowels + c\n      },\n      97 ... 122 => if c > 97 +\
    \ diff_vowels {\n        c + diff_vowels\n      } else {\n        122 - 97 + diff_vowels\
    \ + c\n      },\n      _ => c\n    };\n    if vowels_ptr.is_some() && encode_char\
    \ == *vowels_ptr.unwrap() {\n      vowels_ptr = vowels_iter.next();\n      if\
    \ let Some(letter) = alphabet_bytes.get(encode_char - 97 + 2) {\n        encoded.push(*letter\
    \ as char);\n      }\n    } else {\n      encoded.push(encode_char as char);\n\
    \    }\n  }\n  encoded", "    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"\
    ];\n    let vowels2 = [\"b\", \"f\", \"j\", \"p\", \"v\"];\n    let alphabets\
    \ = \"abcdefghijklmnopqrstuvwxyz\".to_string();\n    let alphabets2 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    .to_string();\n    let mut encoded = String::new();\n    for ch in message.chars()\
    \ {\n        if vowels.contains(&ch.to_string().as_str()) {\n            let idx\
    \ = alphabets.find(ch).unwrap();\n            let new_idx = (idx + 2) % vowels.len();\n\
    \            encoded.push_str(vowels2[new_idx]);\n        } else if vowels2.contains(&ch.to_string().as_str())\
    \ {\n            let idx = alphabets2.find(ch).unwrap();\n            let new_idx\
    \ = (idx + 2) % vowels2.len();\n            encoded.push_str(vowels[new_idx]);\n\
    \        } else {\n            encoded.push(ch);\n        }\n    }\n    encoded",
  "    let mut encoded = String::new();\n    for letter in message.chars() {\n   \
    \     match letter {\n            'a' => encoded.push('c'),\n            'e' =>\
    \ encoded.push('g'),\n            'i' => encoded.push('k'),\n            'o' =>\
    \ encoded.push('q'),\n            'u' => encoded.push('y'),\n            ' ' =>\
    \ encoded.push(' '),\n            _ => encoded.push(letter.to_uppercase().next().unwrap()),\n\
    \        }\n    }\n    encoded", "    let mut encoded_message = String::new();\n\
    \    for character in message.chars() {\n        if character.is_lowercase() {\n\
    \            encoded_message.push(character.to_uppercase().next().unwrap());\n\
    \        } else if character.is_uppercase() {\n            encoded_message.push(character.to_lowercase().next().unwrap());\n\
    \        } else {\n            encoded_message.push(character);\n        }\n \
    \   }\n    encoded_message", "    let mut encoded_message = String::new();\n \
    \   let vowels = \"aeiou\";\n    let mut i = 0;\n    while i < message.len() {\n\
    \        let letter = message.chars().nth(i).unwrap();\n        if is_vowel(letter)\
    \ {\n            let new_letter = determine_new_letter(letter, vowels);\n    \
    \        encoded_message.push(new_letter);\n        } else {\n            encoded_message.push(letter);\n\
    \        }\n        i += 1;\n    }\n    return encoded_message;", "    let lower_case_vowels\
    \ = ['a', 'e', 'i', 'o', 'u'];\n    let upper_case_vowels = ['A', 'E', 'I', 'O',\
    \ 'U'];\n    let mut result = String::new();\n    for c in message.chars() {\n\
    \        if lower_case_vowels.contains(&c) {\n            let next_char = (c as\
    \ u8 + 2) as char;\n            result.push(next_char);\n        } else if upper_case_vowels.contains(&c)\
    \ {\n            let next_char = (c as u8 + 2) as char;\n            result.push(next_char);\n\
    \        } else if c.is_ascii_uppercase() {\n            let next_char = (c as\
    \ u8 + 32) as char;\n            result.push(next_char);\n        } else if c.is_ascii_lowercase()\
    \ {\n            let next_char = (c as u8 - 32) as char;\n            result.push(next_char);\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    result",
  "    let mut result = String::from(\"\");\n    for c in message.chars() {\n    \
    \    match c {\n            'a' => result.push('c'),\n            'e' => result.push('g'),\n\
    \            'i' => result.push('k'),\n            'o' => result.push('q'),\n\
    \            'u' => result.push('y'),\n            'A' => result.push('C'),\n\
    \            'E' => result.push('G'),\n            'I' => result.push('K'),\n\
    \            'O' => result.push('Q'),\n            'U' => result.push('Y'),\n\
    \            ' ' => result.push(' '),\n            _ => result.push(c),\n    \
    \    }\n    }\n    result", '    unimplemented!()', "    let vowels = ['a', 'e',\
    \ 'i', 'o', 'u'];\n    let mut encoded_message = String::from(\"\");\n    for\
    \ c in message.chars() {\n        let mut next_char = c;\n        if vowels.contains(&c)\
    \ {\n            let distance = (c as u8 + 2) - 'a' as u8;\n            next_char\
    \ = 'a' as u8 + distance % 5;\n        }\n        let mut next_char = if c.is_ascii_uppercase()\
    \ {\n            next_char.to_ascii_lowercase()\n        } else {\n          \
    \  next_char.to_ascii_uppercase()\n        };\n        encoded_message.push(next_char);\n\
    \    }\n    encoded_message", '    unimplemented!()', '    return "abc".to_string();',
  "    let mut result = String::from(\"\");\n    for c in message.chars() {\n    \
    \    let up = c.is_uppercase();\n        if up {\n            result.push(c.to_lowercase().next().unwrap());\n\
    \        } else {\n            result.push(c.to_uppercase().next().unwrap());\n\
    \        }\n    }\n    let chars: Vec<char> = result.chars().collect();\n    let\
    \ mut result = String::from(\"\");\n    for c in chars {\n        let index =\
    \ ENCODE_VOWELS.find(c).unwrap();\n        let new_c = ENCODE_VOWELS.chars().nth(index\
    \ + 2).unwrap();\n        result.push(new_c);\n    }\n    result", "    let mut\
    \ encoded = String::new();\n    for c in message.chars() {\n        match c {\n\
    \            'a' | 'A' => encoded.push('c'),\n            'e' | 'E' => encoded.push('g'),\n\
    \            'i' | 'I' => encoded.push('k'),\n            'o' | 'O' => encoded.push('q'),\n\
    \            'u' | 'U' => encoded.push('y'),\n            c if c.is_lowercase()\
    \ => encoded.push((c as u8 + 2) as char),\n            c if c.is_uppercase() =>\
    \ encoded.push((c as u8 + 2 - 32) as char),\n            _ => encoded.push(c),\n\
    \        }\n    }\n    encoded", "    let mut result = String::new();\n    let\
    \ alphabet = \"abcdefghijklmnopqrstuvwxyz\".to_string();\n    let vowels = \"\
    aeiou\".to_string();\n    for c in message.chars() {\n        if c.is_ascii_lowercase()\
    \ {\n            result.push(c.to_ascii_uppercase());\n        } else if c.is_ascii_uppercase()\
    \ {\n            result.push(c.to_ascii_lowercase());\n        } else {\n    \
    \        result.push(c);\n        }\n    }\n    result", "    message.chars().map(|c|\
    \ {\n        if c.is_lowercase() {\n            c.to_uppercase().next().unwrap()\n\
    \        } else if c.is_uppercase() {\n            c.to_lowercase().next().unwrap()\n\
    \        } else {\n            c\n        }\n    }).map(|c| {\n        match c\
    \ {\n            'a' => 'c',\n            'e' => 'g',\n            'i' => 'k',\n\
    \            'o' => 'q',\n            'u' => 'y',\n            _ => c\n      \
    \  }\n    }).collect()", "    // TODO\n    \"\".to_string()", "    //TODO\n  \
    \  String::new()", "    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut\
    \ shifted_message = String::new();\n    for c in message.chars() {\n        if\
    \ vowels.contains(&c) {\n            match c {\n                'a' => shifted_message.push('c'),\n\
    \                'e' => shifted_message.push('g'),\n                'i' => shifted_message.push('k'),\n\
    \                'o' => shifted_message.push('q'),\n                'u' => shifted_message.push('s'),\n\
    \                _ => (),\n            }\n        } else {\n            shifted_message.push(c);\n\
    \        }\n    }\n    shifted_message", "    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    ;\n    let mut new_message = String::from(\"\");\n    for character in message.chars()\
    \ {\n        let mut index = alphabet.find(character).unwrap();\n        if character.is_lowercase()\
    \ {\n            index += 2;\n            new_message.push_str(&alphabet[index..index+1]);\n\
    \        } else {\n            index += 2;\n            new_message.push_str(&alphabet[index..index+1].to_uppercase());\n\
    \        }\n    }\n    new_message", "    let alphabet: [char; 26] = [\n     \
    \   'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n       \
    \ 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'\n    ];\n  \
    \  let vowels: [char; 5] = ['a', 'e', 'i', 'o', 'u'];\n    let mut encoded_message\
    \ = String::new();\n    for ch in message.chars() {\n        if ch.is_lowercase()\
    \ {\n            if let Some(index) = alphabet.iter().position(|&x| x == ch) {\n\
    \                encoded_message.push(alphabet[index-1]);\n            }\n   \
    \     } else if ch.is_uppercase() {\n            if let Some(index) = alphabet.iter().position(|&x|\
    \ x == ch.to_lowercase().next().unwrap()) {\n                encoded_message.push(alphabet[index+1].to_uppercase().next().unwrap());\n\
    \            }\n        } else {\n            encoded_message.push(ch);\n    \
    \    }\n    }\n    for ch in encoded_message.chars() {\n        if vowels.contains(&ch)\
    \ {\n            match ch {\n                'a' => encoded_message = encoded_message.replace(ch,\
    \ \"c\"),\n                'e' => encoded_message = encoded_message.replace(ch,\
    \ \"g\"),\n                'i' => encoded_message = encoded_message.replace(ch,\
    \ \"k\"),\n                'o' => encoded_message = encoded_message.replace(ch,\
    \ \"q\"),\n                'u' => encoded_message = encoded_message.replace(ch,\
    \ \"s\"),\n                _ => encoded_message.push(ch),\n            }\n   \
    \     }\n    }\n    encoded_message", "    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    ;\n    let vowels = \"aeiou\";\n    let mut encoded = String::new();\n    for\
    \ character in message.chars() {\n        match character {\n            'a' =>\
    \ encoded.push(alphabet.chars().nth(2).unwrap()),\n            'e' => encoded.push(alphabet.chars().nth(4).unwrap()),\n\
    \            'i' => encoded.push(alphabet.chars().nth(6).unwrap()),\n        \
    \    'o' => encoded.push(alphabet.chars().nth(8).unwrap()),\n            'u' =>\
    \ encoded.push(alphabet.chars().nth(10).unwrap()),\n            'A' => encoded.push(alphabet.chars().nth(2).unwrap().to_uppercase().next().unwrap()),\n\
    \            'E' => encoded.push(alphabet.chars().nth(4).unwrap().to_uppercase().next().unwrap()),\n\
    \            'I' => encoded.push(alphabet.chars().nth(6).unwrap().to_uppercase().next().unwrap()),\n\
    \            'O' => encoded.push(alphabet.chars().nth(8).unwrap().to_uppercase().next().unwrap()),\n\
    \            'U' => encoded.push(alphabet.chars().nth(10).unwrap().to_uppercase().next().unwrap()),\n\
    \            _ => encoded.push(character),\n        }\n    }\n    encoded", '    message.chars().map(|x|
    encode_letter(x)).collect()', "    if message.is_empty() {\n        return message;\n\
    \    }\n\n    let mut encoded_message = String::new();\n    for character in message.chars()\
    \ {\n        if character.is_uppercase() {\n            encoded_message.push(character.to_lowercase().next().unwrap());\n\
    \        } else if character.is_lowercase() {\n            encoded_message.push(character.to_uppercase().next().unwrap());\n\
    \        } else {\n            encoded_message.push(character);\n        }\n \
    \   }\n\n    encoded_message", "    let message_bytes = message.into_bytes();\n\
    \    let mut encoded_bytes = vec![];\n    for byte in message_bytes {\n      \
    \  if byte >= 65 && byte <= 90 {\n            encoded_bytes.push(byte + 32);\n\
    \        } else if byte >= 97 && byte <= 122 {\n            encoded_bytes.push(byte\
    \ - 32);\n        } else {\n            encoded_bytes.push(byte);\n        }\n\
    \    }\n    String::from_utf8(encoded_bytes).unwrap()", "    let mut encoded_message\
    \ = String::from(\"\");\n    for c in message.chars() {\n        if c.is_ascii_uppercase()\
    \ {\n            encoded_message.push(c.to_ascii_lowercase());\n        } else\
    \ if c.is_ascii_lowercase() {\n            encoded_message.push(c.to_ascii_uppercase());\n\
    \        } else {\n            encoded_message.push(c);\n        }\n    }\n  \
    \  encoded_message", "    let encoded = message.chars().map(|x| {\n        let\
    \ mut x = x.to_ascii_lowercase();\n        if x == 'z' {\n            x = 'b';\n\
    \        } else if x == 'y' {\n            x = 'a';\n        } else if x == 'x'\
    \ {\n            x = '@';\n        } else if x == 'w' {\n            x = '9';\n\
    \        } else if x == 'v' {\n            x = '8';\n        } else if x == 'u'\
    \ {\n            x = '7';\n        } else if x == 't' {\n            x = '6';\n\
    \        } else if x == 's' {\n            x = '5';\n        } else if x == 'r'\
    \ {\n            x = '4';\n        } else if x == 'q' {\n            x = '3';\n\
    \        } else if x == 'p' {\n            x = '2';\n        } else if x == 'o'\
    \ {\n            x = '1';\n        } else if x == 'n' {\n            x = '0';\n\
    \        } else if x == 'm' {\n            x = 'z';\n        } else if x == 'l'\
    \ {\n            x = 'y';\n        } else if x == 'k' {\n            x = 'x';\n\
    \        } else if x == 'j' {\n            x = 'w';\n        } else if x == 'i'\
    \ {\n            x = 'v';\n        } else if x == 'h' {\n            x = 'u';\n\
    \        } else if x == 'g' {\n            x = 't';\n        } else if x == 'f'\
    \ {\n            x = 's';\n        } else if x == 'e' {\n            x = 'r';\n\
    \        } else if x == 'd' {\n            x = 'q';\n        } else if x == 'c'\
    \ {\n            x = 'p';\n        } else if x == 'b' {\n            x = 'o';\n\
    \        } else if x == 'a' {\n            x = 'n';\n        }\n        let y\
    \ = x.to_as", "    let v = ['a', 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n\
    \    for c in message.chars() {\n        match c {\n            'a' => result.push('c'),\n\
    \            'e' => result.push('g'),\n            'i' => result.push('k'),\n\
    \            'o' => result.push('q'),\n            'u' => result.push('s'),\n\
    \            c if v.contains(&c) => result.push(c.to_ascii_uppercase()),\n   \
    \         _ => result.push(c),\n        }\n    }\n    result", "    let mut result\
    \ = String::new();\n    for ch in message.chars() {\n        if ch.is_ascii_lowercase()\
    \ {\n            result.push(ch.to_ascii_uppercase());\n        } else if ch.is_ascii_uppercase()\
    \ {\n            result.push(ch.to_ascii_lowercase());\n        } else {\n   \
    \         result.push(ch);\n        }\n    }\n    let mut result: Vec<char> =\
    \ result.chars().collect();\n    for ch in result.iter_mut() {\n        if ch.is_ascii_lowercase()\
    \ {\n            let mut index = 0;\n            for ch2 in ALPHABET.chars() {\n\
    \                if ch2 == *ch {\n                    break;\n               \
    \ }\n                index += 1;\n            }\n            index += 2;\n   \
    \         index %= 26;\n            *ch = ALPHABET.chars().nth(index).unwrap();\n\
    \        } else if ch.is_ascii_uppercase() {\n            let mut index = 0;\n\
    \            for ch2 in ALPHABET.chars() {\n                if ch2 == *ch {\n\
    \                    break;\n                }\n                index += 1;\n\
    \            }\n            index += 2;\n            index %= 26;\n          \
    \  *ch = ALPHABET.chars().nth(index).unwrap().to_ascii_uppercase();\n        }\n\
    \    }\n    result.iter().collect()", "    let message = message.as_bytes();\n\
    \    let mut result = Vec::new();\n    for &ch in message {\n        let letter\
    \ = match ch {\n            b'a'..=b'z' => ch - b'a',\n            b'A'..=b'Z'\
    \ => ch - b'A',\n            _ => panic!(\"only letters\"),\n        };\n    \
    \    match letter {\n            b'a'..=b'y' => result.push(b'a' + letter + 2),\n\
    \            b'z' => result.push(b'a'),\n            b'A'..=b'Y' => result.push(b'A'\
    \ + letter + 2),\n            b'Z' => result.push(b'A'),\n            _ => unreachable!(),\n\
    \        }\n    }\n    String::from_utf8(result).unwrap()", '    String::from("encode
    message here")', "    let mut message = message.chars().peekable();\n    let mut\
    \ encoded_message = String::new();\n    while let Some(c) = message.next() {\n\
    \        if c.is_ascii_alphabetic() {\n            let mut next_char = c.to_ascii_lowercase();\n\
    \            if next_char.is_ascii_lowercase() {\n                next_char =\
    \ next_char.to_ascii_uppercase();\n            }\n            if next_char ==\
    \ 'A' || next_char == 'E' || next_char == 'I' || next_char == 'O' || next_char\
    \ == 'U' {\n                let peek = message.peek();\n                if let\
    \ Some(n) = peek {\n                    if n == &'A' || n == &'E' || n == &'I'\
    \ || n == &'O' || n == &'U' {\n                        next_char = match n {\n\
    \                            'A' => 'C',\n                            'E' => 'G',\n\
    \                            'I' => 'K',\n                            'O' => 'Q',\n\
    \                            'U' => 'W',\n                            _ => '_',\n\
    \                        };\n                        message.next();\n       \
    \             }\n                }\n            }\n            encoded_message.push(next_char);\n\
    \        } else {\n            encoded_message.push(c);\n        }\n    }\n  \
    \  encoded_message", "    let encoded_map = \"abcdefghijklmnopqrstuvwxyz\".chars().fold(HashMap::new(),\
    \ |mut map, ch| {\n        map.insert(ch, vec![2, 4, 5, 7, 9, 11, 13, 15, 17,\
    \ 19, 21, 23]);\n        map\n    });\n    let vowels = \"aeiou\".chars().collect::<HashSet<_>>();\n\
    \    let mut result = String::new();\n    let mut iter = message.chars();\n  \
    \  while let Some(ch) = iter.next() {\n        if ch.is_uppercase() {\n      \
    \      result.push(ch.to_lowercase().next().unwrap());\n        } else if vowels.contains(&ch)\
    \ {\n            let random_picker = encoded_map.get(&ch).unwrap();\n        \
    \    let random_index = rand::thread_rng().gen_range(0, random_picker.len());\n\
    \            let shift = random_picker[random_index];\n            let mut next_char\
    \ = ch as u8 + shift;\n            if next_char > 122 {\n                next_char\
    \ = next_char - 26;\n            }\n            result.push(next_char as char);\n\
    \        } else {\n            result.push(ch);\n        }\n    }\n    result",
  '    message.chars().map(|c| encode_char(c)).collect()', "    let alphabets = \"\
    abcdefghijklmnopqrstuvwxyz\".to_string();\n    let mut vowels: Vec<char> = vec![];\n\
    \    let mut encoded_message = message.clone();\n    for i in message.chars()\
    \ {\n        if i.is_alphabetic() {\n            encoded_message = encoded_message.replace(i,\
    \ if i.is_uppercase() {\n                i.to_lowercase().next().unwrap()\n  \
    \          } else {\n                i.to_uppercase().next().unwrap()\n      \
    \      });\n        }\n        if i.is_lowercase() {\n            if alphabets.contains(i)\
    \ {\n                vowels.push(i);\n            }\n        }\n    }\n    for\
    \ i in vowels {\n        let mut temp = alphabets.find(i).unwrap() + 2;\n    \
    \    if temp > alphabets.len() {\n            temp = temp - alphabets.len();\n\
    \        }\n        encoded_message = encoded_message.replace(i, alphabets.chars().nth(temp).unwrap());\n\
    \    }\n    encoded_message", "    let mut v = Vec::new();\n    let mut n = 2;\n\
    \    let mut z = 1;\n    let mut result = String::new();\n    let vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    for c in message.chars() {\n        if vowels.contains(&c)\
    \ {\n            v.push(c);\n        }\n    }\n    for c in message.chars() {\n\
    \        if c.is_lowercase() {\n            result.push(c.to_uppercase().next().unwrap());\n\
    \        } else if c.is_uppercase() {\n            result.push(c.to_lowercase().next().unwrap());\n\
    \        } else if c.is_alphabetic() {\n            result.push(v[v.len() - n].to_uppercase().next().unwrap());\n\
    \            n += 1;\n        } else {\n            result.push(c);\n        }\n\
    \    }\n    result", "    // Save ourselves from some repetitive calculations\n\
    \    let lower_vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let upper_vowels =\
    \ vec!['A', 'E', 'I', 'O', 'U'];\n    let lower_letters = ['a', 'b', 'c', 'd',\
    \ 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\
    \ 'u', 'v', 'w', 'x', 'y', 'z'];\n    let upper_letters = ['A', 'B', 'C', 'D',\
    \ 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',\
    \ 'U', 'V', 'W', 'X', 'Y', 'Z'];\n\n    // Get the index of the letter we're at\n\
    \    fn get_index(letter: char, list: &[char]) -> usize {\n        for (i, l)\
    \ in list.iter().enumerate() {\n            if l == &letter {\n              \
    \  return i;\n            }\n        }\n        // If we're here, we're not in\
    \ the list\n        panic!(\"Letter not in list!\");\n    }\n\n    // Create a\
    \ new string and fill it\n    let mut new_message = String::new();\n    for letter\
    \ in message.chars() {\n        if lower_vowels.contains(&letter) {\n        \
    \    // If it's lowercase, replace with the letter 2 forward in the alphabet,\
    \ wrapping if necessary\n            let index = get_index(letter, &lower_vowels);\n\
    \            let new_index = (index + 2) % lower_vowels.len();\n            new_message.push(lower_vowels[new_index]);\n\
    \        } else if upper_vowels.contains(&letter) {\n            // If it's uppercase,\
    \ replace with the letter 2 forward in the alphabet, wrapping if necessary\n \
    \           let index = get_index(letter, &", '    unimplemented!()', "    let\
    \ mut res = String::new();\n    let mut itr = message.chars();\n    while let\
    \ Some(c) = itr.next() {\n        if !c.is_alphabetic() {\n            res.push(c);\n\
    \            continue;\n        }\n        if c.is_ascii_uppercase() {\n     \
    \       res.push(c.to_ascii_lowercase());\n        } else {\n            res.push(c.to_ascii_uppercase());\n\
    \        }\n        match c {\n            'a' | 'e' | 'i' | 'o' | 'u' => res.push(itr.next().unwrap()),\n\
    \            _ => res.push(c),\n        }\n    }\n    res", "    // TODO\n   \
    \ return String::from(\"\");", "    let mut encoded = String::new();\n    let\
    \ mut chars = message.chars();\n    while let Some(c) = chars.next() {\n     \
    \   let c_lower = c.to_lowercase().collect::<Vec<char>>()[0];\n        if c.is_lowercase()\
    \ {\n            encoded.push(c.to_uppercase().collect::<Vec<char>>()[0]);\n \
    \       } else if c.is_uppercase() {\n            encoded.push(c_lower);\n   \
    \     } else {\n            encoded.push(c);\n        }\n        match c_lower\
    \ {\n            'a' => encoded.push('c'),\n            'e' => encoded.push('g'),\n\
    \            'i' => encoded.push('k'),\n            'o' => encoded.push('q'),\n\
    \            'u' => encoded.push('y'),\n            _ => encoded.push(c),\n  \
    \      }\n    }\n    encoded", "    let alpha = vec![\"a\", \"b\", \"c\", \"d\"\
    , \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\"\
    , \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"\
    ];\n    let vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut new_string\
    \ = String::new();\n    let mut in_vowel = false;\n    for c in message.chars()\
    \ {\n        let c_lower = c.to_lowercase().collect::<Vec<char>>()[0];\n     \
    \   let curr_char = alpha[c_lower as usize - 97];\n        let mut in_vowel =\
    \ false;\n        for vowel in vowels.iter() {\n            if curr_char == vowel\
    \ {\n                in_vowel = true;\n            }\n        }\n        if in_vowel\
    \ {\n            let mut new_vowel_index = 0;\n            for i in 0..(alpha.len()\
    \ - 2) {\n                if curr_char == alpha[i] {\n                    new_vowel_index\
    \ = i + 2;\n                }\n            }\n            new_string += alpha[new_vowel_index];\n\
    \        } else {\n            new_string += curr_char;\n        }\n    }\n  \
    \  new_string", "    let mut my_answer = String::new();\n    let mut capital =\
    \ false;\n    let mut message = message.to_lowercase();\n    let vowels = [\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let chars: Vec<char> = message.chars().collect();\n\
    \    let mut i = 0;\n    while i < chars.len() {\n        let mut letter = String::new();\n\
    \        letter.push(chars[i]);\n        if vowels.contains(&letter.as_str())\
    \ {\n            if i == chars.len() - 1 {\n                my_answer.push_str(chars[i].to_string().as_str());\n\
    \            } else {\n                my_answer.push_str(chars[i + 2].to_string().as_str());\n\
    \            }\n            i += 1;\n        } else {\n            if capital\
    \ {\n                my_answer.push_str(chars[i].to_string().to_uppercase().as_str());\n\
    \                capital = false;\n            } else {\n                my_answer.push_str(chars[i].to_string().as_str());\n\
    \                capital = true;\n            }\n        }\n        i += 1;\n\
    \    }\n    my_answer", "    let mut a = message.chars();\n    let mut b = message.chars();\n\
    \    let mut c = message.chars();\n    let mut encoded = String::new();\n    for\
    \ i in 0..message.len() {\n        let c = a.next().unwrap();\n        let c2\
    \ = b.next().unwrap();\n        let c3 = c2.to_lowercase().collect::<Vec<char>>();\n\
    \        let c4 = c.to_lowercase().collect::<Vec<char>>();\n        let c5 = c3[0];\n\
    \        let c6 = c4[0];\n        let c7 = match c5 {\n            'a' => 'c',\n\
    \            'e' => 'g',\n            'i' => 'k',\n            'o' => 'q',\n \
    \           'u' => 'y',\n            _ => c2,\n        };\n        let c8 = match\
    \ c6 {\n            'a' => 'A',\n            'e' => 'E',\n            'i' => 'I',\n\
    \            'o' => 'O',\n            'u' => 'U',\n            _ => c,\n     \
    \   };\n        let c9 = match c6 {\n            'A' => 'a',\n            'E'\
    \ => 'e',\n            'I' => 'i',\n            'O' => 'o',\n            'U' =>\
    \ 'u',\n            _ => c,\n        };\n        encoded.push(c8);\n        encoded.push(c7);\n\
    \        encoded.push(c9);\n    }\n    encoded", '    String::from("")', "   \
    \ let chars: Vec<char> = message.chars().collect();\n    let mut out: Vec<char>\
    \ = Vec::new();\n    for c in chars {\n        if c.is_alphabetic() {\n      \
    \      if c.is_lowercase() {\n                out.push(c.to_uppercase().to_string().chars().next().unwrap());\n\
    \            } else {\n                out.push(c.to_lowercase().to_string().chars().next().unwrap());\n\
    \            }\n        } else {\n            out.push(c);\n        }\n    }\n\
    \    let mut output: String = out.into_iter().collect();\n    for v in vec!['a',\
    \ 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'] {\n        output = output.replace(v,\
    \ \"\");\n    }\n    output", "    let mut encoded_message = String::new();\n\
    \    for c in message.chars() {\n        if c.is_alphabetic() {\n            encoded_message.push(c.to_ascii_uppercase());\n\
    \        } else {\n            encoded_message.push(c);\n        }\n    }\n  \
    \  encoded_message", "    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut encoded = String::new();\n    for c in message.chars() {\n        if vowels.contains(&c)\
    \ {\n            encoded.push(vowels[((vowels.iter().position(|&x| x == c).unwrap()\
    \ + 2) % 5) as usize]);\n        } else if c.is_uppercase() {\n            encoded.push(c.to_lowercase().to_string().chars().next().unwrap());\n\
    \        } else {\n            encoded.push(c.to_uppercase().to_string().chars().next().unwrap());\n\
    \        }\n    }\n    encoded", "    let alphabet: Vec<char> = \"abcdefghijklmnopqrstuvwxyz\"\
    .chars().collect();\n    let mut encoded_message = String::new();\n    for letter\
    \ in message.chars() {\n        let index = match alphabet.iter().position(|&r|\
    \ r == letter) {\n            Some(index) => index,\n            None => 0,\n\
    \        };\n        let index = match alphabet.iter().position(|&r| r == letter.to_ascii_lowercase())\
    \ {\n            Some(index) => index,\n            None => 0,\n        };\n \
    \       let encoded_letter = match letter.is_uppercase() {\n            true =>\
    \ alphabet[(index + 2) % alphabet.len()].to_ascii_uppercase(),\n            false\
    \ => alphabet[(index + 2) % alphabet.len()],\n        };\n        encoded_message.push(encoded_letter);\n\
    \    }\n    encoded_message", '    "cipher".to_string()', "    // https://stackoverflow.com/questions/32081808/iterate-over-chars-in-a-string-in-rust\n\
    \    let alpha: Vec<char> = \"abcdefghijklmnopqrstuvwxyz\".chars().collect();\n\
    \    let mut encoded_message = String::new();\n    for c in message.chars() {\n\
    \        if c.is_ascii_uppercase() {\n            // use alpha.iter().position\
    \ instead of alpha.iter().find_position\n            // because find_position\
    \ returns Option<(usize, char)> whereas \n            // position() returns Option<usize>\n\
    \            let pos = alpha.iter().position(|&ch| ch == c.to_ascii_lowercase()).unwrap();\n\
    \            encoded_message.push(alpha[pos]);\n        } else if c.is_ascii_lowercase()\
    \ {\n            let pos = alpha.iter().position(|&ch| ch == c).unwrap();\n  \
    \          encoded_message.push(alpha[pos].to_ascii_uppercase());\n        } else\
    \ {\n            encoded_message.push(c);\n        }\n    }\n    // https://stackoverflow.com/questions/34971539/how-do-i-replace-a-substring-within-a-string-in-rust\n\
    \    return encoded_message.replace(\"a\", \"c\").replace(\"e\", \"g\").replace(\"\
    i\", \"k\").replace(\"o\", \"q\").replace(\"u\", \"w\");", "    // your code here\n\
    \    let mut result: String = String::new();\n    for letter in message.chars()\
    \ {\n        match letter {\n            'a' => result.push('c'),\n          \
    \  'e' => result.push('g'),\n            'i' => result.push('k'),\n          \
    \  'o' => result.push('q'),\n            'u' => result.push('s'),\n          \
    \  'A' => result.push('C'),\n            'E' => result.push('G'),\n          \
    \  'I' => result.push('K'),\n            'O' => result.push('Q'),\n          \
    \  'U' => result.push('S'),\n            _ => result.push(letter)\n        }\n\
    \    }\n    result", '    unimplemented!()', "    let vowels = \"aeiouAEIOU\"\
    ;\n    let chars: Vec<char> = message.chars().collect();\n    let mut result =\
    \ String::new();\n    for c in chars {\n        if vowels.contains(c) {\n    \
    \        let v = (c as u8) + 2;\n            result.push(v as char);\n       \
    \ } else {\n            let c = if c.is_uppercase() {\n                c.to_lowercase().to_string()\n\
    \            } else {\n                c.to_uppercase().to_string()\n        \
    \    };\n            result.push_str(&c);\n        }\n    }\n    result", "  \
    \  message.chars().map(|c| {\n        if c.is_alphabetic() {\n            if c.is_uppercase()\
    \ {\n                c.to_lowercase().collect::<Vec<char>>()[0]\n            }\
    \ else {\n                c.to_uppercase().collect::<Vec<char>>()[0]\n       \
    \     }\n        } else {\n            c\n        }\n    }).collect::<String>()",
  '    "result".to_string()', "    let alphabets = [\"a\", \"b\", \"c\", \"d\", \"\
    e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"\
    p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n\
    \    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut encoded_string\
    \ = String::new();\n    for character in message.chars() {\n        match character\
    \ {\n            'A'...'Z' => {\n                encoded_string.push(character.to_ascii_lowercase());\n\
    \            },\n            'a'...'z' => {\n                encoded_string.push(character);\n\
    \            },\n            _ => {\n                encoded_string.push(character);\n\
    \            }\n        }\n    }\n    let mut i = 0;\n    for character in encoded_string.chars()\
    \ {\n        for vowel in vowels.iter() {\n            if character == vowel.chars().next().unwrap()\
    \ {\n                encoded_string.replace_range(i..i+1, alphabets[i+2]);\n \
    \           }\n        }\n        i += 1;\n    }\n    encoded_string", "    let\
    \ mut res = String::new();\n    for c in message.chars() {\n        if c.is_alphabetic()\
    \ {\n            if c.is_uppercase() {\n                res.push(c.to_lowercase().collect::<Vec<char>>()[0]);\n\
    \            } else {\n                res.push(c.to_uppercase().collect::<Vec<char>>()[0]);\n\
    \            }\n        } else {\n            res.push(c);\n        }\n    }\n\
    \    res", "    let new_message = message.chars().map(|x| {\n            match\
    \ x {\n                'a' => 'c',\n                'e' => 'g',\n            \
    \    'i' => 'k',\n                'o' => 'q',\n                'u' => 'y',\n \
    \               'A' => 'C',\n                'E' => 'G',\n                'I'\
    \ => 'K',\n                'O' => 'Q',\n                'U' => 'Y',\n        \
    \        _ => if x.is_lowercase() { x.to_uppercase().next().unwrap() } else {\
    \ x.to_lowercase().next().unwrap() },\n            }\n        }).collect();\n\
    \    new_message", "    message.chars().map(|x| {\n        if \"a\" <= x && x\
    \ <= \"z\" {\n            let offset = if x == 'y' {\n                24\n   \
    \         } else if x == 'z' {\n                25\n            } else {\n   \
    \             x as i8 - 'a' as i8 + 2\n            };\n            (offset + 'a'\
    \ as i8) as u8 as char\n        } else if \"A\" <= x && x <= \"Z\" {\n       \
    \     let offset = if x == 'Y' {\n                24\n            } else if x\
    \ == 'Z' {\n                25\n            } else {\n                x as i8\
    \ - 'A' as i8 + 2\n            };\n            (offset + 'A' as i8) as u8 as char\n\
    \        } else {\n            x\n        }\n    }).collect()", '  "".to_string()',
  "    // TODO: Implement this function\n    return message;", "    let mut encoded_string\
    \ = String::new();\n    let vowels: Vec<char> = vec!['a', 'e', 'i', 'o', 'u'];\n\
    \    for c in message.chars() {\n        let mut is_vowel = false;\n        for\
    \ v in vowels.iter() {\n            if c == *v {\n                is_vowel = true;\n\
    \                break;\n            }\n        }\n        if is_vowel {\n   \
    \         let mut char_int = ((c as u8) + 2) as char;\n            if (char_int\
    \ as u8) > (b'z') {\n                char_int = ((char_int as u8) - 26) as char;\n\
    \            }\n            encoded_string.push(char_int);\n        } else {\n\
    \            encoded_string.push(c);\n        }\n    }\n    encoded_string", " \
    \   // convert to ascii\n    let ascii = message.as_bytes();\n    let mut encoded\
    \ = String::new();\n    for i in ascii {\n        match i {\n            // to\
    \ uppercase\n            b'a'...b'z' => encoded.push(i.to_ascii_uppercase() as\
    \ char),\n            b'A'...b'Z' => encoded.push(i.to_ascii_lowercase() as char),\n\
    \            // increase\n            // b'a' => encoded.push('c'),\n        \
    \    // b'e' => encoded.push('g'),\n            // b'i' => encoded.push('k'),\n\
    \            // b'o' => encoded.push('q'),\n            // b'u' => encoded.push('y'),\n\
    \            // b'A' => encoded.push('C'),\n            // b'E' => encoded.push('G'),\n\
    \            // b'I' => encoded.push('K'),\n            // b'O' => encoded.push('Q'),\n\
    \            // b'U' => encoded.push('Y'),\n            _ => encoded.push(i as\
    \ char),\n        }\n    }\n    encoded", "    let vowels = [ 'a', 'e', 'i', 'o',\
    \ 'u' ];\n    let mut message_chars = message.chars();\n    let mut new_string\
    \ = String::new();\n    while let Some(letter) = message_chars.next() {\n    \
    \    match vowels.contains(&letter) {\n            true => {\n               \
    \ match vowels.contains(&((letter as u8 + 2) as char)) {\n                   \
    \ true => new_string.push((letter as u8 + 2) as char),\n                    false\
    \ => new_string.push((letter as u8 + 3) as char),\n                }\n       \
    \     },\n            false => new_string.push(letter),\n        }\n    }\n  \
    \  new_string", '    message.chars().map(|c| encode_letter(c)).collect()', " \
    \   // convert to bytes\n    let mut encoded_message = message.into_bytes();\n\
    \    for i in 0..encoded_message.len() {\n        let mut char = encoded_message[i];\n\
    \        // to uppercase\n        if char >= 'a' as u8 && char <= 'z' as u8 {\n\
    \            char = char - 32;\n        }\n        // swap case\n        if char\
    \ >= 'A' as u8 && char <= 'Z' as u8 {\n            if char >= 'A' as u8 && char\
    \ <= 'M' as u8 {\n                char = char + 13;\n            } else {\n  \
    \              char = char - 13;\n            }\n        }\n        // replace\
    \ vowels\n        if char == 'A' as u8 || char == 'E' as u8 || char == 'I' as\
    \ u8 || char == 'O' as u8 || char == 'U' as u8 {\n            char = char + 2;\n\
    \        }\n        encoded_message[i] = char;\n    }\n    return String::from_utf8(encoded_message).unwrap();",
  "    let mut encoded_message = message.clone();\n    let vowels = [65, 69, 73, 79,\
    \ 85, 97, 101, 105, 111, 117];\n    for i in 0..message.len() {\n        let index\
    \ = message.chars().nth(i).unwrap() as u32;\n        if vowels.contains(&index)\
    \ {\n            let new_index = (((index - 1) % 26) + 1) + 2;\n            encoded_message.replace_range(i..i+1,\
    \ &(new_index as u8 as char).to_string());\n        } else if (65..90).contains(&index)\
    \ {\n            encoded_message.replace_range(i..i+1, &(index+32).to_string());\n\
    \        } else if (97..122).contains(&index) {\n            encoded_message.replace_range(i..i+1,\
    \ &(index-32).to_string());\n        }\n    }\n    encoded_message", '    String::from("A")',
  "    let mut cipher = String::new();\n    for i in message.chars() {\n        match\
    \ i {\n            'a' | 'A' => cipher.push('c'),\n            'e' | 'E' => cipher.push('g'),\n\
    \            'i' | 'I' => cipher.push('k'),\n            'o' | 'O' => cipher.push('q'),\n\
    \            'u' | 'U' => cipher.push('y'),\n            'A'..='Z' => cipher.push((i\
    \ as u8 + 32) as char),\n            'a'..='z' => cipher.push((i as u8 - 32) as\
    \ char),\n            _ => cipher.push(i),\n        }\n    }\n    cipher", " \
    \   //let vowels = ['a', 'e', 'i', 'o', 'u'];\n    let mut new_message = String::new();\n\
    \    for c in message.chars() {\n        match c {\n            'a' => new_message.push('c'),\n\
    \            'e' => new_message.push('g'),\n            'i' => new_message.push('k'),\n\
    \            'o' => new_message.push('q'),\n            'u' => new_message.push('s'),\n\
    \            'A' => new_message.push('C'),\n            'E' => new_message.push('G'),\n\
    \            'I' => new_message.push('K'),\n            'O' => new_message.push('Q'),\n\
    \            'U' => new_message.push('S'),\n            ' ' => new_message.push('\
    \ '),\n            _ => new_message.push(c),\n        }\n    }\n    new_message",
  '    unimplemented!()', "    let mut ret = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_ascii_uppercase() {\n            let mut c = c.to_ascii_lowercase();\n\
    \            match c {\n                'a' => c = 'c',\n                'e' =>\
    \ c = 'g',\n                'i' => c = 'k',\n                'o' => c = 'q',\n\
    \                'u' => c = 's',\n                _ => {}\n            }\n   \
    \         ret.push(c);\n        } else if c.is_ascii_lowercase() {\n         \
    \   let mut c = c.to_ascii_uppercase();\n            match c {\n             \
    \   'A' => c = 'C',\n                'E' => c = 'G',\n                'I' => c\
    \ = 'K',\n                'O' => c = 'Q',\n                'U' => c = 'S',\n \
    \               _ => {}\n            }\n            ret.push(c);\n        } else\
    \ {\n            ret.push(c);\n        }\n    }\n    ret", "    let mut encoded_msg\
    \ = String::new();\n    let vowel_array = ['a', 'e', 'i', 'o', 'u'];\n    let\
    \ vowels_iter = vowel_array.iter();\n    let mut prev_vowel_index = 0;\n    let\
    \ mut index = 0;\n    let mut prev_vowel = false;\n    for ch in message.chars()\
    \ {\n        let mut letter_pos = ch as u8;\n        if letter_pos >= 65 && letter_pos\
    \ <= 90 {\n            // uppercase\n            letter_pos += 32;\n        }\n\
    \        if letter_pos >= 97 && letter_pos <= 122 {\n            for vowel in\
    \ vowels_iter {\n                if *vowel == ch {\n                    if prev_vowel\
    \ {\n                        letter_pos = (letter_pos + 2 - 97) % 26 + 97;\n \
    \                   } else {\n                        letter_pos = (letter_pos\
    \ + 1 - 97) % 26 + 97;\n                    }\n                    prev_vowel\
    \ = true;\n                    break;\n                }\n            }\n    \
    \        if !prev_vowel {\n                if letter_pos >= 97 && letter_pos <=\
    \ 122 {\n                    letter_pos -= 32;\n                }\n          \
    \  }\n        }\n        encoded_msg.push(letter_pos as char);\n        index\
    \ += 1;\n    }\n    encoded_msg", "    message.chars().map(|c| match c {\n   \
    \     'a' => 'c',\n        'A' => 'C',\n        'e' => 'g',\n        'E' => 'G',\n\
    \        'i' => 'k',\n        'I' => 'K',\n        'o' => 'q',\n        'O' =>\
    \ 'Q',\n        'u' => 'y',\n        'U' => 'Y',\n        ' ' => ' ',\n      \
    \  a => match a.is_uppercase() {\n            true => a.to_lowercase().to_string().chars().nth(0).unwrap(),\n\
    \            false => a.to_uppercase().to_string().chars().nth(0).unwrap(),\n\
    \        }\n    }).collect()", "    let mut result = String::new();\n    for c\
    \ in message.chars() {\n        if c.is_alphabetic() {\n            result.push(shift_char(c));\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    result",
  "    let mut encoded_message = String::new();\n    let vowels = vec!['a', 'e', 'i',\
    \ 'o', 'u'];\n    for character in message.chars() {\n        if vowels.contains(&character)\
    \ {\n            encoded_message.push(vowels[(vowels.iter().position(|&x| x ==\
    \ character).unwrap() + 2) % 5]);\n        } else if character.is_uppercase()\
    \ {\n            encoded_message.push(character.to_lowercase().next().unwrap());\n\
    \        } else {\n            encoded_message.push(character.to_uppercase().next().unwrap());\n\
    \        }\n    }\n    encoded_message", "    let vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"];\n    let mut encoded_message = String::new();\n    for char in\
    \ message.chars() {\n        let mut new_char = char;\n        if char.is_alphabetic()\
    \ {\n            if char.is_uppercase() {\n                new_char = char.to_lowercase().to_string().chars().nth(0).unwrap();\n\
    \            } else {\n                new_char = char.to_uppercase().to_string().chars().nth(0).unwrap();\n\
    \            }\n            if vowels.contains(&new_char.to_string().as_str())\
    \ {\n                new_char = get_char_two_ahead(new_char);\n            }\n\
    \        }\n        encoded_message.push(new_char);\n    }\n    encoded_message",
  "    let mut encoded_message = String::from(\"\");\n    let mut encoder = Encoder::new();\n\
    \    for character in message.chars() {\n        encoded_message.push(encoder.encode(character));\n\
    \    }\n    encoded_message", "    let mut encoded = message.to_string();\n  \
    \  let a_code = \"a\".chars().next().unwrap() as i32;\n    let z_code = \"z\"\
    .chars().next().unwrap() as i32;\n    let vowels = \"aeiou\";\n    for c in encoded.chars_mut()\
    \ {\n        // flip case\n        *c = if c.is_ascii_uppercase() {\n        \
    \    c.to_ascii_lowercase()\n        } else {\n            c.to_ascii_uppercase()\n\
    \        };\n        // check for vowels\n        if vowels.contains(c) {\n  \
    \          let mut c_code = c.to_ascii_lowercase() as i32;\n            c_code\
    \ += 2;\n            // if we go over the edge, wrap around\n            if c_code\
    \ > z_code {\n                c_code = a_code + (c_code - z_code - 1);\n     \
    \       }\n            *c = c_code as u8 as char;\n        }\n    }\n    encoded",
  "    message.chars().map(|c| {\n        match c {\n            'A' | 'a' => 'C',\n\
    \            'E' | 'e' => 'G',\n            'I' | 'i' => 'K',\n            'O'\
    \ | 'o' => 'Q',\n            'U' | 'u' => 'S',\n            x => match x.is_uppercase()\
    \ {\n                true => x.to_lowercase().next().unwrap(),\n             \
    \   false => x.to_uppercase().next().unwrap(),\n            }\n        }\n   \
    \ }).collect()", "    let mut result = String::new();\n    let vowels = ['a',\
    \ 'e', 'i', 'o', 'u'];\n    for c in message.chars() {\n        if vowels.contains(&c)\
    \ {\n            let new_char = next_char(c, 1);\n            result.push(next_char(new_char,\
    \ 1));\n        } else {\n            result.push(c);\n        }\n    }\n    result",
  "    // TODO\n    \"\".to_string()", "    message.chars().map(|c| {\n        match\
    \ c {\n            'a' => 'c',\n            'e' => 'g',\n            'i' => 'k',\n\
    \            'o' => 'q',\n            'u' => 'y',\n            _ => c.to_ascii_uppercase(),\n\
    \        }\n    }).collect()", "    let mut encoded = String::new();\n    for\
    \ (_i, c) in message.chars().enumerate() {\n        match c {\n            'a'\
    \ | 'A' => encoded.push('c'),\n            'e' | 'E' => encoded.push('g'),\n \
    \           'i' | 'I' => encoded.push('k'),\n            'o' | 'O' => encoded.push('q'),\n\
    \            'u' | 'U' => encoded.push('y'),\n            _ => encoded.push(c),\n\
    \        }\n    }\n    encoded", "    message.chars().map(|c| {\n        if c.is_lowercase()\
    \ {\n            c.to_uppercase().next().unwrap()\n        } else if c.is_uppercase()\
    \ {\n            c.to_lowercase().next().unwrap()\n        } else {\n        \
    \    c\n        }\n    }).map(|c| {\n        match c {\n            'A' => 'C',\n\
    \            'E' => 'G',\n            'I' => 'K',\n            'O' => 'Q',\n \
    \           'U' => 'W',\n            'a' => 'c',\n            'e' => 'g',\n  \
    \          'i' => 'k',\n            'o' => 'q',\n            'u' => 'w',\n   \
    \         _ => c\n        }\n    }).collect()", "    message.chars().map(|ch|\
    \ {\n        let offset = if ch.is_ascii_uppercase() { 32 } else { 0 };\n    \
    \    let mut ch = ch as u8 + offset;\n        if ch == 'a' as u8 { ch = 'c' as\
    \ u8; }\n        else if ch == 'e' as u8 { ch = 'g' as u8; }\n        else if\
    \ ch == 'i' as u8 { ch = 'k' as u8; }\n        else if ch == 'o' as u8 { ch =\
    \ 'q' as u8; }\n        else if ch == 'u' as u8 { ch = 'w' as u8; }\n        else\
    \ if ch >= 'z' as u8 { ch -= 26; }\n        else if ch == 'A' as u8 { ch = 'C'\
    \ as u8; }\n        else if ch == 'E' as u8 { ch = 'G' as u8; }\n        else\
    \ if ch == 'I' as u8 { ch = 'K' as u8; }\n        else if ch == 'O' as u8 { ch\
    \ = 'Q' as u8; }\n        else if ch == 'U' as u8 { ch = 'W' as u8; }\n      \
    \  else if ch >= 'Z' as u8 { ch -= 26; }\n        ch -= offset;\n        ch as\
    \ char\n    }).collect()", '    message.chars().map(|c| encode_char(c)).collect()',
  "    let mut coder: HashMap<char, char> = HashMap::new();\n    let mut viter = \"\
    aeiou\".chars();\n    coder.insert('a', viter.next().unwrap());\n    coder.insert('e',\
    \ viter.next().unwrap());\n    coder.insert('i', viter.next().unwrap());\n   \
    \ coder.insert('o', viter.next().unwrap());\n    coder.insert('u', viter.next().unwrap());\n\
    \    let mut rv = String::new();\n    for c in message.chars() {\n        if coder.contains_key(&c)\
    \ {\n            rv.push(coder[&c]);\n        } else if coder.contains_key(&c.to_lowercase().nth(0).unwrap())\
    \ {\n            rv.push(coder[&c.to_lowercase().nth(0).unwrap()].to_uppercase().nth(0).unwrap());\n\
    \        } else {\n            rv.push(c);\n        }\n    }\n    rv", "    //\
    \ TODO: implement this\n    message", "    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    ;\n    message.chars().map(|x| {\n        match x {\n            'a'...'z' =>\
    \ {\n                let index = (alphabet.find(x).unwrap() + 2) % 26;\n     \
    \           alphabet.chars().nth(index).unwrap()\n            },\n           \
    \ 'A'...'Z' => {\n                let index = (alphabet.to_uppercase().find(x).unwrap()\
    \ + 2) % 26;\n                alphabet.to_uppercase().chars().nth(index).unwrap()\n\
    \            },\n            _ => x\n        }\n    }).collect()", "    let mut\
    \ chars: Vec<char> = message.chars().collect();\n    for i in 0..chars.len() {\n\
    \        let ch = chars[i];\n        if ch.is_alphabetic() {\n            chars[i]\
    \ = if ch.is_uppercase() {\n                ch.to_lowercase().nth(0).unwrap()\n\
    \            } else {\n                ch.to_uppercase().nth(0).unwrap()\n   \
    \         };\n            match ch {\n                'a' | 'e' | 'i' | 'o' |\
    \ 'u' => {\n                    chars[i] = ALPHABET[(ALPHABET.iter().position(|&c|\
    \ c == chars[i]).unwrap() + 2) % 26];\n                },\n                _ =>\
    \ {}\n            }\n        }\n    }\n    return chars.into_iter().collect();",
  "    message.chars().map(|x| \n        match x {\n            'a' => 'c',\n    \
    \        'e' => 'g',\n            'i' => 'k',\n            'o' => 'q',\n     \
    \       'u' => 'y',\n            _ => x.to_uppercase().next().unwrap()\n     \
    \   }\n    ).collect()", "    message.chars().map(|x| match x {\n        'a' =>\
    \ 'c',\n        'e' => 'g',\n        'i' => 'k',\n        'o' => 'q',\n      \
    \  'u' => 'w',\n        'A' => 'C',\n        'E' => 'G',\n        'I' => 'K',\n\
    \        'O' => 'Q',\n        'U' => 'W',\n        _ => x.to_ascii_uppercase(),\n\
    \    }).collect()", "    let mut encoded_message = String::from(\"\");\n    let\
    \ mut alpha_vec = Vec::new();\n    for i in 97..=122 {\n        alpha_vec.push(i\
    \ as char);\n    }\n    for i in 0..message.len() {\n        let mut ch = message.chars().nth(i).unwrap();\n\
    \        if ch.is_lowercase() {\n            ch = ch.to_uppercase().next().unwrap();\n\
    \        } else if ch.is_uppercase() {\n            ch = ch.to_lowercase().next().unwrap();\n\
    \        }\n        if alpha_vec.contains(&ch) {\n            let idx = alpha_vec.iter().position(|&r|\
    \ r == ch).unwrap();\n            if ch == 'u' {\n                ch = 'A';\n\
    \            } else if ch == 'U' {\n                ch = 'a';\n            } else\
    \ {\n                let idx = alpha_vec.iter().position(|&r| r == ch).unwrap();\n\
    \                let new_char = alpha_vec.get(idx + 2).unwrap();\n           \
    \     ch = *new_char;\n            }\n        }\n        encoded_message.push(ch);\n\
    \    }\n    encoded_message", "    let mut encoded = String::new();\n    let vowels\
    \ = vec!['a', 'e', 'i', 'o', 'u'];\n    for c in message.chars() {\n        if\
    \ c.is_lowercase() {\n            encoded.push(c.to_uppercase().next().unwrap());\n\
    \        } else if c.is_uppercase() {\n            encoded.push(c.to_lowercase().next().unwrap());\n\
    \        } else {\n            encoded.push(c);\n        }\n    }\n    for v in\
    \ vowels {\n        let old_v = encoded.find(v);\n        if old_v != None {\n\
    \            encoded.remove(old_v.unwrap());\n            let next_v = old_v.unwrap()\
    \ + 2;\n            encoded.insert(next_v, v);\n        }\n    }\n    encoded",
  "    let mut encoded = String::new();\n    let vowels = ['a', 'e', 'i', 'o', 'u'];\n\
    \    for c in message.chars() {\n        if c.is_ascii_uppercase() {\n       \
    \     encoded.push(c.to_ascii_lowercase());\n        } else if c.is_ascii_lowercase()\
    \ {\n            encoded.push(c.to_ascii_uppercase());\n        } else {\n   \
    \         encoded.push(c);\n        }\n    }\n    encoded", "    let my_dict =\
    \ [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut new_message = \"\".to_string();\n\
    \    for c in message.chars() {\n        let mut new_char = c;\n        if c.is_alphabetic()\
    \ {\n            if c.is_uppercase() {\n                new_char = c.to_lowercase().next().unwrap();\n\
    \            } else {\n                new_char = c.to_uppercase().next().unwrap();\n\
    \            }\n            let index = my_dict.iter().position(|&r| r == new_char.to_string().as_str());\n\
    \            match index {\n                Some(n) => {\n                   \
    \ let next_letter = ((n + 2) % 5) as usize;\n                    new_char = my_dict[next_letter].chars().next().unwrap();\n\
    \                },\n                None => ()\n            }\n        }\n  \
    \      new_message.push(new_char);\n    }\n    new_message", "    let mut encoded\
    \ = String::new();\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n    let\
    \ mut alphabet_char = alphabet.chars();\n    let mut alphabet_index = 1;\n   \
    \ let mut vowel_index: usize = 0;\n    let vowels = \"aeiou\";\n    let mut vowels_char\
    \ = vowels.chars();\n    for character in message.chars() {\n        if vowels_char.next()\
    \ == Some(character) {\n            let vowel_char = match alphabet_char.nth(vowel_index\
    \ + 2) {\n                Some(c) => c,\n                None => alphabet_char.nth(0).unwrap(),\n\
    \            };\n            encoded.push(vowel_char);\n            vowel_index\
    \ = 0;\n            alphabet_char = alphabet.chars();\n        } else {\n    \
    \        encoded.push(match character.is_uppercase() {\n                true =>\
    \ alphabet_char.nth(alphabet_index).unwrap().to_uppercase().next().unwrap(),\n\
    \                false => alphabet_char.nth(alphabet_index).unwrap(),\n      \
    \      });\n            alphabet_index += 1;\n            vowel_index += 1;\n\
    \        }\n    }\n    encoded", "    message.chars().map(|c| {\n        match\
    \ c {\n            'a' => 'c',\n            'e' => 'g',\n            'i' => 'k',\n\
    \            'o' => 'q',\n            'u' => 'y',\n            'A' => 'C',\n \
    \           'E' => 'G',\n            'I' => 'K',\n            'O' => 'Q',\n  \
    \          'U' => 'Y',\n            c => {\n                if c.is_ascii_lowercase()\
    \ {\n                    c.to_ascii_uppercase()\n                } else {\n  \
    \                  c.to_ascii_lowercase()\n                }\n            }\n\
    \        }\n    }).collect()", '    return message;', '    return String::new();',
  "    let mut result = String::from(\"\");\n    for c in message.chars() {\n    \
    \    if is_vowel(c) {\n            result.push(next_letter(c, 2));\n        }\
    \ else if is_lowercase(c) {\n            result.push(c.to_uppercase().next().unwrap());\n\
    \        } else {\n            result.push(c.to_lowercase().next().unwrap());\n\
    \        }\n    }\n    result", "    let vowel_shift = [b'a', b'e', b'i', b'o',\
    \ b'u'];\n    let mut encoded = Vec::new();\n    for b in message.as_bytes() {\n\
    \        let mut b = b.clone();\n        if *b >= b'a' && *b <= b'z' {\n     \
    \       b += b'A' - b'a';\n        }\n        else if *b >= b'A' && *b <= b'Z'\
    \ {\n            b += b'a' - b'A';\n        }\n        if vowel_shift.contains(&b)\
    \ {\n            b += 2;\n        }\n        encoded.push(b);\n    }\n    String::from_utf8(encoded).unwrap()",
  "    let mut result = String::new();\n    for c in message.chars() {\n        if\
    \ is_lowercase_vowel(c) {\n            result.push(next_vowel(c));\n        }\
    \ else if is_uppercase_vowel(c) {\n            result.push(next_vowel(c).to_uppercase().next().unwrap());\n\
    \        } else if is_lowercase_letter(c) {\n            result.push(c.to_uppercase().next().unwrap());\n\
    \        } else if is_uppercase_letter(c) {\n            result.push(c.to_lowercase().next().unwrap());\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    result",
  '    String::from("Encoded Message")', "\tmessage.chars().map(|c| {\n\t\tif c.is_ascii_alphabetic()\
    \ {\n\t\t\tmatch c {\n\t\t\t\t'a' => 'c',\n\t\t\t\t'e' => 'g',\n\t\t\t\t'i' =>\
    \ 'k',\n\t\t\t\t'o' => 'q',\n\t\t\t\t'u' => 'y',\n\t\t\t\t'A' => 'C',\n\t\t\t\t\
    'E' => 'G',\n\t\t\t\t'I' => 'K',\n\t\t\t\t'O' => 'Q',\n\t\t\t\t'U' => 'Y',\n\t\
    \t\t\tc => if c.is_ascii_uppercase() { \n\t\t\t\t\t(c as u8 + 2).to_ascii_uppercase()\n\
    \t\t\t\t} else {\n\t\t\t\t\t(c as u8 + 2).to_ascii_lowercase()\n\t\t\t\t}\n\t\t\
    \t}\n\t\t} else {\n\t\t\tc\n\t\t}\n\t}).collect()", "    let lowercase_alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\";\n    let uppercase_alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    ;\n    let vowels = \"aeiou\";\n    let mut encoded_message = String::new();\n\
    \    for character in message.chars() {\n        if character.is_alphabetic()\
    \ {\n            let lowercase_character = character.to_lowercase().next().unwrap();\n\
    \            if vowels.contains(lowercase_character) {\n                let mut\
    \ encoded_character = lowercase_character;\n                let mut encoded_alphabet\
    \ = lowercase_alphabet;\n                if character.is_uppercase() {\n     \
    \               encoded_alphabet = uppercase_alphabet;\n                }\n  \
    \              let mut encoded_index = 0;\n                for (index, letter)\
    \ in encoded_alphabet.chars().enumerate() {\n                    if letter ==\
    \ lowercase_character {\n                        encoded_index = index;\n    \
    \                    break;\n                    }\n                }\n      \
    \          encoded_index += 2;\n                encoded_index %= encoded_alphabet.len();\n\
    \                for (index, letter) in encoded_alphabet.chars().enumerate() {\n\
    \                    if index == encoded_index {\n                        encoded_character\
    \ = letter;\n                        break;\n                    }\n         \
    \       }\n                encoded_message.push(encoded_character);\n        \
    \    } else {\n                encoded_message.push(character);\n            }\n\
    \        } else {\n            encoded_message.push(character);\n        }\n \
    \   }\n    encoded_message", '    message.chars().map(|c| c.to_string()).collect::<Vec<String>>().join("")',
  "    let vowels = \"aeiou\";\n    let mut new_message = String::new();\n    for\
    \ c in message.chars() {\n        match c {\n            'a' => new_message.push('c'),\n\
    \            'e' => new_message.push('g'),\n            'i' => new_message.push('k'),\n\
    \            'o' => new_message.push('q'),\n            'u' => new_message.push('s'),\n\
    \            'A' => new_message.push('C'),\n            'E' => new_message.push('G'),\n\
    \            'I' => new_message.push('K'),\n            'O' => new_message.push('Q'),\n\
    \            'U' => new_message.push('S'),\n            _ => new_message.push(c),\n\
    \        }\n    }\n    new_message", "    let mut encoded_message = String::from(\"\
    \");\n    for ch in message.chars() {\n        if ch.is_alphabetic() {\n     \
    \       encoded_message.push(swap_char(ch));\n        } else {\n            encoded_message.push(ch);\n\
    \        }\n    }\n    encoded_message", "    let mut message = message.chars().collect::<Vec<char>>();\n\
    \    for idx in 0..message.len() {\n        match message[idx] {\n           \
    \ 'a' => message[idx] = 'c',\n            'A' => message[idx] = 'C',\n       \
    \     'e' => message[idx] = 'g',\n            'E' => message[idx] = 'G',\n   \
    \         'i' => message[idx] = 'k',\n            'I' => message[idx] = 'K',\n\
    \            'o' => message[idx] = 'q',\n            'O' => message[idx] = 'Q',\n\
    \            'u' => message[idx] = 's',\n            'U' => message[idx] = 'S',\n\
    \            'y' => message[idx] = 'a',\n            'Y' => message[idx] = 'A',\n\
    \            c if c.is_uppercase() => message[idx] = c.to_lowercase().nth(0).unwrap(),\n\
    \            c if c.is_lowercase() => message[idx] = c.to_uppercase().nth(0).unwrap(),\n\
    \            _ => {}\n        }\n    }\n    String::from_iter(message)", "   \
    \ let mut chars = message.chars();\n    let mut ret = String::new();\n    while\
    \ let Some(c) = chars.next() {\n        match c {\n            'a'...'z' => {\n\
    \                let ch = c as u8;\n                let converted = \n       \
    \             if ch >= 110 {\n                        97 + (ch + 2 - 122)\n  \
    \                  } else {\n                        ch + 2\n                \
    \    };\n                ret.push(converted as char);\n            },\n      \
    \      'A'...'Z' => {\n                let ch = c as u8;\n                let\
    \ converted = \n                    if ch >= 78 {\n                        65\
    \ + (ch + 2 - 90)\n                    } else {\n                        ch +\
    \ 2\n                    };\n                ret.push(converted as char);\n  \
    \          },\n            _ => ret.push(c),\n        }\n    }\n    ret", "  \
    \  let chars = message.chars();\n    let mut result = String::new();\n    for\
    \ c in chars {\n        match c {\n            'a' => result.push('c'),\n    \
    \        'e' => result.push('g'),\n            'i' => result.push('k'),\n    \
    \        'o' => result.push('q'),\n            'u' => result.push('s'),\n    \
    \        'A' => result.push('C'),\n            'E' => result.push('G'),\n    \
    \        'I' => result.push('K'),\n            'O' => result.push('Q'),\n    \
    \        'U' => result.push('S'),\n            'A' ... 'Z' => result.push((c as\
    \ u8 + 32) as char),\n            'a' ... 'z' => result.push((c as u8 - 32) as\
    \ char),\n            _ => result.push(c),\n        }\n    }\n    result", " \
    \   // TODO implement this function\n    let mut encoded_message = String::new();\n\
    \    let vowels: Vec<char> = vec!['a', 'e', 'i', 'o', 'u'];\n    for character\
    \ in message.chars() {\n        if vowels.contains(&character) {\n           \
    \ let index = (character as u8) - 97;\n            encoded_message.push(((index\
    \ + 2) % 26 + 97) as char);\n        } else if character.is_ascii_uppercase()\
    \ {\n            encoded_message.push(character.to_ascii_lowercase());\n     \
    \   } else {\n            encoded_message.push(character.to_ascii_uppercase());\n\
    \        }\n    }\n    encoded_message", "    let mut result = String::new();\n\
    \    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    for c in message.chars() {\n\
    \        let encoded = if c.is_lowercase() { c.to_uppercase().next().unwrap()\
    \ }\n                        else { c.to_lowercase().next().unwrap() };\n    \
    \    let encoded = if vowels.contains(&encoded) { vowels[vowels.iter().position(|&v|\
    \ v == encoded).unwrap()+2] }\n                        else { encoded };\n   \
    \     result.push(encoded);\n    }\n    result", "    let mut encoded = String::new();\n\
    \    let ascii_offset: u8 = 'a' as u8;\n    let mut chars = message.chars();\n\
    \    loop {\n        match chars.next() {\n            Some(c) => {\n        \
    \        if c.is_lowercase() {\n                    encoded.push_str(&(c.to_ascii_uppercase().to_string()));\n\
    \                } else if c.is_uppercase() {\n                    encoded.push_str(&(c.to_ascii_lowercase().to_string()));\n\
    \                } else {\n                    encoded.push_str(&c.to_string());\n\
    \                }\n            },\n            None => break,\n        }\n  \
    \  }\n    chars = encoded.chars();\n    encoded.clear();\n    loop {\n       \
    \ match chars.next() {\n            Some(c) => {\n                if c == 'a'\
    \ {\n                    encoded.push_str(\"c\");\n                } else if c\
    \ == 'e' {\n                    encoded.push_str(\"g\");\n                } else\
    \ if c == 'i' {\n                    encoded.push_str(\"k\");\n              \
    \  } else if c == 'o' {\n                    encoded.push_str(\"q\");\n      \
    \          } else if c == 'u' {\n                    encoded.push_str(\"y\");\n\
    \                } else if c == 'A' {\n                    encoded.push_str(\"\
    C\");\n                } else if c == 'E' {\n                    encoded.push_str(\"\
    G\");\n                } else if c == 'I' {\n                    encoded.push_str(\"\
    K\");\n                } else if c == 'O' {\n                    encoded.push_str(\"\
    Q\");\n                } else if c == 'U' {\n                    encoded.push_str(\"\
    Y\");\n                } else {\n                    encoded.push_str(&c.to_string());\n\
    \                }\n            },\n            None => break,\n        }\n  \
    \  }\n    encoded", '    return message;', '    unimplemented!();', "    let mut\
    \ cipher = String::from(\"\");\n    for i in message.as_bytes() {\n        let\
    \ mut char_value = i;\n        if char_value < 97 {\n            if char_value\
    \ == 65 {\n                char_value = 65 + 32;\n            } else if char_value\
    \ == 69 {\n                char_value = 69 + 32;\n            } else if char_value\
    \ == 73 {\n                char_value = 73 + 32;\n            } else if char_value\
    \ == 79 {\n                char_value = 79 + 32;\n            } else if char_value\
    \ == 85 {\n                char_value = 85 + 32;\n            }\n        } else\
    \ {\n            if char_value == 97 {\n                char_value = 97 - 32;\n\
    \            } else if char_value == 101 {\n                char_value = 101 -\
    \ 32;\n            } else if char_value == 105 {\n                char_value =\
    \ 105 - 32;\n            } else if char_value == 111 {\n                char_value\
    \ = 111 - 32;\n            } else if char_value == 117 {\n                char_value\
    \ = 117 - 32;\n            }\n        }\n        cipher.push(char_value as char);\n\
    \    }\n    return cipher;", "    let mut encoded_string = String::from(\"\");\n\
    \    for c in message.chars() {\n        let mut encoded_char = String::from(\"\
    \");\n        if c.is_lowercase() {\n            encoded_char.push(c.to_uppercase().to_string());\n\
    \        } else if c.is_uppercase() {\n            encoded_char.push(c.to_lowercase().to_string());\n\
    \        } else {\n            encoded_char.push(c.to_string());\n        }\n\
    \        encoded_string.push_str(&encoded_char);\n    }\n    encoded_string",
  "    let mut encoded = String::from(\"\");\n    for ch in message.chars() {\n  \
    \      if ch.is_alphabetic() {\n            encoded.push(match ch {\n        \
    \        'a' => 'c',\n                'e' => 'g',\n                'i' => 'k',\n\
    \                'o' => 'q',\n                'u' => 'y',\n                _ if\
    \ ch.is_uppercase() => ch.to_lowercase().next().unwrap(),\n                _ =>\
    \ ch.to_uppercase().next().unwrap(),\n            });\n        } else {\n    \
    \        encoded.push(ch);\n        }\n    }\n    encoded", "    message.chars().map(|c|\
    \ {\n        if c.is_alphabetic() {\n            let base = match c.is_lowercase()\
    \ {\n                true => b'a',\n                false => b'A',\n         \
    \   };\n            let offset = if \"aeiou\".contains(c) {\n                2\n\
    \            } else {\n                0\n            };\n            (base +\
    \ (c as u8 - base + offset) % 26) as char\n        } else {\n            c\n \
    \       }\n    }).collect()", "    const ALPHABET: &'static [char] = &['a', 'b',\
    \ 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r',\
    \ 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n    const VOWELS: &'static [char]\
    \ = &['a', 'e', 'i', 'o', 'u'];\n    let message_chars: Vec<char> = message.chars().collect();\n\
    \    let mut result = String::new();\n    for ch in message_chars {\n        if\
    \ ALPHABET.contains(&ch) {\n            if VOWELS.contains(&ch) {\n          \
    \      result.push(ALPHABET[((ALPHABET.iter().position(|&x| x == ch).unwrap()\
    \ + 2) % ALPHABET.len()) as usize]);\n            } else {\n                result.push(ALPHABET[((ALPHABET.iter().position(|&x|\
    \ x == ch).unwrap() + 2) % ALPHABET.len()) as usize]);\n            }\n      \
    \  } else {\n            result.push(ch);\n        }\n    }\n    result", "  \
    \  message.chars().map(|x|\n        match x {\n            'a' => 'c',\n     \
    \       'e' => 'g',\n            'i' => 'k',\n            'o' => 'q',\n      \
    \      'u' => 'w',\n            'A' => 'C',\n            'E' => 'G',\n       \
    \     'I' => 'K',\n            'O' => 'Q',\n            'U' => 'W',\n        \
    \    _ => x.to_ascii_uppercase(),\n        }\n    ).collect()", "    message.chars().map(|x|\
    \ match x {\n        'A' => 'C',\n        'E' => 'G',\n        'I' => 'K',\n \
    \       'O' => 'Q',\n        'U' => 'W',\n        'a' => 'c',\n        'e' =>\
    \ 'g',\n        'i' => 'k',\n        'o' => 'q',\n        'u' => 'w',\n      \
    \  _ => x.to_uppercase().nth(0).unwrap_or(x),\n    }).collect()", "    let mut\
    \ encoded_message = message.to_lowercase();\n    for char in encoded_message.chars_mut()\
    \ {\n        let number = if char.is_alphabetic() {\n            char.to_digit(36).unwrap()\
    \ - 9\n        } else {\n            char.to_digit(36).unwrap()\n        };\n\
    \        char = std::char::from_digit(number, 36).unwrap();\n    }\n    encoded_message",
  "    let mut result = String::new();\n    let vowels = String::from(\"AEIOUaeiou\"\
    );\n    let mut letter_count = 0;\n    for i in message.chars() {\n        match\
    \ i {\n            'a'..='z' => result.push((i as u8 + 32) as char),\n       \
    \     'A'..='Z' => result.push((i as u8 + 32) as char),\n            ' ' => result.push('\
    \ '),\n            _ => result.push(i),\n        }\n    }\n    for i in result.chars()\
    \ {\n        match i {\n            'a' | 'e' | 'i' | 'o' | 'u' => result.push_str(&(vowels.chars().nth(letter_count\
    \ + 2).unwrap().to_string())),\n            _ => letter_count += 1,\n        }\n\
    \    }\n    result", "    // TODO: implement me!\n    unimplemented!()", "   \
    \ let mut encoded = String::new();\n    for letter in message.chars() {\n    \
    \    match letter {\n            'a' | 'A' => encoded.push('c'),\n           \
    \ 'e' | 'E' => encoded.push('g'),\n            'i' | 'I' => encoded.push('k'),\n\
    \            'o' | 'O' => encoded.push('q'),\n            'u' | 'U' => encoded.push('y'),\n\
    \            'y' | 'Y' => encoded.push('a'),\n            ' ' => encoded.push('\
    \ '),\n            '.' => encoded.push('.'),\n            _ => encoded.push(letter),\n\
    \        }\n    }\n    encoded", "\tlet mut encoded = String::new();\n\tlet vowels\
    \ = String::from(\"aeiou\");\n\tlet s = message.chars().collect::<Vec<char>>();\n\
    \tfor (i, c) in s.iter().enumerate() {\n\t\tif vowels.contains(c) {\n\t\t\tlet\
    \ c = match c {\n\t\t\t\t'a' => 'c',\n\t\t\t\t'e' => 'g',\n\t\t\t\t'i' => 'k',\n\
    \t\t\t\t'o' => 'q',\n\t\t\t\t'u' => 'y',\n\t\t\t\t_ => panic!(\"not a vowel: {}\"\
    , c),\n\t\t\t};\n\t\t\tencoded.push(c);\n\t\t} else {\n\t\t\tencoded.push(s[i].to_ascii_uppercase());\n\
    \t\t}\n\t}\n\tencoded", '    String::from("t3s7 c1d3")', "    let index = |c:\
    \ char| (c as u8 - b'a') as usize;\n    let mut encoded = message.clone();\n \
    \   encoded.retain(|c| c.is_alphabetic());\n    encoded.to_lowercase();\n    encoded.chars().map(|c|\
    \ {\n        let i = index(c);\n        if \"aeiou\".contains(c) {\n         \
    \   std::char::from_u32( (i + 2) as u32 + b'a' as u32).unwrap()\n        } else\
    \ {\n            c\n        }\n    }).collect()", "    let mut encoded = String::new();\n\
    \    for i in message.chars() {\n        match i {\n            'a' | 'A' => encoded.push_str(\"\
    c\"),\n            'e' | 'E' => encoded.push_str(\"g\"),\n            'i' | 'I'\
    \ => encoded.push_str(\"k\"),\n            'o' | 'O' => encoded.push_str(\"q\"\
    ),\n            'u' | 'U' => encoded.push_str(\"s\"),\n            'y' | 'Y' =>\
    \ encoded.push_str(\"a\"),\n            'A' => encoded.push_str(\"C\"),\n    \
    \        'E' => encoded.push_str(\"G\"),\n            'I' => encoded.push_str(\"\
    K\"),\n            'O' => encoded.push_str(\"Q\"),\n            'U' => encoded.push_str(\"\
    S\"),\n            'Y' => encoded.push_str(\"A\"),\n            _ => encoded.push(i)\n\
    \        }\n    }\n    encoded", "    let mut result = String::new();\n    let\
    \ vowels = ['a', 'e', 'i', 'o', 'u'];\n    for c in message.chars() {\n      \
    \  let is_vowel = vowels.contains(&c);\n        let mut c_char = c;\n        if\
    \ c.is_ascii_lowercase() {\n            c_char = c.to_ascii_uppercase();\n   \
    \     } else if c.is_ascii_uppercase() {\n            c_char = c.to_ascii_lowercase();\n\
    \        }\n        if is_vowel {\n            c_char = (c_char as u8 + 2) as\
    \ char;\n        }\n        result.push(c_char);\n    }\n    result", "    let\
    \ vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    ;\n    message.chars().map(|c| {\n        let m = c.to_string().to_lowercase();\n\
    \        if vowels.contains(&m.as_str()) {\n            return alphabet.chars().nth((alphabet.find(m.as_str()).unwrap()\
    \ + 2) % 26).unwrap();\n        }\n        c\n    }).collect()", "    let mut\
    \ encoded = String::new();\n    for char in message.chars() {\n        let swap_case_char\
    \ = match char.is_uppercase() {\n            true => char.to_lowercase().next().unwrap(),\n\
    \            false => char.to_uppercase().next().unwrap(),\n        };\n     \
    \   let mut encoded_char = swap_case_char;\n        if is_vowel(swap_case_char)\
    \ {\n            encoded_char = swap_case_char.chars().skip(2).next().unwrap();\n\
    \        }\n        encoded.push(encoded_char);\n    }\n    encoded", '    return
    String::new();', "    let mut encoded_message = message.to_lowercase();\n    for\
    \ char in message.chars() {\n        if char.is_alphabetic() {\n            encoded_message.push(\n\
    \                ((char as u8) + 2) as char\n            );\n        }\n    }\n\
    \    encoded_message", "    let mut v = Vec::new();\n    for c in message.chars()\
    \ {\n        let d = if c.is_lowercase() {\n            c.to_uppercase().next().unwrap()\n\
    \        } else {\n            c.to_lowercase().next().unwrap()\n        };\n\
    \        let e = match d {\n            'A' => 'C',\n            'E' => 'G',\n\
    \            'I' => 'K',\n            'O' => 'Q',\n            'U' => 'W',\n \
    \           'Y' => 'A',\n            _ => d,\n        };\n        v.push(e);\n\
    \    }\n    v.into_iter().collect()", "    let vowels = \"aeiou\";\n    let mut\
    \ encoded = String::new();\n    for ch in message.chars() {\n        if vowels.contains(ch)\
    \ {\n            encoded.push(next_vowel(ch));\n        } else if ch.is_uppercase()\
    \ {\n            encoded.push(ch.to_lowercase().next().unwrap());\n        } else\
    \ {\n            encoded.push(ch.to_uppercase().next().unwrap());\n        }\n\
    \    }\n    encoded", "    message.chars().map(|c|\n        match c {\n      \
    \      'a' ... 'z' => \n                (((c as u8) - 'a' as u8 + 2) % 26 + 'a'\
    \ as u8) as char,\n            'A' ... 'Z' => \n                (((c as u8) -\
    \ 'A' as u8 + 2) % 26 + 'A' as u8) as char,\n            _ => c\n        }\n \
    \   ).collect()", "    let mut message_chars = message.chars();\n    let mut encoded_message:\
    \ String = String::new();\n    while let Some(c) = message_chars.next() {\n  \
    \      let encoded_letter = match c {\n            'a' => 'c',\n            'e'\
    \ => 'g',\n            'i' => 'k',\n            'o' => 'q',\n            'u' =>\
    \ 'y',\n            'A' => 'C',\n            'E' => 'G',\n            'I' => 'K',\n\
    \            'O' => 'Q',\n            'U' => 'Y',\n            _ => match c.is_uppercase()\
    \ {\n                true => c.to_lowercase().next().unwrap(),\n             \
    \   false => c.to_uppercase().next().unwrap(),\n            }\n        };\n  \
    \      encoded_message.push(encoded_letter);\n    }\n    encoded_message", " \
    \   let vowels = ['a', 'e', 'i', 'o', 'u'];\n    let mut encoded = String::new();\n\
    \    for c in message.chars() {\n        if vowels.contains(&c) {\n          \
    \  encoded.push(((c as u8) + 2) as char);\n        } else {\n            encoded.push(c);\n\
    \        }\n    }\n    encoded", "    let mut encoded_message = String::new();\n\
    \    for c in message.chars() {\n        match c {\n            'a' => encoded_message.push('c'),\n\
    \            'e' => encoded_message.push('g'),\n            'i' => encoded_message.push('k'),\n\
    \            'o' => encoded_message.push('q'),\n            'u' => encoded_message.push('y'),\n\
    \            'A' => encoded_message.push('C'),\n            'E' => encoded_message.push('G'),\n\
    \            'I' => encoded_message.push('K'),\n            'O' => encoded_message.push('Q'),\n\
    \            'U' => encoded_message.push('Y'),\n            _ => encoded_message.push(c),\n\
    \        }\n    }\n    encoded_message", "    let mut encoded = \"\".to_string();\n\
    \    for b in message.bytes() {\n        if b >= 65 && b <= 90 {\n           \
    \ encoded.push((b + 32) as char);\n        } else if b >= 97 && b <= 122 {\n \
    \           encoded.push((b - 32) as char);\n        } else {\n            encoded.push(b\
    \ as char);\n        }\n    }\n    encoded", "    let mut encoded = message.clone();\n\
    \    let mut idx = 0;\n    while idx < encoded.len() {\n        let curr = encoded.chars().nth(idx).unwrap();\n\
    \        if curr.is_alphabetic() {\n            let uppered = curr.to_uppercase().nth(0).unwrap();\n\
    \            let new_letter = (uppered as u8 + 2) as char;\n            if new_letter\
    \ > 'Z' {\n                let wrap_letter = (new_letter as u8 - 26) as char;\n\
    \                let _ = encoded.replace_range(idx..idx+1, &wrap_letter.to_lowercase().to_string());\n\
    \            } else {\n                let _ = encoded.replace_range(idx..idx+1,\
    \ &new_letter.to_lowercase().to_string());\n            }\n        }\n       \
    \ idx += 1;\n    }\n    encoded", "    let mut current = 0;\n    let mut result\
    \ = String::new();\n    let vowels = [\n        'a', 'e', 'i', 'o', 'u', 'A',\
    \ 'E', 'I', 'O', 'U'\n    ];\n    for letter in message.chars() {\n        if\
    \ vowels.contains(&letter) {\n            let mut code = letter as u8;\n     \
    \       if code < 104 {\n                code += 2;\n            } else {\n  \
    \              code -= 20;\n            }\n            result.push(code as char);\n\
    \        } else if letter.is_uppercase() {\n            result.push(letter.to_lowercase().next().unwrap());\n\
    \        } else {\n            result.push(letter.to_uppercase().next().unwrap());\n\
    \        }\n    }\n    result", "    let mut encoded_message = String::from(\"\
    \");\n    for (i, character) in message.chars().enumerate() {\n        let next_letter\
    \ = match character {\n            'a' => 'c',\n            'e' => 'g',\n    \
    \        'i' => 'k',\n            'o' => 'q',\n            'u' => 'w',\n     \
    \       _ => character\n        };\n        encoded_message.push(next_letter);\n\
    \    }\n    return encoded_message;", "    let s = message.chars().map(|c| {\n\
    \        if c.is_alphabetic() {\n            if c.is_lowercase() {\n         \
    \       c.to_uppercase().to_string()\n            } else {\n                c.to_lowercase().to_string()\n\
    \            }\n        } else {\n            c.to_string()\n        }\n    }).collect::<String>();\n\
    \    let v = s.chars().map(|c| {\n        if c.is_alphabetic() {\n           \
    \ if c == 'a' {\n                'c'\n            } else if c == 'e' {\n     \
    \           'g'\n            } else if c == 'i' {\n                'k'\n     \
    \       } else if c == 'o' {\n                'q'\n            } else if c ==\
    \ 'u' {\n                'w'\n            } else {\n                c\n      \
    \      }\n        } else {\n            c\n        }\n    }).collect::<String>();\n\
    \    return v;", '    String::from("")', "    let vowels = \"aeiou\";\n    let\
    \ consonants = \"bcdfghjklmnpqrstvwxyz\";\n    let mut result = \"\".to_string();\n\
    \    for c in message.chars() {\n        if c.is_ascii_lowercase() {\n       \
    \     if let Some(index) = vowels.find(c) {\n                result.push(vowels.chars().nth((index\
    \ + 2) % 5).unwrap());\n            } else if let Some(index) = consonants.find(c)\
    \ {\n                result.push(consonants.chars().nth((index + 2) % 21).unwrap());\n\
    \            }\n        } else if c.is_ascii_uppercase() {\n            if let\
    \ Some(index) = vowels.find(c.to_ascii_lowercase()) {\n                result.push(vowels.chars().nth((index\
    \ + 2) % 5).unwrap().to_ascii_uppercase());\n            } else if let Some(index)\
    \ = consonants.find(c.to_ascii_lowercase()) {\n                result.push(consonants.chars().nth((index\
    \ + 2) % 21).unwrap().to_ascii_uppercase());\n            }\n        } else {\n\
    \            result.push(c);\n        }\n    }\n    result", "    message.chars().map(|c|\
    \ {\n        let upper = c.is_uppercase();\n        let mut c = c.to_lowercase().next().unwrap();\n\
    \        match c {\n            'a' => c = 'c',\n            'e' => c = 'g',\n\
    \            'i' => c = 'k',\n            'o' => c = 'q',\n            'u' =>\
    \ c = 's',\n            _ => {}\n        }\n        if upper { c.to_uppercase().next().unwrap()\
    \ } else { c }\n    }).collect()", "    let mut encoded_message = String::new();\n\
    \    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    for c in message.chars() {\n\
    \        let next_char = if vowels.contains(&c) {\n            match c {\n   \
    \             'a' => 'c',\n                'e' => 'g',\n                'i' =>\
    \ 'k',\n                'o' => 'q',\n                'u' => 'y',\n           \
    \     _ => ' ',\n            }\n        } else {\n            c\n        };\n\
    \        encoded_message.push(next_char);\n    }\n    encoded_message", "    message.chars().map(|char|\
    \ {\n        let mut new_char = char;\n        if char.is_lowercase() {\n    \
    \        new_char = char.to_uppercase().next().unwrap();\n        }\n        if\
    \ char.is_uppercase() {\n            new_char = char.to_lowercase().next().unwrap();\n\
    \        }\n        match char {\n            'a' => 'c',\n            'e' =>\
    \ 'g',\n            'i' => 'k',\n            'o' => 'q',\n            'u' => 'y',\n\
    \            _ => new_char,\n        }\n    }).collect()", "    message.chars().map(|c|\
    \ {\n        if c.is_lowercase() {\n            c.to_uppercase().next().unwrap()\n\
    \        } else if c.is_uppercase() {\n            c.to_lowercase().next().unwrap()\n\
    \        } else {\n            c\n        }\n    }).map(|c| {\n        if \"aeiou\"\
    .contains(c) {\n            let c = c as i8 + 2;\n            if c > 122 {\n \
    \               (c - 26) as u8 as char\n            } else {\n               \
    \ c as u8 as char\n            }\n        } else {\n            c\n        }\n\
    \    }).collect()"]
stop_tokens:
- "\n}"
