name: HumanEval_45_triangle_area
language: rs
prompt: "/// Given length of a side and high return area for a triangle.\nfn triangle_area(a:\
  \ isize, h: isize) -> f64 {\n"
tests: "}\n\nfn main() {\n    let candidate = triangle_area;\n    assert_eq!(candidate(5,\
  \ 3), 7.5);\n    assert_eq!(candidate(2, 2), 2.0);\n    assert_eq!(candidate(10,\
  \ 8), 40.0);\n}\n"
completions: ['    return 0.5 * a as f64 * h as f64;', '    f64::from(a) * f64::from(h)
    / 2.0', "    let f64_a = a as f64;\n    let f64_h = h as f64;\n    0.5 * f64_a\
    \ * f64_h", "    // Note that we use explicit casting here.\n    // That is, we\
    \ are telling the compiler\n    // how to interpret each numeric literal.\n  \
    \  // Also note that f64 is a double-precision float.\n    // See https://doc.rust-lang.org/std/primitive.f64.html\n\
    \    ((a as f64) * (h as f64)) / 2.0", '    (a as f64 * h as f64) / 2.0', '    ((a
    as f64 * h as f64) / 2f64).round() as f64', '    ((a as f64) * (h as f64)) / 2f64',
  '    (a as f64 * h as f64) / 2.0', '    (0.5 * a as f64 * h as f64).abs()', "  \
    \  let half = a as f64 / 2.0;\n    return half * (h as f64);", "    let result\
    \ = (a as f64 * h as f64) / 2.0;\n    result", '    0.5 * (a as f64) * (h as f64)',
  '    (0.5 * (a as f64) * (h as f64)) as f64', '    0.5 * a as f64 * h as f64', '    a
    as f64 * h as f64 / 2.0', "    let area = (a as f64 * h as f64) / 2.0;\n    area",
  '    (a as f64 * h as f64 / 2.0).round()', "    let a = a as f64;\n    let h = h\
    \ as f64;\n    return 0.5 * a * h;", '    ((a as f64) * (h as f64)) / 2.0', '    0.5
    * a as f64 * h as f64', '    ((a as f64) * (h as f64)) / 2.0', '    (h as f64
    * a as f64 / 2.0).abs()', '    0.5 * (a as f64) * (h as f64)', "    if a < 0 ||\
    \ h < 0 {\n        panic!(\"a must be positive and h must be positive\");\n  \
    \  }\n    f64::from(a) * f64::from(h) / 2.0", '    (a as f64 * h as f64) / 2.0',
  "    // Because types for calculating triangle area must be float.\n    let l: f64\
    \ = a as f64;\n    let w: f64 = h as f64;\n    return ((l * w) / 2.0).abs();",
  '    (a as f64) * (h as f64) / 2.0', '    0.5 * a as f64 * h as f64', '    (a as
    f64 * h as f64) / 2.0', '    (a as f64) * (h as f64) / 2.0', '    (0.5 * a as
    f64 * h as f64) as f64', '    0.5 * (a as f64) * (h as f64)', "    let half: f64\
    \ = 0.5;\n    (half * a as f64 * h as f64) as f64", "    let area = a as f64 *\
    \ h as f64 * 0.5;\n    area", "    let result = (a * h) as f64 / 2f64;\n    result",
  '    (a as f64 * h as f64 / 2.0).abs()', '    (a as f64 * h as f64) / 2.0', '    (a
    as f64) * (h as f64) / 2.0', '    (a as f64) * (h as f64) / 2.0', '    (a as f64
    * h as f64) / 2.0', '    (a as f64 * h as f64 / 2.0).abs()', "    let a = a as\
    \ f64;\n    let h = h as f64;\n    a * h / 2.0", "    let (a, h) = (a as f64,\
    \ h as f64);\n    0.5 * a * h", '    (a as f64 * h as f64) as f64 / 2.0', "  \
    \  let a = a as f64;\n    let h = h as f64;\n    a * h / 2.0", "  if a < 0 ||\
    \ h < 0 {\n    panic!(\"Side or high of a triangle is negative.\");\n  }\n  0.5\
    \ * a as f64 * h as f64", '    (a as f64 * h as f64) / 2.0', '    (a as f64 *
    h as f64 / 2.0).round()', '    a as f64 * h as f64 / 2.0', '    (a as f64 * h
    as f64 / 2.0).abs()', '    f64::from(a) * f64::from(h) / 2.0', '  (a * h) as f64
    / 2.0', '    (a as f64 * h as f64 / 2.0).abs()', '    (a as f64 * h as f64 / 2.0).abs()',
  "    // given a and h, return area of triangle\n    f64::from(a * h) / 2f64", '    (a
    as f64) * (h as f64) / 2.0', '    0.5 * a as f64 * h as f64', '    (a as f64 *
    h as f64) / 2.0', '  (a as f64 * h as f64 / 2.0).sqrt()', "    let area = (a as\
    \ f64) * (h as f64) / 2.0;\n    area", '    ((a as f64) * (h as f64)) / 2.0',
  "    let triangle_area: f64 = (a as f64) * (h as f64) / 2.0;\n    return triangle_area;",
  "    // https://en.wikipedia.org/wiki/Heron%27s_formula\n    ((a.pow(2) + h.pow(2)\
    \ + a*h) as f64).sqrt()", '    (a as f64 * h as f64) / 2.0', "    let area = (a\
    \ as f64 * h as f64) / 2.0;\n    return area;", '    (a as f64) * (h as f64) /
    2f64', '    a as f64 * h as f64 / 2.0', "  let float_a = a as f64;\n  let float_h\
    \ = h as f64;\n  float_a * float_h / 2.0", '    (0.5 * a as f64 * h as f64).round()',
  '    ((a as f64) * (h as f64)) / 2.0', "    let x = a as f64;\n    let y = h as\
    \ f64;\n    0.5 * x * y", "    let a_f64 = a as f64;\n    let h_f64 = h as f64;\n\
    \    0.5 * a_f64 * h_f64", '    (a as f64 * h as f64 / 2f64).abs()', '    a as
    f64 * h as f64 / 2f64', "    let area = 0.5 * (a as f64) * (h as f64);\n    area",
  '    (a as f64 * h as f64 / 2.0).abs()', '    0.5f64 * a as f64 * h as f64', '    0.5
    * (a as f64) * (h as f64)', "    let ia: f64 = a as f64;\n    let ih: f64 = h\
    \ as f64;\n    (0.5 * ia * ih) as f64", '    (0.5 * a as f64 * h as f64).abs()',
  '    return (a as f64 * h as f64) / 2.0;', '    (a as f64 * h as f64) / 2.0', '    ((a
    as f64) * (h as f64)) / 2.0', "    let area = 0.5 * a as f64 * h as f64;\n   \
    \ area", '    return (0.5 * (a as f64) * (h as f64)) as f64;', "    let a = a\
    \ as f64;\n    let h = h as f64;\n    return a * h / 2.0;", '    (a as f64 * h
    as f64 / 2.0).abs()', "    let a = a as f64;\n    let h = h as f64;\n    (a *\
    \ h / 2.0).abs()", "    let result = (a as f64 * h as f64) / 2.0;\n    result",
  '    return (a as f64 * h as f64) / 2.0;', "    let result = (a * h) as f64;\n \
    \   result / 2.0", '    (a as f64 * h as f64 / 2f64).abs()', '    (0.5 * (a as
    f64) * (h as f64)) as f64', "    let area = (a as f64) * (h as f64) / 2.0;\n \
    \   area", "    let mut x = a as f64;\n    let mut y = h as f64;\n    x * y /\
    \ 2f64", '    (0.5 * a as f64 * h as f64).abs()', '    (a as f64 * h as f64 /
    2.0).abs()', '    0.5 * a as f64 * h as f64', '    ((a as f64) * (h as f64)) /
    2.0', "    let mut area: f64 = 0.0;\n    area = (a * h) as f64;\n    area / 2.0",
  '    a as f64 * h as f64 / 2f64', '    (a as f64 * h as f64) / 2f64', '    (a as
    f64 * h as f64 / 2.0).abs()', "    let a = a as f64;\n    let h = h as f64;\n\
    \    ((a * h) / 2.0).abs()", '    (a as f64 * h as f64 / 2f64).abs()', '    (0.5
    * a as f64 * h as f64).sqrt()', '    (a as f64 * h as f64) / 2.0', '    return
    (a as f64 * h as f64 * 0.5) as f64;', '    (a as f64 * h as f64) / 2.0', "   \
    \ // Type casting from isize to f64.\n    ((a as f64) * (h as f64)) / 2.0", " \
    \ // let l = a as f64;\n  // let h = h as f64;\n  // let area = l * h / 2.0;\n\
    \  // area\n  0.5 * (a as f64) * (h as f64)", '    (a as f64 * h as f64) / 2.0',
  "    // Todo\n    let result = (a as f64 * h as f64) / 2.0;\n    result", '    f64::from(a)
    * f64::from(h) / 2.0', "    let area = (a as f64) * (h as f64) / 2.0;\n    area",
  '    ((a as f64).powi(2) + (h as f64).powi(2)).sqrt() / 2.0 * h as f64', "    let\
    \ area = (a as f64 * h as f64) / 2.0;\n    area", "    let area = (a * h) as f64\
    \ / 2.0;\n    area", "    let area = a as f64 * h as f64 * 0.5;\n    area", '    (a
    as f64 * h as f64) / 2.0', '    0.5 * a as f64 * h as f64', "    let _a = a as\
    \ f64;\n    let _h = h as f64;\n    (_a * _h) / 2.0", '    (a as f64 * h as f64
    / 2.0).sqrt()', "    let area = (a * h) as f64 / 2f64;\n    area", "    let area\
    \ = (a as f64 * h as f64) / 2.0;\n    area", '    (a as f64 * h as f64 / 2.0).sqrt()',
  '    (a as f64 * h as f64) / 2.0', '    (a as f64 * h as f64 / 2_f64).abs()', " \
    \   let a: f64 = a as f64;\n    let h: f64 = h as f64;\n    (a * h) / 2.0", " \
    \   // Using triangle side a and high h.\n    ((a as f64) * (h as f64)) / 2.0",
  '    (a as f64 * h as f64 / 2.0).abs()', '    ((a as f64) * (h as f64)) / 2.0',
  '    0.5 * (a as f64) * (h as f64)', '    (a as f64 * h as f64) / 2f64', '  (a as
    f64) * (h as f64) / 2.0', "    let area = a as f64 * h as f64 * 0.5;\n    area",
  '    (a as f64 * h as f64) / 2f64', '    (a as f64 * h as f64) / 2.0', "    let\
    \ area = (a as f64 * h as f64) / 2.0;\n    area", '    return (a as f64 * h as
    f64) / 2.0;', '    return ((a as f64 * h as f64) / 2f64).abs();', "    let triangle_area\
    \ = a as f64 * h as f64 / 2.0;\n    triangle_area", '    (a as f64 * h as f64)
    / 2.0', "    let area = (a as f64 * h as f64) / 2.0;\n    area", '  return a as
    f64 * h as f64 / 2.0;', "    let area = a as f64 * h as f64 / 2f64;\n    area",
  '    (a as f64) * (h as f64) / 2.0', '    return a as f64 * h as f64 / 2.0;', " \
    \   let area = ((a as f64) * (h as f64)) / 2.0;\n    area", '    return a as f64
    * h as f64 / 2.0;', '    ((a as f64) * (h as f64)) / 2.0', '    (a as f64 * h
    as f64) / 2.0', '    (a as f64) * (h as f64) / 2.0', '    (a as f64 * h as f64
    / 2.0).round()', "    let x = a as f64;\n    let y = h as f64;\n    (x * y) /\
    \ 2.0", "  let area = (a as f64 * h as f64) / 2.0;\n  area", '    (a as f64 *
    h as f64) / 2.0', '    (a as f64 * h as f64 / 2.0).abs()', '    ((a as f64 * h
    as f64) / 2.0) as f64', '    (a as f64 * h as f64 / 2.0).abs()', "    let triangle\
    \ = (a * h) as f64 / 2.0;\n    triangle", "    let mut area: f64 = f64::from(a\
    \ * h) / 2f64;\n    println!(\"Triangle area is {}\", area);\n    area", "   \
    \ let f_a = a as f64;\n    let f_h = h as f64;\n    0.5 * f_a * f_h", "    let\
    \ area = (a as f64 * h as f64) / 2.0;\n    area", '    ((a as f64) * (h as f64))
    / 2.0', '    (a as f64) * (h as f64) / 2f64', '    return a as f64 * h as f64
    / 2.0;', '    (a as f64) * (h as f64) / 2.0', '    (a as f64) * (h as f64) / 2.0',
  '    ((a as f64) * (h as f64)) / 2.0', '    (h as f64) * (a as f64) / 2.0', '    a
    as f64 * h as f64 / 2.0', '    (a as f64 * h as f64 / 2f64).abs()', "    let area\
    \ = (a * h) as f64 / 2.0;\n    area", '    (a as f64 * h as f64) / 2.0', "   \
    \ let a_f = a as f64;\n    let h_f = h as f64;\n    (a_f * h_f) / 2.0", '    ((a
    as f64) * (h as f64)) / 2.0', '    (a as f64 * h as f64) / 2.0', "    let a =\
    \ a as f64;\n    let h = h as f64;\n    a * h / 2.0", "    let area = (a as f64)\
    \ * (h as f64) / 2.0;\n    area", '    (a as f64) * (h as f64) / 2.0', '    (a
    as f64 * h as f64) / 2.0', '    ((a as f64) * (h as f64)) / 2f64', '    (a as
    f64 * h as f64) / 2.0', '    (a as f64 * h as f64) as f64 * 0.5', '    (((a as
    f64) * (h as f64)) / 2_f64).abs()', '    ((a as f64) * (h as f64)) / 2.0', " \
    \   // let a = a as f64;\n    // let h = h as f64;\n    // 0.5 * a * h\n    0.5\
    \ * a as f64 * h as f64", '  (a as f64 * h as f64 * 0.5).abs()', "    // Uncomment\
    \ the code below, to make the function work.\n    // fn triangle_area_helper(a:\
    \ isize, h: isize) -> f64 {\n    //     let area: f64 = (0.5 * a as f64 * h as\
    \ f64).abs();\n    //     area\n    // }\n    // triangle_area_helper(a, h) as\
    \ f64\n    unimplemented!()", '  (0.5 * a as f64 * h as f64).floor()', '    a
    as f64 * h as f64 / 2_f64', "    let a = a as f64;\n    let h = h as f64;\n  \
    \  a * h / 2.0", '    0.5 * a as f64 * h as f64', '    (a as f64) * (h as f64)
    / 2.0', '    ((a as f64) * (h as f64)) / 2.0', '    (0.5 * a as f64 * h as f64).sqrt()',
  "    let area = (a as f64 * h as f64) / 2.0;\n    area", "    let area = a as f64\
    \ * h as f64 / 2.0;\n    area", "    let area = 0.5 * (a as f64) * (h as f64);\n\
    \    return area;"]
stop_tokens:
- "\n}"
