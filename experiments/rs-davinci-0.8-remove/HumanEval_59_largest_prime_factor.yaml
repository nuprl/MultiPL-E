name: HumanEval_59_largest_prime_factor
language: rs
prompt: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
  fn largest_prime_factor(n: isize) -> isize {\n"
tests: "}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
  \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n  \
  \  assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
completions: ["    let upper_bound = (n as f64).sqrt() as isize + 1;\n    for i in\
    \ (2..upper_bound).rev() {\n        if n % i == 0 && is_prime(i) {\n         \
    \   return i;\n        }\n    }\n    panic!(\"The largest prime factor of {} is\
    \ larger than {}.\", n, upper_bound);", "    let mut largest = 0;\n    let mut\
    \ i = 2;\n    while i * i <= n {\n        if n % i == 0 {\n            while n\
    \ % i == 0 {\n                n /= i;\n            }\n            largest = i;\n\
    \        }\n        i += 1;\n    }\n    if n > 1 {\n        return n;\n    }\n\
    \    largest", "    let mut largest_prime = 0;\n    let mut factor = 2;\n    let\
    \ mut remainder = n;\n    while remainder > 1 {\n        while remainder % factor\
    \ == 0 {\n            remainder /= factor;\n            largest_prime = factor;\n\
    \        }\n        factor += 1;\n    }\n    largest_prime", "    let mut r =\
    \ n;\n    let mut p = 2;\n    while p * p <= r {\n        if r % p == 0 {\n  \
    \          r /= p;\n        } else {\n            p += 1;\n        }\n    }\n\
    \    r", "    let mut factor = 2;\n    let mut n = n;\n    while n > 1 {\n   \
    \     if n % factor == 0 {\n            n /= factor;\n        } else {\n     \
    \       factor += 1;\n        }\n    }\n    factor", "  // Only odd numbers can\
    \ be a factor of n, and there are no primes\n  // between 2 and 6.\n  for i in\
    \ (3..)\n         .step_by(2)\n         .take_while(|&i| i * i <= n) {\n    if\
    \ n % i == 0 {\n      return largest_prime_factor(n / i);\n    }\n  }\n  n", " \
    \   for p in (2..).take_while(|x| x*x <= n) {\n        if n % p == 0 {\n     \
    \       return largest_prime_factor(n / p);\n        }\n    }\n    n", '    (2..n).filter(|i|
    is_prime(*i) && n % i == 0).max().unwrap()', "    let mut number = n;\n    let\
    \ mut i = 2;\n    while i < number {\n        if is_prime(i) && number % i ==\
    \ 0 {\n            number /= i;\n        }\n        i += 1;\n    }\n    number",
  "    let mut largest_factor = 2;\n    let mut num = n;\n    while num % 2 == 0 {\n\
    \        num /= 2;\n    }\n    let mut factor = 3;\n    while num > 1 {\n    \
    \    if num % factor == 0 {\n            num /= factor;\n            largest_factor\
    \ = factor;\n        } else {\n            factor += 2;\n        }\n    }\n  \
    \  largest_factor", "    let mut tmp = n;\n    for i in 2..(n as f64).sqrt() as\
    \ isize + 1 {\n        if tmp % i == 0 {\n            tmp /= i;\n            while\
    \ tmp % i == 0 {\n                tmp /= i;\n            }\n        }\n    }\n\
    \    tmp", "    let mut t = n;\n    let mut i = 2;\n    while i <= t {\n     \
    \   if t % i == 0 {\n            t /= i;\n        } else {\n            i += 1;\n\
    \        }\n    }\n    return i;", "    for i in (2..).take_while(|&i| i * i <=\
    \ n) {\n        if n % i == 0 {\n            return largest_prime_factor(n / i);\n\
    \        }\n    }\n    n", "    let mut current_factor = 2;\n    let mut copy\
    \ = n;\n    while copy > 1 {\n        if is_prime(current_factor) && copy % current_factor\
    \ == 0 {\n            copy /= current_factor;\n        } else {\n            current_factor\
    \ += 1;\n        }\n    }\n    current_factor", "    if is_prime(n) {\n      \
    \  return n;\n    }\n\n    let largest_factor = prime_factors(n).iter().max().unwrap();\n\
    \    *largest_factor", "    let mut smallest_prime_factor = 2;\n    let mut factors\
    \ = Vec::new();\n    let mut number = n;\n    loop {\n        if smallest_prime_factor\
    \ * smallest_prime_factor > number {\n            break;\n        }\n        if\
    \ number % smallest_prime_factor == 0 {\n            number /= smallest_prime_factor;\n\
    \            factors.push(smallest_prime_factor);\n        } else {\n        \
    \    smallest_prime_factor += 1;\n        }\n    }\n    factors.push(number);\n\
    \    println!(\"Factors are {:?}\", factors);\n    factors.iter().max().unwrap().clone()",
  "    // We only have to check up to the square root of n.\n    let max = (n as f64).sqrt()\
    \ as isize;\n    // start with the smallest prime, which is 2\n    let mut factor\
    \ = 2;\n    while factor <= max {\n        if n % factor == 0 {\n            //\
    \ If there's a factor of n, then that factor is prime,\n            // so it must\
    \ be the largest prime factor we're looking for.\n            return n / factor;\n\
    \        }\n        // we only need to check for the smallest prime factors,\n\
    \        // so we only have to check every other number\n        factor += 1;\n\
    \    }\n    // No prime factors found. n must be prime.\n    return n;", "   \
    \ for i in (1..).map(|x| x * 2 + 1).take_while(|&x| x * x <= n) {\n        if\
    \ n % i == 0 {\n            return largest_prime_factor(n / i);\n        }\n \
    \   }\n    n", "    let mut n = n;\n    let mut p = 3;\n    while n > 1 {\n  \
    \      if n % p == 0 {\n            n /= p;\n        } else {\n            p +=\
    \ 2;\n        }\n    }\n    p", "    let mut current = n;\n    let mut largest_prime\
    \ = 2;\n    let mut factor = 2;\n    while current > 1 {\n        if current %\
    \ factor == 0 {\n            current /= factor;\n            if factor > largest_prime\
    \ {\n                largest_prime = factor;\n            }\n        } else {\n\
    \            factor += 1;\n        }\n    }\n    largest_prime", "    let mut\
    \ factor = 2;\n    let mut n = n;\n    while n > 1 {\n        if n % factor ==\
    \ 0 {\n            while n % factor == 0 {\n                n /= factor;\n   \
    \         }\n        }\n        factor += 1;\n    }\n    factor - 1", "    let\
    \ mut p = 2;\n    let mut n = n;\n    while n > 1 {\n        if n % p == 0 {\n\
    \            n /= p;\n        } else {\n            p += 1;\n        }\n    }\n\
    \    p", "    let mut factor = n / 2;\n    while ! is_prime(factor) {\n      \
    \  factor -= 1;\n    }\n    factor", "    let mut factor = 2;\n    let mut n =\
    \ n;\n    while n % factor != 0 {\n        factor += 1;\n    }\n    n / factor",
  "    let mut result = 1;\n    let mut div = 2;\n    let mut temp = n;\n    while\
    \ temp > 1 {\n        if is_prime(div) && temp % div == 0 {\n            temp\
    \ /= div;\n            result = div;\n        }\n        div += 1;\n    }\n  \
    \  result", "    let mut i = 2;\n    let mut largest = n;\n    while i < largest\
    \ {\n        if n % i == 0 {\n            largest = n / i;\n        }\n      \
    \  i += 1;\n    }\n    largest", "    // Check divisibility by primes starting\
    \ with 2. (The largest prime\n    // factor of any composite is always <= n /\
    \ 2).\n    let mut i = 2;\n    while i * i <= n {\n        // Get rid of multiples\
    \ of i, so that i will be prime.\n        while n % i == 0 {\n            n /=\
    \ i;\n        }\n        i += 1;\n    }\n    n", "    for i in (2..).take_while(|&i|\
    \ i * i <= n) {\n        if n % i == 0 {\n            return largest_prime_factor(n\
    \ / i);\n        }\n    }\n    n", "    let mut f = (1..).find(|&x| n % x == 0).unwrap();\n\
    \    let m = n / f;\n    if is_prime(m) { m } else { largest_prime_factor(m) }",
  "    if n % 2 == 0 {\n        return largest_prime_factor(n / 2);\n    }\n    for\
    \ d in (3..).step_by(2) {\n        if n % d == 0 {\n            return largest_prime_factor(n\
    \ / d);\n        }\n    }\n    return 0;", "    let mut n = n;\n    for i in (2..).take_while(|&x|\
    \ x * x <= n) {\n        while n % i == 0 {\n            n /= i;\n        }\n\
    \    }\n    n", "    // let mut n = n;\n    let mut i = 2;\n    while i * i <=\
    \ n {\n        if n % i == 0 {\n            n /= i;\n        } else {\n      \
    \      i += 1;\n        }\n    }\n    n", "    // try 2...sqrt(n)\n    let n_sqrt\
    \ = (n as f64).sqrt() as isize;\n    let mut i = n_sqrt;\n    while i > 1 {\n\
    \        if n % i == 0 && is_prime(i) {\n            return i;\n        }\n  \
    \      i -= 1;\n    }\n    panic!(\"largest_prime_factor failed\");", "    let\
    \ limit = (n as f64).sqrt() as isize;\n    let mut p = 3;\n    while p <= limit\
    \ {\n        if n % p == 0 {\n            return largest_prime_factor(n / p);\n\
    \        }\n        p += 2;\n    }\n    n", "    // Start at the lowest prime\n\
    \    let mut f = 2;\n    let mut n = n;\n    // Loop until all the factors are\
    \ exhausted\n    while n > 1 {\n        // If f divides n, remove all factors\
    \ of f\n        if n % f == 0 {\n            while n % f == 0 {\n            \
    \    n /= f;\n            }\n        }\n        // Get the next prime\n      \
    \  f = get_next_prime(f);\n    }\n    // Return the largest factor\n    f", " \
    \   for i in (2..n).rev() {\n        if i.is_prime() && n % i == 0 {\n       \
    \     return i;\n        }\n    }\n    unreachable!()", "    let mut k = 2;\n\
    \    let mut factor = 0;\n    while k * k <= n {\n        if n % k == 0 {\n  \
    \          factor = k;\n            while n % k == 0 {\n                n /= k;\n\
    \            }\n        }\n        k += 1;\n    }\n    if n > 1 {\n        factor\
    \ = n;\n    }\n    factor", "    let mut factor = 3;\n    while n % factor !=\
    \ 0 {\n        factor += 2;\n    }\n    while n % factor == 0 {\n        n /=\
    \ factor;\n    }\n    if n > 1 {\n        largest_prime_factor(n)\n    } else\
    \ {\n        factor\n    }", "    for i in 2..=n {\n        if is_prime(i) &&\
    \ n % i == 0 {\n            return largest_prime_factor(n / i);\n        }\n \
    \   }\n    return n;", "    let mut factor = n;\n    let mut factor_set = HashSet::new();\n\
    \    let mut i = 2;\n    while i * i <= factor {\n        if factor % i == 0 {\n\
    \            factor_set.insert(i);\n            factor /= i;\n        } else {\n\
    \            i += 1;\n        }\n    }\n    if factor != 1 {\n        factor_set.insert(factor);\n\
    \    }\n    factor_set.into_iter().max().unwrap()", "    let mut largest = 0;\n\
    \    for i in 2..(n/2 + 1) {\n        if n % i == 0 && is_prime(i) {\n       \
    \     largest = i;\n        }\n    }\n    largest", "    let mut curr_factor =\
    \ 2;\n    let mut num = n;\n    while num > 1 {\n        if num % curr_factor\
    \ == 0 {\n            num /= curr_factor;\n        } else {\n            curr_factor\
    \ += 1;\n        }\n    }\n    curr_factor", "    let mut n = n;\n    let mut\
    \ p: isize = 2;\n    while n % p != 0 {\n        p += 1;\n    }\n    while n %\
    \ p == 0 {\n        n /= p;\n    }\n    if n == 1 {\n        p\n    } else {\n\
    \        largest_prime_factor(n)\n    }", "    let mut n = n;\n    let mut i =\
    \ 2;\n    while i * i <= n {\n        if n % i == 0 {\n            n /= i;\n \
    \       } else {\n            i += 1;\n        }\n    }\n    n", "    let mut\
    \ i = 2;\n    while i <= n {\n        if is_prime(i) && (n % i == 0) {\n     \
    \       return largest_prime_factor(n / i);\n        }\n        i += 1;\n    }\n\
    \    panic!(\"The largest prime factor must be less than or equal to n.\")", " \
    \   let n_sqrt = (n as f64).sqrt() as isize;\n    let mut factor = 2;\n    while\
    \ factor <= n_sqrt {\n        if n % factor == 0 {\n            return largest_prime_factor(n\
    \ / factor);\n        }\n        factor += 1;\n    }\n    n", "    let mut prime_factors\
    \ = Vec::new();\n    let mut n = n;\n    let mut n_factors = factors(n);\n   \
    \ while n_factors.len() > 1 {\n        let mut is_prime = true;\n        for n_factor\
    \ in n_factors.iter() {\n            let factor_factors = factors(*n_factor);\n\
    \            if factor_factors.len() > 1 {\n                is_prime = false;\n\
    \                break;\n            }\n        }\n        if is_prime {\n   \
    \         prime_factors.extend(n_factors);\n            break;\n        } else\
    \ {\n            for n_factor in n_factors.iter() {\n                if *n_factor\
    \ < n {\n                    n = *n_factor;\n                    break;\n    \
    \            }\n            }\n            n_factors = factors(n);\n        }\n\
    \    }\n    *prime_factors.iter().max().unwrap()", "    if n < 2 {\n        return\
    \ 0;\n    }\n    let mut factor = 2;\n    let mut n = n;\n    while n > 1 {\n\
    \        if n % factor == 0 {\n            n /= factor;\n        } else {\n  \
    \          factor += 1;\n        }\n    }\n    factor", "    let mut curr = n;\n\
    \    let mut i = 2;\n    let mut largest = 2;\n    while i <= curr / i {\n   \
    \     if curr % i == 0 {\n            largest = i;\n            while curr % i\
    \ == 0 {\n                curr /= i;\n            }\n        }\n        i += 1;\n\
    \    }\n    if curr > largest {\n        curr\n    } else {\n        largest\n\
    \    }", "    let mut candidate = n / 2;\n    loop {\n        if is_prime(candidate)\
    \ && (n % candidate == 0) {\n            return candidate;\n        }\n      \
    \  candidate -= 1;\n    }", "    let mut largest_prime_factor = 1;\n    let mut\
    \ prime_factors = HashSet::new();\n    let mut next_prime = 2;\n    let mut num\
    \ = n;\n    loop {\n        if num == 1 {\n            break;\n        }\n   \
    \     // if num is divisible by next_prime, add it to the set\n        if num\
    \ % next_prime == 0 {\n            largest_prime_factor = next_prime;\n      \
    \      prime_factors.insert(next_prime);\n            num /= next_prime;\n   \
    \     } else {\n            // otherwise, get the next prime number\n        \
    \    next_prime = next_prime_after(next_prime);\n        }\n    }\n    largest_prime_factor",
  "  let mut prime_factors = (2..).filter(|i| is_prime(*i)).take_while(|i| i * i <=\
    \ n);\n  let mut largest_factor = *prime_factors.next().unwrap();\n  while n %\
    \ largest_factor != 0 {\n    largest_factor = *prime_factors.next().unwrap();\n\
    \  }\n  largest_factor", "    for i in 2..n {\n        if n % i == 0 {\n     \
    \       return largest_prime_factor(n / i);\n        }\n    }\n    panic!(\"largest_prime_factor:\
    \ n is a prime number\");", "    let mut largest = 1;\n    let mut test = 2;\n\
    \    let mut num = n;\n    while num > 1 {\n        while num % test == 0 {\n\
    \            largest = test;\n            num /= test;\n        }\n        test\
    \ += 1;\n    }\n    largest", "    let mut current_factor = 2;\n    let mut remainder\
    \ = n;\n    let mut largest_factor = 1;\n\n    while remainder > 1 {\n       \
    \ if remainder % current_factor == 0 {\n            remainder /= current_factor;\n\
    \            largest_factor = current_factor;\n        } else {\n            current_factor\
    \ += 1;\n        }\n    }\n\n    largest_factor", "    for factor in (2..(n as\
    \ f64).sqrt() as isize + 1).rev() {\n        if n % factor == 0 && is_prime(factor)\
    \ {\n            return factor;\n        }\n    }\n    panic!(\"Invalid arguments\"\
    );", "    for i in (2..(n/2 + 1)).rev() {\n        if n % i == 0 && is_prime(i)\
    \ {\n            return i;\n        }\n    }\n    panic!(\"No largest prime factor\
    \ found\");", "    let mut i = 2;\n    while i * i <= n {\n        if n % i ==\
    \ 0 {\n            return largest_prime_factor(n / i);\n        }\n        i +=\
    \ 1;\n    }\n    n", "    // Append primes to our prime list as we need them.\n\
    \    let mut primes = vec![2];\n    let mut p = 2;\n    while n > 1 {\n      \
    \  while n % p == 0 {\n            n /= p;\n        }\n        p = next_prime(p);\n\
    \        primes.push(p);\n    }\n    primes.pop().unwrap()", "    let mut n =\
    \ n;\n    let mut candidate = 2;\n    while n > 1 {\n        if n % candidate\
    \ == 0 {\n            n /= candidate;\n        } else {\n            candidate\
    \ += 1;\n        }\n    }\n    candidate", "  for f in (2..).filter(|&x| is_prime(x)).take_while(|&x|\
    \ x <= n) {\n    if n % f == 0 {\n      return largest_prime_factor(n / f);\n\
    \    }\n  }\n  unreachable!();", "    // TODO: implement\n    return 0;", "  let\
    \ mut prime = 2;\n  let mut k = n;\n  while k % prime == 0 {\n    k /= prime;\n\
    \  }\n  let mut divisor = 3;\n  while k > 1 {\n    if k % divisor == 0 {\n   \
    \   prime = divisor;\n      k /= divisor;\n    } else {\n      divisor += 2;\n\
    \    }\n  }\n  prime", "    // We can skip 2, 3 and 5 because they are the only\
    \ primes below 10.\n    // If n is composite and is divisible by one of them,\
    \ then n is divisible\n    // by some other prime.\n    let prime_multiples =\
    \ vec![\n        // 2\n        vec![2, 4, 6, 8],\n        // 3\n        vec![3,\
    \ 9],\n        // 5\n        vec![5],\n    ];\n\n    let mut largest_prime_factor\
    \ = 1;\n    for prime in (7..n).filter(|x| is_prime(*x)) {\n        if n % prime\
    \ == 0 {\n            largest_prime_factor = prime;\n        }\n    }\n\n    if\
    \ largest_prime_factor > 1 {\n        largest_prime_factor\n    } else {\n   \
    \     // if n is not divisible by any of the primes > 5, it is a prime > 5.\n\
    \        n\n    }", "    for i in 2..((n as f64).sqrt() as isize + 1) {\n    \
    \    if n % i == 0 {\n            return largest_prime_factor(n / i);\n      \
    \  }\n    }\n    n", "    let mut n = n;\n    let mut factor = 2;\n    while n\
    \ % factor != 0 {\n        factor += 1;\n    }\n    n / factor", "    // Take\
    \ advantage of the fact that if a number can be expressed as a product of\n  \
    \  // two prime numbers, at least one of them is <= sqrt(n).\n\n    let mut i\
    \ = 2;\n    while i <= (n as f64).sqrt() as isize {\n        if n % i == 0 {\n\
    \            return largest_prime_factor(n / i);\n        }\n        i += 1;\n\
    \    }\n    n", "    let mut d = 2;\n    while n % d != 0 {\n        d += 1;\n\
    \    }\n    let q = n / d;\n    if q == 1 {\n        d\n    } else {\n       \
    \ largest_prime_factor(q)\n    }", "    let mut n = n;\n    let mut divisor =\
    \ 2;\n    while n > 1 {\n        if n % divisor == 0 {\n            n /= divisor;\n\
    \        } else {\n            divisor += 1;\n        }\n    }\n    divisor",
  "    let mut i = 2;\n    let mut n = n;\n    let mut max_factor = 1;\n    while\
    \ i * i <= n {\n        if n % i == 0 {\n            n /= i;\n            max_factor\
    \ = i;\n        } else {\n            i += 1;\n        }\n    }\n    if n > 1\
    \ {\n        max_factor = n;\n    }\n    max_factor", "    let mut prime = 2;\n\
    \    let mut factor = n;\n    while factor % prime == 0 {\n        factor /= prime;\n\
    \    }\n    prime += 1;\n    while factor > 1 {\n        while factor % prime\
    \ == 0 {\n            factor /= prime;\n        }\n        prime += 2;\n    }\n\
    \    prime - 2", "    // We can immediately eliminate 1, 2, and 3 from the set\
    \ of possible\n    // solutions because they are all prime.\n    let mut largest\
    \ = 4;\n    let mut running = n;\n    while running % 2 == 0 {\n        largest\
    \ = 2;\n        running /= 2;\n    }\n    // This range is where all the prime\
    \ factors will be.\n    for p in (3..isize::sqrt(n) + 1).step_by(2) {\n      \
    \  if running % p == 0 {\n            largest = p;\n            running /= p;\n\
    \        }\n    }\n    largest", "    let mut factor = 2;\n    let mut n = n;\n\
    \    while n > 1 {\n        if n % factor == 0 {\n            n /= factor;\n \
    \       } else {\n            factor += 1;\n        }\n    }\n    factor", " \
    \   let mut a = 2;\n    let mut b = n;\n    while a * a <= b {\n        if b %\
    \ a == 0 {\n            b /= a;\n        } else {\n            a += 1;\n     \
    \   }\n    }\n    b", "    for i in (2..).take_while(|&i| i * i <= n) {\n    \
    \    if n % i == 0 {\n            return largest_prime_factor(n / i);\n      \
    \  }\n    }\n    n", "    for i in (2..).take_while(|&i| i * i <= n) {\n     \
    \   if n % i == 0 {\n            return largest_prime_factor(n / i);\n       \
    \ }\n    }\n    n", "    let mut n = n;\n    let mut factor = 2;\n    while n\
    \ % factor != 0 {\n        factor += 1;\n    }\n    while n % factor == 0 {\n\
    \        n /= factor;\n    }\n    if n == 1 {\n        factor\n    } else {\n\
    \        largest_prime_factor(n)\n    }", "    let mut factor = 0;\n    let mut\
    \ i = 2;\n    let mut n = n;\n    while i <= n {\n        if n % i == 0 {\n  \
    \          factor = i;\n            n /= i;\n            while n % i == 0 {\n\
    \                n /= i;\n            }\n        }\n        i += 1;\n    }\n \
    \   factor", "    let mut prime_factors = Vec::new();\n    let mut dividend =\
    \ n;\n    let mut divisor = 2;\n    while dividend > 1 {\n        if dividend\
    \ % divisor == 0 {\n            prime_factors.push(divisor);\n            dividend\
    \ /= divisor;\n        } else {\n            divisor += 1;\n        }\n    }\n\
    \    prime_factors.iter().max().unwrap().clone()", "    let mut f = 2;\n    while\
    \ n % f != 0 {\n        f += 1;\n    }\n    let quotient = n / f;\n    if is_prime(quotient)\
    \ {\n        quotient\n    } else {\n        largest_prime_factor(quotient)\n\
    \    }", "    let mut primes = Primes::new();\n    loop {\n        let p = primes.next().unwrap();\n\
    \        if n % p == 0 {\n            return p;\n        }\n    }", "    let mut\
    \ i = 2;\n    while i < n / 2 {\n        if n % i == 0 {\n            return largest_prime_factor(n\
    \ / i);\n        }\n        i += 1;\n    }\n    n", "    for p in factors(n) {\n\
    \        if is_prime(p) {\n            return p;\n        }\n    }\n    panic!(\"\
    No prime factor\");", "    let mut factor = 2;\n    let mut n = n;\n    while\
    \ n % factor != 0 {\n        factor += 1;\n    }\n    n / factor", "    if is_prime(n)\
    \ {\n        return n;\n    }\n\n    // Find the smallest factor.\n    let mut\
    \ factor = 2;\n    while n % factor != 0 {\n        factor += 1;\n    }\n\n  \
    \  // Return the largest prime factor of n / factor.\n    largest_prime_factor(n\
    \ / factor)", "    let mut i = 2;\n    while i * i <= n {\n        if n % i ==\
    \ 0 {\n            // If i is not prime, then the largest prime factor is not\
    \ in the\n            // range [2,i].\n            if !is_prime(i) {\n       \
    \         return largest_prime_factor(n / i);\n            }\n            return\
    \ n / i;\n        }\n        i += 1;\n    }\n    // n is prime\n    n", "    let\
    \ mut current = n;\n    let mut result = 0;\n    while current % 2 == 0 {\n  \
    \      current /= 2;\n    }\n    if current == 1 {\n        return 2;\n    }\n\
    \    for d in (3..).step_by(2) {\n        while current % d == 0 {\n         \
    \   current /= d;\n            result = d;\n        }\n        if current == 1\
    \ {\n            return result;\n        }\n    }\n    unreachable!();", "   \
    \ if n < 2 {\n        panic!(\"largest_prime_factor of {} is invalid\", n);\n\
    \    }\n\n    // We only check up to the square root of n.\n    let factor_limit\
    \ = (n as f64).sqrt() as isize;\n\n    // Start checking primes at 5, since 2\
    \ and 3 are the only primes < 5.\n    let mut test_factor = 5;\n\n    // Check\
    \ for whether n is divisible by any smaller primes first.\n    for p in 2..factor_limit\
    \ {\n        if n % p == 0 {\n            return largest_prime_factor(n / p);\n\
    \        }\n    }\n\n    // Try all the odd numbers from 5 to factor_limit.\n\
    \    while test_factor <= factor_limit {\n        if n % test_factor == 0 {\n\
    \            return largest_prime_factor(n / test_factor);\n        }\n      \
    \  test_factor += 2;\n    }\n\n    // None of the smaller primes or odd numbers\
    \ worked, so n must be prime.\n    return n;", "    let mut largest_prime_factor\
    \ = 1;\n    let mut remaining = n;\n    let mut current_prime = 2;\n    while\
    \ remaining > 1 {\n        if remaining % current_prime == 0 {\n            remaining\
    \ /= current_prime;\n            largest_prime_factor = current_prime;\n     \
    \   } else {\n            current_prime = next_prime(current_prime);\n       \
    \ }\n    }\n    largest_prime_factor", "    let mut largest_prime = 1;\n    let\
    \ mut cur = n;\n    let mut i = 2;\n    while i <= cur {\n        if cur % i ==\
    \ 0 {\n            largest_prime = i;\n            cur /= i;\n        } else {\n\
    \            i += 1;\n        }\n    }\n    largest_prime", "    let mut biggest\
    \ = 1;\n    let mut i = 2;\n    while i * i <= n {\n        if n % i == 0 {\n\
    \            biggest = i;\n            n /= i;\n        } else {\n           \
    \ i += 1;\n        }\n    }\n    if n > 1 {\n        biggest = n;\n    }\n   \
    \ biggest", "    let mut n = n;\n    let mut p = 2;\n    while n % p != 0 {\n\
    \        p += 1;\n    }\n    n /= p;\n    while !is_prime(n) {\n        p = largest_prime_factor(n);\n\
    \        n /= p;\n    }\n    n", "    if is_prime(n) {\n        return n;\n  \
    \  }\n\n    let mut d = 2;\n    while d * d <= n {\n        if n % d == 0 {\n\
    \            return largest_prime_factor(n / d);\n        }\n        d += 1;\n\
    \    }\n\n    n", "    assert!(n > 1);\n    let mut n = n;\n    let mut largest_factor\
    \ = 1;\n    for factor in 2..n {\n        if n % factor == 0 {\n            largest_factor\
    \ = factor;\n            n /= factor;\n            while n % factor == 0 {\n \
    \               n /= factor;\n            }\n        }\n    }\n    if n > 1 {\n\
    \        largest_factor = n;\n    }\n    largest_factor", "    let sqrt_n = (n\
    \ as f64).sqrt() as isize;\n    let mut i = sqrt_n;\n    while i > 1 {\n     \
    \   if n % i == 0 && is_prime(i) {\n            return i;\n        }\n       \
    \ i -= 1;\n    }\n    n", "    let mut largest_prime_factor = 0;\n    let mut\
    \ i = 2;\n    while i * i <= n {\n        if n % i == 0 {\n            largest_prime_factor\
    \ = i;\n            while n % i == 0 {\n                n /= i;\n            }\n\
    \        }\n        i += 1;\n    }\n    if n > 1 {\n        largest_prime_factor\
    \ = n;\n    }\n    largest_prime_factor", "    let mut i = 2;\n    let mut res\
    \ = n;\n    while i * i <= n {\n        if res % i == 0 {\n            res /=\
    \ i;\n        } else {\n            i += 1;\n        }\n    }\n    res", "   \
    \ let mut n = n;\n    let mut d = 2;\n    while n > 1 {\n        while n % d ==\
    \ 0 {\n            n /= d;\n        }\n        d += 1;\n    }\n    d - 1", " \
    \   let mut divisor = 2;\n    let mut remaining = n;\n    while divisor * divisor\
    \ <= remaining {\n        if remaining % divisor == 0 {\n            remaining\
    \ /= divisor;\n        } else {\n            divisor += 1;\n        }\n    }\n\
    \    remaining", "    let mut i = 2;\n    while i * i <= n {\n        if n % i\
    \ == 0 {\n            return largest_prime_factor(n / i);\n        }\n       \
    \ i += 1;\n    }\n    return n;", "    let mut prime = 2;\n    let mut max_prime\
    \ = 2;\n    let max = (n as f64).sqrt() as isize;\n    while prime <= max {\n\
    \        if n % prime == 0 {\n            max_prime = largest_prime_factor(n /\
    \ prime);\n            break;\n        }\n        prime += 1;\n    }\n    max_prime",
  "    let mut k = n / 2;\n    while k > 1 {\n        if n % k == 0 && is_prime(k)\
    \ {\n            return k;\n        }\n        k -= 1;\n    }\n    unreachable!();",
  "    let mut d = 2;\n    let mut n = n;\n    while n % d != 0 {\n        d += 1;\n\
    \    }\n    let p = n / d;\n    let mut d = 2;\n    while p % d != 0 {\n     \
    \   d += 1;\n    }\n    return n / d;", "    let mut n = n;\n    let mut i = 2;\n\
    \    let mut prime = 1;\n    while i <= n {\n        if n % i == 0 {\n       \
    \     n /= i;\n            prime = i;\n        } else {\n            i += 1;\n\
    \        }\n    }\n    prime", "    let mut limit = (n as f64).sqrt() as isize;\n\
    \    if limit % 2 == 0 {\n        limit -= 1;\n    }\n    for i in (3..=limit).step_by(2)\
    \ {\n        if n % i == 0 {\n            return largest_prime_factor(n / i);\n\
    \        }\n    }\n    n", "    for factor in (2..).take_while(|&x| x * x <= n)\
    \ {\n        if n % factor == 0 {\n            return largest_prime_factor(n /\
    \ factor);\n        }\n    }\n    n", "    let mut i = 2;\n    let mut m = n;\n\
    \    while i * i <= m {\n        if m % i == 0 {\n            m /= i;\n      \
    \  } else {\n            i += 1;\n        }\n    }\n    m", "    let mut largest\
    \ = 1;\n    let mut factor = 2;\n    let mut num = n;\n    while num > 1 {\n \
    \       if num % factor == 0 {\n            largest = factor;\n            num\
    \ /= factor;\n            while num % factor == 0 {\n                num /= factor;\n\
    \            }\n        }\n        factor += 1;\n    }\n    largest", "    let\
    \ largest_prime_factor = (2..n).rev().find(|&x| is_prime(x) && n % x == 0).unwrap();\n\
    \    largest_prime_factor", "    let mut largest = 1;\n    let mut i = 2;\n  \
    \  let mut m = n;\n    while i <= m {\n        if m % i == 0 {\n            largest\
    \ = i;\n            m /= i;\n        } else {\n            i += 1;\n        }\n\
    \    }\n    largest", "    let mut i = 2;\n    while i * i <= n {\n        if\
    \ n % i == 0 {\n            return largest_prime_factor(n / i);\n        }\n \
    \       i += 1;\n    }\n    n", "    // This algorithm is \"brute force\". It's\
    \ not the fastest way of solving the problem, but\n    // it is conceptually easy\
    \ to understand.\n\n    // Guard against anything that is not a positive integer.\n\
    \    assert!(n > 1);\n\n    // Iterate over a range of possible factors.\n   \
    \ for i in (2..n).rev() {\n        // We only care about prime factors.\n    \
    \    if !is_prime(i) {\n            continue;\n        }\n\n        // If i is\
    \ a factor, then i is the largest prime factor of n.\n        if n % i == 0 {\n\
    \            return i;\n        }\n    }\n\n    // This should never happen.\n\
    \    panic!(\"Failed to find largest prime factor of {}\", n);", "    let s =\
    \ math::square_root(n) as isize;\n    let (mut res, mut i) = (1, 2);\n    loop\
    \ {\n        if (n % i) == 0 {\n            res = i;\n            break;\n   \
    \     }\n        i += 1;\n        if i > s {\n            res = n;\n         \
    \   break;\n        }\n    }\n    res", "    let mut n = n;\n    let mut result\
    \ = 1;\n    let mut i = 2;\n    while i <= n {\n        if n % i == 0 {\n    \
    \        n /= i;\n            result = i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    result", "    let mut num = n;\n    let mut factor\
    \ = 2;\n    while num > 1 {\n        while num % factor == 0 {\n            num\
    \ /= factor;\n        }\n        factor += 1;\n    }\n    factor - 1", "  for\
    \ x in n..1 {\n    if (n % x == 0) && is_prime(x) {\n      return x;\n    }\n\
    \  }\n  0", "    let sqrt_n = (n as f64).sqrt() as isize;\n    let mut p = 2;\n\
    \    while p <= sqrt_n {\n        if n % p == 0 {\n            return largest_prime_factor(n\
    \ / p);\n        }\n        p += 1;\n    }\n    n", "    let mut i = 2;\n    let\
    \ mut largest = 1;\n    while i * i <= n {\n        if n % i == 0 {\n        \
    \    while n % i == 0 {\n                n /= i;\n            }\n            largest\
    \ = i;\n        }\n        i += 1;\n    }\n    if n > 1 {\n        largest = n;\n\
    \    }\n    largest", "    for i in (2..).map(|x| x * x).take_while(|&x| x <=\
    \ n) {\n        if n % i == 0 {\n            return largest_prime_factor(n / i);\n\
    \        }\n    }\n    n", "    for i in (1..).map(|x| x * 2) {\n        if n\
    \ % i == 0 {\n            if is_prime(n / i) {\n                return n / i;\n\
    \            }\n        }\n    }\n    unreachable!();", "    let mut largest_prime_factor\
    \ = 0;\n    let mut value = n;\n    while value % 2 == 0 {\n        largest_prime_factor\
    \ = 2;\n        value /= 2;\n    }\n    let mut divisor = 3;\n    while value\
    \ > 1 {\n        while value % divisor == 0 {\n            largest_prime_factor\
    \ = divisor;\n            value /= divisor;\n        }\n        divisor += 2;\n\
    \    }\n    largest_prime_factor", "    let mut n = n;\n    let mut prime = 2;\n\
    \    while n % prime == 0 {\n        n /= prime;\n    }\n    prime += 1;\n   \
    \ while n > 1 {\n        while n % prime == 0 {\n            n /= prime;\n   \
    \     }\n        prime += 2;\n    }\n    prime - 2", "    for i in (2..=n).rev()\
    \ {\n        if n % i == 0 && is_prime(i) {\n            return i;\n        }\n\
    \    }\n    unreachable!();", "    let upper_bound = (n as f64).sqrt() as isize\
    \ + 1;\n    for i in (2..upper_bound).rev() {\n        if is_prime(i) && n % i\
    \ == 0 {\n            return i;\n        }\n    }\n    1", "    let mut max =\
    \ 0;\n    let mut i = 2;\n    while i * i <= n {\n        if n % i == 0 {\n  \
    \          max = i;\n            while n % i == 0 {\n                n /= i;\n\
    \            }\n        }\n        i += 1;\n    }\n    if n > 1 {\n        max\
    \ = n;\n    }\n    max", "    let mut n = n;\n    let mut d = 2;\n    while n\
    \ % d != 0 {\n        d += 1;\n    }\n    n /= d;\n    if n == 1 {\n        d\n\
    \    } else {\n        largest_prime_factor(n)\n    }", "    let mut i = 2;\n\
    \    while i * i <= n {\n        if n % i == 0 {\n            return largest_prime_factor(n\
    \ / i);\n        } else {\n            i += 1;\n        }\n    }\n    n", "  \
    \  let mut m = n;\n    for i in 2.. {\n        if m == 1 {\n            break;\n\
    \        }\n        if i * i > m {\n            return m;\n        }\n       \
    \ if m % i == 0 {\n            m /= i;\n        }\n    }\n    unreachable!();",
  "    for i in (2..n).rev() {\n        if is_prime(i) && n % i == 0 {\n         \
    \   return i;\n        }\n    }\n    unreachable!();", "    if is_prime(n) {\n\
    \        return n;\n    }\n\n    let mut i = 2;\n    let mut factors = vec![];\n\
    \    let mut is_divisible = false;\n    while i <= n {\n        if is_divisible\
    \ {\n            if n % i == 0 {\n                factors.push(i);\n         \
    \       is_divisible = false;\n            }\n        } else {\n            if\
    \ n % i == 0 {\n                is_divisible = true;\n            }\n        }\n\
    \        i += 1;\n    }\n\n    let mut max = 0;\n    for x in factors {\n    \
    \    if x > max {\n            max = x;\n        }\n    }\n    max", "    let\
    \ factors = primes::factors(n);\n    factors[factors.len() - 1]", "    let mut\
    \ p = 2;\n    let mut n = n;\n    while n % p != 0 {\n        p += 1;\n    }\n\
    \    let q = n / p;\n    if q == 1 {\n        p\n    } else {\n        largest_prime_factor(q)\n\
    \    }", "    let factors = prime_factors(n);\n    *factors.iter().max().unwrap()",
  "    let mut n = n;\n    let mut i = 2;\n    while i < n {\n        if n % i ==\
    \ 0 {\n            n /= i;\n        } else {\n            i += 1;\n        }\n\
    \    }\n    n", "    let mut n = n;\n    let mut largest_factor = 1;\n    let\
    \ mut factor = 2;\n    while n > 1 {\n        while n % factor == 0 {\n      \
    \      n /= factor;\n            largest_factor = factor;\n        }\n       \
    \ factor += 1;\n    }\n    largest_factor", "    let mut largest_factor = 0;\n\
    \    for i in 2..n {\n        if n % i == 0 {\n            largest_factor = largest_prime_factor(n\
    \ / i);\n            break;\n        }\n    }\n    if largest_factor == 0 {\n\
    \        n\n    } else {\n        largest_factor\n    }", "    let mut factors\
    \ = vec![];\n    find_all_factors(n, 2, &mut factors);\n    factors.pop().unwrap()",
  "    let mut largest = 0;\n    let mut i = 2;\n    while i * i <= n {\n        if\
    \ n % i == 0 {\n            while n % i == 0 {\n                n /= i;\n    \
    \        }\n            largest = i;\n        }\n        i += 1;\n    }\n    if\
    \ n > 1 {\n        largest = n;\n    }\n    largest", "    let mut p = 2;\n  \
    \  while p <= n {\n        if n % p == 0 {\n            return largest_prime_factor(n\
    \ / p);\n        }\n        p += 1;\n    }\n    unreachable!();", "    let mut\
    \ f = 3;\n    let mut last_f = 2;\n    let mut max_f = 1;\n    while n > max_f\
    \ {\n        if n % f == 0 {\n            max_f = f;\n            while n % f\
    \ == 0 {\n                n /= f;\n            }\n        }\n        last_f =\
    \ f;\n        f += 2;\n        while f <= last_f {\n            f += 2;\n    \
    \    }\n    }\n    max_f", "    let mut i = n;\n    loop {\n        if is_prime(i)\
    \ {\n            return i;\n        }\n        i -= 1;\n    }", "    let largest_prime_factor\
    \ = n;\n    // Using (2..n) to iterate because we know the largest prime factor\
    \ cannot be larger than n.\n    for i in (2..n).rev() {\n        if is_prime(i)\
    \ && n % i == 0 {\n            largest_prime_factor = i;\n            break;\n\
    \        }\n    }\n    largest_prime_factor", "    // if n is not even, try n-1,\
    \ n-2, n-3, ... until 1.\n    if n % 2 != 0 {\n        for i in (1..n).rev() {\n\
    \            if (n % i == 0) && is_prime(i) {\n                return i;\n   \
    \         }\n        }\n    }\n\n    // if n is even, try n/2, n/3, n/4, ... until\
    \ 1.\n    for i in (1..n).rev() {\n        if (n % i == 0) && is_prime(i) {\n\
    \            return i;\n        }\n    }\n\n    0", "    let mut m = n;\n    let\
    \ mut p = 2;\n    while m > 1 {\n        if m % p == 0 {\n            m /= p;\n\
    \        } else {\n            p += 1;\n        }\n    }\n    p", "    let mut\
    \ n = n;\n    let mut factor = 2;\n    while n % factor != 0 {\n        factor\
    \ += 1;\n    }\n    if n == factor {\n        factor\n    } else {\n        largest_prime_factor(n\
    \ / factor)\n    }", "    let mut prime_factors = Vec::new();\n    let mut n =\
    \ n;\n    while n % 2 == 0 {\n        prime_factors.push(2);\n        n /= 2;\n\
    \    }\n    let mut k = 3;\n    while k * k <= n {\n        while n % k == 0 {\n\
    \            prime_factors.push(k);\n            n /= k;\n        }\n        k\
    \ += 2;\n    }\n    if n > 2 {\n        prime_factors.push(n);\n    }\n    prime_factors.last().unwrap().clone()",
  "    let mut prime = 2;\n    while prime <= n {\n        if n % prime == 0 {\n \
    \           return largest_prime_factor(n / prime);\n        } else {\n      \
    \      prime += 1;\n        }\n    }\n    prime", "    let mut j = n;\n    for\
    \ i in (2..n + 1).rev() {\n        if n % i == 0 && is_prime(i) {\n          \
    \  j = i;\n            break;\n        }\n    }\n    j", "    let mut x = n;\n\
    \    for i in 2..n {\n        if is_prime(i) && x % i == 0 {\n            x /=\
    \ i;\n        }\n    }\n    x", "    let mut remaining = n;\n    let mut factor\
    \ = 2;\n    while remaining > 1 {\n        if remaining % factor == 0 {\n    \
    \        while remaining % factor == 0 {\n                remaining /= factor;\n\
    \            }\n        }\n        factor += 1;\n    }\n    factor - 1", "   \
    \ let mut current_factor = 2;\n    let mut remaining = n;\n    while remaining\
    \ % current_factor == 0 {\n        remaining /= current_factor;\n    }\n    while\
    \ remaining != 1 {\n        current_factor += 1;\n        while remaining % current_factor\
    \ == 0 {\n            remaining /= current_factor;\n        }\n    }\n    current_factor",
  "    let mut n = n;\n    let mut largest_prime = 2;\n    while n > largest_prime\
    \ {\n        if n % largest_prime == 0 {\n            n /= largest_prime;\n  \
    \      } else {\n            largest_prime += 1;\n        }\n    }\n    largest_prime",
  "    // Note: the largest prime factor is at most the square root of n.\n    let\
    \ mut i = 2;\n    let max = ((n as f64).sqrt() as isize) + 1;\n    while i < max\
    \ {\n        if n % i == 0 {\n            return largest_prime_factor(n / i);\n\
    \        }\n        i += 1;\n    }\n    n", "    let mut p = 2;\n    while p <\
    \ n / p {\n        if n % p == 0 {\n            return largest_prime_factor(n\
    \ / p);\n        }\n        p += 1;\n    }\n    return n;", "    // Use a Sieve\
    \ of Eratosthenes to generate all primes up to n\n    let mut sieve = vec![true;\
    \ n as usize];\n    sieve[0] = false;\n    sieve[1] = false;\n    let mut k =\
    \ 2;\n    while k < n {\n        if sieve[k as usize] {\n            let mut j\
    \ = k * k;\n            while j < n {\n                sieve[j as usize] = false;\n\
    \                j += k;\n            }\n        }\n        k += 1;\n    }\n\n\
    \    // Divide n by primes in decreasing order until we find the largest factor\n\
    \    let mut i = n - 1;\n    while i > 1 {\n        if sieve[i as usize] && n\
    \ % i == 0 {\n            return i;\n        }\n        i -= 1;\n    }\n    unreachable!();",
  "    for i in (2..).take_while(|x| x * x <= n) {\n        if n % i == 0 {\n    \
    \        return largest_prime_factor(n / i);\n        }\n    }\n    n", "    let\
    \ mut x = n;\n    let mut factor = 2;\n    while x > 1 {\n        if is_prime(factor)\
    \ && x % factor == 0 {\n            x /= factor;\n        }\n        factor +=\
    \ 1;\n    }\n    factor - 1", "    let mut f = 2;\n    let mut lpf = 0;\n    while\
    \ f * f <= n {\n        if n % f == 0 {\n            lpf = f;\n            while\
    \ n % f == 0 {\n                n /= f;\n            }\n        }\n        f +=\
    \ 1;\n    }\n    if n > 1 {\n        lpf = n;\n    }\n    lpf", "    let mut n\
    \ = n;\n    let mut i = 2;\n    while i < n {\n        if n % i == 0 {\n     \
    \       n /= i;\n        } else {\n            i += 1;\n        }\n    }\n   \
    \ n", "    let mut p = 2;\n    let mut n = n;\n    while n > 1 {\n        if n\
    \ % p == 0 {\n            n /= p;\n        } else {\n            p += 1;\n   \
    \     }\n    }\n    p", "    let mut factors = Vec::new();\n    let mut k = n;\n\
    \    for i in 2..n {\n        if k % i == 0 {\n            factors.push(i);\n\
    \            k /= i;\n        }\n    }\n    *factors.last().unwrap()", "    for\
    \ i in (2..).take_while(|x| x * x <= n) {\n        if n % i == 0 {\n         \
    \   return largest_prime_factor(n / i);\n        }\n    }\n    n", "    let mut\
    \ largest_factor = 1;\n    let mut factor = 2;\n    let mut divisor = n;\n   \
    \ while divisor != 1 {\n        if divisor % factor == 0 {\n            if factor\
    \ > largest_factor {\n                largest_factor = factor;\n            }\n\
    \            divisor /= factor;\n        } else {\n            factor += 1;\n\
    \        }\n    }\n    largest_factor", "    for i in (2..).take_while(|i| i *\
    \ i <= n) {\n        if n % i == 0 {\n            return largest_prime_factor(n\
    \ / i);\n        }\n    }\n    n", "    let mut result = 0;\n    let mut d = 2;\n\
    \    let mut n = n;\n    while n > 1 {\n        while n % d == 0 {\n         \
    \   result = d;\n            n /= d;\n        }\n        d += 1;\n    }\n    result",
  "    let mut n = n;\n    for i in 2..((n as f64).sqrt() as isize + 1) {\n      \
    \  if n % i == 0 {\n            n /= i;\n            while n % i == 0 {\n    \
    \            n /= i;\n            }\n        }\n    }\n    n", "    let ceiling\
    \ = (n as f64).sqrt() as isize;\n    for i in (2..ceiling).rev() {\n        if\
    \ n % i == 0 && is_prime(i) {\n            return i;\n        }\n    }\n    panic!(\"\
    Cannot find largest prime factor\");", "    // upper bound on the largest prime\
    \ factor is the square root of n\n    let limit = isize::sqrt(n);\n    // try\
    \ all odd numbers between 3 and the square root of n\n    for possible_factor\
    \ in (3..limit).step_by(2) {\n        if n % possible_factor == 0 {\n        \
    \    // if n is divisible by a number in the range, return the largest prime factor\n\
    \            return largest_prime_factor(n / possible_factor);\n        }\n  \
    \  }\n    // if no factor was found, we return n\n    n", "    let mut i = 3;\n\
    \    while i <= (n as f64).sqrt() as isize {\n        if n % i == 0 {\n      \
    \      return largest_prime_factor(n / i);\n        }\n        i += 2;\n    }\n\
    \    n", "    let max = n / 2;\n    let mut n = n;\n    let mut i = 2;\n    while\
    \ i <= max {\n        while n % i == 0 {\n            n /= i;\n        }\n   \
    \     i += 1;\n    }\n    n", "    let mut largest_prime = -1;\n    let max =\
    \ (n as f64).sqrt() as isize;\n    for i in 2..max {\n        if n % i == 0 {\n\
    \            if is_prime(i) {\n                largest_prime = i;\n          \
    \  }\n        }\n    }\n    largest_prime", "    let mut cur = n;\n    let mut\
    \ prime = 2;\n    while prime <= cur {\n        if cur % prime == 0 {\n      \
    \      cur /= prime;\n        } else {\n            prime += 1;\n        }\n \
    \   }\n    prime", "    for x in (2..).take_while(|x| x * x <= n) {\n        if\
    \ n % x == 0 {\n            return largest_prime_factor(n / x);\n        }\n \
    \   }\n    n", "    // If a number is a multiple of two, then it is not a prime.\n\
    \    // If it is not a multiple of two, then it is not a multiple of four.\n \
    \   let mut lpf = 0;\n    let mut num = n;\n    if num % 2 == 0 {\n        num\
    \ /= 2;\n        lpf = 2;\n    }\n    // We start checking prime numbers at 3,\
    \ because 2 is the smallest prime\n    // number and we have already checked that.\n\
    \    let mut i = 3;\n    while num != 1 {\n        if num % i == 0 {\n       \
    \     num /= i;\n            lpf = i;\n        } else {\n            i += 2;\n\
    \        }\n    }\n    lpf", "    let mut i = 3;\n    while i * i <= n {\n   \
    \     if n % i == 0 {\n            return largest_prime_factor(n / i);\n     \
    \   }\n        i += 2;\n    }\n    n", "    let mut n = n;\n    let mut i = 2;\n\
    \    while i * i <= n {\n        if n % i == 0 {\n            n /= i;\n      \
    \  } else {\n            i += 1;\n        }\n    }\n    n", "    for divisor in\
    \ (2..).take_while(|d| d * d <= n) {\n        if n % divisor == 0 {\n        \
    \    return largest_prime_factor(n / divisor);\n        }\n    }\n    n", "  \
    \  let mut n = n;\n    let mut factor = 2;\n    let max_factor = (n as f64).sqrt()\
    \ as isize;\n    while factor <= max_factor {\n        if n % factor == 0 {\n\
    \            n /= factor;\n            while n % factor == 0 {\n             \
    \   n /= factor;\n            }\n        }\n        factor += 1;\n    }\n    if\
    \ n > 1 {\n        n\n    } else {\n        factor - 1\n    }", "    let mut factors\
    \ = Vec::new();\n    let mut d = 2;\n    let mut m = n;\n    while m > 1 {\n \
    \       if m % d == 0 {\n            factors.push(d);\n            m /= d;\n \
    \       } else {\n            d += 1;\n        }\n    }\n    factors.last().unwrap().clone()",
  "    let mut p = 2;\n    let mut m = n;\n    while p * p <= m {\n        if m %\
    \ p == 0 {\n            m /= p;\n        } else {\n            p += 1;\n     \
    \   }\n    }\n    m", "    let mut i = 2;\n    while i <= n {\n        if n %\
    \ i == 0 {\n            return largest_prime_factor(n / i);\n        }\n     \
    \   i += 1;\n    }\n    panic!(\"Cannot find largest prime factor of {}\", n);",
  "    let mut i = 2;\n    let mut res = 0;\n    while i * i <= n {\n        if n\
    \ % i == 0 {\n            res = i;\n            while n % i == 0 {\n         \
    \       n /= i;\n            }\n        }\n        i += 1;\n    }\n    if n >\
    \ 1 {\n        res = n;\n    }\n    res", "    for p in (1..(n as f64).sqrt()\
    \ as isize + 1).rev() {\n        if n % p == 0 && is_prime(p) {\n            return\
    \ p;\n        }\n    }\n    unreachable!();", "    for i in (2..n).rev() {\n \
    \       if is_prime(i) && n % i == 0 {\n            return i;\n        }\n   \
    \ }\n    panic!(\"Should never happen!\");", "    let mut result = 1;\n    let\
    \ mut div = 2;\n    let mut n = n;\n    while n > 1 {\n        if n % div == 0\
    \ {\n            result = div;\n            n /= div;\n            // divide out\
    \ all instances of div\n            while n % div == 0 {\n                n /=\
    \ div;\n            }\n        }\n        div += 1;\n    }\n    result", "   \
    \ let mut possible_factor = n / 2;\n    loop {\n        if is_prime(possible_factor)\
    \ && is_factor(possible_factor, n) {\n            return possible_factor;\n  \
    \      }\n        possible_factor -= 1;\n    }", "  let (max_prime, n) = largest_prime_factor_recursive(n,\
    \ 2);\n  assert!(is_prime(n));\n  max_prime", "    let limit = (n as f64).sqrt()\
    \ as isize;\n    //println!(\"limit = {}\", limit);\n    let mut p = 2;\n    while\
    \ p <= limit {\n        //println!(\"p = {}\", p);\n        if n % p == 0 {\n\
    \            return largest_prime_factor(n / p);\n        }\n        p += 1;\n\
    \    }\n    n", "    let mut factors = vec![];\n    let mut rem = n;\n    while\
    \ rem % 2 == 0 {\n        factors.push(2);\n        rem /= 2;\n    }\n    let\
    \ mut factor = 3;\n    while rem > 1 {\n        while rem % factor == 0 {\n  \
    \          factors.push(factor);\n            rem /= factor;\n        }\n    \
    \    factor += 2;\n    }\n    *factors.last().unwrap()", "    let mut largest_prime_factor\
    \ = n;\n    for i in 2..n {\n        if n % i == 0 {\n            largest_prime_factor\
    \ = largest_prime_factor(n / i);\n            break;\n        }\n    }\n    largest_prime_factor",
  "    let mut i = 2;\n    let mut val = n;\n    while i < val {\n        if val %\
    \ i == 0 {\n            val /= i;\n        } else {\n            i += 1;\n   \
    \     }\n    }\n    val", "    let max = f64::floor(f64::sqrt(n as f64)) as isize;\n\
    \    let mut i = 2;\n    while i <= max {\n        if n % i == 0 {\n         \
    \   return largest_prime_factor(n / i);\n        }\n        i += 1;\n    }\n \
    \   n", "    // Keep track of the lowest prime factor.\n    let mut lowest_factor\
    \ = 2;\n    // Keep track of the remaining value.\n    let mut remaining = n;\n\
    \    while remaining > 1 {\n        // Divide by the lowest factor and check the\
    \ remainder.\n        if remaining % lowest_factor == 0 {\n            // The\
    \ lowest factor is indeed a factor.\n            remaining /= lowest_factor;\n\
    \        } else {\n            // The lowest factor is not a factor.\n       \
    \     lowest_factor += 1;\n        }\n    }\n    // Return the lowest factor,\
    \ which will be the largest factor.\n    lowest_factor", "    let mut curr = n;\n\
    \    for i in (2..n).rev() {\n        if curr % i == 0 && is_prime(i) {\n    \
    \        return i;\n        }\n    }\n    unreachable!()", "    let mut largest_factor\
    \ = 2;\n    let mut i = 2;\n    while i <= n {\n        if n % i == 0 {\n    \
    \        largest_factor = i;\n            n /= i;\n        } else {\n        \
    \    i += 1;\n        }\n    }\n    largest_factor", "    // The largest possible\
    \ prime factor is the square root of n.\n    let mut p = (n as f64).sqrt() as\
    \ isize;\n    loop {\n        if is_prime(p) && n % p == 0 {\n            return\
    \ p;\n        }\n        p -= 1;\n    }", "    let mut d = 2;\n    while n % d\
    \ != 0 {\n        d += 1;\n    }\n    let m = n / d;\n    if m == 1 {\n      \
    \  d\n    } else {\n        largest_prime_factor(m)\n    }", "    let mut n =\
    \ n;\n    let mut largest_prime = 1;\n    let mut i = 2;\n    while i < n {\n\
    \        if n % i == 0 {\n            n /= i;\n            largest_prime = i;\n\
    \        } else {\n            i += 1;\n        }\n    }\n    largest_prime",
  "    let mut f = 2;\n    while n % f != 0 {\n        f += 1;\n    }\n    if n /\
    \ f == 1 {\n        f\n    } else {\n        largest_prime_factor(n / f)\n   \
    \ }", "    let mut x = n;\n    let mut i = 2;\n    while i <= x {\n        if\
    \ x % i == 0 {\n            x /= i;\n        } else {\n            i += 1;\n \
    \       }\n    }\n    i"]
stop_tokens:
- "\n}"
