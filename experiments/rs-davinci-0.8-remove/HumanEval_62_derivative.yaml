name: HumanEval_62_derivative
language: rs
prompt: "/// xs represent coefficients of a polynomial.\n/// xs[0] + xs[1] * x + xs[2]\
  \ * x^2 + ....\n/// Return derivative of this polynomial in the same form.\nfn derivative(xs:\
  \ Vec<isize>) -> Vec<isize> {\n"
tests: "}\n\nfn main() {\n    let candidate = derivative;\n    assert_eq!(candidate(vec![3,\
  \ 1, 2, 4, 5]), vec![1, 4, 12, 20]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2,\
  \ 6]);\n    assert_eq!(candidate(vec![3, 2, 1]), vec![2, 2]);\n    assert_eq!(candidate(vec![3,\
  \ 2, 1, 0, 4]), vec![2, 2, 0, 16]);\n    assert_eq!(candidate(vec![1]), Vec::<isize>::new());\n\
  }\n"
completions: ["    let mut ret = Vec::new();\n    for i in 1..xs.len() {\n       \
    \ ret.push(xs[i] * i as isize);\n    }\n    ret", "    let mut der = vec![];\n\
    \    for (i, x) in xs.iter().enumerate() {\n        if i == 0 {\n            continue;\n\
    \        }\n        der.push(i as isize * x);\n    }\n    der", "    xs.iter()\n\
    \        .enumerate()\n        .map(|(i, x)| x * i as isize)\n        .skip(1)\n\
    \        .collect()", "    xs.iter()\n        .enumerate()\n        .map(|(i,\
    \ &x)| x * i as isize)\n        .skip(1)\n        .collect()", "    let mut ys\
    \ = vec![];\n    for i in 1..xs.len() {\n        ys.push(xs[i] * i as isize);\n\
    \    }\n    ys", "    let mut result = Vec::new();\n    for (i, x) in xs.iter().enumerate()\
    \ {\n        if i == 0 {\n            continue;\n        }\n        result.push(i\
    \ as isize * x);\n    }\n    result", "    if xs.len() <= 1 {\n        Vec::new()\n\
    \    } else {\n        let mut new_xs = Vec::new();\n        for (i, x) in xs.iter().enumerate().skip(1)\
    \ {\n            new_xs.push(i as isize * x);\n        }\n        new_xs\n   \
    \ }", "    xs.into_iter()\n        .enumerate()\n        .map(|(i, x)| x * i as\
    \ isize)\n        .skip(1)\n        .collect()", "    xs.iter()\n        .enumerate()\n\
    \        .map(|(i, &c)| i as isize * c)\n        .collect::<Vec<_>>()", "    let\
    \ mut xs = xs;\n    let mut n = xs.len();\n    xs.remove(0);\n    n -= 1;\n  \
    \  let mut deriv = Vec::with_capacity(n);\n    for i in 0..n {\n        deriv.push(xs[i]\
    \ * (n - i) as isize);\n    }\n    deriv", "    xs.iter()\n        .enumerate()\n\
    \        .map(|(i, x)| i as isize * x)\n        .skip(1)\n        .collect()",
  "    xs.iter()\n        .enumerate()\n        .map(|(i, &x)| i as isize * x)\n \
    \       .collect::<Vec<_>>()", "    xs[1..]\n        .iter()\n        .enumerate()\n\
    \        .map(|(i, &x)| x * (i as isize + 1))\n        .collect()", "    let mut\
    \ xs = xs;\n    xs.reverse();\n    let mut res = Vec::new();\n    let mut i =\
    \ 1;\n    for x in xs {\n        if i > 1 {\n            res.push(x * i);\n  \
    \      }\n        i += 1;\n    }\n    res.reverse();\n    res", "    xs.into_iter()\n\
    \        .enumerate()\n        .map(|(i, x)| (i as isize) * x)\n        .collect()",
  "    let mut result = vec![];\n    for (i, x) in xs.iter().enumerate() {\n     \
    \   if i > 0 {\n            result.push(i as isize * x);\n        }\n    }\n \
    \   result", "    let mut result = vec![];\n    for (idx, x) in xs.iter().enumerate()\
    \ {\n        if idx == 0 {\n            continue;\n        }\n        result.push(idx\
    \ as isize * x);\n    }\n    result", '    xs[1..].iter().enumerate().map(|(i,
    &x)| (i as isize + 1) * x).collect()', "    let mut result = Vec::new();\n   \
    \ for (i, x) in xs.iter().enumerate() {\n        if i == 0 {\n            continue;\n\
    \        }\n        result.push(i as isize * x);\n    }\n    result", "    let\
    \ mut d = Vec::new();\n    for i in 1..xs.len() {\n        d.push(xs[i] * i as\
    \ isize);\n    }\n    d", "    let mut ys = Vec::new();\n    for i in 1..xs.len()\
    \ {\n        ys.push(xs[i] * i as isize);\n    }\n    ys", "    let mut ys = vec![];\n\
    \    let len = xs.len();\n    for i in 1..len {\n        ys.push(xs[i] * i as\
    \ isize);\n    }\n    ys", '    (1..xs.len()).map(|i| i as isize * xs[i]).collect()',
  "    xs.iter()\n        .enumerate()\n        .map(|(i, &x)| x * i as isize)\n \
    \       .skip(1)\n        .collect()", "    let mut res = Vec::new();\n    for\
    \ i in 1..xs.len() {\n        res.push(xs[i] * i as isize);\n    }\n    res",
  "    xs.iter()\n        .enumerate()\n        .map(|(i, &x)| (i as isize) * x)\n\
    \        .collect::<Vec<isize>>()", "    let n = xs.len();\n    if n == 1 {\n\
    \        return vec![0];\n    }\n    let mut r = Vec::with_capacity(n - 1);\n\
    \    for i in 1..n {\n        r.push(xs[i] * i as isize);\n    }\n    r", "  \
    \  let mut ret = Vec::new();\n    for (i, x) in xs.iter().enumerate() {\n    \
    \    if i == 0 {\n            continue;\n        }\n        ret.push(x * i as\
    \ isize);\n    }\n    ret", "    xs.iter()\n        .enumerate()\n        .map(|(n,\
    \ x)| x * n as isize)\n        .skip(1)\n        .collect()", "    let mut derivative\
    \ = vec![];\n    for i in 1..xs.len() {\n        derivative.push(xs[i] * i as\
    \ isize);\n    }\n    derivative", "    let mut res = Vec::new();\n    let mut\
    \ p = 1;\n    for x in xs.iter().skip(1) {\n        res.push(p * x);\n       \
    \ p += 1;\n    }\n    res", "    let mut result = Vec::with_capacity(xs.len()\
    \ - 1);\n    for (i, &x) in xs.iter().enumerate().skip(1) {\n        result.push(x\
    \ * i as isize);\n    }\n    result", "    let mut new_xs = Vec::new();\n    new_xs.push(0);\n\
    \    for i in 1..xs.len() {\n        new_xs.push(xs[i] * i as isize);\n    }\n\
    \    new_xs", "    let mut result = Vec::new();\n    let len = xs.len();\n   \
    \ for i in 1..len {\n        result.push(xs[i] * i as isize);\n    }\n    result",
  "    let mut results = Vec::new();\n    for (i, x) in xs.iter().enumerate() {\n\
    \        if i > 0 {\n            results.push(i as isize * x);\n        }\n  \
    \  }\n    results", "    let mut res = Vec::new();\n    for i in 1..xs.len() {\n\
    \        res.push(xs[i] * i as isize);\n    }\n    res", "    let mut ret = vec![];\n\
    \    for i in 1..xs.len() {\n        ret.push(xs[i] * i as isize);\n    }\n  \
    \  ret", "    let mut result = vec![];\n    for i in 1..xs.len() {\n        result.push(xs[i]\
    \ * i as isize);\n    }\n    result", "    xs.into_iter()\n        .enumerate()\n\
    \        .skip(1)\n        .map(|(i, x)| x * i as isize)\n        .collect()",
  "    let mut ret = Vec::new();\n    for i in 1..xs.len() {\n        ret.push(xs[i]\
    \ * i as isize);\n    }\n    ret", "    if xs.len() <= 1 {\n        return vec![];\n\
    \    }\n    let mut result = Vec::new();\n    for i in 1..xs.len() {\n       \
    \ result.push(xs[i] * i as isize);\n    }\n    result", "    let mut res = Vec::new();\n\
    \    for (i, x) in xs.iter().enumerate() {\n        if i == 0 {\n            continue;\n\
    \        }\n        res.push(*x * i as isize);\n    }\n    res", "    let mut\
    \ xss = Vec::new();\n    for i in 1..xs.len() {\n        xss.push(xs[i] * i as\
    \ isize);\n    }\n    xss", "    let mut v = Vec::new();\n    let len = xs.len();\n\
    \    for i in 1..len {\n        v.push(xs[i] * i as isize);\n    }\n    v", " \
    \   let mut res = Vec::new();\n    for i in 1..xs.len() {\n        res.push(xs[i]\
    \ * i as isize);\n    }\n    res", "    let mut result = Vec::with_capacity(xs.len()\
    \ - 1);\n    for i in 1..xs.len() {\n        result.push(xs[i] * i as isize);\n\
    \    }\n    result", "    let mut i = 0;\n    let mut new_xs = Vec::new();\n \
    \   for x in xs {\n        new_xs.push(x * i);\n        i += 1;\n    }\n    new_xs.remove(0);\n\
    \    new_xs", "    xs.iter()\n        .enumerate()\n        .map(|(i, &x)| (i\
    \ as isize) * x)\n        .skip(1)\n        .collect()", "    let mut result =\
    \ Vec::new();\n    for i in 1..xs.len() {\n        result.push(xs[i] * i as isize);\n\
    \    }\n    result", "    let mut result = Vec::new();\n    for i in 1..xs.len()\
    \ {\n        result.push(xs[i] * i as isize);\n    }\n    result", "    let mut\
    \ d = Vec::new();\n    for (n,x) in xs.iter().enumerate() {\n        if n == 0\
    \ { continue; }\n        d.push(*x * n as isize);\n    }\n    d", "    let mut\
    \ result = vec![];\n    for i in 1..xs.len() {\n        result.push(xs[i] * i\
    \ as isize);\n    }\n    result", "    xs.into_iter()\n        .enumerate()\n\
    \        .skip(1)\n        .map(|(i, x)| i as isize * x)\n        .collect()",
  "    xs.iter()\n        .enumerate()\n        .map(|(i, x)| (i as isize) * x)\n\
    \        .skip(1)\n        .collect()", "    let mut xs = xs;\n    let mut res\
    \ = Vec::new();\n    let n = xs.len();\n    for i in 1..n {\n        res.push(xs[i]\
    \ * i as isize);\n    }\n    res", "    let mut new_xs = Vec::new();\n    for\
    \ (i, x) in xs.iter().enumerate() {\n        if i > 0 {\n            new_xs.push(i\
    \ as isize * x);\n        }\n    }\n    new_xs", "    let mut ys = Vec::new();\n\
    \    let n = xs.len();\n    for i in 1..n {\n        ys.push(xs[i] * i as isize);\n\
    \    }\n    ys", "    xs.iter()\n        .enumerate()\n        .map(|(i, &x)|\
    \ (i as isize) * x)\n        .skip(1)\n        .collect()", "    let mut res =\
    \ Vec::new();\n    for i in 1..xs.len() {\n        res.push(xs[i] * i as isize);\n\
    \    }\n    res", "    let n = xs.len();\n    let m = n - 1;\n    let mut dxs\
    \ = Vec::with_capacity(m);\n    for i in 0..m {\n        dxs.push(i as isize *\
    \ xs[i + 1]);\n    }\n    dxs", "    xs.iter()\n        .enumerate()\n       \
    \ .map(|(i, x)| if i == 0 {\n            0\n        } else {\n            x *\
    \ i as isize\n        })\n        .collect()", "    let mut new_xs = vec![];\n\
    \    for (i, x) in xs.iter().enumerate() {\n        if i == 0 {\n            continue;\n\
    \        }\n        new_xs.push(i as isize * x);\n    }\n    new_xs", "    xs.iter()\n\
    \        .enumerate()\n        .skip(1)\n        .map(|(i, &x)| x * i as isize)\n\
    \        .collect()", "    let mut ys = Vec::new();\n    let mut p = 0;\n    for\
    \ x in xs {\n        if p == 0 {\n            p += 1;\n            continue;\n\
    \        }\n        ys.push(p * x);\n        p += 1;\n    }\n    ys", "    let\
    \ n = xs.len();\n    let mut ys = Vec::with_capacity(n - 1);\n    for i in 1..n\
    \ {\n        ys.push(xs[i] * i as isize);\n    }\n    ys", "    let mut result\
    \ = Vec::new();\n    for i in 1..xs.len() {\n        result.push(xs[i] * i as\
    \ isize);\n    }\n    result", "    let mut dxs = vec![];\n    for i in 1..xs.len()\
    \ {\n        dxs.push(xs[i] * i as isize);\n    }\n    dxs", "    let mut ys =\
    \ Vec::new();\n    for i in 1..xs.len() {\n        ys.push(xs[i] * i as isize);\n\
    \    }\n    ys", "    xs.iter()\n        .enumerate()\n        .map(|(i, x)| x\
    \ * i as isize)\n        .collect::<Vec<isize>>()", "    let mut r = vec![];\n\
    \    for (i, x) in xs.iter().enumerate() {\n        if i == 0 {\n            continue;\n\
    \        }\n        r.push(i as isize * x);\n    }\n    r", "    let mut dxs =\
    \ Vec::new();\n    let mut order = xs.len() - 1;\n    for coeff in xs {\n    \
    \    let dc = coeff * order;\n        dxs.push(dc);\n        order -= 1;\n   \
    \ }\n    dxs", "    xs.iter()\n        .enumerate()\n        .skip(1)\n      \
    \  .map(|(i, &x)| x * i as isize)\n        .collect()", "    let mut result =\
    \ vec![];\n    for i in 1..xs.len() {\n        result.push(xs[i] * i as isize);\n\
    \    }\n    result", "    let mut res = vec![];\n    for i in 1..xs.len() {\n\
    \        res.push(xs[i] * i as isize);\n    }\n    res", "    xs.iter()\n    \
    \    .enumerate()\n        .skip(1)\n        .map(|(i, &x)| i as isize * x)\n\
    \        .collect()", "    xs.iter()\n        .enumerate()\n        .skip(1)\n\
    \        .map(|(n, x)| n as isize * x)\n        .collect()", "    xs.iter()\n\
    \        .enumerate()\n        .map(|(i, &x)| x * i as isize)\n        .skip(1)\n\
    \        .collect()", "    let mut der = Vec::new();\n    for (i, x) in xs.iter().enumerate()\
    \ {\n        if i == 0 {\n            continue;\n        }\n        der.push(i\
    \ as isize * x);\n    }\n    der", "    xs.iter()\n        .enumerate()\n    \
    \    .map(|(i, c)| c * i as isize)\n        .collect::<Vec<isize>>()", "    xs.iter()\n\
    \        .enumerate()\n        .skip(1)\n        .map(|(i, &x)| i as isize * x)\n\
    \        .collect()", "    let mut new_xs = Vec::new();\n    let length = xs.len();\n\
    \    for i in 1..length {\n        new_xs.push(xs[i] * i as isize);\n    }\n \
    \   new_xs", "    xs.iter()\n        .enumerate()\n        .map(|(i, &x)| if i\
    \ == 0 { 0 } else { i as isize * x })\n        .collect()", "    let mut result\
    \ = vec![];\n    for (i, x) in xs.iter().enumerate() {\n        if i == 0 {\n\
    \            continue;\n        }\n        result.push(i as isize * x);\n    }\n\
    \    result", "    let deg = xs.len() - 1;\n    if deg < 1 {\n        return xs;\n\
    \    }\n    let mut res = Vec::new();\n    for i in 1..xs.len() {\n        res.push(xs[i]\
    \ * i as isize);\n    }\n    res", "    let mut ys = Vec::new();\n    for (i,\
    \ x) in xs.iter().enumerate() {\n        if i == 0 {\n            continue;\n\
    \        }\n        ys.push(*x * i as isize);\n    }\n    ys", "    let mut res\
    \ = vec![];\n    for (i, x) in xs.iter().enumerate() {\n        if i == 0 {\n\
    \            continue;\n        }\n        res.push(i as isize * x);\n    }\n\
    \    res", "    let mut ys = Vec::new();\n    for i in 1..xs.len() {\n       \
    \ ys.push(xs[i] * i as isize);\n    }\n    ys", "    let mut result = Vec::new();\n\
    \    let mut i = 0;\n    for c in xs {\n        i += 1;\n        if i == 1 {\n\
    \            continue;\n        }\n        result.push(c * i as isize);\n    }\n\
    \    result", "    let mut result = vec![];\n    for i in 1..xs.len() {\n    \
    \    result.push(xs[i] * i as isize);\n    }\n    result", "    let mut res =\
    \ vec![];\n    for i in 1..xs.len() {\n        res.push(xs[i] * i as isize);\n\
    \    }\n    res", "    let mut dxs = vec![];\n    for i in 1..xs.len() {\n   \
    \     dxs.push(xs[i] * i as isize);\n    }\n    dxs", "    xs.iter()\n       \
    \ .enumerate()\n        .skip(1)\n        .map(|(i, &x)| i as isize * x)\n   \
    \     .collect()", "    xs.iter()\n        .enumerate()\n        .map(|(i, x)|\
    \ (i as isize) * x)\n        .collect::<Vec<isize>>()", "    let mut res = Vec::new();\n\
    \    for i in 1..xs.len() {\n        res.push(xs[i] * i as isize);\n    }\n  \
    \  res", "    if xs.len() == 1 {\n        return vec![0];\n    }\n    xs[1..].iter().enumerate().map(|(i,\
    \ &x)| (i + 1) as isize * x).collect()", "    let mut ys = Vec::new();\n    for\
    \ i in 1..xs.len() {\n        ys.push(xs[i] * i as isize);\n    }\n    ys", " \
    \   xs.into_iter()\n        .enumerate()\n        .skip(1)\n        .map(|(i,\
    \ x)| x * i as isize)\n        .collect()", "    let mut ys = Vec::new();\n  \
    \  for (i, x) in xs.iter().enumerate() {\n        if i == 0 {\n            continue;\n\
    \        }\n        ys.push(i as isize * x);\n    }\n    ys", "    xs.iter()\n\
    \        .enumerate()\n        .map(|(i, x)| x * i as isize)\n        .skip(1)\n\
    \        .collect()", "    let mut new_xs = Vec::new();\n    let mut n = 1;\n\
    \    for x in xs {\n        new_xs.push(x * n);\n        n += 1;\n    }\n    new_xs",
  "    xs.iter()\n        .enumerate()\n        .skip(1)\n        .map(|(i, &x)| i\
    \ as isize * x)\n        .collect()", "    let mut xs_new = Vec::new();\n    let\
    \ len = xs.len();\n    for i in 1..len {\n        xs_new.push(xs[i] * i as isize);\n\
    \    }\n    xs_new", "    let mut result = Vec::new();\n    for (i, x) in xs.iter().enumerate()\
    \ {\n        if i > 0 {\n            result.push(i as isize * x);\n        }\n\
    \    }\n    result", "    xs.iter()\n        .enumerate()\n        .map(|(i, x)|\
    \ x * (i as isize))\n        .skip(1)\n        .collect()", "    xs.into_iter()\n\
    \        .enumerate()\n        .map(|(i, x)| i as isize * x)\n        .skip(1)\n\
    \        .collect()", "    let n = xs.len();\n    (1..n).map(|i| xs[i] * i as\
    \ isize).collect()", "    let mut xs = xs;\n    for i in 1..xs.len() {\n     \
    \   xs[i - 1] = xs[i] * i as isize;\n    }\n    xs.pop();\n    xs", "    xs.iter()\n\
    \        .enumerate()\n        .skip(1)\n        .map(|(i, &x)| x * i as isize)\n\
    \        .collect()", "    let mut ys = Vec::new();\n    for (i, x) in xs.iter().enumerate()\
    \ {\n        if i == 0 {\n            continue;\n        }\n        ys.push(i\
    \ as isize * x);\n    }\n    ys", "    if xs.len() == 1 {\n        return vec![0];\n\
    \    }\n    let mut derivative = Vec::new();\n    for i in 1..xs.len() {\n   \
    \     derivative.push(xs[i] * i as isize);\n    }\n    derivative", "    let n\
    \ = xs.len();\n    (1..n).map(|i| xs[i] * i as isize).collect()", "    // TODO\
    \ - you fill in here.\n    unimplemented!();", "    let mut ys = vec![];\n   \
    \ for i in 1..xs.len() {\n        ys.push(xs[i] * i as isize);\n    }\n    ys",
  '    xs[1..].iter().enumerate().map(|(n, &x)| x * (n as isize + 1)).collect()',
  "    let len = xs.len();\n    (1..len).map(|i| xs[i] * i as isize).collect()", " \
    \   let mut ys = Vec::with_capacity(xs.len() - 1);\n    for (i, x) in xs.iter().enumerate()\
    \ {\n        if i == 0 {\n            continue;\n        }\n        ys.push(i\
    \ as isize * x);\n    }\n    ys", "    let n = xs.len();\n    let mut ys = Vec::with_capacity(n\
    \ - 1);\n    for i in 1..n {\n        ys.push(xs[i] * i as isize);\n    }\n  \
    \  ys", "    let mut ys = Vec::new();\n    for (i, x) in xs.iter().enumerate()\
    \ {\n        ys.push(x * i as isize);\n    }\n    ys.remove(0);\n    ys", "  \
    \  let mut dxs = vec![];\n    for (i, x) in xs.iter().enumerate() {\n        if\
    \ i == 0 {\n            continue;\n        }\n        dxs.push(i as isize * x);\n\
    \    }\n    dxs", "    xs.iter()\n        .enumerate()\n        .map(|(i, x)|\
    \ {\n            if i == 0 {\n                0\n            } else {\n      \
    \          *x * i as isize\n            }\n        })\n        .collect()", " \
    \   xs.iter()\n        .enumerate()\n        .map(|(idx, x)| x * idx as isize)\n\
    \        .skip(1)\n        .collect()", "    let mut out = vec![];\n    for i\
    \ in 1..xs.len() {\n        out.push(xs[i] * i as isize);\n    }\n    out", " \
    \   xs.iter()\n        .enumerate()\n        .map(|(i, x)| *x * (i as isize))\n\
    \        .skip(1)\n        .collect()", "    let mut dxs = Vec::new();\n    let\
    \ mut i = 1;\n    for x in xs {\n        dxs.push(x * i);\n        i += 1;\n \
    \   }\n    dxs", "    let mut c = Vec::new();\n    for (i, x) in xs.iter().enumerate()\
    \ {\n        c.push(x * i as isize);\n    }\n    c.drain(0..1);\n    c", "   \
    \ let mut xs_derivative = Vec::new();\n    xs_derivative.push(0);\n    for i in\
    \ 1..xs.len() {\n        xs_derivative.push(xs[i] * i as isize);\n    }\n    xs_derivative",
  "    let mut results = Vec::new();\n    for (i, x) in xs.iter().enumerate() {\n\
    \        if i != 0 {\n            results.push(i as isize * x);\n        }\n \
    \   }\n    results", "    let mut ys = Vec::with_capacity(xs.len() - 1);\n   \
    \ for i in 1..xs.len() {\n        ys.push(xs[i] * i as isize);\n    }\n    ys",
  "    xs.into_iter()\n        .enumerate()\n        .map(|(i, x)| x * (i as isize))\n\
    \        .skip(1)\n        .collect()", "    let mut xs_d = vec![];\n    for (i,\
    \ _) in xs.iter().enumerate() {\n        if i > 0 {\n            xs_d.push(i as\
    \ isize * xs[i]);\n        }\n    }\n    xs_d", "    let mut result = Vec::with_capacity(xs.len()\
    \ - 1);\n    for (exp, &coef) in xs.iter().enumerate().skip(1) {\n        result.push(coef\
    \ * exp as isize);\n    }\n    result", "    let mut result = Vec::new();\n  \
    \  for i in 1..xs.len() {\n        result.push(xs[i] * i as isize);\n    }\n \
    \   result", "    let mut ys = Vec::new();\n    for i in 1..xs.len() {\n     \
    \   ys.push(xs[i] * i as isize);\n    }\n    ys", "    let mut result = Vec::with_capacity(xs.len()\
    \ - 1);\n    for i in 1..xs.len() {\n        result.push(xs[i] * i as isize);\n\
    \    }\n    result", "    let mut new_xs = Vec::new();\n    for i in 1..xs.len()\
    \ {\n        new_xs.push(xs[i] * i as isize);\n    }\n    new_xs", "    let mut\
    \ xs_new = Vec::new();\n    for (i, x) in xs.iter().enumerate() {\n        if\
    \ i == 0 {\n            continue;\n        }\n        xs_new.push(x * i as isize);\n\
    \    }\n    xs_new", "    let mut output = Vec::new();\n    for i in 1..xs.len()\
    \ {\n        output.push(xs[i] * i as isize);\n    }\n    output", "    if xs.len()\
    \ == 1 {\n        vec![0]\n    } else {\n        let mut deriv = Vec::new();\n\
    \        for i in 1..xs.len() {\n            deriv.push(xs[i] * i as isize);\n\
    \        }\n        deriv\n    }", "    let mut xs = xs;\n    for i in 1..xs.len()\
    \ {\n        xs[i] *= i as isize;\n    }\n    xs.remove(0);\n    xs", '    (1..xs.len()).map(|n|
    n as isize * xs[n]).collect()', "    xs.iter()\n        .enumerate()\n       \
    \ .map(|(i, &x)| (i as isize) * x)\n        .skip(1)\n        .collect()", " \
    \   xs.iter()\n        .enumerate()\n        .map(|(i, &x)| x * i as isize)\n\
    \        .skip(1)\n        .collect()", "    let mut xs_prime = Vec::new();\n\
    \    for i in 1..xs.len() {\n        xs_prime.push(xs[i] * i as isize);\n    }\n\
    \    xs_prime", "    let mut result = vec![];\n    for (idx, x) in xs.iter().enumerate()\
    \ {\n        if idx == 0 {\n            continue;\n        }\n        result.push(idx\
    \ as isize * x);\n    }\n    result", "    let mut derivative: Vec<isize> = Vec::new();\n\
    \    for (i, &x) in xs.iter().enumerate() {\n        derivative.push(x * i as\
    \ isize);\n    }\n    derivative.remove(0);\n    derivative", "    let mut ys\
    \ = vec![];\n    for (i, x) in xs.iter().enumerate() {\n        if i > 0 {\n \
    \           ys.push(i as isize * x);\n        }\n    }\n    ys", '    xs[1..].iter().enumerate().map(|(i,
    c)| (i as isize + 1) * c).collect()', "    let mut result = vec![];\n    for (i,\
    \ x) in xs.iter().enumerate() {\n        if i > 0 {\n            result.push(i\
    \ as isize * x);\n        }\n    }\n    result", "    let mut result = vec![];\n\
    \    for (i, x) in xs.iter().enumerate() {\n        if i == 0 {\n            continue;\n\
    \        }\n        result.push(i as isize * x);\n    }\n    result", "    xs.iter()\n\
    \        .skip(1)\n        .enumerate()\n        .map(|(i, &x)| (i + 1) as isize\
    \ * x)\n        .collect()", "    let mut dxs = Vec::with_capacity(xs.len() -\
    \ 1);\n    for (pow, x) in xs.iter().enumerate().skip(1) {\n        dxs.push(pow\
    \ as isize * x);\n    }\n    dxs", "    xs.into_iter()\n        .enumerate()\n\
    \        .map(|(i, x)| x * i as isize)\n        .skip(1)\n        .collect()",
  "    let mut xs = xs;\n    xs.pop();\n    xs\n        .iter()\n        .enumerate()\n\
    \        .map(|(i, x)| (i + 1) as isize * x)\n        .collect()", "    let mut\
    \ ys = Vec::new();\n    for (i, x) in xs.iter().enumerate() {\n        if i ==\
    \ 0 {\n            continue;\n        }\n        ys.push(i as isize * x);\n  \
    \  }\n    ys", "    let mut ys = Vec::with_capacity(xs.len() - 1);\n    for (i,\
    \ x) in xs.iter().enumerate() {\n        if i == 0 {\n            continue;\n\
    \        }\n        ys.push(i as isize * x);\n    }\n    ys", "    let mut result\
    \ = Vec::new();\n    for i in 1..xs.len() {\n        result.push(xs[i] * i as\
    \ isize);\n    }\n    result", "    xs.iter()\n        .enumerate()\n        .map(|(i,\
    \ c)| if i == 0 { 0 } else { i as isize * c })\n        .collect()", '    (1..xs.len()).map(|i|
    i as isize * xs[i]).collect()', "    let mut ys = vec![];\n    for (i, x) in xs.iter().enumerate()\
    \ {\n        if i == 0 {\n            continue;\n        }\n        ys.push(i\
    \ as isize * x);\n    }\n    ys", "    let mut ret = Vec::new();\n    for (i,\
    \ x) in xs.iter().enumerate() {\n        if i == 0 {\n            continue;\n\
    \        }\n        ret.push(x * i as isize);\n    }\n    ret", "    let mut result\
    \ = Vec::new();\n    for i in 1..xs.len() {\n        result.push(xs[i] * i as\
    \ isize);\n    }\n    result", "    let mut res = Vec::new();\n    for (i, x)\
    \ in xs.iter().enumerate() {\n        if i > 0 {\n            res.push(i as isize\
    \ * x);\n        }\n    }\n    res", "    let mut ret = Vec::new();\n    for i\
    \ in 1..xs.len() {\n        ret.push(xs[i] * i as isize);\n    }\n    ret", " \
    \   let mut ret = Vec::new();\n    for i in 1..xs.len() {\n        ret.push(xs[i]\
    \ * i as isize);\n    }\n    ret", "    let mut ys = vec![];\n    let n = xs.len();\n\
    \    for i in 1..n {\n        ys.push(xs[i] * i as isize);\n    }\n    ys", " \
    \   let n = xs.len();\n    let mut v = Vec::with_capacity(n - 1);\n    for i in\
    \ 1..n {\n        v.push(xs[i] * i as isize);\n    }\n    v", "    xs.iter()\n\
    \        .skip(1)\n        .enumerate()\n        .map(|(i, &coef)| (i + 1) as\
    \ isize * coef)\n        .collect()", "    let mut result = vec![];\n    result.reserve(xs.len()\
    \ - 1);\n    for (i, x) in xs.iter().enumerate() {\n        if i > 0 {\n     \
    \       result.push(i as isize * x);\n        }\n    }\n    result", "    let\
    \ mut v = Vec::new();\n    for (n, x) in xs.iter().enumerate() {\n        if n\
    \ > 0 {\n            v.push(n as isize * x);\n        }\n    }\n    v", "    let\
    \ mut dxs = vec![];\n    let mut deg = 0;\n    for x in xs {\n        dxs.push(x\
    \ * deg);\n        deg += 1;\n    }\n    dxs.remove(0);\n    dxs", "    let mut\
    \ ys = vec![];\n    for (n, x) in xs.iter().enumerate() {\n        if n == 0 {\n\
    \            continue;\n        }\n        ys.push(n as isize * x);\n    }\n \
    \   ys", "    let mut result = Vec::new();\n    for i in 1..xs.len() {\n     \
    \   result.push(xs[i] * i as isize);\n    }\n    result", '    (1..xs.len()).map(|i|
    i as isize * xs[i]).collect()', "    let mut xs: Vec<isize> = xs.iter().enumerate().map(|(i,\
    \ &x)| x * i as isize).collect();\n    xs.remove(0);\n    xs", "    let mut dxs\
    \ = vec![];\n    for (i, x) in xs.iter().enumerate() {\n        if i == 0 {\n\
    \            continue;\n        }\n        dxs.push(i as isize * x);\n    }\n\
    \    dxs", "    let len = xs.len();\n    let mut ys = Vec::with_capacity(len -\
    \ 1);\n    for i in 1..len {\n        ys.push(xs[i] * i as isize);\n    }\n  \
    \  ys", "    xs.iter()\n        .enumerate()\n        .map(|(i, x)| x * i as isize)\n\
    \        .collect::<Vec<isize>>()", "    xs.iter()\n        .enumerate()\n   \
    \     .skip(1)\n        .map(|(i, &a)| i as isize * a)\n        .collect()", " \
    \   let mut result = Vec::new();\n    for (i, x) in xs.iter().enumerate() {\n\
    \        result.push(x * i as isize);\n    }\n    result.remove(0);\n    result",
  "    // TODO: can do in-place, no need to allocate new memory.\n    let mut ret\
    \ = Vec::new();\n    for (i, x) in xs.iter().enumerate() {\n        if i == 0\
    \ {\n            continue;\n        }\n        ret.push(x * i as isize);\n   \
    \ }\n    ret", "    let mut result = vec![];\n    for (i, x) in xs.iter().enumerate()\
    \ {\n        if i == 0 {\n            continue;\n        }\n        result.push(i\
    \ as isize * x);\n    }\n    result", "    xs.iter()\n        .enumerate()\n \
    \       .skip(1)\n        .map(|(i, x)| x * i as isize)\n        .collect()",
  "    let mut result = Vec::new();\n    for i in 1..xs.len() {\n        result.push(xs[i]\
    \ * i as isize);\n    }\n    result", "    xs.iter()\n        .enumerate()\n \
    \       .skip(1)\n        .map(|(i, x)| x * i as isize)\n        .collect()",
  "    xs.iter()\n        .enumerate()\n        .skip(1)\n        .map(|(i, &x)| x\
    \ * i as isize)\n        .collect()", "    let mut deriv = Vec::new();\n    let\
    \ mut coeff = 0;\n    for (i, _) in xs.iter().enumerate() {\n        deriv.push(xs[i]\
    \ * coeff);\n        coeff += 1;\n    }\n    deriv", "    let mut result = Vec::new();\n\
    \    for i in 1..xs.len() {\n        result.push(xs[i] * i as isize);\n    }\n\
    \    result", "    let mut xs_deriv = vec![];\n    let mut i = 1;\n    for a in\
    \ xs.iter().skip(1) {\n        xs_deriv.push(i * a);\n        i += 1;\n    }\n\
    \    xs_deriv", "    let mut ys = vec![];\n    for i in 1..xs.len() {\n      \
    \  ys.push(xs[i] * i as isize);\n    }\n    ys", "    let mut result = vec![];\n\
    \    for i in 1..xs.len() {\n        result.push(xs[i] * i as isize);\n    }\n\
    \    result", "    let n = xs.len();\n    let mut ret = Vec::new();\n    for i\
    \ in 1..n {\n        ret.push(xs[i] * i as isize);\n    }\n    ret", "    let\
    \ mut result = vec![];\n    for (i, x) in xs.iter().enumerate() {\n        if\
    \ i > 0 {\n            result.push(i as isize * x);\n        }\n    }\n    result",
  "    let mut derivative = Vec::new();\n    for i in 1..xs.len() {\n        derivative.push(xs[i]\
    \ * i as isize);\n    }\n    derivative", "    let len = xs.len();\n    let mut\
    \ ret = Vec::with_capacity(len - 1);\n    for i in 1..len {\n        ret.push(xs[i]\
    \ * i as isize);\n    }\n    ret", "    let mut dxs = Vec::new();\n    let n =\
    \ xs.len();\n    for i in 1..n {\n        dxs.push(xs[i] * i as isize);\n    }\n\
    \    dxs", "    let mut ys = vec![];\n    let mut deg = xs.len() - 1;\n    for\
    \ x in xs {\n        if deg == 0 {\n            break;\n        }\n        ys.push(x\
    \ * deg as isize);\n        deg -= 1;\n    }\n    ys", "    let mut ys = vec![];\n\
    \    for i in 1..xs.len() {\n        ys.push(xs[i] * i as isize);\n    }\n   \
    \ ys", "    let mut coeff = Vec::new();\n    for i in 1..xs.len() {\n        coeff.push(xs[i]\
    \ * i as isize);\n    }\n    coeff", "    xs.iter()\n        .enumerate()\n  \
    \      .skip(1)\n        .map(|(i, &x)| i as isize * x)\n        .collect()",
  "    let mut result = vec![];\n    for i in 1..xs.len() {\n        result.push(xs[i]\
    \ * i as isize);\n    }\n    result"]
stop_tokens:
- "\n}"
