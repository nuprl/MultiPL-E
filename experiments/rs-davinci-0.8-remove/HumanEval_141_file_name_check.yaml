name: HumanEval_141_file_name_check
language: rs
prompt: "/// Create a function which takes a string representing a file's name, and\
  \ returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
  /// A file's name is considered to be valid if and only if all the following conditions\
  \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
  \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// - The\
  \ substring before the dot should not be empty, and it starts with a letter from\
  \ \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after the\
  \ dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\nfn file_name_check(file_name:\
  \ String) -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
  example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
  1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
  s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
  K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
  )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
  )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
  \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")),\
  \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
  )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
  )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
  )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
  )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
  )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
  )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
  )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
  )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
  )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
  )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
  )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
  )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
  )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
  )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\")),\
  \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
  )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")), String::from(\"\
  No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"No\"));\n\
  }\n"
completions: ["    let valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    if file_name.len()\
    \ == 0 {\n        return \"No\".to_string();\n    }\n    let mut dot_found = false;\n\
    \    let mut digit_count = 0;\n    let mut dot_index = 0;\n    for (i, c) in file_name.chars().enumerate()\
    \ {\n        if c.is_digit(10) {\n            digit_count += 1;\n        }\n \
    \       if !dot_found && c == '.' {\n            dot_found = true;\n         \
    \   dot_index = i;\n        }\n    }\n    if digit_count > 3 || !dot_found ||\
    \ dot_index == 0 {\n        return \"No\".to_string();\n    }\n    let prefix\
    \ = &file_name[0..dot_index];\n    let suffix = &file_name[dot_index+1..];\n \
    \   if prefix.chars().next().unwrap().is_alphabetic() && valid_extensions.contains(&suffix.as_str())\
    \ {\n        return \"Yes\".to_string();\n    }\n    \"No\".to_string()", "  \
    \  let p = vec![\"txt\", \"exe\", \"dll\"];\n    let re = Regex::new(r\"^[a-zA-Z]+[0-9]{0,3}\\\
    .[a-zA-Z]+$\").unwrap();\n    if !re.is_match(&file_name) {\n        return \"\
    No\".to_string();\n    }\n    let filename: Vec<&str> = file_name.split(\".\"\
    ).collect();\n    if !p.contains(&filename[1]) {\n        return \"No\".to_string();\n\
    \    }\n    return \"Yes\".to_string();", "    let mut result = String::from(\"\
    Yes\");\n    let mut count = 0;\n    let mut has_dot = false;\n    let mut post_dot_string\
    \ = String::new();\n    let mut has_post_dot_string = false;\n    let mut has_pre_dot_string\
    \ = false;\n    let mut valid_pre_dot_string = false;\n    let mut valid_post_dot_string\
    \ = false;\n    for c in file_name.chars() {\n        if c == '.' {\n        \
    \    if has_dot {\n                result = String::from(\"No\");\n          \
    \      break;\n            }\n            has_dot = true;\n            if has_pre_dot_string\
    \ {\n                has_post_dot_string = true;\n            }\n        } else\
    \ if c >= 'a' && c <= 'z' {\n            if has_dot {\n                has_post_dot_string\
    \ = true;\n            } else {\n                has_pre_dot_string = true;\n\
    \                valid_pre_dot_string = true;\n            }\n        } else if\
    \ c >= 'A' && c <= 'Z' {\n            if has_dot {\n                has_post_dot_string\
    \ = true;\n            } else {\n                has_pre_dot_string = true;\n\
    \                valid_pre_dot_string = true;\n            }\n        } else if\
    \ c >= '0' && c <= '9' {\n            if has_dot {\n                has_post_dot_string\
    \ = true;\n            } else {\n                has_pre_dot_string = true;\n\
    \            }\n            count += 1;\n            if count > 3 {\n        \
    \        result = String::from(\"No\");\n                break;\n            }\n\
    \        } else {\n            result = String::from(\"No\");\n            break;\n\
    \        }\n        if has_dot && has_post_dot_string {\n            post_dot_string.push(c);\n\
    \        }\n    }\n    if result == String::from(\"Yes\") {\n        if !has_dot\
    \ || !has_pre_dot_string || !has_post_dot_string {\n            result = String::from(\"\
    No\");\n        } else if !valid_", "    // Fill the string below with the right\
    \ answer.\n    if file_name.matches(char::is_numeric).count() > 3 {\n        return\
    \ \"No\".to_string();\n    }\n\n    if file_name.chars().filter(|c| *c == '.').count()\
    \ != 1 {\n        return \"No\".to_string();\n    }\n\n    let (before_dot, after_dot)\
    \ = file_name.split_at(file_name.find('.').unwrap());\n    if before_dot.is_empty()\
    \ || !before_dot.chars().next().unwrap().is_alphabetic() {\n        return \"\
    No\".to_string();\n    }\n\n    match after_dot {\n        \".txt\" | \".exe\"\
    \ | \".dll\" => \"Yes\".to_string(),\n        _ => \"No\".to_string(),\n    }",
  "    lazy_static! {\n        static ref FILE_NAMES: HashSet<String> = [\"txt\",\
    \ \"exe\", \"dll\"].iter().map(|s| s.to_string()).collect();\n    }\n    lazy_static!\
    \ {\n        static ref RE_FILE_NAME: Regex = Regex::new(r\"^([a-zA-Z]+)[\\.]([a-zA-Z]+)$\"\
    ).unwrap();\n    }\n    if !RE_FILE_NAME.is_match(&file_name) {\n        return\
    \ \"No\".to_string();\n    }\n    let (before_dot, after_dot) = RE_FILE_NAME.captures(&file_name).unwrap().get(1..3).unwrap().map(|m|\
    \ m.as_str().to_string()).collect_tuple().unwrap();\n    let no_more_than_three_digits\
    \ = before_dot.chars().filter(|c| c.is_ascii_digit()).count() <= 3;\n    let only_one_dot\
    \ = file_name.chars().filter(|c| *c == '.').count() == 1;\n    let substring_is_valid\
    \ = FILE_NAMES.contains(&after_dot);\n    if no_more_than_three_digits && only_one_dot\
    \ && substring_is_valid {\n        \"Yes\".to_string()\n    } else {\n       \
    \ \"No\".to_string()\n    }", "    if file_name.contains(\".\") {\n        let\
    \ mut digits = 0;\n        let mut len = 0;\n        for i in file_name.chars()\
    \ {\n            if i == '.' {\n                len = 0;\n            } else if\
    \ i.is_digit(10) {\n                digits += 1;\n            } else {\n     \
    \           len += 1;\n            }\n        }\n        if digits <= 3 && len\
    \ >= 1 {\n            let v: Vec<&str> = file_name.split('.').collect();\n   \
    \         if v[1] == \"txt\" || v[1] == \"exe\" || v[1] == \"dll\" {\n       \
    \         return \"Yes\".to_string();\n            }\n        }\n    }\n    \"\
    No\".to_string()", "    let valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    let mut has_dot = false;\n    let mut number_of_digits = 0;\n    let name_split:\
    \ Vec<&str> = file_name.split('.').collect();\n    if name_split.len() != 2 {\n\
    \        return \"No\".to_string();\n    }\n    for c in name_split[0].chars()\
    \ {\n        if c.is_digit(10) {\n            number_of_digits += 1;\n       \
    \ }\n        if number_of_digits > 3 {\n            return \"No\".to_string();\n\
    \        }\n    }\n    for s in valid_extensions.iter() {\n        if s == name_split[1]\
    \ {\n            has_dot = true;\n        }\n    }\n    if has_dot {\n       \
    \ return \"Yes\".to_string();\n    }\n    \"No\".to_string()", "    let re = Regex::new(r\"\
    ^([a-zA-Z]{1}[a-zA-Z0-9_]*)\\.(txt|exe|dll)$\").unwrap();\n    if re.is_match(&file_name)\
    \ {\n        \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n \
    \   }", "  let mut is_valid = true;\n  let mut size = 0;\n  let mut dot_count\
    \ = 0;\n  let mut digit_count = 0;\n  let mut substring_left: String = String::new();\n\
    \  let mut substring_right: String = String::new();\n  let mut is_right_right_valid\
    \ = false;\n  for ch in file_name.chars() {\n    size += 1;\n    if ch.is_digit(10)\
    \ {\n      digit_count += 1;\n    }\n    if digit_count > 3 {\n      is_valid\
    \ = false;\n      break;\n    }\n    if ch == '.' {\n      dot_count += 1;\n \
    \     if dot_count > 1 {\n        is_valid = false;\n        break;\n      }\n\
    \    }\n  }\n  if is_valid && dot_count == 1 {\n    let mut left_size = 0;\n \
    \   let mut right_size = 0;\n    for (i, ch) in file_name.chars().enumerate()\
    \ {\n      if ch == '.' {\n        left_size = i;\n        right_size = size -\
    \ i - 1;\n        break;\n      }\n    }\n    if left_size > 0 && right_size >\
    \ 0 {\n      substring_left = file_name.chars().take(left_size).collect();\n \
    \     substring_right = file_name.chars().skip(left_size + 1).take(right_size).collect();\n\
    \      if !substring_left.is_empty() && substring_left.chars().next().unwrap().is_alphabetic()\
    \ {\n        is_right_right_valid = substring_right == \"txt\" || substring_right\
    \ == \"exe\" ||\n          substring_right == \"dll\";\n      }\n    }\n  }\n\
    \  if is_valid && is_right_right_valid {\n    \"Yes\".to_string()\n  } else {\n\
    \    \"No\".to_string()\n  }", "    let mut dot_found = false;\n    let mut count\
    \ = 0;\n    let mut digits = 0;\n    let mut ext = String::new();\n    let mut\
    \ name = String::new();\n    for c in file_name.chars() {\n        if c == '.'\
    \ {\n            dot_found = true;\n            continue;\n        }\n       \
    \ if c >= '0' && c <= '9' {\n            digits += 1;\n        }\n        if digits\
    \ > 3 {\n            return String::from(\"No\");\n        }\n        if dot_found\
    \ {\n            ext.push(c);\n        } else {\n            name.push(c);\n \
    \       }\n        count += 1;\n    }\n    if count < 3 || digits > 3 || name.len()\
    \ == 0 || !dot_found || ext.len() > 3 || ext.len() == 0 {\n        return String::from(\"\
    No\");\n    }\n    if ext != \"txt\" && ext != \"exe\" && ext != \"dll\" {\n \
    \       return String::from(\"No\");\n    }\n    return String::from(\"Yes\");",
  "    if file_name.chars().filter(|&c| c >= '0' && c <= '9').count() > 3 {\n    \
    \    \"No\".to_string()\n    } else if !file_name.contains('.') {\n        \"\
    No\".to_string()\n    } else {\n        let parts: Vec<&str> = file_name.split('.').collect();\n\
    \        let (before, after) = (parts[0], parts[1]);\n        if before.is_empty()\
    \ {\n            \"No\".to_string()\n        } else if before.chars().next().unwrap()\
    \ < 'A' || before.chars().next().unwrap() > 'z' {\n            \"No\".to_string()\n\
    \        } else if after != \"txt\" && after != \"exe\" && after != \"dll\" {\n\
    \            \"No\".to_string()\n        } else {\n            \"Yes\".to_string()\n\
    \        }\n    }", "    let name_validation = |name: String| {\n        if name.len()\
    \ == 0 {\n            return false;\n        }\n        let mut first_char = true;\n\
    \        let mut has_digits = false;\n        for char in name.chars() {\n   \
    \         if first_char {\n                if !char.is_alphabetic() {\n      \
    \              return false;\n                }\n                first_char =\
    \ false;\n            } else {\n                if char.is_numeric() {\n     \
    \               has_digits = true;\n                }\n            }\n       \
    \ }\n        !has_digits\n    };\n    if !file_name.contains('.') {\n        return\
    \ String::from(\"No\");\n    }\n    let substrings: Vec<&str> = file_name.split('.').collect();\n\
    \    if substrings.len() != 2 {\n        return String::from(\"No\");\n    }\n\
    \    let name = substrings[0].to_string();\n    let extension = substrings[1].to_string();\n\
    \    let valid_extensions = vec![\"txt\", \"exe\", \"dll\"];\n    if !valid_extensions.contains(&extension.as_str())\
    \ {\n        return String::from(\"No\");\n    }\n    if name_validation(name)\
    \ {\n        return String::from(\"Yes\");\n    }\n    String::from(\"No\")",
  "    // Write your code here\n    let mut digits_count = 0;\n    let mut dot_count\
    \ = 0;\n    let mut valid_flag = false;\n    let mut string_length = 0;\n    let\
    \ mut prefix_flag = false;\n    let mut suffix_flag = false;\n    let suffix_array\
    \ = [\"txt\", \"exe\", \"dll\"];\n    for i in file_name.chars() {\n        string_length\
    \ += 1;\n        if i.is_digit(10) {\n            digits_count += 1;\n       \
    \ } else if i == '.' {\n            dot_count += 1;\n        }\n    }\n    if\
    \ digits_count > 3 || dot_count != 1 {\n        valid_flag = false;\n    } else\
    \ {\n        let file_array: Vec<&str> = file_name.split('.').collect();\n   \
    \     if file_array[0].len() != 0 && file_array[0].chars().next().unwrap().is_alphabetic()\
    \ {\n            prefix_flag = true;\n        }\n        for i in suffix_array.iter()\
    \ {\n            if file_array[1] == *i {\n                suffix_flag = true;\n\
    \            }\n        }\n        if prefix_flag && suffix_flag {\n         \
    \   valid_flag = true;\n        }\n    }\n    if valid_flag {\n        return\
    \ \"Yes\".to_string();\n    } else {\n        return \"No\".to_string();\n   \
    \ }", "    let mut num_digits = 0;\n    let mut dot_encountered = false;\n   \
    \ let mut first_char_encountered = false;\n    let mut file_extension_encountered\
    \ = false;\n    let mut file_extension = String::new();\n    for c in file_name.chars()\
    \ {\n        if 'a' <= c && c <= 'z' || 'A' <= c && c <= 'Z' {\n            if\
    \ dot_encountered {\n                return \"No\".to_string();\n            }\n\
    \            first_char_encountered = true;\n        } else if '0' <= c && c <=\
    \ '9' {\n            if !first_char_encountered || dot_encountered {\n       \
    \         return \"No\".to_string();\n            }\n            num_digits +=\
    \ 1;\n            if num_digits > 3 {\n                return \"No\".to_string();\n\
    \            }\n        } else if c == '.' {\n            if dot_encountered ||\
    \ !first_char_encountered {\n                return \"No\".to_string();\n    \
    \        }\n            dot_encountered = true;\n        } else {\n          \
    \  if !dot_encountered {\n                return \"No\".to_string();\n       \
    \     }\n            file_extension.push(c);\n            file_extension_encountered\
    \ = true;\n        }\n    }\n    if !file_extension_encountered {\n        return\
    \ \"No\".to_string();\n    }\n    if file_extension != \"txt\" && file_extension\
    \ != \"exe\" && file_extension != \"dll\" {\n        return \"No\".to_string();\n\
    \    }\n    \"Yes\".to_string()", "    let mut dot_count = 0;\n    let mut number_count\
    \ = 0;\n    let mut letter_count = 0;\n    let mut first_dot_index = 0;\n    let\
    \ mut last_dot_index = 0;\n    let mut first_letter_index = 0;\n    let mut last_letter_index\
    \ = 0;\n    let mut first_num_index = 0;\n    let mut last_num_index = 0;\n  \
    \  for (i, c) in file_name.chars().enumerate() {\n        if dot_count == 0 &&\
    \ c == '.' {\n            dot_count += 1;\n            first_dot_index = i;\n\
    \        }\n        if (dot_count == 1 && c == '.') || c == '.' && i == file_name.len()\
    \ - 1 {\n            dot_count += 1;\n            last_dot_index = i;\n      \
    \  }\n        if c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' {\n            letter_count\
    \ += 1;\n            if first_letter_index == 0 {\n                first_letter_index\
    \ = i;\n            }\n            last_letter_index = i;\n        }\n       \
    \ if c >= '0' && c <= '9' {\n            number_count += 1;\n            if first_num_index\
    \ == 0 {\n                first_num_index = i;\n            }\n            last_num_index\
    \ = i;\n        }\n    }\n    if dot_count != 1 || first_letter_index > first_dot_index\
    \ || letter_count == 0 {\n        return \"No\".to_string();\n    }\n    if number_count\
    \ > 3 || (first_num_index < first_dot_index && number_count > 0) {\n        return\
    \ \"No\".to_string();\n    }\n    if number_count == 0 && letter_count == file_name.len()\
    \ - 1 {\n        return \"No\".to_string();\n    }\n    let after_dot = file_name[(last_dot_index\
    \ + 1)..].to_string();\n    match after_dot.as_str() {\n        \"txt\" | \"exe\"\
    \ | \"", "    // write your code here\n    let mut digits_count = 0;\n    let\
    \ mut dot_count = 0;\n    let mut dot_idx = 0;\n    let mut first_letter_idx =\
    \ 0;\n    let mut extension = String::new();\n    for (i, c) in file_name.chars().enumerate()\
    \ {\n        if c.is_ascii_digit() {\n            digits_count += 1;\n       \
    \ } else if c == '.' {\n            dot_count += 1;\n            dot_idx = i;\n\
    \        } else if c.is_ascii_alphabetic() {\n            first_letter_idx = i;\n\
    \        }\n    }\n    if dot_count == 1 && digits_count <= 3 && dot_idx > first_letter_idx\
    \ {\n        extension = file_name[dot_idx+1..].to_string();\n    }\n    let valid_extensions\
    \ = [\"txt\", \"exe\", \"dll\"];\n    if valid_extensions.contains(&extension.as_str())\
    \ {\n        return \"Yes\".to_string();\n    }\n    \"No\".to_string()", "  \
    \  let mut num_of_digits = 0;\n    let mut dot_flag = false;\n    let mut ext_flag\
    \ = false;\n    let ext_vec = vec![\"txt\", \"exe\", \"dll\"];\n    for c in file_name.chars()\
    \ {\n        if c.is_digit(10) {\n            num_of_digits += 1;\n        }\n\
    \        if num_of_digits > 3 {\n            return \"No\".to_string();\n    \
    \    }\n        if c == '.' {\n            dot_flag = true;\n        }\n     \
    \   if dot_flag {\n            let ext_str = &file_name[(file_name.len() - 3)..];\n\
    \            for ext in ext_vec.iter() {\n                if ext_str == *ext {\n\
    \                    ext_flag = true;\n                }\n            }\n    \
    \        if !ext_flag {\n                return \"No\".to_string();\n        \
    \    }\n        }\n    }\n    if dot_flag && !file_name.starts_with(|c: char|\
    \ c.is_alphabetic()) {\n        return \"No\".to_string();\n    }\n    return\
    \ \"Yes\".to_string();", "    // your code here\n    \"No\".to_string()", "  \
    \  let mut split = file_name.split('.');\n    let front = split.next().unwrap();\n\
    \    let back = split.next().unwrap();\n    let mut num = 0;\n    for c in front.chars()\
    \ {\n        if c.is_numeric() {\n            num += 1;\n        }\n    }\n  \
    \  if num <= 3 && front.chars().any(|c| c.is_alphabetic()) && \n        vec![\"\
    txt\", \"exe\", \"dll\"].contains(&back) {\n        \"Yes\".to_string()\n    }\
    \ else {\n        \"No\".to_string()\n    }", "    let mut count = 0;\n    let\
    \ mut starts_with_letter = false;\n    let mut extension_is_good = false;\n  \
    \  let mut dot_was_found = false;\n    let mut letter_was_found = false;\n   \
    \ let mut extension = String::new();\n    let mut is_valid = true;\n    for c\
    \ in file_name.chars() {\n        if c == '.' {\n            dot_was_found = true;\n\
    \            continue;\n        }\n        if !dot_was_found {\n            if\
    \ c.is_alphabetic() {\n                starts_with_letter = true;\n          \
    \      letter_was_found = true;\n            }\n            else if letter_was_found\
    \ && c.is_digit(10) {\n                count += 1;\n            }\n          \
    \  else {\n                is_valid = false;\n                break;\n       \
    \     }\n        }\n        else {\n            extension.push(c);\n        }\n\
    \    }\n    if count > 3 {\n        is_valid = false;\n    }\n    if !starts_with_letter\
    \ {\n        is_valid = false;\n    }\n    if !dot_was_found {\n        is_valid\
    \ = false;\n    }\n    if !extension.is_empty() {\n        match extension.as_str()\
    \ {\n            \"txt\" | \"exe\" | \"dll\" => {extension_is_good = true;}\n\
    \            _ => {}\n        }\n    }\n    if !extension_is_good {\n        is_valid\
    \ = false;\n    }\n    if is_valid {\n        return String::from(\"Yes\");\n\
    \    }\n    return String::from(\"No\");", "    if file_name.chars().filter(|c|\
    \ c.is_digit(10)).count() > 3 {\n        return \"No\".to_string();\n    }\n \
    \   if file_name.chars().filter(|c| *c == '.').count() != 1 {\n        return\
    \ \"No\".to_string();\n    }\n    let split: Vec<_> = file_name.split('.').collect();\n\
    \    if split[0].len() == 0 {\n        return \"No\".to_string();\n    }\n   \
    \ let first_letter = split[0].chars().next().unwrap();\n    if !first_letter.is_alphabetic()\
    \ {\n        return \"No\".to_string();\n    }\n    let third_part = split[1];\n\
    \    if third_part == \"txt\" || third_part == \"exe\" || third_part == \"dll\"\
    \ {\n        return \"Yes\".to_string();\n    }\n    \"No\".to_string()", "  \
    \  let mut file_name_parts = file_name.split(\".\");\n    let file_start = file_name_parts.next().unwrap();\n\
    \    let file_end = file_name_parts.next().unwrap();\n    let mut num_digits =\
    \ 0;\n    let mut first_char = file_start.chars().next().unwrap();\n    if !(first_char.is_ascii_lowercase()\
    \ || first_char.is_ascii_uppercase()) {\n        return \"No\".to_string();\n\
    \    }\n    for c in file_start.chars() {\n        if c.is_ascii_digit() {\n \
    \           num_digits += 1;\n        }\n    }\n    if num_digits > 3 {\n    \
    \    return \"No\".to_string();\n    }\n    match file_end {\n        \"txt\"\
    \ | \"exe\" | \"dll\" => \"Yes\".to_string(),\n        _ => \"No\".to_string(),\n\
    \    }", "    if file_name.matches(char::is_numeric).count() > 3 {\n        return\
    \ \"No\".to_string();\n    }\n\n    let mut parts = file_name.split('.');\n  \
    \  let before_dot = parts.next().unwrap();\n    let after_dot = parts.next().unwrap();\n\
    \n    if before_dot.is_empty() || !before_dot.chars().next().unwrap().is_alphabetic()\
    \ {\n        return \"No\".to_string();\n    }\n\n    if after_dot == \"txt\"\
    \ || after_dot == \"exe\" || after_dot == \"dll\" {\n        return \"Yes\".to_string();\n\
    \    }\n\n    \"No\".to_string()", "    if file_name.len() > 255 {\n        return\
    \ \"No\".to_string();\n    }\n    let mut dot_count = 0;\n    let mut digits_count\
    \ = 0;\n    let mut dots_index = 0;\n    let mut first_char = ' ';\n    for (i,\
    \ c) in file_name.chars().enumerate() {\n        if c == '.' {\n            dot_count\
    \ += 1;\n            dots_index = i;\n        }\n        if c.is_digit(10) {\n\
    \            digits_count += 1;\n        }\n        if i == 0 {\n            first_char\
    \ = c;\n        }\n    }\n    if first_char.is_lowercase() || first_char.is_uppercase()\
    \ {\n        if digits_count > 3 {\n            return \"No\".to_string();\n \
    \       }\n        if dot_count != 1 {\n            return \"No\".to_string();\n\
    \        }\n        if file_name.len() - dots_index == 1 {\n            return\
    \ \"No\".to_string();\n        }\n        let mut suffix = file_name.chars().skip(dots_index\
    \ + 1).collect::<String>();\n        if suffix.len() > 3 {\n            return\
    \ \"No\".to_string();\n        }\n        suffix = suffix.chars().take(3).collect::<String>();\n\
    \        if suffix == \"txt\" || suffix == \"exe\" || suffix == \"dll\" {\n  \
    \          return \"Yes\".to_string();\n        }\n    }\n    \"No\".to_string()",
  "    let file_name = file_name.into_bytes();\n    let period_pos = file_name.iter().position(|c|\
    \ *c == 46);\n    let last_pos = file_name.len() - 1;\n    let period_pos = match\
    \ period_pos {\n        Some(v) => v,\n        None => return \"No\".to_string(),\n\
    \    };\n    let (front, back) = file_name.split_at(period_pos);\n    let (front,\
    \ back) = (front, &back[1..]);\n    let cond1 = front.iter().any(|c| *c >= 48\
    \ && *c <= 57);\n    let cond2 = front.len() < 1 || front[0] < 65 || front[0]\
    \ > 122 || (front[0] > 90 && front[0] < 97);\n    let cond3 = back.len() != 3\
    \ || !(back[0] == 't' as u8 && back[1] == 'x' as u8 && back[2] == 't' as u8) &&\
    \ !(back[0] == 'e' as u8 && back[1] == 'x' as u8 && back[2] == 'e' as u8) && !(back[0]\
    \ == 'd' as u8 && back[1] == 'l' as u8 && back[2] == 'l' as u8);\n    if cond1\
    \ || cond2 || cond3 {\n        \"No\".to_string()\n    } else {\n        \"Yes\"\
    .to_string()\n    }", "    fn is_valid_file_name(file_name: &str) -> bool {\n\
    \        let last_dot_idx = file_name.rfind('.').unwrap();\n        if file_name.rfind(|c:\
    \ char| !c.is_alphanumeric() && c != '.') != Some(last_dot_idx) {\n          \
    \  return false;\n        }\n        if !file_name.chars().skip(last_dot_idx +\
    \ 1).all(|c| c.is_alphabetic()) {\n            return false;\n        }\n    \
    \    if file_name.chars().filter(|c| c.is_digit(10)).count() > 3 {\n         \
    \   return false;\n        }\n        let after_dot = &file_name[last_dot_idx\
    \ + 1..];\n        after_dot == \"txt\" || after_dot == \"exe\" || after_dot ==\
    \ \"dll\"\n    }\n    if is_valid_file_name(&file_name) {\n        \"Yes\".to_string()\n\
    \    } else {\n        \"No\".to_string()\n    }", "    let splitted: Vec<&str>\
    \ = file_name.split('.').collect();\n    if splitted.len() != 2 {\n        return\
    \ String::from(\"No\");\n    }\n    if splitted[0].contains(' ') || splitted[1].contains('\
    \ ') {\n        return String::from(\"No\");\n    }\n    if splitted[0].chars().filter(|c|\
    \ char::is_digit(*c, 10)).count() > 3 {\n        return String::from(\"No\");\n\
    \    }\n    if splitted[0].chars().filter(|c| char::is_alphabetic(*c)).count()\
    \ == 0 {\n        return String::from(\"No\");\n    }\n    if splitted[1] != \"\
    txt\" && splitted[1] != \"exe\" && splitted[1] != \"dll\" {\n        return String::from(\"\
    No\");\n    }\n    String::from(\"Yes\")", "    let dot_count = file_name.chars().filter(|c|\
    \ *c == '.').count();\n    let digit_count = file_name.chars().filter(|c| c.is_digit(10)).count();\n\
    \    let file_type = file_name.rsplitn(2, '.').collect::<Vec<&str>>()[0];\n  \
    \  let file_type_check = [\"txt\", \"exe\", \"dll\"].contains(&file_type);\n \
    \   let after_dot_check = dot_count == 1 && !file_name.contains(\"..\") && file_type_check;\n\
    \    let before_dot_check = !file_name.contains(\".\") && !file_name.contains(\"\
    \ \");\n    let space_check = file_name.chars().filter(|c| *c == ' ').count()\
    \ == 0;\n    if before_dot_check && space_check && digit_count <= 3 {\n      \
    \  return \"Yes\".to_string();\n    } else if after_dot_check && space_check &&\
    \ digit_count <= 3 {\n        return \"Yes\".to_string();\n    } else {\n    \
    \    return \"No\".to_string();\n    }", "    if file_name.is_empty() {\n    \
    \    return \"No\".to_string();\n    }\n    if file_name.starts_with(\"0\") {\n\
    \        return \"No\".to_string();\n    }\n    let mut digits = 0;\n    let mut\
    \ is_letter = false;\n    let mut after_dot = false;\n    let mut is_dot = false;\n\
    \    let mut extension = String::new();\n    for c in file_name.chars() {\n  \
    \      if c == '.' {\n            if is_dot {\n                return \"No\".to_string();\n\
    \            }\n            is_dot = true;\n            after_dot = true;\n  \
    \          is_letter = false;\n            continue;\n        }\n        if c\
    \ == '0' || c == '1' || c == '2' || c == '3' || c == '4' || c == '5' || c == '6'\
    \ || c == '7' || c == '8' || c == '9' {\n            if !after_dot {\n       \
    \         if is_letter {\n                    digits += 1;\n                }\n\
    \            }\n            if digits >= 3 {\n                return \"No\".to_string();\n\
    \            }\n            is_letter = false;\n            continue;\n      \
    \  }\n        if c == 'a' || c == 'b' || c == 'c' || c == 'd' || c == 'e' || c\
    \ == 'f' || c == 'g' || c == 'h' || c == 'i' || c == 'j' || c == 'k' || c == 'l'\
    \ || c == 'm' || c == 'n' || c == 'o' || c == 'p' || c == 'q' || c == 'r' || c\
    \ == 's' || c == 't' || c == 'u' || c == 'v' || c == 'w' || c == 'x' || c == 'y'\
    \ || c == 'z' || c == 'A' || c == 'B' || c == 'C' || c == 'D' || c == 'E' || c\
    \ == 'F' || c == 'G' || c == 'H' || c == 'I' || c", "    if file_name.chars().filter(|c|\
    \ c.is_digit(10)).count() > 3 {\n        return \"No\".to_string();\n    }\n \
    \   if file_name.contains('.') == false {\n        return \"No\".to_string();\n\
    \    }\n    let mut splits = file_name.split('.');\n    let (name, extension)\
    \ = (splits.next().unwrap(), splits.next().unwrap());\n    if name.is_empty()\
    \ || name.chars().all(|c| c.is_ascii_alphabetic() == false) {\n        return\
    \ \"No\".to_string();\n    }\n    if ![\"txt\", \"exe\", \"dll\"].contains(&extension)\
    \ {\n        return \"No\".to_string();\n    }\n    \"Yes\".to_string()", "  \
    \  if file_name.len() < 4 {\n        return \"No\".to_string();\n    }\n    let\
    \ mut dot_cnt = 0;\n    let mut num_cnt = 0;\n    let mut first_letter = false;\n\
    \    for c in file_name.chars() {\n        if !first_letter {\n            first_letter\
    \ = c.is_alphabetic();\n        }\n        num_cnt += c.is_numeric() as i32;\n\
    \        dot_cnt += c == '.';\n    }\n    if dot_cnt != 1 || num_cnt > 3 || !first_letter\
    \ {\n        return \"No\".to_string();\n    }\n    let v: Vec<&str> = file_name.split('.').collect();\n\
    \    if v.len() != 2 {\n        return \"No\".to_string();\n    }\n    let sfx\
    \ = v[1];\n    if sfx != \"txt\" && sfx != \"exe\" && sfx != \"dll\" {\n     \
    \   return \"No\".to_string();\n    }\n    \"Yes\".to_string()", "    let re =\
    \ Regex::new(r\"^[a-zA-Z]{1}[\\w]{0,}[\\.](txt|exe|dll)$\").unwrap();\n    let\
    \ (first, _) = file_name.split_at(file_name.find('.').unwrap());\n    if first.len()\
    \ > 3 { return \"No\".to_string(); }\n    if re.is_match(&file_name) { \"Yes\"\
    .to_string() } else { \"No\".to_string() }", "    let file_name = file_name.to_lowercase();\n\
    \    let name_parts: Vec<&str> = file_name.split('.').collect();\n    let mut\
    \ count_digits = 0;\n    let mut is_valid = true;\n    if name_parts.len() !=\
    \ 2 {\n        is_valid = false;\n    }\n    for (index, part) in name_parts.iter().enumerate()\
    \ {\n        if index == 0 {\n            for ch in part.chars() {\n         \
    \       if !ch.is_ascii_alphabetic() {\n                    if ch.is_digit(10)\
    \ {\n                        count_digits += 1;\n                    } else {\n\
    \                        is_valid = false;\n                        break;\n \
    \                   }\n                }\n            }\n            if count_digits\
    \ > 3 {\n                is_valid = false;\n            }\n        } else {\n\
    \            if part != \"txt\" && part != \"exe\" && part != \"dll\" {\n    \
    \            is_valid = false;\n            }\n        }\n    }\n    if is_valid\
    \ {\n        \"yes\".to_string()\n    } else {\n        \"no\".to_string()\n \
    \   }", "    let mut counter: i32 = 0;\n    let mut found_dot: bool = false;\n\
    \    let mut starting_letter: bool = false;\n    let mut valid_ending: bool =\
    \ false;\n    let mut it = file_name.chars();\n    match it.next() {\n       \
    \ Some(c) => {\n            if c.is_alphabetic() {\n                starting_letter\
    \ = true;\n            }\n        }\n        None => {\n            return String::from(\"\
    No\");\n        }\n    }\n    for i in it {\n        if i.is_alphabetic() {\n\
    \            continue;\n        }\n        if i.is_digit(10) {\n            counter\
    \ += 1;\n            if counter > 3 {\n                return String::from(\"\
    No\");\n            }\n        }\n        if i == '.' {\n            if found_dot\
    \ {\n                return String::from(\"No\");\n            }\n           \
    \ found_dot = true;\n        }\n    }\n    if counter > 3 {\n        return String::from(\"\
    No\");\n    }\n    let ending = match file_name.split('.').last() {\n        Some(s)\
    \ => s,\n        None => return String::from(\"No\"),\n    };\n    if ending ==\
    \ \"txt\" || ending == \"exe\" || ending == \"dll\" {\n        valid_ending =\
    \ true;\n    }\n    match (found_dot, starting_letter, valid_ending) {\n     \
    \   (true, true, true) => String::from(\"Yes\"),\n        _ => String::from(\"\
    No\"),\n    }", "  match file_name.split('.').collect::<Vec<&str>>().len() {\n\
    \    2 => {\n      let f_name = file_name.split('.').collect::<Vec<&str>>()[0];\n\
    \      let f_type = file_name.split('.').collect::<Vec<&str>>()[1];\n      let\
    \ mut num_of_digits = 0;\n      if f_name.len() == 0 {\n        return \"No\"\
    .to_string();\n      } else {\n        for ch in f_name.chars() {\n          if\
    \ ch >= '0' && ch <= '9' {\n            num_of_digits += 1;\n          }\n   \
    \     }\n        if (num_of_digits > 3) ||\n            (f_type != \"txt\" &&\
    \ f_type != \"exe\" && f_type != \"dll\") {\n          return \"No\".to_string();\n\
    \        }\n      }\n    },\n    _ => return \"No\".to_string(),\n  }\n  \"Yes\"\
    .to_string()", "    use std::collections::HashSet;\n    let mut digits_count =\
    \ 0;\n    let mut dot_seen = false;\n    let mut extensions = HashSet::new();\n\
    \    extensions.insert(\"txt\");\n    extensions.insert(\"exe\");\n    extensions.insert(\"\
    dll\");\n    let mut prefix_seen = false;\n    for c in file_name.chars() {\n\
    \        if 'a' <= c && c <= 'z' || 'A' <= c && c <= 'Z' {\n            prefix_seen\
    \ = true;\n        }\n        if !prefix_seen && c != '.' {\n            return\
    \ \"No\".to_string();\n        }\n        if '0' <= c && c <= '9' {\n        \
    \    digits_count += 1;\n            if digits_count > 3 {\n                return\
    \ \"No\".to_string();\n            }\n        }\n        if c == '.' {\n     \
    \       if dot_seen {\n                return \"No\".to_string();\n          \
    \  }\n            dot_seen = true;\n        }\n    }\n    if !dot_seen {\n   \
    \     return \"No\".to_string();\n    }\n    let mut split = file_name.split('.');\n\
    \    let extension = split.next_back().unwrap();\n    if !extensions.contains(extension)\
    \ {\n        return \"No\".to_string();\n    }\n    \"Yes\".to_string()", "  if\
    \ file_name.chars().filter(|x| x.is_digit(10)).count() > 3 {\n    return \"No\"\
    .to_string();\n  }\n\n  let splitted = file_name.split('.').collect::<Vec<&str>>();\n\
    \  if splitted.len() != 2 {\n    return \"No\".to_string();\n  }\n\n  if splitted[0].len()\
    \ == 0 {\n    return \"No\".to_string();\n  }\n\n  if !splitted[0].chars().next().unwrap().is_alphabetic()\
    \ {\n    return \"No\".to_string();\n  }\n\n  if splitted[1] != \"txt\" && splitted[1]\
    \ != \"exe\" && splitted[1] != \"dll\" {\n    return \"No\".to_string();\n  }\n\
    \n  \"Yes\".to_string()", "  if file_name.contains(char::is_numeric) && file_name.chars().filter(|c|\
    \ c.is_numeric()).count() > 3 {\n    return \"No\".to_string();\n  }\n\n  if !file_name.contains('.')\
    \ {\n    return \"No\".to_string();\n  }\n\n  let split = file_name.split('.').collect::<Vec<&str>>();\n\
    \  if split.len() != 2 {\n    return \"No\".to_string();\n  }\n\n  if split[0].is_empty()\
    \ || !split[0].chars().any(|c| c.is_alphabetic()) {\n    return \"No\".to_string();\n\
    \  }\n\n  match split[1] {\n    \"txt\" | \"exe\" | \"dll\" => \"Yes\".to_string(),\n\
    \    _ => \"No\".to_string(),\n  }", "    let mut count = 0;\n    let mut digits_count\
    \ = 0;\n    let mut dot_flag = false;\n    let mut extension = false;\n    let\
    \ mut pre_dot = false;\n    for i in file_name.chars() {\n        if i.is_digit(10)\
    \ {\n            digits_count += 1;\n        }\n        if i == '.' {\n      \
    \      dot_flag = true;\n        }\n        if count < (file_name.len() - 4) &&\
    \ dot_flag {\n            if let Some(c) = file_name.chars().nth(count + 4) {\n\
    \                if c == '.' {\n                    return \"No\".to_string();\n\
    \                }\n            }\n        }\n        if dot_flag {\n        \
    \    match file_name.chars().nth(count + 1) {\n                Some('t') => {\n\
    \                    if file_name.chars().nth(count + 2) == Some('x')\n      \
    \                  && file_name.chars().nth(count + 3) == Some('t')\n        \
    \            {\n                        extension = true;\n                  \
    \  }\n                }\n                Some('e') => {\n                    if\
    \ file_name.chars().nth(count + 2) == Some('x')\n                        && file_name.chars().nth(count\
    \ + 3) == Some('e')\n                    {\n                        extension\
    \ = true;\n                    }\n                }\n                Some('d')\
    \ => {\n                    if file_name.chars().nth(count + 2) == Some('l')\n\
    \                        && file_name.chars().nth(count + 3) == Some('l')\n  \
    \                  {\n                        extension = true;\n            \
    \        }\n                }\n                _ => (),\n            }\n     \
    \   }\n        if !dot_flag {\n            if i.is_ascii_alphabetic() {\n    \
    \            pre_dot = true;\n            }\n        }\n        count += 1;\n\
    \    }\n    if digits_count > 3 || !dot_flag || !pre_dot || !extension {\n   \
    \     return \"No\".to_string();\n    }\n    \"Yes\".to_string()", "    let mut\
    \ dots = 0;\n    let mut digits = 0;\n    let mut is_valid = true;\n    let mut\
    \ extension = String::new();\n    let mut first_letter = true;\n    let mut prev_dot\
    \ = 0;\n    let mut prev_letter = false;\n    for (i, c) in file_name.chars().enumerate()\
    \ {\n        if c == '.' {\n            dots += 1;\n            if prev_dot ==\
    \ 0 {\n                prev_dot = i;\n            }\n        }\n        if c.is_digit(10)\
    \ {\n            digits += 1;\n        }\n        if c.is_alphabetic() {\n   \
    \         if first_letter {\n                first_letter = false;\n         \
    \       prev_letter = true;\n            }\n        } else {\n            prev_letter\
    \ = false;\n        }\n        if digits > 3 {\n            is_valid = false;\n\
    \            break;\n        }\n        if dots > 1 {\n            is_valid =\
    \ false;\n            break;\n        }\n        if prev_dot > 0 && (i - prev_dot)\
    \ == 1 && prev_letter {\n            is_valid = false;\n            break;\n \
    \       }\n        if prev_dot > 0 && (i - prev_dot) > 0 {\n            extension.push(c);\n\
    \        }\n    }\n    if is_valid && dots == 1 && (prev_dot > 0 && extension.len()\
    \ > 0) {\n        if extension == \"txt\" || extension == \"exe\" || extension\
    \ == \"dll\" {\n            is_valid = true;\n        } else {\n            is_valid\
    \ = false;\n        }\n    } else {\n        is_valid = false;\n    }\n    if\
    \ is_valid {\n        \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n\
    \    }", "    if !file_name.contains('.') {\n        return \"No\".to_string();\n\
    \    }\n    let substring_after_dot = file_name\n        .split('.')\n       \
    \ .collect::<Vec<&str>>()\n        .last()\n        .unwrap()\n        .to_string();\n\
    \    if substring_after_dot != \"txt\" && substring_after_dot != \"exe\" && substring_after_dot\
    \ != \"dll\"\n    {\n        return \"No\".to_string();\n    }\n    let substring_before_dot\
    \ = file_name\n        .split('.')\n        .collect::<Vec<&str>>()\n        .first()\n\
    \        .unwrap()\n        .to_string();\n    if substring_before_dot.chars().next().unwrap().is_digit(10)\
    \ {\n        return \"No\".to_string();\n    }\n    let count_of_nums = substring_before_dot\n\
    \        .chars()\n        .map(|c| c.to_digit(10))\n        .filter(|x| x.is_some())\n\
    \        .count();\n    if count_of_nums > 3 {\n        return \"No\".to_string();\n\
    \    }\n    \"Yes\".to_string()", "    if file_name.chars().filter(|&ch| ch.is_digit(10)).count()\
    \ > 3 {\n        \"No\".to_string()\n    } else if !file_name.contains('.') {\n\
    \        \"No\".to_string()\n    } else {\n        let mut parts = file_name.split('.');\n\
    \        let before_dot = parts.next().unwrap();\n        let after_dot = parts.next().unwrap();\n\
    \        if before_dot.is_empty() || !before_dot.chars().any(|ch| ch.is_alphabetic())\
    \ {\n            \"No\".to_string()\n        } else if after_dot == \"txt\" ||\
    \ after_dot == \"exe\" || after_dot == \"dll\" {\n            \"Yes\".to_string()\n\
    \        } else {\n            \"No\".to_string()\n        }\n    }", "    lazy_static!\
    \ {\n        static ref RE: Regex = Regex::new(r\"^[a-zA-Z][a-zA-Z0-9]{0,3}\\\
    .(txt|exe|dll)$\").unwrap();\n    }\n    if RE.is_match(&file_name) {\n      \
    \  String::from(\"Yes\")\n    } else {\n        String::from(\"No\")\n    }",
  "    let mut count = 0;\n    let mut counter = 0;\n    let mut count_after = 0;\n\
    \    let mut count_dots = 0;\n    let mut check = false;\n    let mut check_after\
    \ = false;\n    let first = file_name.clone().chars().next().unwrap();\n    let\
    \ last = file_name.clone().chars().rev().next().unwrap();\n    let first_after\
    \ = file_name.split('.').nth(1).unwrap().chars().next().unwrap();\n    let last_after\
    \ = file_name.split('.').nth(1).unwrap().chars().rev().next().unwrap();\n    let\
    \ arr: Vec<&str> = vec![\"txt\", \"exe\", \"dll\"];\n    let part_before = file_name.split('.').nth(0).unwrap();\n\
    \    let part_after = file_name.split('.').nth(1).unwrap();\n    let mut first_bool\
    \ = false;\n    let mut second_bool = false;\n    let mut third_bool = false;\n\
    \    let mut fourth_bool = false;\n    let mut first_bool_after = false;\n   \
    \ let mut second_bool_after = false;\n    for i in first.to_string().chars() {\n\
    \        if i.is_ascii_alphabetic() {\n            first_bool = true;\n      \
    \  }\n    }\n    for i in last.to_string().chars() {\n        if i.is_ascii_alphabetic()\
    \ {\n            second_bool = true;\n        }\n    }\n    for i in first_after.to_string().chars()\
    \ {\n        if i.is_ascii_alphabetic() {\n            first_bool_after = true;\n\
    \        }\n    }\n    for i in last_after.to_string().chars() {\n        if i.is_ascii_alphabetic()\
    \ {\n            second_bool_after = true;\n        }\n    }\n    if first_bool\
    \ && second_bool {\n        third_bool = true;\n    }\n    if first_bool_after\
    \ && second_bool_after", "    let mut count = 0;\n    for c in file_name.chars()\
    \ {\n        if c.is_digit(10) {\n            count += 1;\n        }\n    }\n\
    \    if count > 3 {\n        return String::from(\"No\");\n    }\n    if !file_name.contains('.')\
    \ {\n        return String::from(\"No\");\n    }\n    let mut split = file_name.split('.');\n\
    \    let before = split.next().unwrap();\n    let after = split.next().unwrap();\n\
    \    if before.is_empty() || !before.chars().next().unwrap().is_alphabetic() {\n\
    \        return String::from(\"No\");\n    }\n    if after != \"txt\" && after\
    \ != \"exe\" && after != \"dll\" {\n        return String::from(\"No\");\n   \
    \ }\n    return String::from(\"Yes\");", "    if file_name.chars().filter(|x|\
    \ x.is_numeric()).count() > 3 {\n        return \"No\".to_string();\n    }\n \
    \   let v: Vec<_> = file_name.split('.').collect();\n    if v.len() != 2 {\n \
    \       return \"No\".to_string();\n    }\n    if v[0].is_empty() || !v[0].chars().next().unwrap().is_alphabetic()\
    \ {\n        return \"No\".to_string();\n    }\n    if !vec![\"txt\", \"exe\"\
    , \"dll\"].contains(&v[1]) {\n        return \"No\".to_string();\n    }\n    \"\
    Yes\".to_string()", "    let reg = Regex::new(r\"(?i)([a-z]\\d{1,3})\\.(txt|exe|dll)\"\
    ).unwrap();\n    if reg.is_match(&file_name) {\n        \"Yes\".to_string()\n\
    \    } else {\n        \"No\".to_string()\n    }", "    let mut file_name_iter\
    \ = file_name.chars();\n    let mut sub_string_1 = String::new();\n    let mut\
    \ sub_string_2 = String::new();\n    let mut counter = 0;\n    while let Some(c)\
    \ = file_name_iter.next() {\n        if c == '.' {\n            counter += 1;\n\
    \            break;\n        }\n        else {\n            sub_string_1.push(c);\n\
    \        }\n    }\n    while let Some(c) = file_name_iter.next() {\n        sub_string_2.push(c);\n\
    \    }\n    if sub_string_1.chars().count() > 0 && sub_string_1.chars().next().unwrap().is_alphabetic()\
    \ \n        && sub_string_2.chars().count() > 0 && sub_string_2.chars().next().unwrap().is_alphabetic()\
    \ \n        && sub_string_1.chars().filter(|&c| c.is_digit(10)).count() <= 3\n\
    \        && counter == 1 {\n        return String::from(\"Yes\");\n    }\n   \
    \ return String::from(\"No\");", "    let file_name = file_name.to_string();\n\
    \    if file_name.len() == 0 {\n        return \"No\".to_string();\n    }\n  \
    \  if file_name.find(\"..\").is_some() {\n        return \"No\".to_string();\n\
    \    }\n    let mut last_digit_count = 0;\n    let mut dot_count = 0;\n    let\
    \ mut is_first_letter = true;\n    let mut is_second_letter = false;\n    let\
    \ mut is_third_letter = false;\n    let mut is_fourth_letter = false;\n    let\
    \ mut is_fifth_letter = false;\n    let mut prefix = String::new();\n    let mut\
    \ suffix = String::new();\n    for c in file_name.chars() {\n        if c == '.'\
    \ {\n            dot_count += 1;\n            continue;\n        }\n        if\
    \ c.is_digit(10) {\n            last_digit_count += 1;\n            if last_digit_count\
    \ > 3 {\n                return \"No\".to_string();\n            }\n         \
    \   continue;\n        }\n        if c.is_alphabetic() {\n            if is_first_letter\
    \ {\n                prefix.push(c);\n                is_first_letter = false;\n\
    \                is_second_letter = true;\n                continue;\n       \
    \     }\n            if is_second_letter {\n                prefix.push(c);\n\
    \                is_second_letter = false;\n                is_third_letter =\
    \ true;\n                continue;\n            }\n            if is_third_letter\
    \ {\n                prefix.push(c);\n                is_third_letter = false;\n\
    \                is_fourth_letter = true;\n                continue;\n       \
    \     }\n            if is_fourth_letter {\n                prefix.push(c);\n\
    \                is_fourth_letter = false;\n                is_fifth_letter =\
    \ true;\n                continue;\n            }\n            if is_fifth_letter\
    \ {\n                prefix.push(c);\n                is_fifth_letter = false;\n\
    \                continue;\n            }\n            suffix.push(c);\n     \
    \       continue;\n        }\n        return \"No\".to_string();\n    }\n    if",
  "    let mut digits_number = 0;\n    let mut dot_number = 0;\n    let mut dot_position\
    \ = 0;\n    let mut extention_is_correct = false;\n    for (index, letter) in\
    \ file_name.chars().enumerate() {\n        if letter >= '0' && letter <= '9' {\n\
    \            digits_number += 1;\n        }\n        if letter == '.' {\n    \
    \        dot_number += 1;\n            dot_position = index;\n        }\n    }\n\
    \    if digits_number <= 3 && dot_number == 1 {\n        if dot_position > 0 {\n\
    \            if &file_name[dot_position+1..] == \"txt\" || &file_name[dot_position+1..]\
    \ == \"exe\" || &file_name[dot_position+1..] == \"dll\" {\n                extention_is_correct\
    \ = true;\n            }\n        }\n    }\n    if digits_number <= 3 && dot_number\
    \ == 1 && extention_is_correct == true {\n        String::from(\"Yes\")\n    }\
    \ else {\n        String::from(\"No\")\n    }", "    let mut digits_count = 0;\n\
    \    let mut dot_index = 0;\n    let mut dot_index_found = false;\n    let mut\
    \ valid_before_dot = false;\n    let mut valid_after_dot = false;\n    for (i,\
    \ c) in file_name.chars().enumerate() {\n        if c.is_digit(10) {\n       \
    \     digits_count += 1;\n        }\n        if !dot_index_found && c == '.' {\n\
    \            dot_index = i;\n            dot_index_found = true;\n        }\n\
    \    }\n    if digits_count > 3 {\n        return \"No\".to_string();\n    }\n\
    \    let before_dot = &file_name[..dot_index];\n    if before_dot.len() == 0 {\n\
    \        return \"No\".to_string();\n    }\n    let after_dot = &file_name[dot_index+1..];\n\
    \    if after_dot.len() == 0 {\n        return \"No\".to_string();\n    }\n  \
    \  if before_dot.chars().nth(0).unwrap().is_alphabetic() {\n        valid_before_dot\
    \ = true;\n    }\n    if after_dot == \"txt\" || after_dot == \"exe\" || after_dot\
    \ == \"dll\" {\n        valid_after_dot = true;\n    }\n    if valid_before_dot\
    \ && valid_after_dot {\n        return \"Yes\".to_string();\n    }\n    return\
    \ \"No\".to_string();", "    let mut digits = 0;\n    let mut counter = 0;\n \
    \   let mut index = 0;\n    let mut extension_valid = false;\n    let mut prefix_valid\
    \ = false;\n    for c in file_name.chars() {\n        if !c.is_ascii_alphabetic()\
    \ && !c.is_ascii_digit() && c != '.' {\n            return \"No\".to_string();\n\
    \        }\n        if c.is_ascii_digit() {\n            digits += 1;\n      \
    \  }\n        if c == '.' {\n            counter += 1;\n            index = counter;\n\
    \        }\n    }\n    if digits > 3 || counter != 1 {\n        return \"No\"\
    .to_string();\n    }\n    if index == 1 {\n        if file_name.chars().nth(0).unwrap().is_ascii_alphabetic()\
    \ {\n            prefix_valid = true;\n        }\n    } else {\n        if file_name.chars().nth(0).unwrap().is_ascii_alphabetic()\
    \ {\n            if file_name.chars().nth(index-2).unwrap().is_ascii_alphabetic()\
    \ {\n                prefix_valid = true;\n            }\n        }\n    }\n \
    \   if !prefix_valid {\n        return \"No\".to_string();\n    }\n    let mut\
    \ ext_index = 0;\n    for c in file_name.chars().rev() {\n        if c == '.'\
    \ {\n            break;\n        }\n        ext_index += 1;\n    }\n    let ext\
    \ = &file_name[file_name.len()-ext_index..];\n    if ext == \"exe\" || ext ==\
    \ \"txt\" || ext == \"dll\" {\n        extension_valid = true;\n    }\n    if\
    \ extension_valid {\n        return \"Yes\".to_string();\n    }\n    return \"\
    No\".to_string();", "    let valid_extensions = [\"txt\", \"exe\", \"dll\"];\n\
    \    if let Some(dot_position) = file_name.find('.') {\n        let is_valid_extension\
    \ = valid_extensions.contains(&file_name[dot_position+1..].as_str());\n      \
    \  let is_valid_name = (file_name[..dot_position].len() > 0) && \n           \
    \                 file_name[..dot_position].chars().all(|x| x.is_alphabetic());\n\
    \        let is_valid_size = file_name.chars().filter(|x| x.is_digit(10)).count()\
    \ <= 3;\n        if is_valid_name && is_valid_extension && is_valid_size {\n \
    \           return \"Yes\".to_string();\n        }\n    }\n    \"No\".to_string()",
  "    let num_digits = file_name.chars().filter(|c| c.is_digit(10)).count();\n  \
    \  let num_dots = file_name.chars().filter(|c| *c == '.').count();\n    let parts:\
    \ Vec<&str> = file_name.split('.').collect();\n    if num_digits > 3 || num_dots\
    \ != 1 || parts[0].is_empty() || !parts[0].chars().all(|c| c.is_alphabetic())\
    \ {\n        return \"No\".to_string();\n    }\n    match parts[1] {\n       \
    \ \"txt\" | \"exe\" | \"dll\" => \"Yes\".to_string(),\n        _ => \"No\".to_string(),\n\
    \    }", "    let mut counter = 0;\n    let mut index_of_dot = 0;\n    let mut\
    \ length_after_dot = 0;\n    let mut length_before_dot = 0;\n    let mut is_dot_found\
    \ = false;\n    let mut index = 0;\n    for i in file_name.chars() {\n       \
    \ if i == '.' {\n            is_dot_found = true;\n            index_of_dot =\
    \ index;\n        }\n        index += 1;\n    }\n    let is_digit = file_name.chars().any(|c|\
    \ c.is_digit(10));\n    if is_digit == true {\n        for i in file_name.chars()\
    \ {\n            if i.is_digit(10) {\n                counter += 1;\n        \
    \    }\n        }\n    }\n    if counter > 3 {\n        return String::from(\"\
    No\");\n    } else if is_dot_found == false {\n        return String::from(\"\
    No\");\n    } else {\n        let mut first_chars = Vec::new();\n        let mut\
    \ second_chars = Vec::new();\n        let mut third_chars = Vec::new();\n    \
    \    let mut fourth_chars = Vec::new();\n        let mut fifth_chars = Vec::new();\n\
    \        let mut sixth_chars = Vec::new();\n        let mut index = 0;\n     \
    \   for i in file_name.chars() {\n            if index == index_of_dot - 1 {\n\
    \                first_chars.push(i);\n            } else if index == index_of_dot\
    \ - 2 {\n                second_chars.push(i);\n            } else if index ==\
    \ index_of_dot - 3 {\n                third_chars.push(i);\n            } else\
    \ if index == index_of_dot + 1 {\n                fourth_chars.push(i);\n    \
    \        } else if index == index_of_dot + 2 {\n                fifth_chars.push(i);\n\
    \            } else if index == index_of_dot + 3 {\n                sixth_chars.push(i);\n\
    \            }\n            index += 1;\n        }\n        let is_first_char_valid\
    \ =", "    if !file_name.chars().all(char::is_alphanumeric) {\n        return\
    \ \"No\".to_string();\n    }\n    let mut file_name_vec: Vec<&str> = file_name.split('.').collect();\n\
    \    if file_name_vec.len() != 2 {\n        return \"No\".to_string();\n    }\n\
    \    if file_name_vec[0].len() == 0 {\n        return \"No\".to_string();\n  \
    \  }\n    let first_char = file_name_vec[0].chars().next().unwrap();\n    if !first_char.is_alphabetic()\
    \ {\n        return \"No\".to_string();\n    }\n    if file_name_vec[1] != \"\
    txt\" && file_name_vec[1] != \"exe\" && file_name_vec[1] != \"dll\" {\n      \
    \  return \"No\".to_string();\n    }\n    if file_name_vec[0].chars().filter(|c|\
    \ c.is_digit(10)).count() > 3 {\n        return \"No\".to_string();\n    }\n \
    \   \"Yes\".to_string()", '    unimplemented!()', "    let mut valid_name = false;\n\
    \    let mut valid_extension = false;\n    let mut counter = 0;\n    for x in\
    \ file_name.chars() {\n        if x.is_digit(10) {\n            counter += 1;\n\
    \        }\n    }\n    if counter <= 3 {\n        valid_name = true;\n    }\n\
    \    let mut name_extension = file_name.split('.').collect::<Vec<&str>>();\n \
    \   if name_extension.len() == 2 {\n        if name_extension[0].is_empty() ==\
    \ false && name_extension[0].chars().nth(0).unwrap().is_alphabetic() {\n     \
    \       valid_name = true;\n        }\n        if name_extension[1] == \"txt\"\
    \ || name_extension[1] == \"exe\" || name_extension[1] == \"dll\" {\n        \
    \    valid_extension = true;\n        }\n    }\n    if valid_name && valid_extension\
    \ {\n        return \"Yes\".to_string();\n    }\n    return \"No\".to_string();",
  "    let mut digits = 0;\n    let mut dot = false;\n    let mut dot_pos = 0;\n \
    \   let mut file_name_bytes = file_name.as_bytes();\n    for i in 0..file_name_bytes.len()\
    \ {\n        if file_name_bytes[i] >= 48 && file_name_bytes[i] <= 57 {\n     \
    \       digits += 1;\n        }\n        if file_name_bytes[i] == 46 {\n     \
    \       dot = true;\n            dot_pos = i;\n        }\n    }\n    if digits\
    \ > 3 || !dot {\n        return String::from(\"No\");\n    }\n    if dot_pos ==\
    \ 0 || !((file_name_bytes[0] >= 65 && file_name_bytes[0] <= 90)\n        || (file_name_bytes[0]\
    \ >= 97 && file_name_bytes[0] <= 122)) {\n        return String::from(\"No\");\n\
    \    }\n    if dot_pos == file_name_bytes.len() - 1 {\n        return String::from(\"\
    No\");\n    }\n    let suffix = &file_name[dot_pos + 1..];\n    if suffix != \"\
    txt\" && suffix != \"exe\" && suffix != \"dll\" {\n        return String::from(\"\
    No\");\n    }\n    return String::from(\"Yes\");", "    let mut digits_count =\
    \ 0;\n    let mut dot_count = 0;\n    let mut substring_1 = \"\".to_string();\n\
    \    let mut substring_2 = \"\".to_string();\n    let mut correct_substring_2\
    \ = false;\n    let mut correct_substring_1 = false;\n    let mut c = file_name.chars();\n\
    \    let f = c.next();\n    for i in f {\n        if i == '.' {\n            dot_count\
    \ += 1;\n        }\n        if i.is_digit(10) {\n            digits_count += 1;\n\
    \        }\n        if i.is_alphabetic() && dot_count == 0 {\n            substring_1.push(i);\n\
    \        }\n        if i.is_alphabetic() && dot_count == 1 {\n            substring_2.push(i);\n\
    \        }\n    }\n    if digits_count > 3 {\n        return \"No\".to_string();\n\
    \    }\n    if dot_count != 1 {\n        return \"No\".to_string();\n    }\n \
    \   if substring_1.len() == 0 {\n        return \"No\".to_string();\n    }\n \
    \   if substring_1.chars().next().unwrap().is_alphabetic() {\n        correct_substring_1\
    \ = true;\n    }\n    if substring_2 == \"txt\" || substring_2 == \"exe\" || substring_2\
    \ == \"dll\" {\n        correct_substring_2 = true;\n    }\n    if correct_substring_1\
    \ && correct_substring_2 {\n        return \"Yes\".to_string();\n    }\n    \"\
    No\".to_string()", "    let mut is_good = true;\n    let mut digits = 0;\n   \
    \ let mut letters = 0;\n    let mut dots = 0;\n    let mut dot_pos = 0;\n    let\
    \ mut string_after_dot = String::new();\n    let mut string_before_dot = String::new();\n\
    \    for (i, c) in file_name.chars().enumerate() {\n        if c.is_ascii_digit()\
    \ {\n            digits += 1;\n        } else if c.is_ascii_alphabetic() {\n \
    \           letters += 1;\n        } else if c == '.' {\n            dots += 1;\n\
    \            dot_pos = i;\n        }\n    }\n    if digits > 3 || dots != 1 ||\
    \ letters < 1 {\n        is_good = false;\n    } else {\n        string_after_dot\
    \ = file_name[dot_pos + 1..].to_string();\n        string_before_dot = file_name[..dot_pos].to_string();\n\
    \        let mut good_extensions = vec![\"txt\", \"exe\", \"dll\"];\n        let\
    \ ext_index = good_extensions.iter().position(|x| x == &string_after_dot);\n \
    \       if ext_index == None {\n            is_good = false;\n        }\n    \
    \    for c in string_before_dot.chars() {\n            if !c.is_ascii_alphabetic()\
    \ {\n                is_good = false;\n            }\n        }\n    }\n    if\
    \ is_good {\n        return \"Yes\".to_string();\n    } else {\n        return\
    \ \"No\".to_string();\n    }", "    let digits = file_name.chars().filter(|x|\
    \ x.is_digit(10)).count();\n    let mut parts = file_name.split('.');\n    let\
    \ first = parts.next().unwrap();\n    let second = parts.next().unwrap();\n  \
    \  if digits > 3 || first.is_empty() || first.chars().next().unwrap().is_alphabetic()\
    \ != true ||\n        second != \"txt\" && second != \"exe\" && second != \"dll\"\
    \ {\n        return \"No\".to_string();\n    }\n    \"Yes\".to_string()", "  \
    \  let (start, end) = file_name.split_at(file_name.find('.').unwrap());\n    let\
    \ (ext, _) = end.split_at(end.find('.').unwrap() + 1);\n    // Count digits in\
    \ file name\n    let count_digits = start.chars().filter(|c| c.is_numeric()).count();\n\
    \    if count_digits > 3 {\n        return String::from(\"No\");\n    }\n    //\
    \ Check if file name is valid\n    if !(start.chars().next().unwrap().is_alphabetic()\
    \ && \n    (ext == \"txt\" || ext == \"exe\" || ext == \"dll\")) {\n        return\
    \ String::from(\"No\");\n    }\n    return String::from(\"Yes\");", "    use regex::Regex;\n\
    \    lazy_static! {\n        static ref RE: Regex = Regex::new(r\"^[a-zA-Z]{1}[a-zA-Z0-9]{0,9}\\\
    .(txt|exe|dll)$\").unwrap();\n    }\n    let is_valid = RE.is_match(&file_name);\n\
    \    if is_valid {\n        String::from(\"Yes\")\n    } else {\n        String::from(\"\
    No\")\n    }", "    let mut valid = true;\n    let mut count = 0;\n    let mut\
    \ dot_position = 0;\n    let mut valid_exentsion = false;\n    for (i, c) in file_name.chars().enumerate()\
    \ {\n        if valid {\n            match c {\n                '0'..='9' => {\n\
    \                    count += 1;\n                    if count > 3 {\n       \
    \                 valid = false;\n                    }\n                },\n\
    \                '.' => {\n                    if i == 0 || dot_position != 0\
    \ {\n                        valid = false;\n                    } else {\n  \
    \                      dot_position = i;\n                    }\n            \
    \    },\n                'a'..='z' | 'A'..='Z' => {\n                    if i\
    \ > 0 && dot_position == 0 {\n                        valid = false;\n       \
    \             }\n                },\n                _ => valid = false,\n   \
    \         }\n        }\n    }\n    if valid {\n        match &file_name[dot_position\
    \ + 1..] {\n            \"txt\" | \"exe\" | \"dll\" => valid_exentsion = true,\n\
    \            _ => valid_exentsion = false,\n        }\n    }\n    if valid &&\
    \ valid_exentsion {\n        \"Yes\".to_string()\n    } else {\n        \"No\"\
    .to_string()\n    }", "    let pattern = Regex::new(r\"(?i)^[a-z][0-9]{0,3}(\\\
    .[a-z]{2,3})$\").unwrap();\n    if pattern.is_match(&file_name) {\n        \"\
    Yes\".to_string()\n    } else {\n        \"No\".to_string()\n    }", "    // TODO:\
    \ implement this function\n    String::from(\"No\")", "    let mut count = 0;\n\
    \    let dot_idx = file_name.find('.').unwrap();\n    for c in file_name.chars()\
    \ {\n        if c.is_ascii_digit() {\n            count += 1;\n        }\n   \
    \ }\n    if count <= 3 {\n        if file_name.len() - 1 == dot_idx {\n      \
    \      if dot_idx >= 1 {\n                let prefix = &file_name[..dot_idx];\n\
    \                if prefix.starts_with(char::is_alphabetic) {\n              \
    \      let suffix = &file_name[dot_idx + 1..];\n                    if suffix\
    \ == \"txt\" || suffix == \"exe\" || suffix == \"dll\" {\n                   \
    \     return \"Yes\".to_string();\n                    }\n                }\n\
    \            }\n        }\n    }\n    \"No\".to_string()", "    let re = Regex::new(r\"\
    (^[a-zA-Z]{1}[a-zA-Z0-9_]{0,63}\\.(txt|exe|dll)$)\").unwrap();\n    if re.is_match(&file_name)\
    \ {\n        return String::from(\"Yes\");\n    }\n    return String::from(\"\
    No\");", "  let mut digit_count = 0;\n  let mut dot_count = 0;\n  let mut dot_position\
    \ = 0;\n  let mut suffix_count = 0;\n  let mut is_valid = true;\n  let filename_chars:\
    \ Vec<char> = file_name.chars().collect();\n  for i in 0..filename_chars.len()\
    \ {\n    if is_valid == false {\n      break;\n    }\n    match filename_chars[i]\
    \ {\n      '0'...'9' => {\n        digit_count += 1;\n        if digit_count >\
    \ 3 {\n          is_valid = false;\n        }\n      },\n      '.' => {\n    \
    \    dot_count += 1;\n        dot_position = i;\n        if dot_count > 1 {\n\
    \          is_valid = false;\n        }\n      },\n      _ => {\n        if dot_count\
    \ == 0 {\n          if !(filename_chars[i] >= 'a' && filename_chars[i] <= 'z')\
    \ && !(filename_chars[i] >= 'A' && filename_chars[i] <= 'Z') {\n            is_valid\
    \ = false;\n          }\n        } else {\n          let suffix: String = file_name.chars().skip(dot_position\
    \ + 1).collect();\n          match suffix.as_ref() {\n            \"txt\" | \"\
    exe\" | \"dll\" => {\n              suffix_count += 1;\n            },\n     \
    \       _ => {\n              is_valid = false;\n            }\n          }\n\
    \        }\n      }\n    }\n  }\n  if digit_count > 3 || dot_count == 0 || suffix_count\
    \ == 0 {\n    return \"No\".to_string();\n  }\n  return \"Yes\".to_string();",
  "    let mut latin_letters = 0;\n    let mut digits = 0;\n    let mut dots = 0;\n\
    \    let mut found_dot = false;\n    let mut after_dot = false;\n    let mut letters_count\
    \ = 0;\n    let mut letters_after_dot = 0;\n    let mut valid_ending = false;\n\
    \    let mut substr = String::new();\n    let mut substr_after_dot = String::new();\n\
    \    let mut i = 0;\n    for c in file_name.chars() {\n        if c == '.' {\n\
    \            dots += 1;\n            found_dot = true;\n            continue;\n\
    \        }\n        if c.is_digit(10) {\n            digits += 1;\n          \
    \  continue;\n        }\n        if found_dot {\n            after_dot = true;\n\
    \            letters_after_dot += 1;\n            if letters_after_dot <= 3 {\n\
    \                substr_after_dot.push(c);\n            }\n        } else {\n\
    \            latin_letters += 1;\n            if c.is_alphabetic() {\n       \
    \         letters_count += 1;\n                if i == 0 {\n                 \
    \   substr.push(c);\n                }\n            }\n        }\n        i +=\
    \ 1;\n    }\n    if let Ok(_) = substr_after_dot.parse::<f64>() {\n        valid_ending\
    \ = false;\n    } else {\n        valid_ending = match substr_after_dot.as_str()\
    \ {\n            \"txt\" => true,\n            \"exe\" => true,\n            \"\
    dll\" => true,\n            _ => false,\n        };\n    }\n    // println!(\"\
    {}\", substr_after_dot);\n    if latin_letters == digits &&\n        dots == 1\
    \ &&\n        letters_count > 0 &&\n        digits <= 3 &&\n        after_dot\
    \ &&\n        valid_ending {\n        \"Yes\".to_string()\n    } else {\n    \
    \    \"No\".to_string()\n    }", "    // let mut is_valid = true;\n    // for\
    \ c in file_name.chars() {\n    //     if c.is_numeric() {\n    //         is_valid\
    \ = false;\n    //     }\n    // }\n    // if is_valid {\n    //     return \"\
    Yes\".to_string();\n    // } else {\n    //     return \"No\".to_string();\n \
    \   // }\n    let v: Vec<&str> = file_name.split('.').collect();\n    if v.len()\
    \ != 2 {\n        return \"No\".to_string();\n    }\n    let sub_vec: Vec<char>\
    \ = v[0].chars().collect();\n    if sub_vec.len() == 0 {\n        return \"No\"\
    .to_string();\n    }\n    if sub_vec[0].is_numeric() {\n        return \"No\"\
    .to_string();\n    }\n    let mut count_digit = 0;\n    for c in sub_vec {\n \
    \       if c.is_numeric() {\n            count_digit += 1;\n        }\n    }\n\
    \    if count_digit > 3 {\n        return \"No\".to_string();\n    }\n    if v[1]\
    \ != \"txt\" && v[1] != \"exe\" && v[1] != \"dll\" {\n        return \"No\".to_string();\n\
    \    }\n    return \"Yes\".to_string();", "    let s = file_name.chars().fold(\
    \ (0, 0, 0, false), |acc, x| {\n        if x.is_ascii_digit() {\n            (acc.0\
    \ + 1, acc.1, acc.2, acc.3)\n        } else if x == '.' {\n            (acc.0,\
    \ acc.1 + 1, acc.2, acc.3)\n        } else if x.is_ascii_alphabetic() {\n    \
    \        (acc.0, acc.1, acc.2 + 1, true)\n        } else {\n            acc\n\
    \        }\n    });\n    let (digit_count, dot_count, alpha_count, valid_start)\
    \ = s;\n    if digit_count > 3 || dot_count != 1 || alpha_count < 1 || !valid_start\
    \ {\n        return \"No\".to_string();\n    }\n    let dot_index = file_name.find('.').unwrap();\n\
    \    let extension = &file_name[dot_index+1..];\n    if extension == \"txt\" ||\
    \ extension == \"exe\" || extension == \"dll\" {\n        \"Yes\".to_string()\n\
    \    } else {\n        \"No\".to_string()\n    }", "    let invalid_chars = \"\
    0123456789\".to_string();\n    let valid_suffixes = vec![\"txt\", \"exe\", \"\
    dll\"];\n    let mut split = file_name.split(\".\");\n    let prefix = split.next().unwrap();\n\
    \    let mut suffix = split.next().unwrap_or(\"\");\n    let mut counter = 0;\n\
    \    for ch in prefix.chars() {\n        if invalid_chars.contains(ch) {\n   \
    \         counter += 1;\n        }\n    }\n    if counter > 3 {\n        return\
    \ \"No\".to_string();\n    }\n    let mut first_letter = true;\n    for ch in\
    \ prefix.chars() {\n        if !(ch >= 'a' && ch <= 'z' || ch >= 'A' && ch <=\
    \ 'Z') {\n            first_letter = false;\n            break;\n        }\n \
    \   }\n    if first_letter == false {\n        return \"No\".to_string();\n  \
    \  }\n    if prefix.len() < 1 {\n        return \"No\".to_string();\n    }\n \
    \   if suffix == \"\" {\n        return \"No\".to_string();\n    }\n    if !valid_suffixes.contains(&suffix)\
    \ {\n        return \"No\".to_string();\n    }\n    \"Yes\".to_string()", "  \
    \  let digits_regex = Regex::new(r\"[0-9]{4,}\").unwrap();\n    let dot_regex\
    \ = Regex::new(r\"^[a-zA-Z][a-zA-Z\\d]*$\").unwrap();\n    let file_type_regex\
    \ = Regex::new(r\"\\.(txt|exe|dll)$\").unwrap();\n\n    if digits_regex.is_match(&file_name)\
    \ || file_name.contains(\"..\") ||\n        file_name.chars().filter(|c| *c ==\
    \ '.').count() != 1 || \n        !dot_regex.is_match(&file_name) || !file_type_regex.is_match(&file_name)\
    \ {\n            return \"No\".to_string();\n    }\n    \"Yes\".to_string()",
  "    let mut has_dot = false;\n    let mut digits = 0;\n    let mut is_valid = true;\n\
    \    let mut first_char_valid = false;\n    let mut extension_valid = false;\n\
    \    let mut index_dot = 0;\n    let mut index_extension = 0;\n    for (i, c)\
    \ in file_name.chars().enumerate() {\n        if c.is_ascii_digit() {\n      \
    \      digits += 1;\n        } else if c == '.' {\n            has_dot = true;\n\
    \            index_dot = i;\n        } else if c.is_ascii_alphabetic() {\n   \
    \         first_char_valid = true;\n        }\n        if digits > 3 {\n     \
    \       is_valid = false;\n            break;\n        }\n    }\n    if has_dot\
    \ {\n        index_extension = index_dot + 1;\n        let extension = &file_name[index_extension..];\n\
    \        match extension {\n            \"txt\" | \"exe\" | \"dll\" => extension_valid\
    \ = true,\n            _ => extension_valid = false,\n        }\n    }\n    if\
    \ has_dot && first_char_valid && extension_valid {\n        \"Yes\".to_string()\n\
    \    } else {\n        \"No\".to_string()\n    }", "    let mut n = 0;\n    let\
    \ mut chars = file_name.chars();\n    if let Some(c) = chars.next() {\n      \
    \  if !c.is_ascii_alphabetic() {\n            return \"No\".to_string();\n   \
    \     }\n    } else {\n        return \"No\".to_string();\n    }\n    for c in\
    \ chars {\n        if c == '.' {\n            break;\n        }\n        if c.is_ascii_digit()\
    \ {\n            n += 1;\n            if n > 3 {\n                return \"No\"\
    .to_string();\n            }\n        }\n    }\n    let mut ext = String::new();\n\
    \    let mut dot_found = false;\n    for c in chars {\n        if c == '.' {\n\
    \            dot_found = true;\n        } else {\n            ext.push(c);\n \
    \       }\n    }\n    if !dot_found || ext.len() == 0 {\n        return \"No\"\
    .to_string();\n    }\n    match ext.as_str() {\n        \"txt\" | \"exe\" | \"\
    dll\" => \"Yes\".to_string(),\n        _ => \"No\".to_string(),\n    }", "   \
    \ let mut dot_count = 0;\n    let mut num_count = 0;\n    let mut dot_found =\
    \ false;\n    let mut last_dot_index = 0;\n    let mut first_letter_found = false;\n\
    \    let mut first_letter_index = 0;\n    let mut first_letter = ' ';\n    let\
    \ mut last_letter_index = 0;\n    let mut last_letter = ' ';\n    let mut string_end\
    \ = false;\n    let mut slice = file_name.clone();\n    let mut file_type = \"\
    \ \".to_string();\n    for (i, c) in file_name.char_indices() {\n        match\
    \ c {\n            '.' => {\n                dot_count += 1;\n               \
    \ dot_found = true;\n                last_dot_index = i;\n            }\n    \
    \        _ => {\n                if first_letter_found == false {\n          \
    \          first_letter_found = true;\n                    first_letter_index\
    \ = i;\n                    first_letter = c;\n                }\n           \
    \     if i == file_name.len() - 1 {\n                    last_letter_index = i;\n\
    \                    last_letter = c;\n                    string_end = true;\n\
    \                }\n                if dot_found == true && string_end == false\
    \ {\n                    slice = slice[last_dot_index + 1..];\n              \
    \      file_type = slice.to_string();\n                }\n            }\n    \
    \    }\n    }\n    if dot_count > 1 || first_letter_found == false || last_letter_index\
    \ - first_letter_index > 3\n        || file_type != \"txt\" && file_type != \"\
    exe\" && file_type != \"dll\"\n    {\n        \"No\".to_string()\n    } else {\n\
    \        \"Yes\".to_string()\n    }", "    let split = file_name.split('.').collect::<Vec<&str>>();\n\
    \    if split.len() != 2 {\n        return \"No\".to_string();\n    }\n\n    let\
    \ (before, after) = (split[0], split[1]);\n    if !(before.chars().next().unwrap().is_alphabetic()\
    \ && \n         before.chars().all(|c| c.is_alphanumeric())) {\n        return\
    \ \"No\".to_string();\n    }\n\n    if ![\"txt\", \"exe\", \"dll\"].contains(&after)\
    \ {\n        return \"No\".to_string();\n    }\n\n    let count = before.chars().filter(|c|\
    \ c.is_digit(10)).count();\n    if count > 3 {\n        return \"No\".to_string();\n\
    \    }\n\n    \"Yes\".to_string()", "    let file_name = file_name.as_str();\n\
    \    let re = Regex::new(r\"(?i)(?-u)^[a-z]{1}[^0-9\\.]*\\.(txt|exe|dll)$\").unwrap();\n\
    \    if re.is_match(file_name) {\n        return String::from(\"Yes\");\n    }\
    \ else {\n        return String::from(\"No\");\n    }", "    if file_name.starts_with(|c:\
    \ char| c.is_ascii_alphabetic()) {\n        let dot_idx = file_name.find('.').unwrap();\n\
    \        let dot_str = &file_name[dot_idx..];\n        if dot_str == \".txt\"\
    \ || dot_str == \".exe\" || dot_str == \".dll\" {\n            let pre_dot_str\
    \ = &file_name[..dot_idx];\n            if pre_dot_str.chars().any(|c| c.is_digit(10))\
    \ {\n                return \"No\".to_string();\n            } else {\n      \
    \          return \"Yes\".to_string();\n            }\n        }\n    }\n    \"\
    No\".to_string()", "    lazy_static! {\n        static ref FILE_NAME_RE: Regex\
    \ =\n            Regex::new(r\"(?ix)\n                ^                   # beginning\
    \ of string\n                [a-zA-Z]            # leading latin character\n \
    \               [\\w]{0,30}          # 30 random alphanumeric characters\n   \
    \             \\.                  # a dot\n                (?:txt|exe|dll)  \
    \   # file extension\n                $                   # end of string\n  \
    \          \").unwrap();\n    }\n\n    if FILE_NAME_RE.is_match(&file_name) {\n\
    \        \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n    }",
  "    let re = Regex::new(r\"^[a-zA-Z]\\w{1,22}\\.\\w{3}$\").unwrap();\n    let count\
    \ = file_name.matches(char::is_numeric).count();\n    if count > 3 {\n       \
    \ return String::from(\"No\");\n    }\n\n    if re.is_match(&file_name) {\n  \
    \      return String::from(\"Yes\");\n    }\n    String::from(\"No\")", "    let\
    \ mut num_digits = 0;\n    let mut dot_found = false;\n    let mut first_char_found\
    \ = false;\n    let mut second_part_found = false;\n    let second_parts = vec![\"\
    txt\", \"exe\", \"dll\"];\n    for c in file_name.chars() {\n        if c.is_digit(10)\
    \ {\n            num_digits += 1;\n        } else if c == '.' {\n            dot_found\
    \ = true;\n        } else if c.is_alphabetic() {\n            first_char_found\
    \ = true;\n        } else if !first_char_found {\n            return \"No\".to_string();\n\
    \        }\n        if num_digits > 3 {\n            return \"No\".to_string();\n\
    \        }\n        if c == '.' && first_char_found {\n            second_part_found\
    \ = true;\n        }\n        if second_part_found && !second_parts.contains(&c.to_string().as_str())\
    \ {\n            return \"No\".to_string();\n        }\n    }\n    if !dot_found\
    \ || !first_char_found || !second_part_found {\n        return \"No\".to_string();\n\
    \    }\n    \"Yes\".to_string()", "    let r1 = Regex::new(r\"^[a-zA-Z]+\\d*\\\
    .\\w+$\").unwrap();\n    if r1.is_match(&file_name) {\n        let r2 = Regex::new(r\"\
    \\d\").unwrap();\n        let count = r2.find_iter(&file_name).count();\n    \
    \    if count <= 3 {\n            let parts: Vec<&str> = file_name.split('.').collect();\n\
    \            if parts.len() == 2 {\n                let r3 = Regex::new(r\"txt|exe|dll\"\
    ).unwrap();\n                if r3.is_match(parts[1]) {\n                    return\
    \ \"Yes\".to_string();\n                }\n            }\n        }\n    }\n \
    \   \"No\".to_string()", "    let mut dots = 0;\n    let mut digits = 0;\n   \
    \ let mut latin = false;\n    let mut exe = false;\n    let mut exe_allowed =\
    \ false;\n    let mut dll = false;\n    let mut dll_allowed = false;\n    let\
    \ mut txt = false;\n    let mut txt_allowed = false;\n    for ch in file_name.chars()\
    \ {\n        if ch == '.' {\n            dots += 1;\n            exe_allowed =\
    \ true;\n            dll_allowed = true;\n            txt_allowed = true;\n  \
    \      } else if ch.is_digit(10) {\n            digits += 1;\n        } else if\
    \ ch.is_alphabetic() {\n            latin = true;\n        } else if (ch == 'e'\
    \ || ch == 'E') && exe_allowed {\n            exe = true;\n            exe_allowed\
    \ = false;\n        } else if (ch == 'd' || ch == 'D') && dll_allowed {\n    \
    \        dll = true;\n            dll_allowed = false;\n        } else if (ch\
    \ == 't' || ch == 'T') && txt_allowed {\n            txt = true;\n           \
    \ txt_allowed = false;\n        } else {\n            return \"No\".to_string();\n\
    \        }\n    }\n    if dots != 1 || digits > 3 || !latin || (exe == false &&\
    \ dll == false && txt == false) {\n        return \"No\".to_string();\n    }\n\
    \    \"Yes\".to_string()", "    if file_name.chars().filter(|&c| c.is_numeric()).count()\
    \ > 3 {\n        return \"No\".to_string();\n    }\n    let split: Vec<&str> =\
    \ file_name.split('.').collect();\n    if split.len() != 2 {\n        return \"\
    No\".to_string();\n    }\n    if split[0].is_empty() || !split[0].chars().next().unwrap().is_alphabetic()\
    \ {\n        return \"No\".to_string();\n    }\n    if split[1] != \"txt\" &&\
    \ split[1] != \"exe\" && split[1] != \"dll\" {\n        return \"No\".to_string();\n\
    \    }\n    \"Yes\".to_string()", "    if file_name.matches(char::is_numeric).count()\
    \ > 3 {\n        return \"No\".to_string();\n    }\n\n    let name: Vec<&str>\
    \ = file_name.split(\".\").collect();\n    if name.len() != 2 {\n        return\
    \ \"No\".to_string();\n    }\n\n    if !name[0].is_empty() && name[0].matches(char::is_alphabetic).next().is_some()\
    \ {\n        match name[1] {\n            \"txt\" | \"exe\" | \"dll\" => \"Yes\"\
    .to_string(),\n            _ => \"No\".to_string(),\n        }\n    } else {\n\
    \        \"No\".to_string()\n    }", "    if file_name.chars().filter(|c| *c ==\
    \ '.').count() != 1 {\n        return \"No\".to_string();\n    }\n    let mut\
    \ fname_ext: Vec<_> = file_name.split('.').collect();\n    let (fname, ext) =\
    \ (fname_ext.remove(0), fname_ext.remove(0));\n    if fname.len() == 0 {\n   \
    \     return \"No\".to_string();\n    }\n    if !(fname.chars().nth(0).unwrap().is_ascii_alphabetic())\
    \ {\n        return \"No\".to_string();\n    }\n    if fname.chars().filter(|c|\
    \ c.is_ascii_digit()).count() > 3 {\n        return \"No\".to_string();\n    }\n\
    \    if ext != \"txt\" && ext != \"exe\" && ext != \"dll\" {\n        return \"\
    No\".to_string();\n    }\n    \"Yes\".to_string()", "    let dot_index = file_name.find('.').expect(\"\
    No dot in the name!\");\n    let ext = file_name[dot_index+1..].to_lowercase();\n\
    \    if file_name.chars().filter(|c| c.is_digit(10)).count() > 3\n        || ext\
    \ != \"txt\" && ext != \"exe\" && ext != \"dll\"\n        || dot_index == 0\n\
    \        || file_name[..dot_index].chars().any(|c| !c.is_alphabetic()) {\n   \
    \     return \"No\".to_string();\n    }\n    \"Yes\".to_string()", "    let mut\
    \ file_chars = file_name.chars();\n    let mut digits = 0;\n    let mut has_dot\
    \ = false;\n    let mut has_letter = false;\n    let mut has_suffix = false;\n\
    \    let mut first_char = file_chars.next();\n    while let Some(c) = first_char\
    \ {\n        if c.is_alphabetic() {\n            has_letter = true;\n        }\
    \ else if c.is_digit(10) {\n            digits += 1;\n        } else if c == '.'\
    \ {\n            has_dot = true;\n        }\n        first_char = file_chars.next();\n\
    \    }\n    let file_suffix = &file_name[file_name.len() - 3..];\n    if file_suffix\
    \ == \"txt\" || file_suffix == \"exe\" || file_suffix == \"dll\" {\n        has_suffix\
    \ = true;\n    }\n    if has_dot && has_letter && has_suffix && digits <= 3 {\n\
    \        \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n    }",
  "    let mut counter = 0;\n    let mut flag = false;\n    let mut ext_flag = false;\n\
    \    let mut ext = String::new();\n    let mut name = String::new();\n    for\
    \ ch in file_name.chars() {\n        if ch == '.' {\n            flag = true;\n\
    \            continue;\n        }\n        if flag {\n            ext.push(ch);\n\
    \            ext_flag = true;\n        } else {\n            name.push(ch);\n\
    \        }\n        if !ext_flag {\n            if '0' <= ch && ch <= '9' {\n\
    \                counter += 1;\n            }\n        }\n    }\n    if counter\
    \ > 3 || !ext_flag || name.len() < 1 {\n        return String::from(\"No\");\n\
    \    }\n    if ext == \"txt\" || ext == \"exe\" || ext == \"dll\" {\n        return\
    \ String::from(\"Yes\");\n    }\n    return String::from(\"No\");", "    let mut\
    \ dot_counter = 0;\n    let mut number_counter = 0;\n    let mut alphapet_counter\
    \ = 0;\n    let mut delimiter_counter = 0;\n    let mut file_type = String::new();\n\
    \    for c in file_name.chars() {\n        if dot_counter == 0 && c == '.' {\n\
    \            dot_counter += 1;\n            continue;\n        } else if dot_counter\
    \ == 1 && c != '.' {\n            dot_counter += 1;\n            continue;\n \
    \       } else if dot_counter == 1 && c == '.' {\n            return \"No\".to_string();\n\
    \        }\n        if c == '.' {\n            delimiter_counter += 1;\n     \
    \       continue;\n        }\n        if c >= '0' && c <= '9' {\n            number_counter\
    \ += 1;\n            continue;\n        }\n        if c >= 'a' && c <= 'z' ||\
    \ c >= 'A' && c <= 'Z' {\n            alphapet_counter += 1;\n            continue;\n\
    \        }\n        if c == '.' && dot_counter == 2 {\n            if alphapet_counter\
    \ == 0 {\n                return \"No\".to_string();\n            }\n        \
    \    dot_counter += 1;\n            continue;\n        }\n        if delimiter_counter\
    \ == 1 {\n            file_type.push(c);\n        }\n    }\n    if delimiter_counter\
    \ != 1 || dot_counter != 3 || number_counter > 3 {\n        return \"No\".to_string();\n\
    \    }\n    match file_type.as_str() {\n        \"txt\" | \"exe\" | \"dll\" =>\
    \ \"Yes\".to_string(),\n        _ => \"No\".to_string(),\n    }", "    let parts:\
    \ Vec<&str> = file_name.split('.').collect();\n    let digits = file_name.chars().filter(|&c|\
    \ c.is_digit(10)).count();\n    let extension = parts.last().unwrap();\n    if\
    \ digits > 3 || parts.len() != 2 || parts[0].is_empty() || !parts[0].chars().next().unwrap().is_alphabetic()\
    \ || extension != \"txt\" && extension != \"exe\" && extension != \"dll\" {\n\
    \        \"No\".to_string()\n    } else {\n        \"Yes\".to_string()\n    }",
  "    // TODO your code here\n    unimplemented!()", "    let mut it = file_name.chars();\n\
    \    let mut digits = 0;\n    let mut has_dot = false;\n    let mut has_char =\
    \ false;\n    let mut has_ext = false;\n    let mut ext_is_valid = false;\n  \
    \  for x in it {\n        if x.is_ascii_digit() {\n            digits += 1;\n\
    \        } else if x == '.' {\n            has_dot = true;\n        } else if\
    \ x.is_ascii_alphabetic() {\n            has_char = true;\n        } else if x.is_ascii_alphanumeric()\
    \ {\n            let ext: String = it.collect();\n            match ext.as_str()\
    \ {\n                \"txt\" | \"exe\" | \"dll\" => ext_is_valid = true,\n   \
    \             _ => ext_is_valid = false,\n            }\n            has_ext =\
    \ true;\n            break;\n        }\n    }\n    match (digits <= 3, has_dot,\
    \ has_char, has_ext, ext_is_valid) {\n        (true, true, true, true, true) =>\
    \ \"Yes\".to_string(),\n        _ => \"No\".to_string(),\n    }", "    if file_name.chars().filter(|&x|\
    \ x.is_digit(10)).count() > 3 {\n        return \"No\".to_string();\n    }\n \
    \   let file_name_parts: Vec<&str> = file_name.split('.').collect();\n    if file_name_parts.len()\
    \ != 2 {\n        return \"No\".to_string();\n    }\n    if file_name_parts[0].is_empty()\
    \ || !file_name_parts[0].chars().nth(0).unwrap().is_alphabetic() {\n        return\
    \ \"No\".to_string();\n    }\n    match file_name_parts[1] {\n        \"txt\"\
    \ | \"exe\" | \"dll\" => \"Yes\".to_string(),\n        _ => \"No\".to_string(),\n\
    \    }", "    // Your code here.\n    unimplemented!();", "    if file_name.len()\
    \ > 4 && file_name.ends_with(\"txt\") || file_name.ends_with(\"exe\") || file_name.ends_with(\"\
    dll\") {\n        return String::from(\"Yes\");\n    }\n    String::from(\"No\"\
    )", "    // TODO\n    if file_name.is_empty() {\n        return \"No\".to_string();\n\
    \    }\n    let file_name_vec: Vec<&str> = file_name.split('.').collect();\n \
    \   if file_name_vec.len() != 2 {\n        return \"No\".to_string();\n    }\n\
    \    let reg = Regex::new(r\"[a-zA-Z]\\d{0,3}\").unwrap();\n    let first_str\
    \ = file_name_vec[0];\n    if reg.is_match(first_str) {\n        return \"No\"\
    .to_string();\n    }\n    let file_suffix = file_name_vec[1];\n    if file_suffix\
    \ == \"txt\" || file_suffix == \"exe\" || file_suffix == \"dll\" {\n        return\
    \ \"Yes\".to_string();\n    }\n    \"No\".to_string()", "    let mut is_valid\
    \ = true;\n    let mut digit_count = 0;\n    let mut dot_is_found = false;\n \
    \   let mut dot_index = 0;\n    let mut extension = \"\";\n    for (i, ch) in\
    \ file_name.chars().enumerate() {\n        if ch.is_digit(10) {\n            digit_count\
    \ += 1;\n            if digit_count > 3 {\n                is_valid = false;\n\
    \                break;\n            }\n        }\n        if ch == '.' {\n  \
    \          if dot_is_found {\n                is_valid = false;\n            \
    \    break;\n            }\n            dot_is_found = true;\n            dot_index\
    \ = i;\n        }\n    }\n    if !dot_is_found {\n        is_valid = false;\n\
    \    }\n    if is_valid {\n        let mut substring_before_dot = file_name[..dot_index].to_string();\n\
    \        if substring_before_dot.is_empty() {\n            is_valid = false;\n\
    \        } else {\n            substring_before_dot.remove(0);\n            if\
    \ substring_before_dot.is_empty() {\n                is_valid = false;\n     \
    \       } else {\n                for ch in substring_before_dot.chars() {\n \
    \                   if !ch.is_ascii_alphabetic() {\n                        is_valid\
    \ = false;\n                        break;\n                    }\n          \
    \      }\n            }\n        }\n    }\n    if is_valid {\n        extension\
    \ = &file_name[dot_index+1..];\n        match extension {\n            \"txt\"\
    \ | \"exe\" | \"dll\" => (),\n            _ => is_valid = false,\n        }\n\
    \    }\n    if is_valid {\n        return \"Yes\".to_string();\n    }\n    \"\
    No\".to_string()", "    let parts: Vec<&str> = file_name.split('.').collect();\n\
    \    if parts.len() != 2 {\n        return \"No\".to_string();\n    }\n    if\
    \ parts[0].len() == 0 {\n        return \"No\".to_string();\n    }\n    if parts[1]\
    \ != \"txt\" && parts[1] != \"exe\" && parts[1] != \"dll\" {\n        return \"\
    No\".to_string();\n    }\n    let count = parts[0].matches(char::is_numeric).count();\n\
    \    if count > 3 {\n        return \"No\".to_string();\n    }\n    let first_char\
    \ = parts[0].chars().next().unwrap();\n    if !first_char.is_alphabetic() {\n\
    \        return \"No\".to_string();\n    }\n    \"Yes\".to_string()", "    if\
    \ file_name.chars().filter(|&x| x.is_digit(10)).count() > 3 {\n        \"No\"\
    .to_string()\n    } else if file_name.chars().filter(|&x| x == '.').count() !=\
    \ 1 {\n        \"No\".to_string()\n    } else if file_name.chars().filter(|&x|\
    \ !x.is_digit(10) && x != '.').count() == 0 {\n        \"No\".to_string()\n  \
    \  } else if !(file_name.chars().next().unwrap().is_ascii_alphabetic() ||\n  \
    \      file_name.chars().next().unwrap().is_ascii_uppercase()) {\n        \"No\"\
    .to_string()\n    } else {\n        let file_ext = file_name.split('.').last().unwrap();\n\
    \        match file_ext {\n            \"txt\" | \"exe\" | \"dll\" => \"Yes\"\
    .to_string(),\n            _ => \"No\".to_string(),\n        }\n    }", "    let\
    \ mut dots = 0;\n    let mut digits = 0;\n    let mut is_valid = true;\n    let\
    \ mut is_empty = true;\n    let mut is_first_letter = false;\n    let mut first_part\
    \ = String::new();\n    let mut second_part = String::new();\n    let valid_extensions\
    \ = vec![\"txt\", \"exe\", \"dll\"];\n\n    for ch in file_name.chars() {\n  \
    \      if ch == '.' {\n            dots += 1;\n            is_empty = false;\n\
    \            is_first_letter = false;\n        }\n        else if ch.is_digit(10)\
    \ {\n            digits += 1;\n        }\n        else if ch.is_ascii_alphabetic()\
    \ {\n            if !is_first_letter {\n                is_first_letter = true;\n\
    \            }\n        }\n        else {\n            is_valid = false;\n   \
    \         break;\n        }\n        if is_first_letter {\n            first_part.push(ch);\n\
    \        }\n        else {\n            second_part.push(ch);\n        }\n   \
    \ }\n\n    if !is_empty && is_first_letter && dots == 1 && digits <= 3 && valid_extensions.contains(&second_part.as_str())\
    \ {\n        return \"Yes\".to_string();\n    }\n    else {\n        return \"\
    No\".to_string();\n    }", "    if file_name.len() > 255 {\n        return \"\
    No\".to_string();\n    }\n    let mut digits = 0;\n    let mut alphabetic = false;\n\
    \    let mut extension = String::new();\n    let mut has_dot = false;\n    for\
    \ c in file_name.chars() {\n        if c.is_digit(10) {\n            digits +=\
    \ 1;\n        } else if c.is_alphabetic() {\n            alphabetic = true;\n\
    \        } else if c == '.' {\n            has_dot = true;\n        } else {\n\
    \            return \"No\".to_string();\n        }\n        if digits > 3 {\n\
    \            return \"No\".to_string();\n        }\n    }\n    if !alphabetic\
    \ || !has_dot {\n        return \"No\".to_string();\n    }\n    extension = match\
    \ file_name.split('.').collect::<Vec<&str>>().last() {\n        Some(s) => s.to_string(),\n\
    \        None => \"\".to_string(),\n    };\n    match extension.as_str() {\n \
    \       \"txt\" | \"exe\" | \"dll\" => \"Yes\".to_string(),\n        _ => \"No\"\
    .to_string(),\n    }", "    let name_regex = Regex::new(r\"^[a-zA-Z]\\w*(\\.[a-zA-Z]{1,3})?$\"\
    ).unwrap();\n    let digit_regex = Regex::new(r\"[0-9]\").unwrap();\n    let has_digit\
    \ = digit_regex.find(&file_name).is_some();\n    let valid_extension = [\"txt\"\
    , \"exe\", \"dll\"].contains(&file_name.split(\".\").last().unwrap());\n    if\
    \ has_digit || !name_regex.is_match(&file_name) || !valid_extension {\n      \
    \  return \"No\".to_string();\n    }\n    \"Yes\".to_string()", "    if file_name.matches(char::is_numeric).collect::<Vec<_>>().len()\
    \ > 3 {\n        \"No\".to_string()\n    } else if file_name.chars().filter(|c|\
    \ *c == '.').count() != 1 {\n        \"No\".to_string()\n    } else if let Some(before_dot)\
    \ = file_name.chars().take_while(|c| *c != '.').collect::<String>().as_str() {\n\
    \        if before_dot.len() == 0 || !before_dot.chars().next().unwrap().is_ascii_alphabetic()\
    \ {\n            \"No\".to_string()\n        } else if let Some(after_dot) = file_name.chars().skip_while(|c|\
    \ *c != '.').skip(1).collect::<String>().as_str() {\n            if [\"txt\",\
    \ \"exe\", \"dll\"].contains(&after_dot) {\n                \"Yes\".to_string()\n\
    \            } else {\n                \"No\".to_string()\n            }\n   \
    \     } else {\n            \"No\".to_string()\n        }\n    } else {\n    \
    \    \"No\".to_string()\n    }", "  let mut cnt = 0;\n  let mut dot_pos = -1;\n\
    \  let mut valid = true;\n  for (i, c) in file_name.chars().enumerate() {\n  \
    \  if c == '.' {\n      dot_pos = i;\n    } else if c.is_ascii_digit() {\n   \
    \   cnt += 1;\n    }\n  }\n  if cnt > 3 || dot_pos == -1 || dot_pos == 0 || dot_pos\
    \ == file_name.len() - 1 {\n    valid = false;\n  } else {\n    let pre = &file_name[..dot_pos];\n\
    \    let suf = &file_name[dot_pos + 1..];\n    if pre.is_empty() || !pre.chars().next().unwrap().is_ascii_alphabetic()\
    \ {\n      valid = false;\n    } else if suf != \"txt\" && suf != \"exe\" && suf\
    \ != \"dll\" {\n      valid = false;\n    }\n  }\n  if valid {\n    String::from(\"\
    Yes\")\n  } else {\n    String::from(\"No\")\n  }", "    let mut digits_count\
    \ = 0;\n    let mut has_dot = false;\n    let mut has_extension = false;\n   \
    \ let mut is_first_char_valid = false;\n    let mut first_char = ' ';\n    let\
    \ mut extension = String::new();\n    for c in file_name.chars() {\n        if\
    \ digits_count > 3 {\n            return String::from(\"No\");\n        }\n  \
    \      if c == '.' {\n            if has_dot {\n                return String::from(\"\
    No\");\n            }\n            has_dot = true;\n        } else if c == '.'\
    \ {\n            if has_extension {\n                return String::from(\"No\"\
    );\n            }\n            has_extension = true;\n        } else if c.is_alphabetic()\
    \ {\n            if is_first_char_valid {\n                return String::from(\"\
    No\");\n            }\n            is_first_char_valid = true;\n            first_char\
    \ = c;\n        } else if c.is_numeric() {\n            digits_count += 1;\n \
    \       } else {\n            return String::from(\"No\");\n        }\n    }\n\
    \    if !is_first_char_valid || !has_dot || !has_extension {\n        return String::from(\"\
    No\");\n    }\n    if !(extension == \"txt\" || extension == \"exe\" || extension\
    \ == \"dll\") {\n        return String::from(\"No\");\n    }\n    String::from(\"\
    Yes\")", "    println!(\"{}\", file_name);\n    let mut counter: i32 = 0;\n  \
    \  let mut dot: bool = false;\n    let mut result: String = String::from(\"No\"\
    );\n    let mut valid: bool = false;\n    for c in file_name.chars() {\n     \
    \   if c.is_digit(10) {\n            counter += 1;\n        }\n        if c ==\
    \ '.' {\n            dot = true;\n        }\n    }\n    if counter > 3 {\n   \
    \     valid = false;\n    }\n    else if dot {\n        valid = true;\n    }\n\
    \    else {\n        valid = false;\n    }\n    if valid {\n        result = String::from(\"\
    Yes\");\n    }\n    result", '    // Your code here', "    let mut dots = 0;\n\
    \    let mut digits = 0;\n    let mut letters = 0;\n    let mut extension = String::new();\n\
    \    let mut extension_len = 0;\n    let mut is_valid = true;\n    let letters_regex\
    \ = Regex::new(r\"[a-zA-Z]\").unwrap();\n    let file_name_array: Vec<char> =\
    \ file_name.chars().collect();\n    for (i, c) in file_name_array.iter().enumerate()\
    \ {\n        match c {\n            '.' => {\n                dots += 1;\n   \
    \             if (i == 0) || (i == file_name_array.len() - 1) {\n            \
    \        is_valid = false;\n                }\n            },\n            '0'..='9'\
    \ => digits += 1,\n            _ => {\n                if !letters_regex.is_match(c.to_string().as_str())\
    \ {\n                    is_valid = false;\n                } else {\n       \
    \             letters += 1;\n                }\n            }\n        }\n   \
    \     if (dots == 1) && (extension_len > 0) {\n            extension.push(*c);\n\
    \            extension_len += 1;\n        }\n    }\n    if (dots != 1) || (letters\
    \ == 0) || (digits > 3) || (extension_len == 0) || (extension != \"txt\" && extension\
    \ != \"exe\" && extension != \"dll\") {\n        is_valid = false;\n    }\n  \
    \  return if is_valid { \"Yes\".to_string() } else { \"No\".to_string() };", " \
    \   let mut digits_count = 0;\n    let mut dot_found = false;\n    let mut letters_found\
    \ = false;\n    let mut extension_found = false;\n    let mut extension = \"\"\
    .to_string();\n    for c in file_name.chars() {\n        if c.is_digit(10) {\n\
    \            digits_count += 1;\n        }\n        if c == '.' {\n          \
    \  dot_found = true;\n        }\n        if c.is_alphabetic() {\n            letters_found\
    \ = true;\n        }\n        if c.is_alphabetic() && dot_found {\n          \
    \  extension.push(c);\n        }\n    }\n    match extension.as_str() {\n    \
    \    \"txt\" | \"exe\" | \"dll\" => extension_found = true,\n        _ => (),\n\
    \    }\n    if digits_count > 3 || !dot_found || !letters_found || !extension_found\
    \ {\n        \"No\".to_string()\n    } else {\n        \"Yes\".to_string()\n \
    \   }", "    let mut dot_count = 0;\n    let mut number_count = 0;\n    let mut\
    \ allowed_extensions = [\"txt\", \"exe\", \"dll\"];\n    let mut file_name_without_extension\
    \ = String::new();\n    let mut file_extension = String::new();\n    let mut allowed_extension\
    \ = false;\n    let mut valid_file_name = true;\n\n    for (i, c) in file_name.chars().enumerate()\
    \ {\n        if c == '.' {\n            dot_count += 1;\n            file_name_without_extension\
    \ = file_name[..i].to_string();\n            file_extension = file_name[i+1..].to_string();\n\
    \        }\n        if c.is_digit(10) {\n            number_count += 1;\n    \
    \    }\n    }\n\n    for i in 0..allowed_extensions.len() {\n        if allowed_extensions[i]\
    \ == file_extension {\n            allowed_extension = true;\n        }\n    }\n\
    \n    if file_name_without_extension.len() == 0 || !file_name_without_extension.chars().next().unwrap().is_alphabetic()\
    \ {\n        valid_file_name = false;\n    }\n\n    if dot_count == 1 && number_count\
    \ <= 3 && allowed_extension && valid_file_name {\n        return \"Yes\".to_string();\n\
    \    } else {\n        return \"No\".to_string();\n    }", "    if file_name.split(\"\
    .\").len() > 2 {\n        return \"No\".to_string();\n    }\n\n    let mut digits_count\
    \ = 0;\n    let mut char_iter = file_name.chars();\n    let dot_pos = file_name.find('.').unwrap();\n\
    \    let mut got_dot = false;\n    let mut first_char = false;\n    while let\
    \ Some(c) = char_iter.next() {\n        if got_dot {\n            if c != 't'\
    \ && c != 'x' && c != 'd' {\n                return \"No\".to_string();\n    \
    \        }\n        } else {\n            if c.is_ascii_alphabetic() {\n     \
    \           first_char = true;\n            } else if c.is_digit(10) {\n     \
    \           digits_count += 1;\n            } else if c == '.' {\n           \
    \     got_dot = true;\n            } else {\n                return \"No\".to_string();\n\
    \            }\n        }\n    }\n\n    if digits_count > 3 || !first_char {\n\
    \        return \"No\".to_string();\n    }\n\n    \"Yes\".to_string()", "    let\
    \ parts: Vec<&str> = file_name.split('.').collect();\n    if parts.len() != 2\
    \ {\n        return \"No\".to_string();\n    }\n    let part_0 = parts[0];\n \
    \   let part_1 = parts[1];\n    if part_0.len() == 0 || !part_0.chars().next().unwrap().is_alphabetic()\
    \ {\n        return \"No\".to_string();\n    }\n    let valid_exts = [\"txt\"\
    , \"exe\", \"dll\"];\n    if !valid_exts.contains(&part_1) {\n        return \"\
    No\".to_string();\n    }\n    let num_digits = part_0.chars().filter(|c| c.is_digit(10)).count();\n\
    \    if num_digits > 3 {\n        return \"No\".to_string();\n    }\n    \"Yes\"\
    .to_string()", "    let mut parts = file_name.split('.');\n    let pre_dot = parts.next().unwrap();\n\
    \    let post_dot = parts.next().unwrap();\n    let valid_ext = [\"txt\", \"exe\"\
    , \"dll\"].contains(&post_dot);\n    let pre_dot_check = if pre_dot.chars().filter(|c|\
    \ c.is_numeric()).count() > 3 {\n        false\n    } else {\n        let first_char\
    \ = pre_dot.chars().next().unwrap();\n        first_char.is_alphabetic()\n   \
    \ };\n    if valid_ext && pre_dot_check {\n        \"Yes\".to_string()\n    }\
    \ else {\n        \"No\".to_string()\n    }", "    let mut digit_count = 0;\n\
    \    let mut dot_index = -1;\n    let len = file_name.len();\n    let mut fname\
    \ = file_name.to_uppercase();\n    for (i, c) in fname.chars().enumerate() {\n\
    \        if c >= '0' && c <= '9' {\n            digit_count += 1;\n        } else\
    \ if c == '.' {\n            dot_index = i;\n        }\n    }\n    if digit_count\
    \ > 3 || dot_index == -1 || dot_index == 0 || dot_index == len - 1 {\n       \
    \ return \"No\".to_string();\n    }\n    if &fname[dot_index+1..] != \"TXT\" &&\
    \ &fname[dot_index+1..] != \"EXE\" && &fname[dot_index+1..] != \"DLL\" {\n   \
    \     return \"No\".to_string();\n    }\n    return \"Yes\".to_string();", " \
    \   use std::fmt::Write;\n    let mut output = String::new();\n    let mut digits\
    \ = 0;\n    let mut dot_exists = false;\n    let mut sub_str_exists = false;\n\
    \    let mut valid_sub_str = false;\n    for (i, c) in file_name.chars().enumerate()\
    \ {\n        if i == 0 && c.is_digit(10) {\n            let _ = write!(output,\
    \ \"No\");\n            return output;\n        }\n        if c.is_digit(10) {\n\
    \            digits += 1;\n        }\n        if c == '.' {\n            dot_exists\
    \ = true;\n        }\n        if (i > 0 && file_name.chars().nth(i - 1) == Some('.'))\
    \ && !c.is_digit(10) {\n            sub_str_exists = true;\n        }\n      \
    \  if (i > 0 && file_name.chars().nth(i - 1) == Some('.')) && !c.is_digit(10)\
    \ && i < file_name.len() - 1 {\n            if file_name.chars().nth(i + 1) ==\
    \ Some('t') && file_name.chars().nth(i + 2) == Some('x') && file_name.chars().nth(i\
    \ + 3) == Some('t') {\n                valid_sub_str = true;\n            }\n\
    \            if file_name.chars().nth(i + 1) == Some('e') && file_name.chars().nth(i\
    \ + 2) == Some('x') && file_name.chars().nth(i + 3) == Some('e') {\n         \
    \       valid_sub_str = true;\n            }\n            if file_name.chars().nth(i\
    \ + 1) == Some('d') && file_name.chars().nth(i + 2) == Some('l') && file_name.chars().nth(i\
    \ + 3) == Some('l') {\n                valid_sub_str = true;\n            }\n\
    \        }\n    }\n    if digits > 3 || !dot_exists || !", "    let num_of_digits\
    \ = file_name.chars().filter(|&n| n.is_digit(10)).count();\n    let num_of_dots\
    \ = file_name.chars().filter(|&n| n == '.').count();\n    let after_dot: Vec<&str>\
    \ = file_name.split('.').collect();\n    if num_of_digits > 3 || num_of_dots !=\
    \ 1 {\n        return String::from(\"No\");\n    }\n    let first_char = after_dot[0].chars().next().unwrap();\n\
    \    if !(first_char.is_alphabetic() && first_char.is_ascii_lowercase()) {\n \
    \       return String::from(\"No\");\n    }\n    if !(after_dot[1] == \"txt\"\
    \ || after_dot[1] == \"exe\" || after_dot[1] == \"dll\") {\n        return String::from(\"\
    No\");\n    }\n    return String::from(\"Yes\");", "    let mut digits_count =\
    \ 0;\n    let mut dot_count = 0;\n    let mut last_char = '?';\n    let mut first_char\
    \ = '?';\n    let mut dot_index = 0;\n    let mut first_char_index = 0;\n    let\
    \ mut last_char_index = 0;\n    let mut last_three_chars = \"\".to_string();\n\
    \    let chars = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l',\
    \ 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B',\
    \ 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R',\
    \ 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let digits = ['0', '1', '2', '3',\
    \ '4', '5', '6', '7', '8', '9'];\n    let acceptable_endings = [\"txt\", \"exe\"\
    , \"dll\"];\n    let mut flag = false;\n    let mut valid = false;\n    let mut\
    \ ending = \"\".to_string();\n    if file_name.len() > 0 {\n        for (i, c)\
    \ in file_name.chars().enumerate() {\n            if c == '.' {\n            \
    \    if flag {\n                    dot_count += 1;\n                    dot_index\
    \ = i;\n                }\n            } else if !flag {\n                if c.is_alphabetic()\
    \ {\n                    flag = true;\n                    first_char = c;\n \
    \                   first_char_index = i;\n                }\n            } else\
    \ if c.is_alphabetic() {\n                continue;\n            } else if c.is_numeric()\
    \ {\n                digits_count += 1;\n            } else {\n              \
    \  break;\n            }\n            last_char = c;\n            last_char_",
  "    let mut count_digits = 0;\n    let mut count_dot = 0;\n    let mut before_dot_is_empty\
    \ = true;\n    let mut sub_after_dot = String::new();\n    let mut sub_before_dot\
    \ = String::new();\n    for c in file_name.chars() {\n        if c == '.' {\n\
    \            before_dot_is_empty = false;\n            count_dot += 1;\n     \
    \   } else if !before_dot_is_empty {\n            sub_after_dot.push(c);\n   \
    \     } else if c.is_ascii_digit() {\n            count_digits += 1;\n       \
    \ } else if c.is_ascii_alphabetic() {\n            sub_before_dot.push(c);\n \
    \       }\n    }\n    if count_digits > 3 || count_dot != 1 || sub_before_dot.is_empty()\
    \ ||\n       sub_after_dot != \"txt\" && sub_after_dot != \"exe\" && sub_after_dot\
    \ != \"dll\" {\n        return String::from(\"No\");\n    }\n    String::from(\"\
    Yes\")", "    // Your code here\n    let mut cnt_digit = 0;\n    let mut dot_check\
    \ = false;\n    let mut before_dot = String::new();\n    let mut after_dot = String::new();\n\
    \    for (i, c) in file_name.chars().enumerate() {\n        match c {\n      \
    \      '0'...'9' => cnt_digit += 1,\n            '.' => {\n                dot_check\
    \ = true;\n                let (before, after) = file_name.split_at(i);\n    \
    \            before_dot = before.to_string();\n                after_dot = after.to_string();\n\
    \            },\n            _ => (),\n        }\n    }\n    if cnt_digit > 3\
    \ || !dot_check || before_dot.is_empty() || !(before_dot.chars().next().unwrap().is_alphabetic())\
    \ {\n        return \"No\".to_string();\n    }\n    match after_dot.as_str() {\n\
    \        \".txt\" | \".exe\" | \".dll\" => \"Yes\".to_string(),\n        _ =>\
    \ \"No\".to_string(),\n    }", "    let mut count = 0;\n    let mut flag = false;\n\
    \    let mut splitted = file_name.split('.');\n    let ext = splitted.next_back().unwrap().to_string();\n\
    \    let mut body = splitted.next().unwrap().to_string();\n    body.chars().for_each(|c|\
    \ {\n        if !flag && (c.is_alphabetic() || c.is_whitespace()) {\n        \
    \    flag = true;\n        }\n        if c.is_digit(10) {\n            count +=\
    \ 1;\n        }\n    });\n    if count > 3 || !flag || body.len() == 0 || ![\"\
    txt\", \"exe\", \"dll\"].contains(&ext.as_str()) {\n        \"No\".to_string()\n\
    \    } else {\n        \"Yes\".to_string()\n    }", "    if let Some((name, extension))\
    \ = file_name.split_at(file_name.find('.').unwrap()) {\n        let extension\
    \ = &extension[1..];\n        if name.chars().any(|c| c.is_ascii_alphabetic())\
    \ &&\n            name.chars().filter(|c| c.is_ascii_digit()).count() <= 3 &&\n\
    \            extension == \"txt\" || extension == \"exe\" || extension == \"dll\"\
    \ {\n            \"Yes\".to_string()\n        } else {\n            \"No\".to_string()\n\
    \        }\n    } else {\n        \"No\".to_string()\n    }", "    let mut count\
    \ = 0;\n    let mut i: usize = 0;\n    let mut p = 0;\n    let mut s = 0;\n  \
    \  for i in 0..file_name.len() {\n        if count >= 3 {\n            return\
    \ \"No\".to_string();\n        }\n        if file_name.chars().nth(i).unwrap().is_digit(10)\
    \ {\n            count += 1;\n        }\n        if file_name.chars().nth(i).unwrap()\
    \ == '.' {\n            p = i;\n            s = file_name.len() - i - 1;\n   \
    \     }\n    }\n    if (p > 0) && (s > 0) && ((s == 3) || (s == 2) || (s == 4))\
    \ {\n        let f = file_name.chars().nth(0).unwrap();\n        if !f.is_alphabetic()\
    \ {\n            return \"No\".to_string();\n        }\n        if s == 3 {\n\
    \            if file_name.as_str()[p+1..p+4] != \"txt\" {\n                return\
    \ \"No\".to_string();\n            }\n        }\n        if s == 2 {\n       \
    \     if file_name.as_str()[p+1..p+3] != \"exe\" {\n                return \"\
    No\".to_string();\n            }\n        }\n        if s == 4 {\n           \
    \ if file_name.as_str()[p+1..p+5] != \"dll\" {\n                return \"No\"\
    .to_string();\n            }\n        }\n        return \"Yes\".to_string();\n\
    \    }\n    return \"No\".to_string();", "    let file_name = file_name.to_lowercase();\n\
    \    let digits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];\n    let\
    \ mut digit_count = 0;\n    let mut has_dot = false;\n    let mut extension =\
    \ None;\n    let mut after_dot = None;\n    let mut before_dot = \"\";\n    for\
    \ c in file_name.chars() {\n        if digits.contains(&c) {\n            digit_count\
    \ += 1;\n        }\n        if c == '.' {\n            has_dot = true;\n     \
    \   }\n        if let Some(s) = after_dot {\n            extension = Some(s +\
    \ &c.to_string());\n        }\n        if has_dot {\n            after_dot = Some(c.to_string());\n\
    \        } else {\n            before_dot += &c.to_string();\n        }\n    }\n\
    \    let valid_extension = match extension {\n        Some(ext) => ext == \"txt\"\
    \ || ext == \"exe\" || ext == \"dll\",\n        None => false,\n    };\n    let\
    \ valid_before_dot = match before_dot.chars().next() {\n        Some(c) => c.is_alphabetic(),\n\
    \        None => false,\n    };\n    let valid_after_dot = match after_dot {\n\
    \        Some(s) => s != \".\",\n        None => false,\n    };\n    if digit_count\
    \ > 3 || !has_dot || !valid_before_dot || !valid_after_dot || !valid_extension\
    \ {\n        \"No\".to_string()\n    } else {\n        \"Yes\".to_string()\n \
    \   }", "    let mut is_valid = true;\n    let mut number_of_digits = 0;\n   \
    \ let mut file_name_arr: Vec<char> = file_name.chars().collect();\n    let mut\
    \ has_dot = false;\n    let mut is_first_char_alpha = false;\n    let mut extension\
    \ = \"\".to_string();\n    for i in 0..file_name_arr.len() {\n        let mut\
    \ current_char = file_name_arr[i];\n        // Check if valid digit\n        if\
    \ current_char >= '0' && current_char <= '9' {\n            number_of_digits +=\
    \ 1;\n            if number_of_digits > 3 {\n                is_valid = false;\n\
    \                break;\n            }\n        }\n        if current_char ==\
    \ '.' {\n            has_dot = true;\n            if i == 0 {\n              \
    \  is_valid = false;\n                break;\n            }\n            if i\
    \ == file_name_arr.len() - 1 {\n                is_valid = false;\n          \
    \      break;\n            }\n            let valid_extensions = [\"txt\", \"\
    exe\", \"dll\"];\n            let extension_length = file_name_arr.len() - i -\
    \ 1;\n            extension = file_name[i+1..i+1+extension_length].to_string();\n\
    \            if !valid_extensions.contains(&extension.as_str()) {\n          \
    \      is_valid = false;\n                break;\n            }\n        }\n \
    \       if i == 0 {\n            if current_char >= 'a' && current_char <= 'z'\
    \ {\n                is_first_char_alpha = true;\n            } else if current_char\
    \ >= 'A' && current_char <= 'Z' {\n                is_first_char_alpha = true;\n\
    \            } else {\n                is_valid = false;\n                break;\n\
    \            }\n        }\n    }\n    if !has_dot {\n        is_valid = false;\n\
    \    }\n    if !is_first_char_alpha {\n        is_valid = false;\n    }\n    if\
    \ is_valid {\n        \"Yes\".to_string()\n    }", '    unimplemented!();', " \
    \   let parts: Vec<&str> = file_name.split('.').collect();\n    let re = Regex::new(r\"\
    ^[a-zA-Z][a-zA-Z0-9]{0,9}$\").unwrap();\n    let len = parts.len();\n    if len\
    \ != 2 {\n        return \"No\".to_string();\n    }\n    if parts[0].len() ==\
    \ 0 {\n        return \"No\".to_string();\n    }\n    if !re.is_match(parts[0])\
    \ {\n        return \"No\".to_string();\n    }\n    if !(parts[1] == \"txt\" ||\
    \ parts[1] == \"exe\" || parts[1] == \"dll\") {\n        return \"No\".to_string();\n\
    \    }\n    \"Yes\".to_string()", "  let mut correct = 0;\n  let mut digits =\
    \ 0;\n  let mut dot = 0;\n  let mut latin = false;\n  let mut ext = false;\n \
    \ let mut i = 0;\n  for c in file_name.chars() {\n    if c.is_digit(10) {\n  \
    \    digits += 1;\n    }\n    if c == '.' {\n      dot += 1;\n    }\n    if !latin\
    \ && (c.is_alphabetic() || c == '.') {\n      if i == 0 && c == '.' {\n      \
    \  correct = -1;\n        break;\n      }\n      latin = true;\n    }\n    if\
    \ latin && c == '.' {\n      latin = false;\n    }\n    if !ext && (c == 't' ||\
    \ c == 'e' || c == 'd') {\n      ext = true;\n    }\n    if ext && c == '.' {\n\
    \      ext = false;\n    }\n    i += 1;\n  }\n  if (latin || ext) && dot == 1\
    \ && digits <= 3 {\n    correct = 1;\n  }\n  match correct {\n    -1 => \"No\"\
    .to_string(),\n    1 => \"Yes\".to_string(),\n    _ => \"No\".to_string(),\n \
    \ }", "    let regex = Regex::new(r\"^([a-zA-Z]{1}[a-zA-Z0-9]{0,3})\\.(txt|exe|dll)$\"\
    ).unwrap();\n    match regex.is_match(&file_name) {\n        true => String::from(\"\
    Yes\"),\n        false => String::from(\"No\"),\n    }", "    let split: Vec<&str>\
    \ = file_name.split(\".\").collect();\n    if !split[0].is_empty() && split[0].chars().all(|c|\
    \ c.is_ascii_alphabetic())\n        && split[1] == \"txt\" || split[1] == \"exe\"\
    \ || split[1] == \"dll\"\n        && !file_name.matches(char::is_numeric).collect::<Vec<&str>>().iter().any(|n|\
    \ n.len() > 3)\n    {\n        return \"Yes\".to_string();\n    }\n    \"No\"\
    .to_string()", "    let parts: Vec<&str> = file_name.split(\".\").collect();\n\
    \    let fname = parts[0];\n    let ext = parts[1];\n    let is_ext_valid = ext\
    \ == \"txt\" || ext == \"exe\" || ext == \"dll\";\n    let has_dot = file_name.chars().filter(|&c|\
    \ c == '.').count() == 1;\n    let digits_count = file_name.chars().filter(|&c|\
    \ c >= '0' && c <= '9').count();\n    let is_fname_valid = (fname.chars().nth(0).unwrap()\
    \ >= 'a' && fname.chars().nth(0).unwrap() <= 'z')\n        || (fname.chars().nth(0).unwrap()\
    \ >= 'A' && fname.chars().nth(0).unwrap() <= 'Z');\n    if is_ext_valid && has_dot\
    \ && digits_count <= 3 && is_fname_valid {\n        return \"Yes\".to_string();\n\
    \    } else {\n        return \"No\".to_string();\n    }", "    let dot_idx =\
    \ file_name.find('.').unwrap();\n    let before_dot = &file_name[..dot_idx];\n\
    \    let after_dot = &file_name[dot_idx+1..];\n    if before_dot.chars().any(|ch|\
    \ !ch.is_ascii_alphabetic()) {\n        return \"No\".to_string();\n    }\n  \
    \  if after_dot.chars().any(|ch| !ch.is_ascii_alphanumeric()) {\n        return\
    \ \"No\".to_string();\n    }\n    if !(after_dot == \"txt\" || after_dot == \"\
    exe\" || after_dot == \"dll\") {\n        return \"No\".to_string();\n    }\n\
    \    if after_dot.chars().filter(|ch| ch.is_ascii_digit()).count() > 3 {\n   \
    \     return \"No\".to_string();\n    }\n    \"Yes\".to_string()", "    let mut\
    \ letters = false;\n    let mut dot = false;\n    let mut digits = 0;\n    let\
    \ mut ext = String::new();\n    for ch in file_name.chars() {\n        if ch.is_alphabetic()\
    \ {\n            letters = true;\n        } else if ch == '.' {\n            dot\
    \ = true;\n        } else if ch.is_numeric() {\n            digits += 1;\n   \
    \     } else {\n            return \"No\".to_string();\n        }\n        if\
    \ dot {\n            ext.push(ch);\n        }\n    }\n    if letters && digits\
    \ <= 3 && ext == \".txt\" || ext == \".exe\" || ext == \".dll\" {\n        \"\
    Yes\".to_string()\n    } else {\n        \"No\".to_string()\n    }", "    fn check_digits(s:\
    \ &str) -> bool {\n        let mut n_digits = 0;\n        for c in s.chars() {\n\
    \            if !c.is_numeric() {\n                return false;\n           \
    \ }\n            n_digits += 1;\n        }\n        n_digits <= 3\n    }\n\n \
    \   fn check_extension(s: &str) -> bool {\n        match s {\n            \"txt\"\
    \ | \"exe\" | \"dll\" => true,\n            _ => false,\n        }\n    }\n\n\
    \    let mut vec: Vec<&str> = file_name.split(\".\").collect();\n    if vec.len()\
    \ != 2 {\n        return \"No\".to_string();\n    }\n    let file_name = vec.remove(0);\n\
    \    let file_extension = vec.remove(0);\n    if !file_name.chars().next().unwrap().is_alphabetic()\
    \ {\n        return \"No\".to_string();\n    }\n    if !check_digits(file_name)\
    \ {\n        return \"No\".to_string();\n    }\n    if !check_extension(file_extension)\
    \ {\n        return \"No\".to_string();\n    }\n    \"Yes\".to_string()", "  \
    \  // TODO: implement the function here\n    let mut count = 0;\n    let mut has_one_dot\
    \ = false;\n    let mut is_digit = false;\n    let mut has_correct_suffix = false;\n\
    \    let mut has_correct_prefix = false;\n    let mut i = 0;\n    while i < file_name.len()\
    \ {\n        if file_name.chars().nth(i).unwrap().is_ascii_digit() {\n       \
    \     count += 1;\n            is_digit = true;\n        }\n        if file_name.chars().nth(i).unwrap()\
    \ == '.' {\n            has_one_dot = true;\n        }\n        i += 1;\n    }\n\
    \    if count <= 3 {\n        has_correct_prefix = true;\n    }\n    if file_name.ends_with(\"\
    txt\") || file_name.ends_with(\"exe\") || file_name.ends_with(\"dll\") {\n   \
    \     has_correct_suffix = true;\n    }\n    if !is_digit {\n        has_correct_prefix\
    \ = true;\n    }\n    if has_one_dot && has_correct_prefix && has_correct_suffix\
    \ {\n        return \"Yes\".to_string();\n    }\n    return \"No\".to_string();",
  "    let mut ext = String::new();\n    let mut name = String::new();\n    let mut\
    \ has_dot = false;\n    let mut count = 0;\n    for c in file_name.chars() {\n\
    \        if c == '.' {\n            has_dot = true;\n            continue;\n \
    \       }\n        if has_dot {\n            ext.push(c);\n        } else {\n\
    \            name.push(c);\n        }\n        if c.is_digit(10) {\n         \
    \   count += 1;\n        }\n    }\n    if count > 3 {\n        return String::from(\"\
    No\");\n    }\n    let ok_ext = [\"txt\", \"exe\", \"dll\"];\n    let mut found\
    \ = false;\n    for ex in ok_ext.iter() {\n        if ext == *ex {\n         \
    \   found = true;\n            break;\n        }\n    }\n    if !found {\n   \
    \     return String::from(\"No\");\n    }\n    if name.len() == 0 {\n        return\
    \ String::from(\"No\");\n    }\n    for c in name.chars() {\n        if !c.is_alphabetic()\
    \ {\n            return String::from(\"No\");\n        }\n    }\n    return String::from(\"\
    Yes\");", "    if file_name.chars().filter(|x| x.is_numeric()).count() > 3 {\n\
    \        \"No\".to_string()\n    } else if file_name.chars().filter(|x| x == &'.').count()\
    \ != 1 {\n        \"No\".to_string()\n    } else if !file_name.chars().nth(0).unwrap().is_alphabetic()\
    \ {\n        \"No\".to_string()\n    } else {\n        let post_dot = &file_name.split('.').nth(1).unwrap();\n\
    \        match post_dot {\n            \"txt\" | \"exe\" | \"dll\" => \"Yes\"\
    .to_string(),\n            _ => \"No\".to_string(),\n        }\n    }", "    if\
    \ file_name.chars().filter(|c| c.is_numeric()).count() > 3 {\n        return \"\
    No\".to_string();\n    }\n    let substrs: Vec<&str> = file_name.split('.').collect();\n\
    \    if substrs.len() != 2 {\n        return \"No\".to_string();\n    }\n    if\
    \ substrs[0].is_empty() || !substrs[0].chars().next().unwrap().is_alphabetic()\
    \ {\n        return \"No\".to_string();\n    }\n    if !(substrs[1] == \"txt\"\
    \ || substrs[1] == \"exe\" || substrs[1] == \"dll\") {\n        return \"No\"\
    .to_string();\n    }\n    \"Yes\".to_string()", "    if file_name.find('.').is_none()\
    \ {\n        return \"No\".to_string();\n    }\n    let has_extension = file_name.split('.').last().map_or(false,\
    \ |s| {\n        [\"txt\", \"exe\", \"dll\"].contains(&s)\n    });\n    if !has_extension\
    \ {\n        return \"No\".to_string();\n    }\n    let has_digit = file_name.split('.').next().map_or(false,\
    \ |s| {\n        s.matches(char::is_numeric).count() > 3\n    });\n    if has_digit\
    \ {\n        return \"No\".to_string();\n    }\n    let has_alphabet = file_name.split('.').next().map_or(false,\
    \ |s| {\n        s.chars().all(|c| c.is_alphabetic())\n    });\n    if !has_alphabet\
    \ {\n        return \"No\".to_string();\n    }\n    return \"Yes\".to_string();",
  "    if file_name.chars().filter(|c| c.is_digit(10)).count() > 3 {\n        return\
    \ \"No\".to_string();\n    }\n    let parts: Vec<&str> = file_name.split(\".\"\
    ).collect();\n    if parts.len() != 2 {\n        return \"No\".to_string();\n\
    \    }\n    if parts[0].is_empty() || !parts[0].chars().next().unwrap().is_alphabetic()\
    \ {\n        return \"No\".to_string();\n    }\n    match parts[1] {\n       \
    \ \"txt\" | \"exe\" | \"dll\" => \"Yes\".to_string(),\n        _ => \"No\".to_string(),\n\
    \    }", "    let vec = file_name.split(\".\").collect::<Vec<&str>>();\n    if\
    \ vec.len() != 2 {\n        \"No\".to_string()\n    } else {\n        let ext\
    \ = vec[1];\n        if ext != \"txt\" && ext != \"exe\" && ext != \"dll\" {\n\
    \            \"No\".to_string()\n        } else {\n            let mut num_of_digits\
    \ = 0;\n            for c in vec[0].chars() {\n                if c >= '0' &&\
    \ c <= '9' {\n                    num_of_digits += 1;\n                }\n   \
    \         }\n            if num_of_digits > 3 {\n                \"No\".to_string()\n\
    \            } else {\n                \"Yes\".to_string()\n            }\n  \
    \      }\n    }", "    let parts: Vec<_> = file_name.split('.').collect();\n \
    \   if parts.len() != 2 {\n        return \"No\".to_string();\n    }\n    let\
    \ ext = parts[1];\n    if parts[0].len() == 0 {\n        return \"No\".to_string();\n\
    \    }\n    if !(ext == \"txt\" || ext == \"exe\" || ext == \"dll\") {\n     \
    \   return \"No\".to_string();\n    }\n    let mut num_digits = 0;\n    for ch\
    \ in parts[0].chars() {\n        if ch.is_digit(10) {\n            num_digits\
    \ += 1;\n        }\n    }\n    if num_digits > 3 {\n        return \"No\".to_string();\n\
    \    }\n    let first_char = parts[0].chars().next().unwrap();\n    if !(first_char.is_alphabetic()\
    \ || first_char.is_alphabetic()) {\n        return \"No\".to_string();\n    }\n\
    \    \"Yes\".to_string()", "  let mut dot_count = 0;\n  let mut count = 0;\n \
    \ let mut result = \"Yes\".to_string();\n  let mut has_dot = false;\n  let mut\
    \ has_non_number = false;\n  let mut has_number = false;\n  let mut has_three_number\
    \ = false;\n  let mut has_first_char = false;\n  let mut has_txt = false;\n  let\
    \ mut has_exe = false;\n  let mut has_dll = false;\n  let mut has_first_char_error\
    \ = false;\n  let last_char = file_name.chars().last().unwrap();\n  let first_char\
    \ = file_name.chars().next().unwrap();\n  if first_char.is_ascii_lowercase() ||\
    \ first_char.is_ascii_uppercase() {\n    has_first_char = true;\n  } else {\n\
    \    has_first_char_error = true;\n  }\n  for c in file_name.chars() {\n    match\
    \ c {\n      '.' => {\n        dot_count += 1;\n        has_dot = true;\n    \
    \  },\n      '0'...'9' => {\n        count += 1;\n        has_number = true;\n\
    \      },\n      _ => {\n        has_non_number = true;\n      }\n    }\n  }\n\
    \  if count > 3 {\n    has_three_number = true;\n  }\n  if dot_count != 1 {\n\
    \    result = \"No\".to_string();\n  }\n  if !has_dot {\n    result = \"No\".to_string();\n\
    \  }\n  if !has_first_char {\n    result = \"No\".to_string();\n  }\n  if has_first_char_error\
    \ {\n    result = \"No\".to_string();\n  }\n  if !has_non_number {\n    result\
    \ = \"No\".to_string();\n  }\n  if !has_number {\n    result = \"No\".to_string();\n\
    \  }\n  if has_three_number {\n    result = \"No\".to_string();\n  }\n  if", " \
    \   let dot_pos = file_name.rfind('.').unwrap();\n    let before_dot = &file_name[..dot_pos];\n\
    \    let after_dot = &file_name[dot_pos+1..];\n    if file_name.matches(char::is_numeric).count()\
    \ > 3\n        || !before_dot.starts_with(char::is_alphabetic)\n        || !(after_dot\
    \ == \"txt\" || after_dot == \"exe\" || after_dot == \"dll\") {\n        \"No\"\
    .to_string()\n    } else {\n        \"Yes\".to_string()\n    }", "    let mut\
    \ num_digits = 0;\n    let mut dot_count = 0;\n    let mut exst_count = 0;\n \
    \   let mut alph_count = 0;\n    let mut exts = vec![\"txt\".to_string(), \"exe\"\
    .to_string(), \"dll\".to_string()];\n    let mut count = 0;\n    let mut begin_of_ext:\
    \ i32 = 0;\n    let mut file_name_vec: Vec<char> = file_name.chars().collect();\n\
    \    while count < file_name_vec.len() {\n        if file_name_vec[count].is_numeric()\
    \ {\n            num_digits += 1;\n        }\n        if file_name_vec[count]\
    \ == '.' {\n            begin_of_ext = count as i32 + 1;\n            dot_count\
    \ += 1;\n        }\n        if count < file_name_vec.len() - 1 {\n           \
    \ if file_name_vec[count].is_alphabetic() && file_name_vec[count + 1].is_alphabetic()\
    \ {\n                alph_count += 1;\n            }\n        }\n        count\
    \ += 1;\n    }\n    for ext in exts {\n        if file_name[begin_of_ext as usize..].to_string()\
    \ == ext {\n            exst_count += 1;\n        }\n    }\n    if num_digits\
    \ > 3 || dot_count != 1 || alph_count == 0 || exst_count != 1 {\n        return\
    \ \"No\".to_string();\n    }\n    return \"Yes\".to_string();", "    let mut numbers\
    \ = 0;\n    let mut dot = false;\n    let mut prefix = false;\n    let mut postfix\
    \ = false;\n    let prefix_chars = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i',\
    \ 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',\
    \ 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',\
    \ 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let postfix_chars\
    \ = ['t', 'x', 'd'];\n    for c in file_name.chars() {\n        if numbers > 3\
    \ {\n            return \"No\".to_string();\n        } else if c == '.' {\n  \
    \          if dot {\n                return \"No\".to_string();\n            }\
    \ else {\n                dot = true;\n            }\n        } else if c.is_digit(10)\
    \ {\n            numbers += 1;\n        } else if !dot {\n            if !prefix_chars.contains(&c)\
    \ {\n                return \"No\".to_string();\n            } else {\n      \
    \          prefix = true;\n            }\n        } else {\n            if postfix_chars.contains(&c)\
    \ {\n                postfix = true;\n            } else {\n                return\
    \ \"No\".to_string();\n            }\n        }\n    }\n    if numbers <= 3 &&\
    \ dot && prefix && postfix {\n        \"Yes\".to_string()\n    } else {\n    \
    \    \"No\".to_string()\n    }", "    let mut digits_count = 0;\n    let mut dot_count\
    \ = 0;\n    let mut no_char_before_dot = true;\n    let mut after_dot = String::new();\n\
    \    for ch in file_name.chars() {\n        if ch.is_digit(10) {\n           \
    \ digits_count += 1;\n        } else if ch == '.' {\n            dot_count +=\
    \ 1;\n            no_char_before_dot = false;\n        } else if ch.is_alphabetic()\
    \ {\n            no_char_before_dot = false;\n        }\n        if dot_count\
    \ == 1 {\n            after_dot.push(ch);\n        }\n    }\n    if dot_count\
    \ != 1 {\n        return String::from(\"No\");\n    }\n    if digits_count > 3\
    \ {\n        return String::from(\"No\");\n    }\n    if no_char_before_dot {\n\
    \        return String::from(\"No\");\n    }\n    if after_dot == \".txt\" ||\
    \ after_dot == \".exe\" || after_dot == \".dll\" {\n        return String::from(\"\
    Yes\");\n    }\n    return String::from(\"No\");", "    // Find the dot\n    if\
    \ let Some(pos) = file_name.find('.') {\n        // Extract the strings before\
    \ and after the dot\n        let before_dot = &file_name[..pos];\n        let\
    \ after_dot = &file_name[pos+1..];\n        // Check that the before dot starts\
    \ with a letter\n        if before_dot.chars().next().unwrap().is_alphabetic()\
    \ {\n            // Check that the after dot is in the list\n            if after_dot\
    \ == \"txt\" || after_dot == \"exe\" || after_dot == \"dll\" {\n             \
    \   // Check that there are no more than 3 digits\n                if !before_dot.chars().filter(|&c|\
    \ c.is_digit(10)).take(4).any(|_| true) {\n                    return \"Yes\"\
    .to_string();\n                }\n            }\n        }\n    }\n    \"No\"\
    .to_string()", "    if file_name.matches(char::is_numeric).count() > 3 {\n   \
    \     return \"No\".to_string();\n    }\n    let mut name = file_name.split(\"\
    .\").collect::<Vec<&str>>();\n    if name.len() != 2 {\n        return \"No\"\
    .to_string();\n    }\n    let name = name.iter().map(|&x| x.to_string()).collect::<Vec<String>>();\n\
    \    if name[0].is_empty() || !name[0].chars().next().unwrap().is_alphabetic()\
    \ {\n        return \"No\".to_string();\n    }\n    if name[1] != \"txt\" && name[1]\
    \ != \"exe\" && name[1] != \"dll\" {\n        return \"No\".to_string();\n   \
    \ }\n    \"Yes\".to_string()", "    let v: Vec<&str> = file_name.split('.').collect();\n\
    \    let last = v.last().unwrap();\n    if last == \"txt\" || last == \"exe\"\
    \ || last == \"dll\" {\n        let first: Vec<char> = v[0].chars().collect();\n\
    \        if first.len() == 0 {\n            return \"No\".to_string();\n     \
    \   }\n        if !(first[0] >= 'a' && first[0] <= 'z' || first[0] >= 'A' && first[0]\
    \ <= 'Z') {\n            return \"No\".to_string();\n        }\n        for c\
    \ in first {\n            if c >= '0' && c <= '9' {\n                return \"\
    No\".to_string();\n            }\n        }\n        return \"Yes\".to_string();\n\
    \    }\n    \"No\".to_string()", "    if !file_name.contains('.') {\n        return\
    \ \"No\".to_string();\n    }\n    let mut pre_dot = file_name.split('.').nth(0).unwrap().to_string();\n\
    \    let mut count = 0;\n    while pre_dot.len() > 0 {\n        if pre_dot.chars().nth(0).unwrap().is_digit(10)\
    \ {\n            pre_dot.remove(0);\n            count += 1;\n        } else {\n\
    \            break;\n        }\n    }\n    if count > 3 {\n        return \"No\"\
    .to_string();\n    }\n    let ext = file_name.split('.').nth(1).unwrap().to_string();\n\
    \    if ext == \"txt\" || ext == \"exe\" || ext == \"dll\" {\n        return \"\
    Yes\".to_string();\n    }\n    \"No\".to_string()", "    let dot_index = file_name.find('.').unwrap();\n\
    \    let (before_dot, after_dot) = file_name.split_at(dot_index);\n    let after_dot\
    \ = &after_dot[1..];\n\n    let _ = before_dot.find(|c: char| c.is_digit(10));\n\
    \n    // TODO: https://stackoverflow.com/questions/52888761/how-to-count-number-of-digits-in-a-string-in-rust\n\
    \    // let before_dot_digits = before_dot.chars().filter(|c| c.is_digit(10)).count();\n\
    \    let before_dot_digits = 0;\n\n    let mut r = Regex::new(r\"[a-zA-Z]\").unwrap();\n\
    \    let before_dot_first_letter = r.find(before_dot).is_some();\n\n    let mut\
    \ r = Regex::new(r\"^txt|exe|dll$\").unwrap();\n    let after_dot_valid = r.find(after_dot).is_some();\n\
    \n    let all_conditions_met =\n        before_dot_digits <= 3 && before_dot_first_letter\
    \ && after_dot_valid;\n\n    if all_conditions_met {\n        String::from(\"\
    Yes\")\n    } else {\n        String::from(\"No\")\n    }", "    // regex approach\n\
    \    // let mut valid = true;\n    // let re = Regex::new(r\"^[a-zA-Z][a-zA-Z0-9]{0,3}\\\
    .(txt|exe|dll)$\").unwrap();\n    // valid = re.is_match(&file_name);\n    //\
    \ match valid {\n    //     true => \"Yes\".to_string(),\n    //     false =>\
    \ \"No\".to_string(),\n    // }\n\n    // substr approach\n    let file_type =\
    \ [\".txt\", \".exe\", \".dll\"];\n    let mut count_dot = 0;\n    let mut count_num\
    \ = 0;\n    for c in file_name.chars() {\n        match c {\n            '0'...'9'\
    \ => count_num += 1,\n            '.' => count_dot += 1,\n            _ => (),\n\
    \        }\n    }\n    let fname = &file_name[..file_name.find('.').unwrap()];\n\
    \    if count_dot != 1 || count_num > 3 || fname.len() == 0 || !fname.chars().next().unwrap().is_alphabetic()\
    \ {\n        return \"No\".to_string();\n    }\n    for suffix in file_type.iter()\
    \ {\n        if file_name.ends_with(suffix) {\n            return \"Yes\".to_string();\n\
    \        }\n    }\n    \"No\".to_string()", "    let mut counter = 0;\n    let\
    \ mut has_dot = false;\n    let mut text_after_dot = \"\";\n    let mut is_valid\
    \ = true;\n    for i in file_name.chars() {\n        if i.is_numeric() {\n   \
    \         counter += 1;\n        }\n        if i == '.' {\n            has_dot\
    \ = true;\n        }\n        if i.is_alphabetic() {\n            text_after_dot\
    \ = &file_name[i.len_utf8()..];\n        }\n    }\n    if counter > 3 || !has_dot\
    \ || text_after_dot != \"txt\" || text_after_dot != \"exe\" || text_after_dot\
    \ != \"dll\" {\n        is_valid = false;\n    }\n    if is_valid {\n        \"\
    Yes\".to_string()\n    } else {\n        \"No\".to_string()\n    }", "    // create\
    \ a regex\n    let re = Regex::new(r\"^(?P<base>[a-zA-Z]+)(?P<version>\\d{0,3})\\\
    .(?P<extension>txt|exe|dll)$\").unwrap();\n    let file_name = file_name.trim();\n\
    \    // check if the name of the file match the pattern of the regex\n    if re.is_match(file_name)\
    \ {\n        // if it does, extract the captured groups\n        let caps = re.captures(file_name).unwrap();\n\
    \        // extract each captured group\n        let base = caps.name(\"base\"\
    ).unwrap().as_str();\n        let version = caps.name(\"version\").unwrap().as_str();\n\
    \        let extension = caps.name(\"extension\").unwrap().as_str();\n       \
    \ // return 'Yes' if there are no more than three digits in the version, \n  \
    \      // and there is a dot in the file's name\n        if version.len() <= 3\
    \ && file_name.contains('.') {\n            String::from(\"Yes\")\n        }\n\
    \        // return 'No' otherwise\n        else {\n            String::from(\"\
    No\")\n        }\n    }\n    // return 'No' if the file's name doesn't match the\
    \ pattern of the regex\n    else {\n        String::from(\"No\")\n    }", "  \
    \  if file_name.chars().filter(|c| c.is_digit(10)).count() > 3 {\n        return\
    \ \"No\".to_string();\n    }\n    let vec: Vec<&str> = file_name.split(\".\").collect();\n\
    \    if vec.len() != 2 {\n        return \"No\".to_string();\n    }\n    if vec[0].is_empty()\
    \ || !vec[0].chars().all(|c| c.is_alphabetic()) {\n        return \"No\".to_string();\n\
    \    }\n    if vec[1] != \"txt\" && vec[1] != \"exe\" && vec[1] != \"dll\" {\n\
    \        return \"No\".to_string();\n    }\n    \"Yes\".to_string()", "    lazy_static!\
    \ {\n        static ref RE_GOOD_NAME: Regex = Regex::new(r\"^[a-zA-Z]\\w{0,24}\\\
    .(txt|exe|dll)$\").unwrap();\n    }\n    if RE_GOOD_NAME.is_match(&file_name)\
    \ {\n        \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n \
    \   }", "    if file_name.matches(char::is_numeric).count() > 3 {\n        return\
    \ \"No\".to_string();\n    }\n\n    let parts: Vec<&str> = file_name.split('.').collect();\n\
    \    if parts.len() != 2 {\n        return \"No\".to_string();\n    }\n\n    if\
    \ !parts[0].chars().next().unwrap().is_alphabetic() {\n        return \"No\".to_string();\n\
    \    }\n\n    match parts[1] {\n        \"txt\" | \"exe\" | \"dll\" => \"Yes\"\
    .to_string(),\n        _ => \"No\".to_string(),\n    }", "    // TODO\n    let\
    \ re = Regex::new(r\"([a-zA-Z]+)(\\d{0,3})\\.(exe|txt|dll)\").unwrap();\n    if\
    \ re.is_match(&file_name) {\n        \"Yes\".to_string()\n    } else {\n     \
    \   \"No\".to_string()\n    }", "  let mut count_digits = 0;\n  let mut found_dot\
    \ = false;\n  let mut found_alphabet = false;\n  let mut count_alphabet = 0;\n\
    \  let mut string_before_dot = String::new();\n  let mut string_after_dot = String::new();\n\
    \  let mut found_valid_after_dot = false;\n  for c in file_name.chars() {\n  \
    \  if c.is_ascii_digit() {\n      count_digits += 1;\n    }\n    if c == '.' {\n\
    \      found_dot = true;\n    }\n    if c.is_ascii_alphabetic() {\n      found_alphabet\
    \ = true;\n      count_alphabet += 1;\n    }\n  }\n  if count_digits > 3 {\n \
    \   return String::from(\"No\");\n  }\n  if !found_dot {\n    return String::from(\"\
    No\");\n  }\n  if !found_alphabet {\n    return String::from(\"No\");\n  }\n \
    \ let mut count_from_beginning = 0;\n  for c in file_name.chars() {\n    if c\
    \ == '.' {\n      count_from_beginning += 1;\n      break;\n    }\n    string_before_dot.push(c);\n\
    \    count_from_beginning += 1;\n  }\n  if string_before_dot.len() == 0 {\n  \
    \  return String::from(\"No\");\n  }\n  let mut count_from_end = 0;\n  for c in\
    \ file_name.chars().rev() {\n    if c == '.' {\n      count_from_end += 1;\n \
    \     break;\n    }\n    string_after_dot.push(c);\n    count_from_end += 1;\n\
    \  }\n  let string_after_dot = string_after_dot.chars().rev().collect::<String>();\n\
    \  if string_after_dot.len() == 0 {\n    return String::from(\"No\");\n  }\n \
    \ let mut file_extensions = vec![\"txt\", \"exe\", \"dll\"];\n  for file_extension\
    \ in file_extensions {", "    let mut num_of_digits = 0;\n    let mut dot_index\
    \ = 0;\n    let mut dot_exists = false;\n    let mut letters_before_dot = false;\n\
    \    let mut is_valid = true;\n    for (i, c) in file_name.chars().enumerate()\
    \ {\n        if c.is_digit(10) {\n            num_of_digits += 1;\n        }\n\
    \        if c == '.' {\n            dot_index = i;\n            dot_exists = true;\n\
    \        }\n        if c.is_ascii_alphabetic() {\n            letters_before_dot\
    \ = true;\n        }\n    }\n    if num_of_digits > 3 || !dot_exists || !letters_before_dot\
    \ {\n        is_valid = false;\n    }\n    let substring_after_dot = file_name.get(dot_index+1..).unwrap();\n\
    \    if !substring_after_dot.eq_ignore_ascii_case(\"txt\") &&\n       !substring_after_dot.eq_ignore_ascii_case(\"\
    exe\") &&\n       !substring_after_dot.eq_ignore_ascii_case(\"dll\") {\n     \
    \      is_valid = false;\n       }\n    if is_valid {\n        return String::from(\"\
    Yes\");\n    }\n    return String::from(\"No\");", "  let valid_extensions = [\"\
    txt\", \"exe\", \"dll\"];\n  let mut found_dots = 0;\n  let mut found_digits =\
    \ 0;\n  let mut is_valid = true;\n  let mut index = 0;\n  let mut last_index =\
    \ 0;\n  let mut extension_index = 0;\n  let mut is_pre_dot_valid = false;\n  let\
    \ mut is_post_dot_valid = false;\n  for c in file_name.chars() {\n    if c ==\
    \ '.' {\n      if found_dots == 0 {\n        is_pre_dot_valid = index == 0 ? false\
    \ : true;\n        last_index = index;\n        found_dots += 1;\n      } else\
    \ {\n        is_valid = false;\n        break;\n      }\n    } else if c >= '0'\
    \ && c <= '9' {\n      found_digits += 1;\n    } else if c >= 'a' && c <= 'z'\
    \ {\n      is_pre_dot_valid = true;\n    } else if c >= 'A' && c <= 'Z' {\n  \
    \    is_pre_dot_valid = true;\n    } else {\n      is_valid = false;\n      break;\n\
    \    }\n    index += 1;\n  }\n  if found_dots == 1 && found_digits <= 3 && is_pre_dot_valid\
    \ && is_valid {\n    let after_dot = &file_name[last_index+1..index];\n    extension_index\
    \ = 0;\n    for ext in valid_extensions.iter() {\n      if ext == after_dot {\n\
    \        is_post_dot_valid = true;\n        break;\n      }\n      extension_index\
    \ += 1;\n    }\n  }\n  if is_valid && is_pre_dot_valid && is_post_dot_valid {\n\
    \    return \"Yes\".to_string();\n  }\n  return \"No\".to_string();", "    let\
    \ re = Regex::new(r\"^[a-zA-Z]+\\d{0,3}\\.(txt|exe|dll)$\").unwrap();\n    if\
    \ re.is_match(&file_name) {\n        String::from(\"Yes\")\n    } else {\n   \
    \     String::from(\"No\")\n    }", "    lazy_static! {\n        static ref DIGITS_REGEX:\
    \ Regex = Regex::new(r\"[0-9]{4,}\").unwrap();\n        static ref VALID_EXTENSIONS:\
    \ HashSet<&'static str> = [\"txt\", \"exe\", \"dll\"].iter().cloned().collect();\n\
    \    }\n\n    let dot_index = file_name.find('.').ok_or(\"file name has no extension\"\
    )?;\n    if dot_index == 0 {\n        return \"No\".to_string();\n    }\n    let\
    \ (name, extension) = file_name.split_at(dot_index);\n    let extension = &extension[1..];\n\
    \n    if DIGITS_REGEX.is_match(name) {\n        return \"No\".to_string();\n \
    \   }\n    if !VALID_EXTENSIONS.contains(extension) {\n        return \"No\".to_string();\n\
    \    }\n    \"Yes\".to_string()", "    if file_name.chars().filter(|c| c.is_digit(10)).count()\
    \ > 3 {\n        return \"No\".to_string();\n    }\n    let parts: Vec<&str> =\
    \ file_name.split('.').collect();\n    if parts.len() != 2 {\n        return \"\
    No\".to_string();\n    }\n    let (first, second) = (parts[0], parts[1]);\n  \
    \  if first.is_empty() || !first.chars().next().unwrap().is_alphabetic() {\n \
    \       return \"No\".to_string();\n    }\n    if ![\"txt\", \"exe\", \"dll\"\
    ].contains(&second) {\n        return \"No\".to_string();\n    }\n    \"Yes\"\
    .to_string()", "    if file_name.split(\".\").collect::<Vec<&str>>().len() !=\
    \ 2 {\n        return \"No\".to_string();\n    }\n    let file_name_parts = file_name.split(\"\
    .\").collect::<Vec<&str>>();\n    let mut numbers = 0;\n    for c in file_name_parts[0].chars()\
    \ {\n        if !c.is_alphabetic() {\n            numbers += 1;\n        }\n \
    \   }\n    if numbers > 3 {\n        return \"No\".to_string();\n    }\n    if\
    \ file_name_parts[1] != \"txt\" && file_name_parts[1] != \"exe\" && file_name_parts[1]\
    \ != \"dll\" {\n        return \"No\".to_string();\n    }\n    \"Yes\".to_string()",
  "    let digits = \"0123456789\";\n    let allowed_extensions = [\"txt\", \"exe\"\
    , \"dll\"];\n    let mut digits_count = 0;\n    let mut is_pre_dot_ok = false;\n\
    \    let mut is_post_dot_ok = false;\n    let mut is_extension_ok = false;\n \
    \   let mut dot_count = 0;\n    let mut is_dot_ok = false;\n    let mut i = 0;\n\
    \    let mut ext = \"\";\n    for c in file_name.chars() {\n        if c == '.'\
    \ {\n            dot_count += 1;\n            is_dot_ok = true;\n            i\
    \ = 1;\n        } else if c.is_alphabetic() && i == 0 {\n            is_pre_dot_ok\
    \ = true;\n        } else if c.is_alphabetic() && i == 1 {\n            ext.push(c);\n\
    \        } else if digits.contains(c) {\n            digits_count += 1;\n    \
    \    }\n    }\n    if digits_count <= 3 {\n        is_post_dot_ok = true;\n  \
    \  }\n    for extension in allowed_extensions.iter() {\n        if extension ==\
    \ &ext {\n            is_extension_ok = true;\n        }\n    }\n    if is_pre_dot_ok\
    \ && is_post_dot_ok && is_dot_ok && is_extension_ok && dot_count == 1 {\n    \
    \    \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n    }", " \
    \   let mut count = 0;\n    let mut dot_found = false;\n    let mut number_found\
    \ = false;\n    let mut valid_name = false;\n    let mut valid_extension = false;\n\
    \    let mut valid_no_extension = false;\n    let parts: Vec<&str> = file_name.split('.').collect();\n\
    \    if parts.len() == 2 {\n        for c in parts[0].chars() {\n            if\
    \ !c.is_digit(10) {\n                if c.is_alphabetic() {\n                \
    \    if valid_name == false {\n                        valid_name = true;\n  \
    \                  }\n                } else {\n                    return \"\
    No\".to_string();\n                }\n            } else {\n                number_found\
    \ = true;\n                count += 1;\n            }\n        }\n        if count\
    \ > 3 {\n            return \"No\".to_string();\n        }\n        if parts[1]\
    \ == \"txt\" || parts[1] == \"exe\" || parts[1] == \"dll\" {\n            valid_extension\
    \ = true;\n        }\n    } else if parts.len() == 1 {\n        valid_no_extension\
    \ = true;\n    }\n    if valid_extension && valid_name {\n        return \"Yes\"\
    .to_string();\n    } else if valid_no_extension && valid_name {\n        return\
    \ \"Yes\".to_string();\n    } else {\n        return \"No\".to_string();\n   \
    \ }", "    let mut num = 0;\n    let mut dot = false;\n    let mut dot_pos = 0;\n\
    \    let mut extension = String::new();\n    let mut valid = true;\n    let mut\
    \ i = 0;\n    while i < file_name.len() {\n        if file_name.chars().nth(i).unwrap().is_ascii_digit()\
    \ {\n            num += 1;\n        }\n        if file_name.chars().nth(i).unwrap()\
    \ == '.' {\n            dot = true;\n            dot_pos = i;\n        }\n   \
    \     i += 1;\n    }\n    for j in dot_pos + 1..file_name.len() {\n        extension.push(file_name.chars().nth(j).unwrap());\n\
    \    }\n    if num > 3 || !dot || extension.len() == 0 || \n        (file_name.chars().nth(0).unwrap().is_ascii_digit()\
    \ && \n        !file_name.chars().nth(0).unwrap().is_ascii_lowercase() && \n \
    \       !file_name.chars().nth(0).unwrap().is_ascii_uppercase()) || \n       \
    \ (extension != \"txt\" && extension != \"exe\" && extension != \"dll\") {\n \
    \       valid = false;\n    }\n    if valid {\n        return String::from(\"\
    Yes\");\n    }\n    else {\n        return String::from(\"No\");\n    }", "  \
    \  // check number of digits\n    let d_count = file_name.matches(char::is_numeric).count();\n\
    \    if d_count > 3 {\n        return String::from(\"No\");\n    }\n\n    // check\
    \ dot '.'\n    let dot_count = file_name.matches('.').count();\n    if dot_count\
    \ != 1 {\n        return String::from(\"No\");\n    }\n\n    // check substring\
    \ before '.'\n    let parts: Vec<&str> = file_name.split('.').collect();\n   \
    \ let sub_before_dot = parts[0];\n    if sub_before_dot.is_empty() {\n       \
    \ return String::from(\"No\");\n    }\n    if !(sub_before_dot.chars().next().unwrap().is_alphabetic())\
    \ {\n        return String::from(\"No\");\n    }\n\n    // check substring after\
    \ '.'\n    let sub_after_dot = parts[1];\n    let valid_strings = [\"txt\", \"\
    exe\", \"dll\"];\n    if !valid_strings.contains(&sub_after_dot) {\n        return\
    \ String::from(\"No\");\n    }\n\n    return String::from(\"Yes\");", "    //Solution\
    \ Code Here\n    \"Yes\".to_string()", "    let digit_regex = Regex::new(r\"\\\
    d\").unwrap();\n    let ext_regex = Regex::new(r\"\\.[a-zA-Z]{2,4}$\").unwrap();\n\
    \    let filename_regex = Regex::new(r\"[a-zA-Z]{1}[a-zA-Z0-9]*\").unwrap();\n\
    \    let digit_count = digit_regex.find_iter(&file_name).count();\n    if (digit_count\
    \ > 3) ||\n        (file_name.contains('.') == false) ||\n        (ext_regex.is_match(&file_name)\
    \ == false) ||\n        (filename_regex.is_match(&file_name.split('.').next().unwrap())\
    \ == false) {\n        return String::from(\"No\");\n    }\n    String::from(\"\
    Yes\")", "    let mut digits = 0;\n    let mut dot = false;\n    let mut position\
    \ = 0;\n    let mut extension = false;\n    for c in file_name.chars() {\n   \
    \     if c == '.' {\n            dot = true;\n            position = 0;\n    \
    \    } else if c.is_digit(10) {\n            digits += 1;\n        } else if c.is_alphabetic()\
    \ {\n            if position == 0 {\n                if c.is_uppercase() {\n \
    \                   return \"No\".to_string();\n                }\n          \
    \  } else {\n                extension = true;\n            }\n            position\
    \ += 1;\n        } else {\n            return \"No\".to_string();\n        }\n\
    \    }\n    if !extension || !dot || digits > 3 {\n        return \"No\".to_string();\n\
    \    }\n    \"Yes\".to_string()", "    lazy_static! {\n        static ref REGEX:\
    \ Regex = Regex::new(r\"^[a-zA-Z][a-zA-Z0-9]{0,3}\\.(txt|exe|dll)$\").unwrap();\n\
    \    }\n    match REGEX.is_match(&file_name) {\n        true => \"Yes\".to_string(),\n\
    \        false => \"No\".to_string(),\n    }", "    fn is_letter(c: char) -> bool\
    \ {\n        return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');\n    }\n\
    \n    fn is_digit(c: char) -> bool {\n        return c >= '0' && c <= '9';\n \
    \   }\n\n    fn letter_digits_count(s: &str) -> usize {\n        let mut count\
    \ = 0;\n        for c in s.chars() {\n            if is_letter(c) || is_digit(c)\
    \ {\n                count += 1;\n            }\n        }\n        return count;\n\
    \    }\n\n    fn digit_count(s: &str) -> usize {\n        let mut count = 0;\n\
    \        for c in s.chars() {\n            if is_digit(c) {\n                count\
    \ += 1;\n            }\n        }\n        return count;\n    }\n\n    if file_name.len()\
    \ <= 4 {\n        return \"No\".to_string();\n    }\n\n    let mut in_ext = false;\n\
    \    let mut count_digits = 0;\n    let mut dot_found = false;\n    let mut letters_found\
    \ = false;\n    let mut ext_valid = false;\n    for c in file_name.chars() {\n\
    \        if c == '.' {\n            if dot_found || count_digits > 3 {\n     \
    \           return \"No\".to_string();\n            }\n            dot_found =\
    \ true;\n            in_ext = true;\n            continue;\n        }\n\n    \
    \    if !in_ext {\n            if is_letter(c) {\n                letters_found\
    \ = true;\n            } else if is_digit(c) {\n                count_digits +=\
    \ 1;\n            } else {\n                return \"No\".to_string();\n     \
    \       }\n        } else {\n            if !is_letter(c) {\n                return\
    \ \"No\".to_string();\n            }\n        }\n    }\n\n    if !dot_found ||\
    \ !letters_found || count_digits > 3 {\n        return \"No\".to_string();\n \
    \   }\n\n    let parts: Vec<&str> = file_name.split", "    let name_without_extension:\
    \ &str = &file_name.split(\".\").collect::<Vec<&str>>()[0];\n    let extension:\
    \ &str = &file_name.split(\".\").collect::<Vec<&str>>()[1];\n    if name_without_extension.len()\
    \ == 0 || name_without_extension.contains(\" \") {\n        return \"No\".to_string();\n\
    \    }\n    if name_without_extension.chars().any(|x| x.is_digit(10)) {\n    \
    \    return \"No\".to_string();\n    }\n    let count_digits = name_without_extension.chars().filter(|x|\
    \ x.is_digit(10)).count();\n    if count_digits > 3 {\n        return \"No\".to_string();\n\
    \    }\n    let valid_extensions = vec![\"txt\", \"exe\", \"dll\"];\n    if !valid_extensions.contains(&extension)\
    \ {\n        return \"No\".to_string();\n    }\n    \"Yes\".to_string()", "  \
    \  let mut count = 0;\n    let mut contains_dot = false;\n    let mut string_before_dot\
    \ = \"\".to_string();\n    let mut string_after_dot = \"\".to_string();\n    for\
    \ c in file_name.chars() {\n        if c == '.' {\n            contains_dot =\
    \ true;\n            continue;\n        }\n\n        if contains_dot {\n     \
    \       string_after_dot += &c.to_string();\n        } else {\n            string_before_dot\
    \ += &c.to_string();\n        }\n\n        if c.is_digit(10) {\n            count\
    \ += 1;\n        }\n    }\n\n    if count > 3 {\n        return \"No\".to_string();\n\
    \    }\n\n    if !contains_dot {\n        return \"No\".to_string();\n    }\n\n\
    \    if string_before_dot.is_empty() {\n        return \"No\".to_string();\n \
    \   }\n\n    let first_char = string_before_dot.chars().next().unwrap();\n   \
    \ if !first_char.is_alphabetic() {\n        return \"No\".to_string();\n    }\n\
    \n    let extensions = vec![\"txt\", \"exe\", \"dll\"];\n    if !extensions.contains(&string_after_dot.as_str())\
    \ {\n        return \"No\".to_string();\n    }\n\n    \"Yes\".to_string()", " \
    \   let is_number = (|c: char| c.is_digit(10)) as fn(char) -> bool;\n    let is_invalid_extension\
    \ = (|c: char| match c {\n        't' | 'x' | 'd' => false,\n        _ => true,\n\
    \    }) as fn(char) -> bool;\n    let is_invalid_name = (|c: char| match c {\n\
    \        '.' => true,\n        _ => c.is_digit(10),\n    }) as fn(char) -> bool;\n\
    \    let mut name = file_name.to_string();\n    let mut is_ok = true;\n    let\
    \ mut counter = 0;\n    if name.len() > 1 {\n        let extension = name.split('.').collect::<Vec<&str>>();\n\
    \        if extension.len() != 2 {\n            is_ok = false;\n        } else\
    \ {\n            let mut extension = extension[1].to_string();\n            extension.retain(is_invalid_extension);\n\
    \            if extension.len() != 0 {\n                is_ok = false;\n     \
    \       }\n        }\n        name.retain(is_invalid_name);\n        if name.len()\
    \ != 0 {\n            is_ok = false;\n        }\n        name = file_name.to_string();\n\
    \        let mut name = name.split('.').collect::<Vec<&str>>();\n        name.remove(1);\n\
    \        name = name[0].split('').collect::<Vec<&str>>();\n        for i in name\
    \ {\n            if i.chars().all(is_number) {\n                counter += 1;\n\
    \            }\n        }\n        if counter > 3 {\n            is_ok = false;\n\
    \        }\n    } else {\n        is_ok = false;\n    }\n    if is_ok {\n    \
    \    \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n    }", " \
    \   let mut count = 0;\n    let splits: Vec<&str> = file_name.split('.').collect();\n\
    \    if splits.len() != 2 {\n        return \"No\".to_string();\n    }\n    for\
    \ ch in splits[0].chars() {\n        if !ch.is_ascii_alphabetic() {\n        \
    \    return \"No\".to_string();\n        }\n    }\n    for ch in splits[1].chars()\
    \ {\n        if ch.is_ascii_digit() {\n            count += 1;\n        }\n  \
    \  }\n    if count > 3 {\n        return \"No\".to_string();\n    }\n    if splits[1]\
    \ == \"txt\" || splits[1] == \"exe\" || splits[1] == \"dll\" {\n        return\
    \ \"Yes\".to_string();\n    }\n    \"No\".to_string()", "    if file_name.chars().filter(|&c|\
    \ c.is_digit(10)).count() > 3 {\n        \"No\".to_string()\n    } else if file_name.matches('.').count()\
    \ != 1 {\n        \"No\".to_string()\n    } else if file_name.split('.').next().unwrap().len()\
    \ == 0 ||\n              !file_name.split('.').next().unwrap().chars().next().unwrap().is_alphabetic()\
    \ {\n        \"No\".to_string()\n    } else if !(file_name.ends_with(\".txt\"\
    ) || file_name.ends_with(\".exe\") || file_name.ends_with(\".dll\")) {\n     \
    \   \"No\".to_string()\n    } else {\n        \"Yes\".to_string()\n    }", " \
    \   if file_name.chars().filter(|c| c.is_digit(10)).count() > 3 {\n        \"\
    No\".to_string()\n    } else if file_name.split('.').count() != 2 {\n        \"\
    No\".to_string()\n    } else if file_name.starts_with(|c: char| !c.is_alphabetic())\
    \ {\n        \"No\".to_string()\n    } else if ![\"txt\", \"exe\", \"dll\"].contains(&file_name.split('.').collect::<Vec<&str>>()[1])\
    \ {\n        \"No\".to_string()\n    } else {\n        \"Yes\".to_string()\n \
    \   }", "    let re = Regex::new(r\"^[a-zA-Z]+[0-9]{0,3}\\.[a-zA-Z]{3}$\").unwrap();\n\
    \    match re.is_match(&file_name) {\n        true => \"Yes\".to_string(),\n \
    \       false => \"No\".to_string(),\n    }", "    // let re = regex::Regex::new(r\"\
    ^[a-zA-Z]+[0-9]{0,3}\\.[txt|exe|dll]$\").unwrap();\n    let re = regex::Regex::new(r\"\
    ^[a-zA-Z]+[0-9]{0,3}\\.(txt|exe|dll)$\").unwrap();\n    if re.is_match(&file_name)\
    \ {\n        String::from(\"Yes\")\n    } else {\n        String::from(\"No\"\
    )\n    }", "    // convert the string to an array of characters\n    let mut chars:\
    \ Vec<char> = file_name.chars().collect();\n    // get the length of the array\n\
    \    let length = chars.len();\n    // check that the string is longer than 0\n\
    \    if length > 0 {\n        // locate the dot (.)\n        let dot = chars.iter().position(|&r|\
    \ r == '.');\n        // check that the dot exists\n        if dot.is_some() {\n\
    \            // get the index of the dot\n            let dot_index = dot.unwrap();\n\
    \            // check that the dot is not the first character\n            if\
    \ dot_index > 0 {\n                // get the index of the last character\n  \
    \              let last_index = length - 1;\n                // check that the\
    \ dot is not the last character\n                if dot_index < last_index {\n\
    \                    // check that the dot only exists once\n                \
    \    if file_name.matches(\".\").count() == 1 {\n                        // get\
    \ the characters before the dot\n                        let prefix: String =\
    \ chars[0..dot_index].iter().collect();\n                        // check that\
    \ the prefix is not empty and has 1 letter\n                        if prefix.len()\
    \ > 0 && prefix.len() < 2 {\n                            // check that the prefix\
    \ starts with a letter\n                            if prefix.chars().next().unwrap().is_alphabetic()\
    \ {\n                                // get the characters after the dot\n   \
    \                             let postfix: String = chars[dot_index + 1..length].iter().collect();\n\
    \                                // check that the postfix has 3 characters\n\
    \                                if postfix.len() == 3 {\n                   \
    \                 // check that the postfix is 1 of the legal postfixes\n    \
    \                                if postfix == \"txt\" || postfix == \"exe\" ||\
    \ postfix == \"dll\" {\n                                        // get the characters\
    \ that are digits ('0'-'9')\n                                        let digits:\
    \ Vec<char> = chars.iter().filter(|&r| r.is_digit(10)).collect();\n          \
    \                              // get the length of the digits array\n       \
    \                                 let digits_length = digits.len();\n        \
    \                                // check that the number of digits is less than\
    \ 4\n                                        if digits_length < 4 {\n        \
    \                        ", "    let mut count = 0;\n    let mut before_dot =\
    \ String::new();\n    let mut after_dot = String::new();\n    let mut found_dot\
    \ = false;\n    for ch in file_name.chars() {\n        if ch == '.' {\n      \
    \      found_dot = true;\n        } else if ch >= '0' && ch <= '9' {\n       \
    \     count += 1;\n        } else if !found_dot {\n            before_dot.push(ch);\n\
    \        } else {\n            after_dot.push(ch);\n        }\n    }\n    if count\
    \ > 3 || before_dot.is_empty() || !before_dot.chars().next().unwrap().is_ascii_alphabetic()\
    \ {\n        \"No\".to_string()\n    } else if after_dot != \"txt\" && after_dot\
    \ != \"exe\" && after_dot != \"dll\" {\n        \"No\".to_string()\n    } else\
    \ {\n        \"Yes\".to_string()\n    }", "    if let Some(location) = file_name.find('.')\
    \ {\n        let (before, after) = file_name.split_at(location);\n        let\
    \ after = &after[1..];\n        if before.len() == 0 || before.len() > 4 {\n \
    \           return \"No\".to_string();\n        }\n        if !before.chars().nth(0).unwrap().is_alphabetic()\
    \ {\n            return \"No\".to_string();\n        }\n        let digits = before.chars().filter(|x|\
    \ x.is_numeric()).count();\n        if digits > 3 {\n            return \"No\"\
    .to_string();\n        }\n        if !&[\"txt\", \"exe\", \"dll\"].contains(&after)\
    \ {\n            return \"No\".to_string();\n        }\n        return \"Yes\"\
    .to_string();\n    }\n    \"No\".to_string()", "    match file_name.matches(char::is_numeric).count()\
    \ {\n        n if n > 3 => \"No\".to_string(),\n        _ => match file_name.matches('.').count()\
    \ {\n            1 => match file_name.split('.').collect::<Vec<&str>>() {\n  \
    \              vec if vec[0].is_empty() => \"No\".to_string(),\n             \
    \   vec if vec[0].chars().next().unwrap().is_alphabetic() =>\n               \
    \     match vec[1] {\n                        \"txt\" | \"exe\" | \"dll\" => \"\
    Yes\".to_string(),\n                        _ => \"No\".to_string(),\n       \
    \             },\n                _ => \"No\".to_string(),\n            },\n \
    \           _ => \"No\".to_string(),\n        },\n    }", "    let mut res = String::from(\"\
    No\");\n    let mut digits = String::from(\"\");\n    let mut name = String::from(\"\
    \");\n    let mut ext = String::from(\"\");\n    let mut dot_count = 0;\n    for\
    \ c in file_name.chars() {\n        if c == '.' {\n            dot_count += 1;\n\
    \            continue;\n        }\n        if c >= '0' && c <= '9' {\n       \
    \     digits.push(c);\n        }\n        if dot_count == 0 {\n            name.push(c);\n\
    \        } else {\n            ext.push(c);\n        }\n    }\n    if digits.len()\
    \ <= 3 && dot_count == 1 && name.len() != 0 &&\n        ext == \"txt\" || ext\
    \ == \"exe\" || ext == \"dll\" {\n        res = String::from(\"Yes\");\n    }\n\
    \    res", "    if file_name.len() > 31 {\n        return \"No\".to_string();\n\
    \    }\n    let ext_split: Vec<&str> = file_name.split(\".\").collect();\n   \
    \ if ext_split.len() != 2 {\n        return \"No\".to_string();\n    }\n    if\
    \ ext_split[0].len() == 0 || !ext_split[0].chars().next().unwrap().is_alphabetic()\
    \ {\n        return \"No\".to_string();\n    }\n    if ext_split[1] != \"txt\"\
    \ && ext_split[1] != \"exe\" && ext_split[1] != \"dll\" {\n        return \"No\"\
    .to_string();\n    }\n    let mut num_digits = 0;\n    for c in ext_split[0].chars()\
    \ {\n        if c.is_numeric() {\n            num_digits += 1;\n        }\n  \
    \  }\n    if num_digits > 3 {\n        return \"No\".to_string();\n    }\n   \
    \ \"Yes\".to_string()", "    if file_name.len() < 3 {\n        return \"No\".to_string();\n\
    \    }\n    let mut digits_count = 0;\n    let mut dot_count = 0;\n    let mut\
    \ valid_file_type = false;\n    let mut previous_char = ' ';\n    for ch in file_name.chars()\
    \ {\n        if ch.is_digit(10) {\n            digits_count += 1;\n        }\n\
    \        if ch == '.' {\n            dot_count += 1;\n        }\n        if dot_count\
    \ == 1 && !valid_file_type {\n            let file_type = file_name.chars().skip_while(|c|\
    \ *c != '.').skip(1).collect::<String>();\n            valid_file_type = file_type\
    \ == \"txt\" || file_type == \"exe\" || file_type == \"dll\";\n        }\n   \
    \     if dot_count == 1 && previous_char == '.' {\n            return \"No\".to_string();\n\
    \        }\n        previous_char = ch;\n    }\n    if digits_count > 3 || dot_count\
    \ != 1 || !valid_file_type {\n        return \"No\".to_string();\n    }\n    \"\
    Yes\".to_string()", "    match file_name.split('.').collect::<Vec<&str>>().as_slice()\
    \ {\n        [a, b] => match b {\n            \"txt\" | \"exe\" | \"dll\" => match\
    \ a.chars().fold(0, |acc, c| if c.is_digit(10) { acc + 1 } else { acc }) {\n \
    \               3 => return \"No\".to_string(),\n                _ => return \"\
    Yes\".to_string(),\n            },\n            _ => return \"No\".to_string(),\n\
    \        },\n        _ => return \"No\".to_string(),\n    }", "    let mut alphabet\
    \ = false;\n    let mut count = 0;\n    let mut dot = false;\n    let mut extension\
    \ = false;\n    let valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    for c\
    \ in file_name.chars() {\n        if c.is_alphabetic() {\n            alphabet\
    \ = true;\n        }\n        if c.is_numeric() {\n            count += 1;\n \
    \       }\n        if c == '.' {\n            dot = true;\n        }\n    }\n\
    \    if dot {\n        let file_parts: Vec<&str> = file_name.split('.').collect();\n\
    \        for ext in valid_extensions.iter() {\n            if file_parts[1] ==\
    \ *ext {\n                extension = true;\n            }\n        }\n    }\n\
    \    if alphabet && dot && extension && count <= 3 {\n        return \"Yes\".to_string();\n\
    \    }\n    return \"No\".to_string();", "    let mut count_digit = 0;\n    let\
    \ mut has_dot = false;\n    let mut has_pre_dot = false;\n    let mut has_post_dot\
    \ = false;\n    let mut position_dot = 0;\n    let mut position_digit = 0;\n \
    \   let mut char_vec: Vec<char> = file_name.chars().collect();\n    for (index,\
    \ c) in char_vec.iter().enumerate() {\n        if c.is_digit(10) {\n         \
    \   count_digit += 1;\n            position_digit = index;\n        }\n      \
    \  if c == &'.' {\n            has_dot = true;\n            position_dot = index;\n\
    \        }\n    }\n    if !has_dot || position_dot == 0 || position_dot + 1 ==\
    \ char_vec.len() {\n        return \"No\".to_string();\n    }\n    if count_digit\
    \ > 3 {\n        return \"No\".to_string();\n    }\n    if position_digit > position_dot\
    \ {\n        return \"No\".to_string();\n    }\n    let pre_dot: String = char_vec[0..position_dot].iter().collect();\n\
    \    let post_dot: String = char_vec[position_dot + 1..char_vec.len()].iter().collect();\n\
    \    if pre_dot.len() == 0 {\n        return \"No\".to_string();\n    }\n    if\
    \ post_dot.len() == 0 {\n        return \"No\".to_string();\n    }\n    let pre_dot_first_char\
    \ = pre_dot.chars().nth(0).unwrap();\n    if pre_dot_first_char.is_alphabetic()\
    \ {\n        has_pre_dot = true;\n    }\n    let mut post_dot_vec: Vec<&str> =\
    \ vec![\"txt\", \"exe\", \"dll\"];\n    for elem in post_dot_vec.iter() {\n  \
    \      if post_dot == elem.to_string() {\n            has_post_dot = true;\n \
    \       }\n    }\n    if has_dot && has_pre_dot && has_post_dot {\n        return\
    \ \"Yes\".", "    let (before_dot, after_dot) = file_name.split_at(file_name.find('.').unwrap());\n\
    \    let after_dot = &after_dot[1..];\n    if !(after_dot == \"txt\" || after_dot\
    \ == \"exe\" || after_dot == \"dll\") {\n        return \"No\".to_string();\n\
    \    }\n    if !(before_dot.starts_with(char::is_alphabetic)) {\n        return\
    \ \"No\".to_string();\n    }\n    if before_dot.chars().filter(|&x| x.is_digit(10)).count()\
    \ > 3 {\n        return \"No\".to_string();\n    }\n    return \"Yes\".to_string();",
  "    let mut s = file_name.split(\".\");\n    let name = s.next().unwrap();\n  \
    \  let ext = s.next().unwrap();\n    if name.is_empty() || name.len() > 10 ||\
    \ ext.len() > 3 {\n        \"No\".to_string()\n    } else {\n        let mut chars\
    \ = name.chars();\n        if !is_alphabetic(chars.next().unwrap()) {\n      \
    \      \"No\".to_string()\n        } else {\n            let mut num_digits =\
    \ 0;\n            for ch in chars {\n                if is_numeric(ch) {\n   \
    \                 num_digits += 1;\n                }\n            }\n       \
    \     if num_digits > 3 {\n                \"No\".to_string()\n            } else\
    \ {\n                let valid_extensions = [\"txt\", \"exe\", \"dll\"];\n   \
    \             if valid_extensions.contains(&ext) {\n                    \"Yes\"\
    .to_string()\n                } else {\n                    \"No\".to_string()\n\
    \                }\n            }\n        }\n    }", "    println!(\"file_name:\
    \ {}\", file_name);\n    let mut iter = file_name.chars();\n    let mut num_digits\
    \ = 0;\n    let mut num_dots = 0;\n    let mut has_dot = false;\n    let mut first_char_is_letter\
    \ = false;\n    let mut last_char_is_txt = false;\n    let mut last_char_is_exe\
    \ = false;\n    let mut last_char_is_dll = false;\n    while let Some(x) = iter.next()\
    \ {\n        if x == '.' {\n            has_dot = true;\n            num_dots\
    \ += 1;\n        }\n        if x.is_digit(10) {\n            num_digits += 1;\n\
    \        }\n        if x == 't' {\n            last_char_is_txt = true;\n    \
    \    }\n        if x == 'e' {\n            last_char_is_exe = true;\n        }\n\
    \        if x == 'd' {\n            last_char_is_dll = true;\n        }\n    \
    \    if x.is_alphabetic() {\n            first_char_is_letter = true;\n      \
    \  }\n    }\n    if !has_dot || !first_char_is_letter || num_dots > 1 || num_digits\
    \ > 3 {\n        String::from(\"No\")\n    } else if last_char_is_txt || last_char_is_exe\
    \ || last_char_is_dll {\n        String::from(\"Yes\")\n    } else {\n       \
    \ String::from(\"No\")\n    }", "    const ERROR_COUNT: &str = \"Yes\";\n    const\
    \ ERROR_DOT: &str = \"No\";\n    const ERROR_EXT: &str = \"No\";\n    const ERROR_PREFIX:\
    \ &str = \"No\";\n    const NO_ERROR: &str = \"Yes\";\n\n    let mut count = 0;\n\
    \    let mut dot_location = 0;\n    let mut first_letter = false;\n    let mut\
    \ file_extension = false;\n    let mut file_name_correct = true;\n\n    for (pos,\
    \ c) in file_name.chars().enumerate() {\n        match c {\n            '.' =>\
    \ {\n                dot_location = pos;\n                file_extension = true;\n\
    \            },\n            '0'...'9' => {\n                count += 1;\n   \
    \             if count > 3 {\n                    file_name_correct = false;\n\
    \                    break;\n                }\n            },\n            'a'...'z'\
    \ | 'A'...'Z' => {\n                if pos < dot_location {\n                \
    \    first_letter = true;\n                }\n            },\n            _ =>\
    \ {\n                file_name_correct = false;\n                break;\n    \
    \        }\n        }\n    }\n\n    if !file_name_correct {\n        return NO_ERROR.to_string();\n\
    \    }\n\n    if count > 3 {\n        return ERROR_COUNT.to_string();\n    }\n\
    \n    if !file_extension {\n        return ERROR_DOT.to_string();\n    }\n\n \
    \   let file_extension = &file_name[dot_location+1..];\n    if file_extension\
    \ == \"txt\" || file_extension == \"exe\" || file_extension == \"dll\" {\n   \
    \     if first_letter {\n            return NO_ERROR.to_string();\n        } else\
    \ {\n            return ERROR_PREFIX.to_string();\n        }\n    } else {\n \
    \       return ERROR_EXT.to_string();\n    }"]
stop_tokens:
- "\n}"
