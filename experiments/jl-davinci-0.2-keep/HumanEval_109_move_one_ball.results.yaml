name: HumanEval_109_move_one_ball
language: julia
results:
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    return true\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpvm1f0cmy.jl:38\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpvm1f0cmy.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvm1f0cmy.jl:35\ntest set: Test Failed at /tmp/tmpvm1f0cmy.jl:39\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpvm1f0cmy.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvm1f0cmy.jl:35\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpvm1f0cmy.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    # You can\
    \ add helper functions here\n    return false\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2]) == true)\n\t\
    @test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4, 3, 1, 2]) ==\
    \ false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpy308p0c_.jl:37\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\n   Evaluated: false == true\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpy308p0c_.jl:37\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpy308p0c_.jl:36\ntest set: Test Failed at /tmp/tmpy308p0c_.jl:38\n\
    \  Expression: candidate([3, 5, 10, 1, 2]) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpy308p0c_.jl:38\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpy308p0c_.jl:36\ntest set: Test Failed at /tmp/tmpy308p0c_.jl:41\n\
    \  Expression: candidate(Vector{Int64}([])) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpy308p0c_.jl:41\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpy308p0c_.jl:36\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     3      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpy308p0c_.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr)==0\n        return\
    \ true\n    end\n    if length(arr)==1\n        return true\n    end\n    if length(arr)==2\n\
    \        if arr[1]>arr[2]\n            return false\n        else\n          \
    \  return true\n        end\n    end\n    for i in 1:length(arr)-1\n        if\
    \ arr[i]>arr[i+1]\n            return false\n        end\n    end\n    return\
    \ true\nend\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp8rqpyirp.jl:53\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\n   Evaluated: false == true\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp8rqpyirp.jl:53\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8rqpyirp.jl:52\ntest set: Test Failed at /tmp/tmp8rqpyirp.jl:54\n\
    \  Expression: candidate([3, 5, 10, 1, 2]) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp8rqpyirp.jl:54\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8rqpyirp.jl:52\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8rqpyirp.jl:50\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr)==0\n        return\
    \ true\n    end\n    for i in 1:length(arr)\n        if arr[i]==i\n          \
    \  continue\n        elseif arr[i]==i+1\n            arr[i],arr[i+1]=arr[i+1],arr[i]\n\
    \        else\n            return false\n        end\n    end\n    return true\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpoh8wbzoq.jl:47\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\n   Evaluated: false == true\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpoh8wbzoq.jl:47\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpoh8wbzoq.jl:46\ntest set: Test Failed at /tmp/tmpoh8wbzoq.jl:48\n\
    \  Expression: candidate([3, 5, 10, 1, 2]) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpoh8wbzoq.jl:48\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpoh8wbzoq.jl:46\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpoh8wbzoq.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    return true\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpgxacd98i.jl:38\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpgxacd98i.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgxacd98i.jl:35\ntest set: Test Failed at /tmp/tmpgxacd98i.jl:39\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpgxacd98i.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgxacd98i.jl:35\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgxacd98i.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr)==0\n        return\
    \ true\n    end\n    if length(arr)==1\n        return true\n    end\n    if length(arr)==2\n\
    \        if arr[1]>arr[2]\n            return false\n        else\n          \
    \  return true\n        end\n    end\n    if length(arr)==3\n        if arr[1]>arr[2]\n\
    \            if arr[2]>arr[3]\n                return false\n            else\n\
    \                return true\n            end\n        else\n            if arr[1]>arr[3]\n\
    \                return false\n            else\n                return true\n\
    \            end\n        end\n    end\n    if length(arr)>3\n        if arr[1]>arr[2]\n\
    \            if arr[2]>arr[3]\n                return false\n            else\n\
    \                return true\n            end\n        else\n            if arr[1]>arr[3]\n\
    \                return false\n            else\n                return true\n\
    \            end\n        end\n    end\nend\nusing Test\n\n@testset begin\n\n\
    candidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2]) == true)\n\t@test(candidate([3,\
    \ 5, 10, 1, 2]) == true)\n\t@test(candidate([4, 3, 1, 2]) == false)\n\t@test(candidate([3,\
    \ 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([])) == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpwefieqm1.jl:80\n  Expression: candidate([3,\
    \ 5, 4, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpwefieqm1.jl:80\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwefieqm1.jl:76\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwefieqm1.jl:74\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    return true\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpz9e38gxu.jl:38\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpz9e38gxu.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpz9e38gxu.jl:35\ntest set: Test Failed at /tmp/tmpz9e38gxu.jl:39\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpz9e38gxu.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpz9e38gxu.jl:35\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpz9e38gxu.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    # You can\
    \ add helper functions as needed\n    return true\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2]) == true)\n\
    \t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4, 3, 1, 2])\
    \ == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp40qhm6lh.jl:39\\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\\n   Evaluated: true == false\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmp40qhm6lh.jl:39\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp40qhm6lh.jl:36\\ntest set: Test Failed at /tmp/tmp40qhm6lh.jl:40\\\
    n  Expression: candidate([3, 5, 4, 1, 2]) == false\\n   Evaluated: true == false\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp40qhm6lh.jl:40\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp40qhm6lh.jl:36\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    3     2      5\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr)==0\n        return\
    \ true\n    end\n    if length(arr)==1\n        return true\n    end\n    if length(arr)==2\n\
    \        if arr[1]>arr[2]\n            return false\n        else\n          \
    \  return true\n        end\n    end\n    if length(arr)==3\n        if arr[1]>arr[2]\n\
    \            if arr[2]>arr[3]\n                return false\n            else\n\
    \                return true\n            end\n        else\n            if arr[1]>arr[3]\n\
    \                return false\n            else\n                return true\n\
    \            end\n        end\n    end\n    if length(arr)>3\n        if arr[1]>arr[2]\n\
    \            if arr[2]>arr[3]\n                return false\n            else\n\
    \                return true\n            end\n        else\n            if arr[1]>arr[3]\n\
    \                return false\n            else\n                return true\n\
    \            end\n        end\n    end\nend\nusing Test\n\n@testset begin\n\n\
    candidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2]) == true)\n\t@test(candidate([3,\
    \ 5, 10, 1, 2]) == true)\n\t@test(candidate([4, 3, 1, 2]) == false)\n\t@test(candidate([3,\
    \ 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([])) == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpbz6ty2dl.jl:80\n  Expression: candidate([3,\
    \ 5, 4, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpbz6ty2dl.jl:80\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbz6ty2dl.jl:76\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbz6ty2dl.jl:74\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    # You can\
    \ add helper functions as needed\n    return true\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2]) == true)\n\
    \t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4, 3, 1, 2])\
    \ == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp746aoezv.jl:39\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp746aoezv.jl:39\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp746aoezv.jl:36\ntest set: Test Failed at /tmp/tmp746aoezv.jl:40\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp746aoezv.jl:40\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp746aoezv.jl:36\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp746aoezv.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # your code here\n    return true\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp651pm7x5.jl:38\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp651pm7x5.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp651pm7x5.jl:35\ntest set: Test Failed at /tmp/tmp651pm7x5.jl:39\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp651pm7x5.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp651pm7x5.jl:35\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp651pm7x5.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    # You can\
    \ add helper functions as needed\n    # You can add additional import statements\
    \ as needed\n    # You can use the built-in sort function\n    \n    # Your code\
    \ here\n    # You can add helper functions as needed\n    # You can add additional\
    \ import statements as needed\n    # You can use the built-in sort function\n\
    \    if length(arr) == 0\n        return true\n    end\n    if length(arr) ==\
    \ 1\n        return true\n    end\n    if length(arr) == 2\n        if arr[1]\
    \ > arr[2]\n            return false\n        else\n            return true\n\
    \        end\n    end\n    if length(arr) == 3\n        if arr[1] > arr[2]\n \
    \           if arr[2] > arr[3]\n                return false\n            else\n\
    \                return true\n            end\n        else\n            if arr[1]\
    \ > arr[3]\n                return false\n            else\n                return\
    \ true\n            end\n        end\n    end\n    if length(arr) > 3\n      \
    \  if arr[1] > arr[2]\n            if arr[2] > arr[3]\n                return\
    \ false\n            else\n                return true\n            end\n    \
    \    else\n            if arr[1] > arr[3]\n                return false\n    \
    \        else\n                return true\n            end\n        end\n   \
    \ end\nend\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp2leynrsk.jl:89\n  Expression: candidate([3,\
    \ 5, 4, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp2leynrsk.jl:89\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2leynrsk.jl:85\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2leynrsk.jl:83\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr)==0\n        return\
    \ true\n    end\n    if length(arr)==1\n        return true\n    end\n    if length(arr)==2\n\
    \        if arr[1]>arr[2]\n            return false\n        else\n          \
    \  return true\n        end\n    end\n    if length(arr)==3\n        if arr[1]>arr[2]\n\
    \            if arr[2]>arr[3]\n                return false\n            else\n\
    \                return true\n            end\n        else\n            if arr[1]>arr[3]\n\
    \                return false\n            else\n                return true\n\
    \            end\n        end\n    end\n    if length(arr)>3\n        if arr[1]>arr[2]\n\
    \            if arr[2]>arr[3]\n                return false\n            else\n\
    \                return true\n            end\n        else\n            if arr[1]>arr[3]\n\
    \                return false\n            else\n                return true\n\
    \            end\n        end\n    end\nend\nusing Test\n\n@testset begin\n\n\
    candidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2]) == true)\n\t@test(candidate([3,\
    \ 5, 10, 1, 2]) == true)\n\t@test(candidate([4, 3, 1, 2]) == false)\n\t@test(candidate([3,\
    \ 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([])) == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpchx6f520.jl:80\n  Expression: candidate([3,\
    \ 5, 4, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpchx6f520.jl:80\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpchx6f520.jl:76\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpchx6f520.jl:74\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    return true\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp2sck0068.jl:38\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp2sck0068.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2sck0068.jl:35\ntest set: Test Failed at /tmp/tmp2sck0068.jl:39\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp2sck0068.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2sck0068.jl:35\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2sck0068.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr)==0\n        return\
    \ true\n    end\n    for i in 1:length(arr)\n        if arr[i]==i\n          \
    \  continue\n        elseif arr[i]==i+1\n            arr[i],arr[i+1]=arr[i+1],arr[i]\n\
    \        else\n            return false\n        end\n    end\n    return true\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpt8onqal_.jl:47\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\n   Evaluated: false == true\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpt8onqal_.jl:47\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpt8onqal_.jl:46\ntest set: Test Failed at /tmp/tmpt8onqal_.jl:48\n\
    \  Expression: candidate([3, 5, 10, 1, 2]) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpt8onqal_.jl:48\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpt8onqal_.jl:46\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpt8onqal_.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    # You can\
    \ add helper functions as required\n    # You can also change the function signature\
    \ as required\n    return true\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2]) == true)\n\t@test(candidate([3,\
    \ 5, 10, 1, 2]) == true)\n\t@test(candidate([4, 3, 1, 2]) == false)\n\t@test(candidate([3,\
    \ 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([])) == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp_9_2xuqj.jl:40\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp_9_2xuqj.jl:40\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_9_2xuqj.jl:37\ntest set: Test Failed at /tmp/tmp_9_2xuqj.jl:41\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp_9_2xuqj.jl:41\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_9_2xuqj.jl:37\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_9_2xuqj.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr) == 0\n        return\
    \ true\n    end\n    if length(arr) == 1\n        return true\n    end\n    if\
    \ length(arr) == 2\n        if arr[1] > arr[2]\n            return false\n   \
    \     else\n            return true\n        end\n    end\n    if length(arr)\
    \ == 3\n        if arr[1] > arr[2]\n            if arr[2] > arr[3]\n         \
    \       return false\n            else\n                return true\n        \
    \    end\n        else\n            if arr[1] > arr[3]\n                return\
    \ false\n            else\n                return true\n            end\n    \
    \    end\n    end\n    if length(arr) > 3\n        if arr[1] > arr[2]\n      \
    \      if arr[2] > arr[3]\n                return false\n            else\n  \
    \              return true\n            end\n        else\n            if arr[1]\
    \ > arr[3]\n                return false\n            else\n                return\
    \ true\n            end\n        end\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2]) == true)\n\t\
    @test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4, 3, 1, 2]) ==\
    \ false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp6_3hq6cd.jl:80\\n  Expression: candidate([3,\
    \ 5, 4, 1, 2]) == false\\n   Evaluated: true == false\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmp6_3hq6cd.jl:80\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp6_3hq6cd.jl:76\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr)==0\n        return\
    \ true\n    end\n    for i in 1:length(arr)\n        if arr[i]==i\n          \
    \  continue\n        elseif arr[i]==i+1\n            arr[i],arr[i+1]=arr[i+1],arr[i]\n\
    \        else\n            return false\n        end\n    end\n    return true\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp8q2xsilg.jl:47\\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\\n   Evaluated: false == true\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmp8q2xsilg.jl:47\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp8q2xsilg.jl:46\\ntest set: Test Failed at /tmp/tmp8q2xsilg.jl:48\\\
    n  Expression: candidate([3, 5, 10, 1, 2]) == true\\n   Evaluated: false == true\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp8q2xsilg.jl:48\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp8q2xsilg.jl:46\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    3     2      5\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    if length(arr)\
    \ == 0\n        return true\n    end\n    if length(arr) == 1\n        return\
    \ true\n    end\n    if length(arr) == 2\n        return true\n    end\n    if\
    \ length(arr) == 3\n        return true\n    end\n    if length(arr) == 4\n  \
    \      return true\n    end\n    if length(arr) == 5\n        return true\n  \
    \  end\n    if length(arr) == 6\n        return true\n    end\n    if length(arr)\
    \ == 7\n        return true\n    end\n    if length(arr) == 8\n        return\
    \ true\n    end\n    if length(arr) == 9\n        return true\n    end\n    if\
    \ length(arr) == 10\n        return true\n    end\n    if length(arr) == 11\n\
    \        return true\n    end\n    if length(arr) == 12\n        return true\n\
    \    end\n    if length(arr) == 13\n        return true\n    end\n    if length(arr)\
    \ == 14\n        return true\n    end\n    if length(arr) == 15\n        return\
    \ true\n    end\n    if length(arr) == 16\n        return true\n    end\n    if\
    \ length(arr) == 17\n        return true\n    end\n    if length(arr) == 18\n\
    \        return true\n    end\n    if length(arr) == 19\n        return true\n\
    \    end\n    if length(arr) == 20\n        return true\n    end\n    if length(arr)\
    \ == 21\n        return true\n    end\n    if length(arr) == 22\n        return\
    \ true\n    end\n    if length(arr) == 23\n        return true\n    end\n    if\
    \ length(arr) == 24\n        return true\n    end\n    if length(arr) == 25\n\
    \        return true\n    end\n    if length(arr) == 26\n        return true\n\
    \    end\n    if length(arr) == 27\n        return true\n    end\n    if length(arr)\
    \ == 28\n        return true\n    end\n    if length(arr) == 29\n        return\
    \ true\n    end\n    if length(arr) == 30\n        return true\n    end\n    if\
    \ length(arr) == 31\n\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\
    \t@test(candidate([3, 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2])\
    \ == true)\n\t@test(candidate([4, 3, 1, 2]) == false)\n\t@test(candidate([3, 5,\
    \ 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([])) == true)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpbe9rdxrq.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpbe9rdxrq.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1,\
    \ 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmph024hyuc.jl:35\n  Test threw exception\n\
    \  Expression: candidate([3, 4, 5, 1, 2]) == true\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Bool\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmph024hyuc.jl:29\n   [2] top-level scope at /tmp/tmph024hyuc.jl:35\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmph024hyuc.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmph024hyuc.jl:36\n  Test threw exception\n  Expression: candidate([3,\
    \ 5, 10, 1, 2]) == true\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmph024hyuc.jl:29\n   [2] top-level scope at /tmp/tmph024hyuc.jl:36\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmph024hyuc.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmph024hyuc.jl:37\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmph024hyuc.jl:29\n   [2] top-level scope at /tmp/tmph024hyuc.jl:37\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmph024hyuc.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmph024hyuc.jl:38\n  Test threw exception\n  Expression: candidate([3,\
    \ 5, 4, 1, 2]) == false\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmph024hyuc.jl:29\n   [2] top-level scope at /tmp/tmph024hyuc.jl:38\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmph024hyuc.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmph024hyuc.jl:39\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == true\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Bool\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmph024hyuc.jl:29\n   [2] top-level scope at /tmp/tmph024hyuc.jl:39\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmph024hyuc.jl:34\n  \nTest Summary: | Error \
    \ Total\ntest set      |     5      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmph024hyuc.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    return true\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpg_4i7zql.jl:38\\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\\n   Evaluated: true == false\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmpg_4i7zql.jl:38\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpg_4i7zql.jl:35\\ntest set: Test Failed at /tmp/tmpg_4i7zql.jl:39\\\
    n  Expression: candidate([3, 5, 4, 1, 2]) == false\\n   Evaluated: true == false\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpg_4i7zql.jl:39\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpg_4i7zql.jl:35\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    3     2      5\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr) == 0\n        return\
    \ true\n    end\n    if length(arr) == 1\n        return true\n    end\n    if\
    \ length(arr) == 2\n        if arr[1] > arr[2]\n            return false\n   \
    \     else\n            return true\n        end\n    end\n    if length(arr)\
    \ == 3\n        if arr[1] > arr[2]\n            if arr[2] > arr[3]\n         \
    \       return false\n            else\n                return true\n        \
    \    end\n        else\n            if arr[1] > arr[3]\n                return\
    \ false\n            else\n                return true\n            end\n    \
    \    end\n    end\n    if length(arr) > 3\n        if arr[1] > arr[2]\n      \
    \      if arr[2] > arr[3]\n                return false\n            else\n  \
    \              return true\n            end\n        else\n            if arr[1]\
    \ > arr[3]\n                return false\n            else\n                return\
    \ true\n            end\n        end\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2]) == true)\n\t\
    @test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4, 3, 1, 2]) ==\
    \ false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpwlk87qjj.jl:80\n  Expression: candidate([3,\
    \ 5, 4, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpwlk87qjj.jl:80\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwlk87qjj.jl:76\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwlk87qjj.jl:74\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr)==0\n        return\
    \ true\n    end\n    for i in 1:length(arr)\n        if arr[i]==i\n          \
    \  continue\n        elseif arr[i]==i+1\n            arr[i],arr[i+1]=arr[i+1],arr[i]\n\
    \        else\n            return false\n        end\n    end\n    return true\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpyg3t6va1.jl:47\\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\\n   Evaluated: false == true\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmpyg3t6va1.jl:47\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpyg3t6va1.jl:46\\ntest set: Test Failed at /tmp/tmpyg3t6va1.jl:48\\\
    n  Expression: candidate([3, 5, 10, 1, 2]) == true\\n   Evaluated: false == true\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpyg3t6va1.jl:48\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpyg3t6va1.jl:46\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    3     2      5\\n'"
  stderr: "b'ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\\nin expression starting at /tmp/tmpyg3t6va1.jl:44\\n'"
  exit_code: -1
  status: Timeout
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1,\
    \ 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpnfof58ss.jl:35\n  Test threw exception\n\
    \  Expression: candidate([3, 4, 5, 1, 2]) == true\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Bool\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpnfof58ss.jl:29\n   [2] top-level scope at /tmp/tmpnfof58ss.jl:35\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpnfof58ss.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmpnfof58ss.jl:36\n  Test threw exception\n  Expression: candidate([3,\
    \ 5, 10, 1, 2]) == true\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpnfof58ss.jl:29\n   [2] top-level scope at /tmp/tmpnfof58ss.jl:36\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpnfof58ss.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmpnfof58ss.jl:37\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpnfof58ss.jl:29\n   [2] top-level scope at /tmp/tmpnfof58ss.jl:37\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpnfof58ss.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmpnfof58ss.jl:38\n  Test threw exception\n  Expression: candidate([3,\
    \ 5, 4, 1, 2]) == false\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpnfof58ss.jl:29\n   [2] top-level scope at /tmp/tmpnfof58ss.jl:38\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpnfof58ss.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmpnfof58ss.jl:39\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == true\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Bool\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpnfof58ss.jl:29\n   [2] top-level scope at /tmp/tmpnfof58ss.jl:39\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpnfof58ss.jl:34\n  \nTest Summary: | Error \
    \ Total\ntest set      |     5      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnfof58ss.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr)==0\n        return\
    \ true\n    end\n    if length(arr)==1\n        return true\n    end\n    if length(arr)==2\n\
    \        if arr[1]<=arr[2]\n            return true\n        else\n          \
    \  return false\n        end\n    end\n    if length(arr)==3\n        if arr[1]<=arr[2]\
    \ && arr[2]<=arr[3]\n            return true\n        elseif arr[1]<=arr[3] &&\
    \ arr[3]<=arr[2]\n            return true\n        elseif arr[2]<=arr[1] && arr[1]<=arr[3]\n\
    \            return true\n        elseif arr[2]<=arr[3] && arr[3]<=arr[1]\n  \
    \          return true\n        elseif arr[3]<=arr[1] && arr[1]<=arr[2]\n    \
    \        return true\n        elseif arr[3]<=arr[2] && arr[2]<=arr[1]\n      \
    \      return true\n        else\n            return false\n        end\n    end\n\
    \    if length(arr)>3\n        for i in 1:length(arr)\n            if arr[i]<=arr[i+1]\n\
    \                return true\n            else\n                return false\n\
    \            end\n        end\n    end\nend\nusing Test\n\n@testset begin\n\n\
    candidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2]) == true)\n\t@test(candidate([3,\
    \ 5, 10, 1, 2]) == true)\n\t@test(candidate([4, 3, 1, 2]) == false)\n\t@test(candidate([3,\
    \ 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([])) == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp5dirzxpw.jl:76\n  Expression: candidate([3,\
    \ 5, 4, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp5dirzxpw.jl:76\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5dirzxpw.jl:72\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5dirzxpw.jl:70\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    # You can\
    \ add helper functions if needed\n    # You can add additional imports if needed\n\
    \    if length(arr) == 0\n        return true\n    end\n    if length(arr) ==\
    \ 1\n        return true\n    end\n    if length(arr) == 2\n        if arr[1]\
    \ <= arr[2]\n            return true\n        else\n            return false\n\
    \        end\n    end\n    if length(arr) == 3\n        if arr[1] <= arr[2] &&\
    \ arr[2] <= arr[3]\n            return true\n        elseif arr[1] <= arr[3] &&\
    \ arr[3] <= arr[2]\n            return true\n        elseif arr[2] <= arr[1] &&\
    \ arr[1] <= arr[3]\n            return true\n        elseif arr[2] <= arr[3] &&\
    \ arr[3] <= arr[1]\n            return true\n        elseif arr[3] <= arr[1] &&\
    \ arr[1] <= arr[2]\n            return true\n        elseif arr[3] <= arr[2] &&\
    \ arr[2] <= arr[1]\n            return true\n        else\n            return\
    \ false\n        end\n    end\n    if length(arr) > 3\n        if arr[1] <= arr[2]\
    \ && arr[2] <= arr[3]\n            return true\n        elseif arr[1] <= arr[3]\
    \ && arr[3] <= arr[2]\n            return true\n        elseif arr[2] <= arr[1]\
    \ && arr[1] <= arr[3]\n            return true\n        elseif arr[2] <= arr[3]\
    \ && arr[3] <= arr[1]\n            return true\n        elseif arr[3] <= arr[1]\
    \ && arr[1] <= arr[2]\n            return true\n        elseif arr[3] <= arr[2]\
    \ && arr[2] <= arr[1]\n            return true\n        else\n            return\
    \ false\n        end\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2]) == true)\n\t@test(candidate([3,\
    \ 5, 10, 1, 2]) == true)\n\t@test(candidate([4, 3, 1, 2]) == false)\n\t@test(candidate([3,\
    \ 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([])) == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp6xe9l7k5.jl:86\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp6xe9l7k5.jl:86\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6xe9l7k5.jl:83\ntest set: Test Failed at /tmp/tmp6xe9l7k5.jl:87\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp6xe9l7k5.jl:87\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6xe9l7k5.jl:83\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6xe9l7k5.jl:81\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr)==0\n        return\
    \ true\n    end\n    for i in 1:length(arr)\n        if arr[i]==i\n          \
    \  continue\n        elseif arr[i]==i+1\n            arr[i],arr[i+1]=arr[i+1],arr[i]\n\
    \        else\n            return false\n        end\n    end\n    return true\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpxezy8vvd.jl:47\\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\\n   Evaluated: false == true\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmpxezy8vvd.jl:47\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpxezy8vvd.jl:46\\ntest set: Test Failed at /tmp/tmpxezy8vvd.jl:48\\\
    n  Expression: candidate([3, 5, 10, 1, 2]) == true\\n   Evaluated: false == true\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpxezy8vvd.jl:48\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpxezy8vvd.jl:46\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    3     2      5\\n'"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr)==0\n        return\
    \ true\n    end\n    if length(arr)==1\n        return true\n    end\n    if length(arr)==2\n\
    \        if arr[1]>arr[2]\n            return false\n        else\n          \
    \  return true\n        end\n    end\n    if length(arr)==3\n        if arr[1]>arr[2]\n\
    \            return false\n        elseif arr[2]>arr[3]\n            return false\n\
    \        else\n            return true\n        end\n    end\n    if length(arr)>3\n\
    \        if arr[1]>arr[2]\n            return false\n        elseif arr[2]>arr[3]\n\
    \            return false\n        else\n            return move_one_ball(arr[2:end])\n\
    \        end\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\
    \t@test(candidate([3, 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2])\
    \ == true)\n\t@test(candidate([4, 3, 1, 2]) == false)\n\t@test(candidate([3, 5,\
    \ 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([])) == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp1_kya91h.jl:65\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\n   Evaluated: false == true\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp1_kya91h.jl:65\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1_kya91h.jl:64\ntest set: Test Failed at /tmp/tmp1_kya91h.jl:66\n\
    \  Expression: candidate([3, 5, 10, 1, 2]) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp1_kya91h.jl:66\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1_kya91h.jl:64\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1_kya91h.jl:62\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr) == 0\n        return\
    \ true\n    end\n    for i in 1:length(arr)\n        if arr[i] == i\n        \
    \    continue\n        elseif arr[i] == i+1\n            arr[i], arr[i+1] = arr[i+1],\
    \ arr[i]\n        else\n            return false\n        end\n    end\n    return\
    \ true\nend\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp9shpw2ab.jl:47\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\n   Evaluated: false == true\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp9shpw2ab.jl:47\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9shpw2ab.jl:46\ntest set: Test Failed at /tmp/tmp9shpw2ab.jl:48\n\
    \  Expression: candidate([3, 5, 10, 1, 2]) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp9shpw2ab.jl:48\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9shpw2ab.jl:46\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9shpw2ab.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    return true\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp4z0hzv2t.jl:38\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp4z0hzv2t.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4z0hzv2t.jl:35\ntest set: Test Failed at /tmp/tmp4z0hzv2t.jl:39\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp4z0hzv2t.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4z0hzv2t.jl:35\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4z0hzv2t.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr)==0\n        return\
    \ true\n    end\n    for i in 1:length(arr)\n        if arr[i]==i\n          \
    \  continue\n        elseif arr[i]==i+1\n            arr[i],arr[i+1]=arr[i+1],arr[i]\n\
    \        else\n            return false\n        end\n    end\n    return true\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpn03rp3kx.jl:47\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\n   Evaluated: false == true\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpn03rp3kx.jl:47\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpn03rp3kx.jl:46\ntest set: Test Failed at /tmp/tmpn03rp3kx.jl:48\n\
    \  Expression: candidate([3, 5, 10, 1, 2]) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpn03rp3kx.jl:48\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpn03rp3kx.jl:46\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpn03rp3kx.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr) == 0\n        return\
    \ true\n    end\n    for i in 1:length(arr)\n        if arr[i] == i\n        \
    \    continue\n        elseif arr[i] == i + 1\n            arr[i], arr[i + 1]\
    \ = arr[i + 1], arr[i]\n        else\n            return false\n        end\n\
    \    end\n    return true\nend\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\
    \t@test(candidate([3, 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2])\
    \ == true)\n\t@test(candidate([4, 3, 1, 2]) == false)\n\t@test(candidate([3, 5,\
    \ 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([])) == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmppbgqsqvp.jl:47\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\n   Evaluated: false == true\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmppbgqsqvp.jl:47\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmppbgqsqvp.jl:46\ntest set: Test Failed at /tmp/tmppbgqsqvp.jl:48\n\
    \  Expression: candidate([3, 5, 10, 1, 2]) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmppbgqsqvp.jl:48\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmppbgqsqvp.jl:46\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmppbgqsqvp.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    # You can\
    \ add helper functions here\n    # You can also use other data structures\n  \
    \  # You can also use other languages\n    # You can also use other IDEs\n   \
    \ # You can also use other compilers\n    # You can also use other operating systems\n\
    \    # You can also use other hardware\n    # You can also use other anything\n\
    \    # You can also use other everything\n    # You can also use other anything\n\
    \    # You can also use other everything\n    # You can also use other anything\n\
    \    # You can also use other everything\n    # You can also use other anything\n\
    \    # You can also use other everything\n    # You can also use other anything\n\
    \    # You can also use other everything\n    # You can also use other anything\n\
    \    # You can also use other everything\n    # You can also use other anything\n\
    \    # You can also use other everything\n    # You can also use other anything\n\
    \    # You can also use other everything\n    # You can also use other anything\n\
    \    # You can also use other everything\n    # You can also use other anything\n\
    \    # You can also use other everything\n    # You can also use other anything\n\
    \    # You can also use other everything\n    # You can also use other anything\n\
    \    # You can also use other everything\n    # You can also use other anything\n\
    \    # You can also use other everything\n    # You can also use other anything\n\
    \    # You can also use other everything\n    # You can also use other anything\n\
    \    # You can also use other everything\n    # You can also use other anything\n\
    \    # You can also use other everything\n    # You can also use other anything\n\
    \    # You can also use other everything\n    # You can also use other anything\n\
    \    # You can also use other everything\n    # You can also use other anything\n\
    \    # You can also use other everything\n    # You can also use other anything\n\
    \    # You can also use other everything\n    # You can also use other anything\n\
    \    # You can also use other everything\n    # You can also use other anything\n\
    \    # You can also use other everything\n    # You can also use other anything\n\
    \    # You can also use other everything\n    # You can also use other anything\n\
    \    # You can also use other everything\n    # You can also use\nusing Test\n\
    \n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1,\
    \ 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp_wnwxuyx.jl:27\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp_wnwxuyx.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp_wnwxuyx.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    return true\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp28tyk4bd.jl:38\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp28tyk4bd.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp28tyk4bd.jl:35\ntest set: Test Failed at /tmp/tmp28tyk4bd.jl:39\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp28tyk4bd.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp28tyk4bd.jl:35\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp28tyk4bd.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    return true\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpcqm_3afi.jl:38\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpcqm_3afi.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpcqm_3afi.jl:35\ntest set: Test Failed at /tmp/tmpcqm_3afi.jl:39\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpcqm_3afi.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpcqm_3afi.jl:35\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpcqm_3afi.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Write your code here\n    #\
    \ You can add helper functions as needed\n    # You can add helper functions as\
    \ needed\n    if length(arr)==0\n        return true\n    end\n    if length(arr)==1\n\
    \        return true\n    end\n    if length(arr)==2\n        if arr[1]<=arr[2]\n\
    \            return true\n        else\n            return false\n        end\n\
    \    end\n    if length(arr)==3\n        if arr[1]<=arr[2] && arr[2]<=arr[3]\n\
    \            return true\n        elseif arr[1]<=arr[3] && arr[3]<=arr[2]\n  \
    \          return true\n        elseif arr[2]<=arr[1] && arr[1]<=arr[3]\n    \
    \        return true\n        elseif arr[2]<=arr[3] && arr[3]<=arr[1]\n      \
    \      return true\n        elseif arr[3]<=arr[1] && arr[1]<=arr[2]\n        \
    \    return true\n        elseif arr[3]<=arr[2] && arr[2]<=arr[1]\n          \
    \  return true\n        else\n            return false\n        end\n    end\n\
    \    if length(arr)>3\n        if arr[1]<=arr[2] && arr[2]<=arr[3]\n         \
    \   return true\n        elseif arr[1]<=arr[3] && arr[3]<=arr[2]\n           \
    \ return true\n        elseif arr[2]<=arr[1] && arr[1]<=arr[3]\n            return\
    \ true\n        elseif arr[2]<=arr[3] && arr[3]<=arr[1]\n            return true\n\
    \        elseif arr[3]<=arr[1] && arr[1]<=arr[2]\n            return true\n  \
    \      elseif arr[3]<=arr[2] && arr[2]<=arr[1]\n            return true\n    \
    \    else\n            return false\n        end\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2])\
    \ == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpkui7puiq.jl:86\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpkui7puiq.jl:86\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpkui7puiq.jl:83\ntest set: Test Failed at /tmp/tmpkui7puiq.jl:87\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpkui7puiq.jl:87\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpkui7puiq.jl:83\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpkui7puiq.jl:81\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr)==0\n        return\
    \ true\n    end\n    if length(arr)==1\n        return true\n    end\n    if length(arr)==2\n\
    \        if arr[1]<=arr[2]\n            return true\n        else\n          \
    \  return false\n        end\n    end\n    if length(arr)==3\n        if arr[1]<=arr[2]\
    \ && arr[2]<=arr[3]\n            return true\n        elseif arr[1]<=arr[3] &&\
    \ arr[3]<=arr[2]\n            return true\n        elseif arr[2]<=arr[1] && arr[1]<=arr[3]\n\
    \            return true\n        elseif arr[2]<=arr[3] && arr[3]<=arr[1]\n  \
    \          return true\n        elseif arr[3]<=arr[1] && arr[1]<=arr[2]\n    \
    \        return true\n        elseif arr[3]<=arr[2] && arr[2]<=arr[1]\n      \
    \      return true\n        else\n            return false\n        end\n    end\n\
    \    if length(arr)>3\n        if arr[1]<=arr[2] && arr[2]<=arr[3]\n         \
    \   return true\n        elseif arr[1]<=arr[3] && arr[3]<=arr[2]\n           \
    \ return true\n        elseif arr[2]<=arr[1] && arr[1]<=arr[3]\n            return\
    \ true\n        elseif arr[2]<=arr[3] && arr[3]<=arr[1]\n            return true\n\
    \        elseif arr[3]<=arr[1] && arr[1]<=arr[2]\n            return true\n  \
    \      elseif arr[3]<=arr[2] && arr[2]<=arr[1]\n            return true\n    \
    \    else\n            return false\n        end\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2])\
    \ == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpwbzanpgz.jl:83\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpwbzanpgz.jl:83\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwbzanpgz.jl:80\ntest set: Test Failed at /tmp/tmpwbzanpgz.jl:84\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpwbzanpgz.jl:84\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwbzanpgz.jl:80\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwbzanpgz.jl:78\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr)==0\n        return\
    \ true\n    end\n    if length(arr)==1\n        return true\n    end\n    if length(arr)==2\n\
    \        if arr[1]<=arr[2]\n            return true\n        else\n          \
    \  return false\n        end\n    end\n    if length(arr)==3\n        if arr[1]<=arr[2]\
    \ && arr[2]<=arr[3]\n            return true\n        elseif arr[1]<=arr[3] &&\
    \ arr[3]<=arr[2]\n            return true\n        elseif arr[2]<=arr[1] && arr[1]<=arr[3]\n\
    \            return true\n        elseif arr[2]<=arr[3] && arr[3]<=arr[1]\n  \
    \          return true\n        elseif arr[3]<=arr[1] && arr[1]<=arr[2]\n    \
    \        return true\n        elseif arr[3]<=arr[2] && arr[2]<=arr[1]\n      \
    \      return true\n        else\n            return false\n        end\n    end\n\
    \    if length(arr)>3\n        if arr[1]<=arr[2] && arr[2]<=arr[3]\n         \
    \   return true\n        elseif arr[1]<=arr[3] && arr[3]<=arr[2]\n           \
    \ return true\n        elseif arr[2]<=arr[1] && arr[1]<=arr[3]\n            return\
    \ true\n        elseif arr[2]<=arr[3] && arr[3]<=arr[1]\n            return true\n\
    \        elseif arr[3]<=arr[1] && arr[1]<=arr[2]\n            return true\n  \
    \      elseif arr[3]<=arr[2] && arr[2]<=arr[1]\n            return true\n    \
    \    else\n            return false\n        end\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2])\
    \ == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpe_cnq1gb.jl:83\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpe_cnq1gb.jl:83\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpe_cnq1gb.jl:80\ntest set: Test Failed at /tmp/tmpe_cnq1gb.jl:84\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpe_cnq1gb.jl:84\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpe_cnq1gb.jl:80\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpe_cnq1gb.jl:78\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr)==0\n        return\
    \ true\n    end\n    for i in 1:length(arr)\n        if arr[i]==i\n          \
    \  continue\n        elseif arr[i]==i+1\n            arr[i],arr[i+1]=arr[i+1],arr[i]\n\
    \        else\n            return false\n        end\n    end\n    return true\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpctmnxzon.jl:47\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\n   Evaluated: false == true\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpctmnxzon.jl:47\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpctmnxzon.jl:46\ntest set: Test Failed at /tmp/tmpctmnxzon.jl:48\n\
    \  Expression: candidate([3, 5, 10, 1, 2]) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpctmnxzon.jl:48\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpctmnxzon.jl:46\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpctmnxzon.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    return false\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpwy6v754y.jl:36\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\n   Evaluated: false == true\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpwy6v754y.jl:36\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwy6v754y.jl:35\ntest set: Test Failed at /tmp/tmpwy6v754y.jl:37\n\
    \  Expression: candidate([3, 5, 10, 1, 2]) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpwy6v754y.jl:37\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwy6v754y.jl:35\ntest set: Test Failed at /tmp/tmpwy6v754y.jl:40\n\
    \  Expression: candidate(Vector{Int64}([])) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpwy6v754y.jl:40\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwy6v754y.jl:35\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     3      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwy6v754y.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    return true\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpt1pz8t_p.jl:38\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpt1pz8t_p.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpt1pz8t_p.jl:35\ntest set: Test Failed at /tmp/tmpt1pz8t_p.jl:39\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpt1pz8t_p.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpt1pz8t_p.jl:35\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpt1pz8t_p.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    return true\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpqlmax1w6.jl:38\\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\\n   Evaluated: true == false\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmpqlmax1w6.jl:38\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpqlmax1w6.jl:35\\ntest set: Test Failed at /tmp/tmpqlmax1w6.jl:39\\\
    n  Expression: candidate([3, 5, 4, 1, 2]) == false\\n   Evaluated: true == false\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpqlmax1w6.jl:39\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpqlmax1w6.jl:35\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    3     2      5\\n'"
  stderr: "b'ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\\nin expression starting at /tmp/tmpqlmax1w6.jl:33\\n'"
  exit_code: -1
  status: Timeout
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Write your code here\n    #\
    \ Return True if it is possible to get the sorted array by performing \n    #\
    \ right shift operation else return False.\n    # If the given array is empty\
    \ then return True.\n    # Note: The given list is guaranteed to have unique elements.\n\
    \    return true\nend\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\
    \t@test(candidate([3, 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2])\
    \ == true)\n\t@test(candidate([4, 3, 1, 2]) == false)\n\t@test(candidate([3, 5,\
    \ 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([])) == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp_z0h8twc.jl:42\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp_z0h8twc.jl:42\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_z0h8twc.jl:39\ntest set: Test Failed at /tmp/tmp_z0h8twc.jl:43\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp_z0h8twc.jl:43\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_z0h8twc.jl:39\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_z0h8twc.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr) == 0\n        return\
    \ true\n    end\n    if length(arr) == 1\n        return true\n    end\n    if\
    \ length(arr) == 2\n        return true\n    end\n    if length(arr) == 3\n  \
    \      return true\n    end\n    if length(arr) == 4\n        return true\n  \
    \  end\n    if length(arr) == 5\n        return true\n    end\n    if length(arr)\
    \ == 6\n        return true\n    end\n    if length(arr) == 7\n        return\
    \ true\n    end\n    if length(arr) == 8\n        return true\n    end\n    if\
    \ length(arr) == 9\n        return true\n    end\n    if length(arr) == 10\n \
    \       return true\n    end\n    if length(arr) == 11\n        return true\n\
    \    end\n    if length(arr) == 12\n        return true\n    end\n    if length(arr)\
    \ == 13\n        return true\n    end\n    if length(arr) == 14\n        return\
    \ true\n    end\n    if length(arr) == 15\n        return true\n    end\n    if\
    \ length(arr) == 16\n        return true\n    end\n    if length(arr) == 17\n\
    \        return true\n    end\n    if length(arr) == 18\n        return true\n\
    \    end\n    if length(arr) == 19\n        return true\n    end\n    if length(arr)\
    \ == 20\n        return true\n    end\n    if length(arr) == 21\n        return\
    \ true\n    end\n    if length(arr) == 22\n        return true\n    end\n    if\
    \ length(arr) == 23\n        return true\n    end\n    if length(arr) == 24\n\
    \        return true\n    end\n    if length(arr) == 25\n        return true\n\
    \    end\n    if length(arr) == 26\n        return true\n    end\n    if length(arr)\
    \ == 27\n        return true\n    end\n    if length(arr) == 28\n        return\
    \ true\n    end\n    if length(arr) == 29\n        return true\n    end\n    if\
    \ length(arr) == 30\n        return true\n    end\n    if length(arr) == 31\n\
    \        return true\n    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\
    \t@test(candidate([3, 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2])\
    \ == true)\n\t@test(candidate([4, 3, 1, 2]) == false)\n\t@test(candidate([3, 5,\
    \ 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([])) == true)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpi7ml07ry.jl:27\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpi7ml07ry.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpi7ml07ry.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr) == 0\n        return\
    \ true\n    end\n    for i in 1:length(arr)\n        if i == length(arr)\n   \
    \         return true\n        end\n        if arr[i] > arr[i+1]\n           \
    \ return false\n        end\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2]) == true)\n\t@test(candidate([3,\
    \ 5, 10, 1, 2]) == true)\n\t@test(candidate([4, 3, 1, 2]) == false)\n\t@test(candidate([3,\
    \ 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([])) == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpktk0nu2j.jl:45\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\n   Evaluated: false == true\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpktk0nu2j.jl:45\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpktk0nu2j.jl:44\ntest set: Test Failed at /tmp/tmpktk0nu2j.jl:46\n\
    \  Expression: candidate([3, 5, 10, 1, 2]) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpktk0nu2j.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpktk0nu2j.jl:44\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpktk0nu2j.jl:42\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    if length(arr)==0\n\
    \        return true\n    end\n    if length(arr)==1\n        return true\n  \
    \  end\n    if length(arr)==2\n        if arr[1]>arr[2]\n            return false\n\
    \        else\n            return true\n        end\n    end\n    for i in 1:length(arr)-1\n\
    \        if arr[i]>arr[i+1]\n            return false\n        end\n    end\n\
    \    return true\nend\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\
    \t@test(candidate([3, 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2])\
    \ == true)\n\t@test(candidate([4, 3, 1, 2]) == false)\n\t@test(candidate([3, 5,\
    \ 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([])) == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp60uqraqq.jl:54\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\n   Evaluated: false == true\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp60uqraqq.jl:54\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp60uqraqq.jl:53\ntest set: Test Failed at /tmp/tmp60uqraqq.jl:55\n\
    \  Expression: candidate([3, 5, 10, 1, 2]) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp60uqraqq.jl:55\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp60uqraqq.jl:53\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp60uqraqq.jl:51\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    # You can\
    \ add helper functions as needed\n    return false\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2]) == true)\n\
    \t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4, 3, 1, 2])\
    \ == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmplx9yi91n.jl:37\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\n   Evaluated: false == true\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmplx9yi91n.jl:37\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplx9yi91n.jl:36\ntest set: Test Failed at /tmp/tmplx9yi91n.jl:38\n\
    \  Expression: candidate([3, 5, 10, 1, 2]) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmplx9yi91n.jl:38\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplx9yi91n.jl:36\ntest set: Test Failed at /tmp/tmplx9yi91n.jl:41\n\
    \  Expression: candidate(Vector{Int64}([])) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmplx9yi91n.jl:41\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplx9yi91n.jl:36\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     3      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmplx9yi91n.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code goes here\n    return\
    \ true\nend\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpidg220if.jl:38\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpidg220if.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpidg220if.jl:35\ntest set: Test Failed at /tmp/tmpidg220if.jl:39\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpidg220if.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpidg220if.jl:35\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpidg220if.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr) == 0\n        return\
    \ true\n    end\n    for i in 1:length(arr)\n        if arr[i] == i\n        \
    \    continue\n        elseif arr[i] == i+1\n            arr[i], arr[i+1] = arr[i+1],\
    \ arr[i]\n        else\n            return false\n        end\n    end\n    return\
    \ true\nend\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpt9w3svck.jl:47\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\n   Evaluated: false == true\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpt9w3svck.jl:47\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpt9w3svck.jl:46\ntest set: Test Failed at /tmp/tmpt9w3svck.jl:48\n\
    \  Expression: candidate([3, 5, 10, 1, 2]) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpt9w3svck.jl:48\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpt9w3svck.jl:46\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpt9w3svck.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    return true\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmps00f36mh.jl:38\\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\\n   Evaluated: true == false\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmps00f36mh.jl:38\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmps00f36mh.jl:35\\ntest set: Test Failed at /tmp/tmps00f36mh.jl:39\\\
    n  Expression: candidate([3, 5, 4, 1, 2]) == false\\n   Evaluated: true == false\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmps00f36mh.jl:39\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmps00f36mh.jl:35\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    3     2      5\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr)==0\n        return\
    \ true\n    end\n    if length(arr)==1\n        return true\n    end\n    if length(arr)==2\n\
    \        if arr[1]>arr[2]\n            return false\n        else\n          \
    \  return true\n        end\n    end\n    if length(arr)==3\n        if arr[1]>arr[2]\n\
    \            if arr[2]>arr[3]\n                return false\n            else\n\
    \                return true\n            end\n        else\n            if arr[1]>arr[3]\n\
    \                return false\n            else\n                return true\n\
    \            end\n        end\n    end\n    if length(arr)>3\n        if arr[1]>arr[2]\n\
    \            if arr[2]>arr[3]\n                return false\n            else\n\
    \                return true\n            end\n        else\n            if arr[1]>arr[3]\n\
    \                return false\n            else\n                return true\n\
    \            end\n        end\n    end\nend\nusing Test\n\n@testset begin\n\n\
    candidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2]) == true)\n\t@test(candidate([3,\
    \ 5, 10, 1, 2]) == true)\n\t@test(candidate([4, 3, 1, 2]) == false)\n\t@test(candidate([3,\
    \ 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([])) == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpcxkygbno.jl:80\n  Expression: candidate([3,\
    \ 5, 4, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpcxkygbno.jl:80\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpcxkygbno.jl:76\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpcxkygbno.jl:74\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    return true\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp_uab5v5d.jl:38\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp_uab5v5d.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_uab5v5d.jl:35\ntest set: Test Failed at /tmp/tmp_uab5v5d.jl:39\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp_uab5v5d.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_uab5v5d.jl:35\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_uab5v5d.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Write your code here\n    #\
    \ You can add functions as well\n    # You can return True or False\n    # You\
    \ can also return a tuple (True or False, number of right shift operations)\n\
    \    # You can also return a tuple (True or False, [list of indices of elements\
    \ to be shifted])\n    # You can also return a tuple (True or False, [list of\
    \ indices of elements to be shifted], number of right shift operations)\n    #\
    \ You can also return a tuple (True or False, [list of indices of elements to\
    \ be shifted], number of right shift operations, number of left shift operations)\n\
    \    # You can also return a tuple (True or False, [list of indices of elements\
    \ to be shifted], number of right shift operations, number of left shift operations,\
    \ number of swap operations)\n    # You can also return a tuple (True or False,\
    \ [list of indices of elements to be shifted], number of right shift operations,\
    \ number of left shift operations, number of swap operations, number of reverse\
    \ operations)\n    # You can also return a tuple (True or False, [list of indices\
    \ of elements to be shifted], number of right shift operations, number of left\
    \ shift operations, number of swap operations, number of reverse operations, number\
    \ of insert operations)\n    # You can also return a tuple (True or False, [list\
    \ of indices of elements to be shifted], number of right shift operations, number\
    \ of left shift operations, number of swap operations, number of reverse operations,\
    \ number of insert operations, number of delete operations)\n    # You can also\
    \ return a tuple (True or False, [list of indices of elements to be shifted],\
    \ number of right shift operations, number of left shift operations, number of\
    \ swap operations, number of reverse operations, number of insert operations,\
    \ number of delete operations, number of append operations)\n    # You can also\
    \ return a tuple (True or False, [list of indices of elements to be shifted],\
    \ number of right shift operations, number of left shift operations, number of\
    \ swap operations, number of reverse operations, number of insert operations,\
    \ number of delete operations, number of append operations, number of pop operations)\n\
    \    # You can also return a tuple (True or False, [list of indices of elements\
    \ to be shifted], number of right shift operations, number of left shift operations,\
    \ number of swap operations, number of reverse operations, number of insert operations,\
    \ number of delete operations,\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\
    \t@test(candidate([3, 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2])\
    \ == true)\n\t@test(candidate([4, 3, 1, 2]) == false)\n\t@test(candidate([3, 5,\
    \ 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([])) == true)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpnwec8xbj.jl:27\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpnwec8xbj.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpnwec8xbj.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    # You can\
    \ add helper functions as needed\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2]) == true)\n\t@test(candidate([3,\
    \ 5, 10, 1, 2]) == true)\n\t@test(candidate([4, 3, 1, 2]) == false)\n\t@test(candidate([3,\
    \ 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([])) == true)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpz24o2_ag.jl:36\n  Test threw exception\n\
    \  Expression: candidate([3, 4, 5, 1, 2]) == true\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Bool\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpz24o2_ag.jl:30\n   [2] top-level scope at /tmp/tmpz24o2_ag.jl:36\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpz24o2_ag.jl:35\n  \ntest set: Error During\
    \ Test at /tmp/tmpz24o2_ag.jl:37\n  Test threw exception\n  Expression: candidate([3,\
    \ 5, 10, 1, 2]) == true\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpz24o2_ag.jl:30\n   [2] top-level scope at /tmp/tmpz24o2_ag.jl:37\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpz24o2_ag.jl:35\n  \ntest set: Error During\
    \ Test at /tmp/tmpz24o2_ag.jl:38\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpz24o2_ag.jl:30\n   [2] top-level scope at /tmp/tmpz24o2_ag.jl:38\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpz24o2_ag.jl:35\n  \ntest set: Error During\
    \ Test at /tmp/tmpz24o2_ag.jl:39\n  Test threw exception\n  Expression: candidate([3,\
    \ 5, 4, 1, 2]) == false\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpz24o2_ag.jl:30\n   [2] top-level scope at /tmp/tmpz24o2_ag.jl:39\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpz24o2_ag.jl:35\n  \ntest set: Error During\
    \ Test at /tmp/tmpz24o2_ag.jl:40\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == true\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Bool\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpz24o2_ag.jl:30\n   [2] top-level scope at /tmp/tmpz24o2_ag.jl:40\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpz24o2_ag.jl:35\n  \nTest Summary: | Error \
    \ Total\ntest set      |     5      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpz24o2_ag.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr) == 0\n        return\
    \ true\n    end\n    if length(arr) == 1\n        return true\n    end\n    if\
    \ length(arr) == 2\n        return true\n    end\n    if length(arr) == 3\n  \
    \      if arr[1] > arr[2]\n            arr[1], arr[2] = arr[2], arr[1]\n     \
    \       return true\n        end\n        if arr[2] > arr[3]\n            arr[2],\
    \ arr[3] = arr[3], arr[2]\n            return true\n        end\n        return\
    \ true\n    end\n    if length(arr) == 4\n        if arr[1] > arr[2]\n       \
    \     arr[1], arr[2] = arr[2], arr[1]\n            return true\n        end\n\
    \        if arr[2] > arr[3]\n            arr[2], arr[3] = arr[3], arr[2]\n   \
    \         return true\n        end\n        if arr[3] > arr[4]\n            arr[3],\
    \ arr[4] = arr[4], arr[3]\n            return true\n        end\n        return\
    \ true\n    end\n    if length(arr) == 5\n        if arr[1] > arr[2]\n       \
    \     arr[1], arr[2] = arr[2], arr[1]\n            return true\n        end\n\
    \        if arr[2] > arr[3]\n            arr[2], arr[3] = arr[3], arr[2]\n   \
    \         return true\n        end\n        if arr[3] > arr[4]\n            arr[3],\
    \ arr[4] = arr[4], arr[3]\n            return true\n        end\n        if arr[4]\
    \ > arr[5]\n            arr[4], arr[5] = arr[5], arr[4]\n            return true\n\
    \        end\n        return true\n    end\n    if length(arr) == 6\n        if\
    \ arr[1] > arr[2]\n            arr[1], arr[2] = arr[2], arr[1]\n            return\
    \ true\n        end\n        if arr[2] > arr[3]\n            arr[2], arr[3] =\
    \ arr[3],\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpi9exqktf.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpi9exqktf.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr) == 0\n        return\
    \ true\n    end\n    for i in 1:length(arr)\n        if arr[i] == i\n        \
    \    continue\n        elseif arr[i] == i+1\n            arr[i], arr[i+1] = arr[i+1],\
    \ arr[i]\n        else\n            return false\n        end\n    end\n    return\
    \ true\nend\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp_9nxcl3i.jl:47\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\n   Evaluated: false == true\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp_9nxcl3i.jl:47\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_9nxcl3i.jl:46\ntest set: Test Failed at /tmp/tmp_9nxcl3i.jl:48\n\
    \  Expression: candidate([3, 5, 10, 1, 2]) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp_9nxcl3i.jl:48\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_9nxcl3i.jl:46\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_9nxcl3i.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    return true\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpjcgr9199.jl:38\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpjcgr9199.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpjcgr9199.jl:35\ntest set: Test Failed at /tmp/tmpjcgr9199.jl:39\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpjcgr9199.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpjcgr9199.jl:35\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpjcgr9199.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr) == 0\n        return\
    \ true\n    end\n    if length(arr) == 1\n        return true\n    end\n    if\
    \ length(arr) == 2\n        return true\n    end\n    if length(arr) == 3\n  \
    \      if arr[1] <= arr[2] <= arr[3]\n            return true\n        else\n\
    \            return false\n        end\n    end\n    if length(arr) == 4\n   \
    \     if arr[1] <= arr[2] <= arr[3] <= arr[4]\n            return true\n     \
    \   else\n            return false\n        end\n    end\n    if length(arr) ==\
    \ 5\n        if arr[1] <= arr[2] <= arr[3] <= arr[4] <= arr[5]\n            return\
    \ true\n        else\n            return false\n        end\n    end\n    if length(arr)\
    \ == 6\n        if arr[1] <= arr[2] <= arr[3] <= arr[4] <= arr[5] <= arr[6]\n\
    \            return true\n        else\n            return false\n        end\n\
    \    end\n    if length(arr) == 7\n        if arr[1] <= arr[2] <= arr[3] <= arr[4]\
    \ <= arr[5] <= arr[6] <= arr[7]\n            return true\n        else\n     \
    \       return false\n        end\n    end\n    if length(arr) == 8\n        if\
    \ arr[1] <= arr[2] <= arr[3] <= arr[4] <= arr[5] <= arr[6] <= arr[7] <= arr[8]\n\
    \            return true\n        else\n            return false\n        end\n\
    \    end\n    if length(arr) == 9\n        if arr[1] <= arr[2] <= arr[3] <= arr[4]\
    \ <= arr[5] <= arr[6] <= arr[7] <= arr[8] <= arr[9]\n            return true\n\
    \        else\n            return false\n        end\n    end\n    if length(arr)\
    \ == 10\n        if arr[1] <= arr[2] <= arr[3] <= arr[4] <= arr[5] <= arr[6] <=\
    \ arr[7] <= arr[8] <= arr[9] <= arr\nusing Test\n\n@testset begin\n\ncandidate\
    \ = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2]) == true)\n\t@test(candidate([3,\
    \ 5, 10, 1, 2]) == true)\n\t@test(candidate([4, 3, 1, 2]) == false)\n\t@test(candidate([3,\
    \ 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([])) == true)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpfxhqcigl.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpfxhqcigl.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    # You can\
    \ add helper functions as needed\n    return true\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2]) == true)\n\
    \t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4, 3, 1, 2])\
    \ == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpyrgcfsbt.jl:39\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpyrgcfsbt.jl:39\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpyrgcfsbt.jl:36\ntest set: Test Failed at /tmp/tmpyrgcfsbt.jl:40\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpyrgcfsbt.jl:40\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpyrgcfsbt.jl:36\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpyrgcfsbt.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    # You can\
    \ add helper functions as needed\n    return true\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2]) == true)\n\
    \t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4, 3, 1, 2])\
    \ == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpbos1eqo8.jl:39\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpbos1eqo8.jl:39\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbos1eqo8.jl:36\ntest set: Test Failed at /tmp/tmpbos1eqo8.jl:40\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpbos1eqo8.jl:40\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbos1eqo8.jl:36\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbos1eqo8.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # YOUR CODE HERE\n    return true\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmprpwgpbj1.jl:38\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmprpwgpbj1.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprpwgpbj1.jl:35\ntest set: Test Failed at /tmp/tmprpwgpbj1.jl:39\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmprpwgpbj1.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprpwgpbj1.jl:35\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmprpwgpbj1.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # YOUR CODE HERE\n    return false\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpqy2biecj.jl:36\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\n   Evaluated: false == true\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpqy2biecj.jl:36\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpqy2biecj.jl:35\ntest set: Test Failed at /tmp/tmpqy2biecj.jl:37\n\
    \  Expression: candidate([3, 5, 10, 1, 2]) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpqy2biecj.jl:37\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpqy2biecj.jl:35\ntest set: Test Failed at /tmp/tmpqy2biecj.jl:40\n\
    \  Expression: candidate(Vector{Int64}([])) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpqy2biecj.jl:40\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpqy2biecj.jl:35\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     3      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqy2biecj.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr)==0\n        return\
    \ true\n    end\n    for i in 1:length(arr)\n        if arr[i]==i\n          \
    \  continue\n        elseif arr[i]==i+1\n            arr[i],arr[i+1]=arr[i+1],arr[i]\n\
    \        else\n            return false\n        end\n    end\n    return true\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpw34knx6u.jl:47\\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\\n   Evaluated: false == true\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmpw34knx6u.jl:47\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpw34knx6u.jl:46\\ntest set: Test Failed at /tmp/tmpw34knx6u.jl:48\\\
    n  Expression: candidate([3, 5, 10, 1, 2]) == true\\n   Evaluated: false == true\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpw34knx6u.jl:48\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpw34knx6u.jl:46\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    3     2      5\\n'"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr)==0\n        return\
    \ true\n    end\n    if length(arr)==1\n        return true\n    end\n    if length(arr)==2\n\
    \        if arr[1]<=arr[2]\n            return true\n        else\n          \
    \  return false\n        end\n    end\n    if length(arr)==3\n        if arr[1]<=arr[2]\
    \ && arr[2]<=arr[3]\n            return true\n        elseif arr[1]<=arr[3] &&\
    \ arr[3]<=arr[2]\n            return true\n        elseif arr[2]<=arr[1] && arr[1]<=arr[3]\n\
    \            return true\n        elseif arr[2]<=arr[3] && arr[3]<=arr[1]\n  \
    \          return true\n        elseif arr[3]<=arr[1] && arr[1]<=arr[2]\n    \
    \        return true\n        elseif arr[3]<=arr[2] && arr[2]<=arr[1]\n      \
    \      return true\n        else\n            return false\n        end\n    end\n\
    \    if length(arr)>3\n        if arr[1]<=arr[2] && arr[2]<=arr[3]\n         \
    \   return true\n        elseif arr[1]<=arr[3] && arr[3]<=arr[2]\n           \
    \ return true\n        elseif arr[2]<=arr[1] && arr[1]<=arr[3]\n            return\
    \ true\n        elseif arr[2]<=arr[3] && arr[3]<=arr[1]\n            return true\n\
    \        elseif arr[3]<=arr[1] && arr[1]<=arr[2]\n            return true\n  \
    \      elseif arr[3]<=arr[2] && arr[2]<=arr[1]\n            return true\n    \
    \    else\n            return false\n        end\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2])\
    \ == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpin783b2r.jl:83\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpin783b2r.jl:83\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpin783b2r.jl:80\ntest set: Test Failed at /tmp/tmpin783b2r.jl:84\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpin783b2r.jl:84\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpin783b2r.jl:80\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpin783b2r.jl:78\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr) == 0\n        return\
    \ true\n    end\n    if length(arr) == 1\n        return true\n    end\n    if\
    \ length(arr) == 2\n        return true\n    end\n    if length(arr) == 3\n  \
    \      return true\n    end\n    if length(arr) == 4\n        return true\n  \
    \  end\n    if length(arr) == 5\n        return true\n    end\n    if length(arr)\
    \ == 6\n        return true\n    end\n    if length(arr) == 7\n        return\
    \ true\n    end\n    if length(arr) == 8\n        return true\n    end\n    if\
    \ length(arr) == 9\n        return true\n    end\n    if length(arr) == 10\n \
    \       return true\n    end\n    if length(arr) == 11\n        return true\n\
    \    end\n    if length(arr) == 12\n        return true\n    end\n    if length(arr)\
    \ == 13\n        return true\n    end\n    if length(arr) == 14\n        return\
    \ true\n    end\n    if length(arr) == 15\n        return true\n    end\n    if\
    \ length(arr) == 16\n        return true\n    end\n    if length(arr) == 17\n\
    \        return true\n    end\n    if length(arr) == 18\n        return true\n\
    \    end\n    if length(arr) == 19\n        return true\n    end\n    if length(arr)\
    \ == 20\n        return true\n    end\n    if length(arr) == 21\n        return\
    \ true\n    end\n    if length(arr) == 22\n        return true\n    end\n    if\
    \ length(arr) == 23\n        return true\n    end\n    if length(arr) == 24\n\
    \        return true\n    end\n    if length(arr) == 25\n        return true\n\
    \    end\n    if length(arr) == 26\n        return true\n    end\n    if length(arr)\
    \ == 27\n        return true\n    end\n    if length(arr) == 28\n        return\
    \ true\n    end\n    if length(arr) == 29\n        return true\n    end\n    if\
    \ length(arr) == 30\n        return true\n    end\n    if length(arr) == 31\n\
    \        return true\n    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\
    \t@test(candidate([3, 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2])\
    \ == true)\n\t@test(candidate([4, 3, 1, 2]) == false)\n\t@test(candidate([3, 5,\
    \ 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([])) == true)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpc32xez54.jl:27\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpc32xez54.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpc32xez54.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr) == 0\n        return\
    \ true\n    end\n    for i in 1:length(arr)\n        if arr[i] == i\n        \
    \    continue\n        elseif arr[i] == i+1\n            arr[i], arr[i+1] = arr[i+1],\
    \ arr[i]\n        else\n            return false\n        end\n    end\n    return\
    \ true\nend\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp94aiw1en.jl:47\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\n   Evaluated: false == true\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp94aiw1en.jl:47\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp94aiw1en.jl:46\ntest set: Test Failed at /tmp/tmp94aiw1en.jl:48\n\
    \  Expression: candidate([3, 5, 10, 1, 2]) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp94aiw1en.jl:48\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp94aiw1en.jl:46\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp94aiw1en.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr) == 0\n        return\
    \ true\n    end\n    if length(arr) == 1\n        return true\n    end\n    if\
    \ length(arr) == 2\n        return true\n    end\n    if length(arr) == 3\n  \
    \      return true\n    end\n    if length(arr) == 4\n        return true\n  \
    \  end\n    if length(arr) == 5\n        return true\n    end\n    if length(arr)\
    \ == 6\n        return true\n    end\n    if length(arr) == 7\n        return\
    \ true\n    end\n    if length(arr) == 8\n        return true\n    end\n    if\
    \ length(arr) == 9\n        return true\n    end\n    if length(arr) == 10\n \
    \       return true\n    end\n    if length(arr) == 11\n        return true\n\
    \    end\n    if length(arr) == 12\n        return true\n    end\n    if length(arr)\
    \ == 13\n        return true\n    end\n    if length(arr) == 14\n        return\
    \ true\n    end\n    if length(arr) == 15\n        return true\n    end\n    if\
    \ length(arr) == 16\n        return true\n    end\n    if length(arr) == 17\n\
    \        return true\n    end\n    if length(arr) == 18\n        return true\n\
    \    end\n    if length(arr) == 19\n        return true\n    end\n    if length(arr)\
    \ == 20\n        return true\n    end\n    if length(arr) == 21\n        return\
    \ true\n    end\n    if length(arr) == 22\n        return true\n    end\n    if\
    \ length(arr) == 23\n        return true\n    end\n    if length(arr) == 24\n\
    \        return true\n    end\n    if length(arr) == 25\n        return true\n\
    \    end\n    if length(arr) == 26\n        return true\n    end\n    if length(arr)\
    \ == 27\n        return true\n    end\n    if length(arr) == 28\n        return\
    \ true\n    end\n    if length(arr) == 29\n        return true\n    end\n    if\
    \ length(arr) == 30\n        return true\n    end\n    if length(arr) == 31\n\
    \        return true\n    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\
    \t@test(candidate([3, 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2])\
    \ == true)\n\t@test(candidate([4, 3, 1, 2]) == false)\n\t@test(candidate([3, 5,\
    \ 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([])) == true)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmppnk4ljj3.jl:27\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmppnk4ljj3.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmppnk4ljj3.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if isempty(arr)\n        return\
    \ true\n    end\n    for i in 1:length(arr)\n        if i != arr[i]\n        \
    \    if i == length(arr)\n                return false\n            end\n    \
    \        if arr[i] != arr[i+1]\n                return false\n            end\n\
    \        end\n    end\n    return true\nend\nusing Test\n\n@testset begin\n\n\
    candidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2]) == true)\n\t@test(candidate([3,\
    \ 5, 10, 1, 2]) == true)\n\t@test(candidate([4, 3, 1, 2]) == false)\n\t@test(candidate([3,\
    \ 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([])) == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpkea9m2fa.jl:48\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\n   Evaluated: false == true\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpkea9m2fa.jl:48\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpkea9m2fa.jl:47\ntest set: Test Failed at /tmp/tmpkea9m2fa.jl:49\n\
    \  Expression: candidate([3, 5, 10, 1, 2]) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpkea9m2fa.jl:49\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpkea9m2fa.jl:47\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpkea9m2fa.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Write your code here\n    #\
    \ Return True if it is possible to get non-decreasing order by performing\n  \
    \  # right shift operation else return False.\n    # If the given array is empty\
    \ then return True.\n    # The given list is guaranteed to have unique elements.\n\
    \    if length(arr) == 0\n        return true\n    end\n    if length(arr) ==\
    \ 1\n        return true\n    end\n    for i in 1:length(arr)\n        if i ==\
    \ 1\n            if arr[i] > arr[i+1]\n                return false\n        \
    \    end\n        elseif i == length(arr)\n            if arr[i] < arr[i-1]\n\
    \                return false\n            end\n        else\n            if arr[i]\
    \ < arr[i-1] || arr[i] > arr[i+1]\n                return false\n            end\n\
    \        end\n    end\n    return true\nend\nusing Test\n\n@testset begin\n\n\
    candidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2]) == true)\n\t@test(candidate([3,\
    \ 5, 10, 1, 2]) == true)\n\t@test(candidate([4, 3, 1, 2]) == false)\n\t@test(candidate([3,\
    \ 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([])) == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpuj_kwhsu.jl:61\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\n   Evaluated: false == true\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpuj_kwhsu.jl:61\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpuj_kwhsu.jl:60\ntest set: Test Failed at /tmp/tmpuj_kwhsu.jl:62\n\
    \  Expression: candidate([3, 5, 10, 1, 2]) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpuj_kwhsu.jl:62\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpuj_kwhsu.jl:60\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpuj_kwhsu.jl:58\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr) == 0\n        return\
    \ true\n    end\n    if length(arr) == 1\n        return true\n    end\n    if\
    \ length(arr) == 2\n        return true\n    end\n    if length(arr) == 3\n  \
    \      if arr[1] > arr[2]\n            arr[1], arr[2] = arr[2], arr[1]\n     \
    \       return true\n        end\n        if arr[1] > arr[3]\n            arr[1],\
    \ arr[3] = arr[3], arr[1]\n            return true\n        end\n        if arr[2]\
    \ > arr[3]\n            arr[2], arr[3] = arr[3], arr[2]\n            return true\n\
    \        end\n        return true\n    end\n    if length(arr) > 3\n        if\
    \ arr[1] > arr[2]\n            arr[1], arr[2] = arr[2], arr[1]\n            return\
    \ true\n        end\n        if arr[1] > arr[3]\n            arr[1], arr[3] =\
    \ arr[3], arr[1]\n            return true\n        end\n        if arr[2] > arr[3]\n\
    \            arr[2], arr[3] = arr[3], arr[2]\n            return true\n      \
    \  end\n        if arr[1] > arr[4]\n            arr[1], arr[4] = arr[4], arr[1]\n\
    \            return true\n        end\n        if arr[2] > arr[4]\n          \
    \  arr[2], arr[4] = arr[4], arr[2]\n            return true\n        end\n   \
    \     if arr[3] > arr[4]\n            arr[3], arr[4] = arr[4], arr[3]\n      \
    \      return true\n        end\n        return true\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1,\
    \ 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmppwm_ofu8.jl:87\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmppwm_ofu8.jl:87\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmppwm_ofu8.jl:84\ntest set: Test Failed at /tmp/tmppwm_ofu8.jl:88\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmppwm_ofu8.jl:88\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmppwm_ofu8.jl:84\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmppwm_ofu8.jl:82\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    return false\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpw841kre0.jl:36\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\n   Evaluated: false == true\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpw841kre0.jl:36\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw841kre0.jl:35\ntest set: Test Failed at /tmp/tmpw841kre0.jl:37\n\
    \  Expression: candidate([3, 5, 10, 1, 2]) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpw841kre0.jl:37\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw841kre0.jl:35\ntest set: Test Failed at /tmp/tmpw841kre0.jl:40\n\
    \  Expression: candidate(Vector{Int64}([])) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpw841kre0.jl:40\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw841kre0.jl:35\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     3      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpw841kre0.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1,\
    \ 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpf21svs5i.jl:35\n  Test threw exception\n\
    \  Expression: candidate([3, 4, 5, 1, 2]) == true\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Bool\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpf21svs5i.jl:29\n   [2] top-level scope at /tmp/tmpf21svs5i.jl:35\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpf21svs5i.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmpf21svs5i.jl:36\n  Test threw exception\n  Expression: candidate([3,\
    \ 5, 10, 1, 2]) == true\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpf21svs5i.jl:29\n   [2] top-level scope at /tmp/tmpf21svs5i.jl:36\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpf21svs5i.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmpf21svs5i.jl:37\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpf21svs5i.jl:29\n   [2] top-level scope at /tmp/tmpf21svs5i.jl:37\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpf21svs5i.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmpf21svs5i.jl:38\n  Test threw exception\n  Expression: candidate([3,\
    \ 5, 4, 1, 2]) == false\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpf21svs5i.jl:29\n   [2] top-level scope at /tmp/tmpf21svs5i.jl:38\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpf21svs5i.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmpf21svs5i.jl:39\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == true\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Bool\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpf21svs5i.jl:29\n   [2] top-level scope at /tmp/tmpf21svs5i.jl:39\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpf21svs5i.jl:34\n  \nTest Summary: | Error \
    \ Total\ntest set      |     5      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpf21svs5i.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1,\
    \ 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpnr7vu8zd.jl:35\n  Test threw exception\n\
    \  Expression: candidate([3, 4, 5, 1, 2]) == true\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Bool\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpnr7vu8zd.jl:29\n   [2] top-level scope at /tmp/tmpnr7vu8zd.jl:35\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpnr7vu8zd.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmpnr7vu8zd.jl:36\n  Test threw exception\n  Expression: candidate([3,\
    \ 5, 10, 1, 2]) == true\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpnr7vu8zd.jl:29\n   [2] top-level scope at /tmp/tmpnr7vu8zd.jl:36\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpnr7vu8zd.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmpnr7vu8zd.jl:37\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpnr7vu8zd.jl:29\n   [2] top-level scope at /tmp/tmpnr7vu8zd.jl:37\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpnr7vu8zd.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmpnr7vu8zd.jl:38\n  Test threw exception\n  Expression: candidate([3,\
    \ 5, 4, 1, 2]) == false\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpnr7vu8zd.jl:29\n   [2] top-level scope at /tmp/tmpnr7vu8zd.jl:38\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpnr7vu8zd.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmpnr7vu8zd.jl:39\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == true\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Bool\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpnr7vu8zd.jl:29\n   [2] top-level scope at /tmp/tmpnr7vu8zd.jl:39\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpnr7vu8zd.jl:34\n  \nTest Summary: | Error \
    \ Total\ntest set      |     5      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnr7vu8zd.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr)==0\n        return\
    \ true\n    end\n    if length(arr)==1\n        return true\n    end\n    if length(arr)==2\n\
    \        if arr[1]<=arr[2]\n            return true\n        else\n          \
    \  return false\n        end\n    end\n    if length(arr)==3\n        if arr[1]<=arr[2]\
    \ && arr[2]<=arr[3]\n            return true\n        elseif arr[1]<=arr[3] &&\
    \ arr[3]<=arr[2]\n            return true\n        elseif arr[2]<=arr[1] && arr[1]<=arr[3]\n\
    \            return true\n        elseif arr[2]<=arr[3] && arr[3]<=arr[1]\n  \
    \          return true\n        elseif arr[3]<=arr[1] && arr[1]<=arr[2]\n    \
    \        return true\n        elseif arr[3]<=arr[2] && arr[2]<=arr[1]\n      \
    \      return true\n        else\n            return false\n        end\n    end\n\
    \    if length(arr)>3\n        if arr[1]<=arr[2] && arr[2]<=arr[3]\n         \
    \   return true\n        elseif arr[1]<=arr[3] && arr[3]<=arr[2]\n           \
    \ return true\n        elseif arr[2]<=arr[1] && arr[1]<=arr[3]\n            return\
    \ true\n        elseif arr[2]<=arr[3] && arr[3]<=arr[1]\n            return true\n\
    \        elseif arr[3]<=arr[1] && arr[1]<=arr[2]\n            return true\n  \
    \      elseif arr[3]<=arr[2] && arr[2]<=arr[1]\n            return true\n    \
    \    else\n            return false\n        end\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2])\
    \ == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmps43h1r6g.jl:83\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmps43h1r6g.jl:83\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmps43h1r6g.jl:80\ntest set: Test Failed at /tmp/tmps43h1r6g.jl:84\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmps43h1r6g.jl:84\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmps43h1r6g.jl:80\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmps43h1r6g.jl:78\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr)==0\n        return\
    \ true\n    end\n    if length(arr)==1\n        return true\n    end\n    if length(arr)==2\n\
    \        if arr[1]<=arr[2]\n            return true\n        else\n          \
    \  return false\n        end\n    end\n    if length(arr)==3\n        if arr[1]<=arr[2]\
    \ && arr[2]<=arr[3]\n            return true\n        elseif arr[1]<=arr[3] &&\
    \ arr[3]<=arr[2]\n            return true\n        elseif arr[2]<=arr[1] && arr[1]<=arr[3]\n\
    \            return true\n        elseif arr[2]<=arr[3] && arr[3]<=arr[1]\n  \
    \          return true\n        elseif arr[3]<=arr[1] && arr[1]<=arr[2]\n    \
    \        return true\n        elseif arr[3]<=arr[2] && arr[2]<=arr[1]\n      \
    \      return true\n        else\n            return false\n        end\n    end\n\
    \    if length(arr)>3\n        if arr[1]<=arr[2] && arr[2]<=arr[3]\n         \
    \   return true\n        elseif arr[1]<=arr[3] && arr[3]<=arr[2]\n           \
    \ return true\n        elseif arr[2]<=arr[1] && arr[1]<=arr[3]\n            return\
    \ true\n        elseif arr[2]<=arr[3] && arr[3]<=arr[1]\n            return true\n\
    \        elseif arr[3]<=arr[1] && arr[1]<=arr[2]\n            return true\n  \
    \      elseif arr[3]<=arr[2] && arr[2]<=arr[1]\n            return true\n    \
    \    else\n            return false\n        end\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2])\
    \ == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp7cgo75xi.jl:83\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp7cgo75xi.jl:83\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7cgo75xi.jl:80\ntest set: Test Failed at /tmp/tmp7cgo75xi.jl:84\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp7cgo75xi.jl:84\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7cgo75xi.jl:80\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7cgo75xi.jl:78\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    # You can\
    \ add helper functions as needed\n    return true\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2]) == true)\n\
    \t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4, 3, 1, 2])\
    \ == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp9v8edd2h.jl:39\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp9v8edd2h.jl:39\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9v8edd2h.jl:36\ntest set: Test Failed at /tmp/tmp9v8edd2h.jl:40\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp9v8edd2h.jl:40\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9v8edd2h.jl:36\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9v8edd2h.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr) == 0\n        return\
    \ true\n    end\n    for i in 1:length(arr)\n        if arr[i] == i\n        \
    \    continue\n        elseif arr[i] == i+1\n            arr[i], arr[i+1] = arr[i+1],\
    \ arr[i]\n        else\n            return false\n        end\n    end\n    return\
    \ true\nend\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpcpdhlfnk.jl:47\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\n   Evaluated: false == true\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpcpdhlfnk.jl:47\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpcpdhlfnk.jl:46\ntest set: Test Failed at /tmp/tmpcpdhlfnk.jl:48\n\
    \  Expression: candidate([3, 5, 10, 1, 2]) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpcpdhlfnk.jl:48\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpcpdhlfnk.jl:46\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpcpdhlfnk.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    return false\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpaahmn5rl.jl:36\\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\\n   Evaluated: false == true\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmpaahmn5rl.jl:36\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpaahmn5rl.jl:35\\ntest set: Test Failed at /tmp/tmpaahmn5rl.jl:37\\\
    n  Expression: candidate([3, 5, 10, 1, 2]) == true\\n   Evaluated: false == true\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpaahmn5rl.jl:37\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpaahmn5rl.jl:35\\ntest set: Test Failed at /tmp/tmpaahmn5rl.jl:40\\\
    n  Expression: candidate(Vector{Int64}([])) == true\\n   Evaluated: false == true\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpaahmn5rl.jl:40\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpaahmn5rl.jl:35\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    2     3      5\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code goes here\n    return\
    \ true\nend\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmplxk8s54j.jl:38\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmplxk8s54j.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplxk8s54j.jl:35\ntest set: Test Failed at /tmp/tmplxk8s54j.jl:39\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmplxk8s54j.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplxk8s54j.jl:35\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmplxk8s54j.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # YOUR CODE HERE\n    return false\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp9yfghdiy.jl:36\\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\\n   Evaluated: false == true\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmp9yfghdiy.jl:36\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp9yfghdiy.jl:35\\ntest set: Test Failed at /tmp/tmp9yfghdiy.jl:37\\\
    n  Expression: candidate([3, 5, 10, 1, 2]) == true\\n   Evaluated: false == true\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp9yfghdiy.jl:37\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp9yfghdiy.jl:35\\ntest set: Test Failed at /tmp/tmp9yfghdiy.jl:40\\\
    n  Expression: candidate(Vector{Int64}([])) == true\\n   Evaluated: false == true\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp9yfghdiy.jl:40\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp9yfghdiy.jl:35\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr) == 0\n        return\
    \ true\n    end\n    for i in 1:length(arr)\n        if arr[i] == i\n        \
    \    continue\n        elseif arr[i] == i+1\n            arr[i], arr[i+1] = arr[i+1],\
    \ arr[i]\n        else\n            return false\n        end\n    end\n    return\
    \ true\nend\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpw1aza5o2.jl:47\\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\\n   Evaluated: false == true\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmpw1aza5o2.jl:47\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpw1aza5o2.jl:46\\ntest set: Test Failed at /tmp/tmpw1aza5o2.jl:48\\\
    n  Expression: candidate([3, 5, 10, 1, 2]) == true\\n   Evaluated: false == true\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpw1aza5o2.jl:48\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpw1aza5o2.jl:46\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    3     2      5\\n'"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr) == 0\n        return\
    \ true\n    end\n    for i in 1:length(arr)\n        if arr[i] == i\n        \
    \    continue\n        elseif arr[i] == i+1\n            arr[i], arr[i+1] = arr[i+1],\
    \ arr[i]\n        else\n            return false\n        end\n    end\n    return\
    \ true\nend\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp847xrdqr.jl:47\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\n   Evaluated: false == true\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp847xrdqr.jl:47\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp847xrdqr.jl:46\ntest set: Test Failed at /tmp/tmp847xrdqr.jl:48\n\
    \  Expression: candidate([3, 5, 10, 1, 2]) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp847xrdqr.jl:48\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp847xrdqr.jl:46\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp847xrdqr.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr) == 0\n        return\
    \ true\n    end\n    if length(arr) == 1\n        return true\n    end\n    for\
    \ i in 1:length(arr)\n        if i == length(arr)\n            if arr[i] < arr[1]\n\
    \                return false\n            end\n        else\n            if arr[i]\
    \ < arr[i+1]\n                continue\n            else\n                return\
    \ false\n            end\n        end\n    end\n    return true\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1,\
    \ 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp_nh10a7u.jl:54\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\n   Evaluated: false == true\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp_nh10a7u.jl:54\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_nh10a7u.jl:53\ntest set: Test Failed at /tmp/tmp_nh10a7u.jl:55\n\
    \  Expression: candidate([3, 5, 10, 1, 2]) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp_nh10a7u.jl:55\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_nh10a7u.jl:53\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_nh10a7u.jl:51\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr) == 0\n        return\
    \ true\n    end\n    for i in 1:length(arr)\n        if i == length(arr)\n   \
    \         return true\n        end\n        if arr[i] > arr[i+1]\n           \
    \ return false\n        end\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2]) == true)\n\t@test(candidate([3,\
    \ 5, 10, 1, 2]) == true)\n\t@test(candidate([4, 3, 1, 2]) == false)\n\t@test(candidate([3,\
    \ 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([])) == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp5mlkh_2z.jl:45\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\n   Evaluated: false == true\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp5mlkh_2z.jl:45\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5mlkh_2z.jl:44\ntest set: Test Failed at /tmp/tmp5mlkh_2z.jl:46\n\
    \  Expression: candidate([3, 5, 10, 1, 2]) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp5mlkh_2z.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5mlkh_2z.jl:44\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5mlkh_2z.jl:42\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr) == 0\n        return\
    \ true\n    end\n    if length(arr) == 1\n        return true\n    end\n    if\
    \ length(arr) == 2\n        return true\n    end\n    if length(arr) == 3\n  \
    \      if arr[1] > arr[2]\n            if arr[2] > arr[3]\n                return\
    \ true\n            else\n                return false\n            end\n    \
    \    else\n            if arr[1] > arr[3]\n                return true\n     \
    \       else\n                return false\n            end\n        end\n   \
    \ end\n    if length(arr) == 4\n        if arr[1] > arr[2]\n            if arr[2]\
    \ > arr[3]\n                if arr[3] > arr[4]\n                    return true\n\
    \                else\n                    return false\n                end\n\
    \            else\n                if arr[1] > arr[3]\n                    if\
    \ arr[3] > arr[4]\n                        return true\n                    else\n\
    \                        return false\n                    end\n             \
    \   else\n                    if arr[1] > arr[4]\n                        return\
    \ true\n                    else\n                        return false\n     \
    \               end\n                end\n            end\n        else\n    \
    \        if arr[1] > arr[3]\n                if arr[3] > arr[4]\n            \
    \        return true\n                else\n                    return false\n\
    \                end\n            else\n                if arr[1] > arr[4]\n \
    \                   return true\n                else\n                    return\
    \ false\n                end\n            end\n        end\n    end\n    if length(arr)\
    \ == 5\n        if arr[1] > arr[2]\n            if arr[2] > arr[3]\n         \
    \       if arr[3] > arr[4]\n                    if arr[4] > arr[5]\n         \
    \               return true\n                    else\n                      \
    \  return false\n                    end\n                else\n             \
    \       if arr[1] > arr[4]\n                        if arr[4] > arr[5]\n     \
    \                       return true\n                        else\n          \
    \                  return false\n                        end\n               \
    \     else\n                        if arr[1] > arr[5]\n                     \
    \       return true\n                        else\n                          \
    \  return false\n                        end\n                    end\n      \
    \          end\n            else\n                if arr[1] > arr[3]\n       \
    \            \nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t\
    @test(candidate([3, 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2])\
    \ == true)\n\t@test(candidate([4, 3, 1, 2]) == false)\n\t@test(candidate([3, 5,\
    \ 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([])) == true)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpxdffrjij.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpxdffrjij.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    return false\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpqq5fsb7z.jl:36\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\n   Evaluated: false == true\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpqq5fsb7z.jl:36\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpqq5fsb7z.jl:35\ntest set: Test Failed at /tmp/tmpqq5fsb7z.jl:37\n\
    \  Expression: candidate([3, 5, 10, 1, 2]) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpqq5fsb7z.jl:37\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpqq5fsb7z.jl:35\ntest set: Test Failed at /tmp/tmpqq5fsb7z.jl:40\n\
    \  Expression: candidate(Vector{Int64}([])) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpqq5fsb7z.jl:40\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpqq5fsb7z.jl:35\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     3      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqq5fsb7z.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr) == 0\n        return\
    \ true\n    end\n    if length(arr) == 1\n        return true\n    end\n    if\
    \ length(arr) == 2\n        if arr[1] > arr[2]\n            return false\n   \
    \     else\n            return true\n        end\n    end\n    if length(arr)\
    \ == 3\n        if arr[1] > arr[2]\n            if arr[2] > arr[3]\n         \
    \       return false\n            else\n                return true\n        \
    \    end\n        else\n            if arr[1] > arr[3]\n                return\
    \ false\n            else\n                return true\n            end\n    \
    \    end\n    end\n    if length(arr) > 3\n        for i in 1:length(arr)\n  \
    \          if arr[i] > arr[i+1]\n                if arr[i+1] > arr[i+2]\n    \
    \                return false\n                else\n                    return\
    \ true\n                end\n            end\n        end\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # YOUR CODE HERE\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1,\
    \ 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpq23j1ed9.jl:35\n  Test threw exception\n\
    \  Expression: candidate([3, 4, 5, 1, 2]) == true\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Bool\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpq23j1ed9.jl:29\n   [2] top-level scope at /tmp/tmpq23j1ed9.jl:35\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq23j1ed9.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmpq23j1ed9.jl:36\n  Test threw exception\n  Expression: candidate([3,\
    \ 5, 10, 1, 2]) == true\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpq23j1ed9.jl:29\n   [2] top-level scope at /tmp/tmpq23j1ed9.jl:36\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq23j1ed9.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmpq23j1ed9.jl:37\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpq23j1ed9.jl:29\n   [2] top-level scope at /tmp/tmpq23j1ed9.jl:37\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq23j1ed9.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmpq23j1ed9.jl:38\n  Test threw exception\n  Expression: candidate([3,\
    \ 5, 4, 1, 2]) == false\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpq23j1ed9.jl:29\n   [2] top-level scope at /tmp/tmpq23j1ed9.jl:38\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq23j1ed9.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmpq23j1ed9.jl:39\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == true\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Bool\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpq23j1ed9.jl:29\n   [2] top-level scope at /tmp/tmpq23j1ed9.jl:39\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq23j1ed9.jl:34\n  \nTest Summary: | Error \
    \ Total\ntest set      |     5      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpq23j1ed9.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    # You can\
    \ add helper functions here\n    # You can also use some inbuilt functions\n \
    \   # You can also use some inbuilt functions\n    if length(arr) == 0\n     \
    \   return true\n    end\n    if length(arr) == 1\n        return true\n    end\n\
    \    if length(arr) == 2\n        return true\n    end\n    if length(arr) ==\
    \ 3\n        if arr[1] < arr[2]\n            if arr[2] < arr[3]\n            \
    \    return true\n            else\n                return false\n           \
    \ end\n        else\n            if arr[1] < arr[3]\n                return true\n\
    \            else\n                return false\n            end\n        end\n\
    \    end\n    if length(arr) == 4\n        if arr[1] < arr[2]\n            if\
    \ arr[2] < arr[3]\n                if arr[3] < arr[4]\n                    return\
    \ true\n                else\n                    return false\n             \
    \   end\n            else\n                if arr[1] < arr[3]\n              \
    \      if arr[3] < arr[4]\n                        return true\n             \
    \       else\n                        return false\n                    end\n\
    \                else\n                    return false\n                end\n\
    \            end\n        else\n            if arr[1] < arr[3]\n             \
    \   if arr[3] < arr[4]\n                    return true\n                else\n\
    \                    return false\n                end\n            else\n   \
    \             return false\n            end\n        end\n    end\n    if length(arr)\
    \ == 5\n        if arr[1] < arr[2]\n            if arr[2] < arr[3]\n         \
    \       if arr[3] < arr[4]\n                    if arr[4] < arr[5]\n         \
    \               return true\n                    else\n                      \
    \  return false\n                    end\n                else\n             \
    \       if arr[1] < arr[4]\n                        if arr[4] < arr[5]\n     \
    \                       return true\n                        else\n          \
    \                  return false\n                        end\n               \
    \     else\n                        return false\n                    end\n  \
    \              end\n            else\n                if arr[1] < arr[3]\n   \
    \                 if arr[3] < arr[4]\n                        if arr[4] < arr[5]\n\
    \                            return true\n                        else\n\nusing\
    \ Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"if\" at /tmp/tmp82snd83n.jl:110\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp82snd83n.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp82snd83n.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    return true\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpn0jvby1b.jl:38\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpn0jvby1b.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpn0jvby1b.jl:35\ntest set: Test Failed at /tmp/tmpn0jvby1b.jl:39\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpn0jvby1b.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpn0jvby1b.jl:35\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpn0jvby1b.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    return true\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpwboai66v.jl:38\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpwboai66v.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwboai66v.jl:35\ntest set: Test Failed at /tmp/tmpwboai66v.jl:39\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpwboai66v.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwboai66v.jl:35\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwboai66v.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr)==0\n        return\
    \ true\n    end\n    for i in 1:length(arr)\n        if arr[i]==i\n          \
    \  continue\n        elseif arr[i]>i\n            return false\n        else\n\
    \            arr[i],arr[arr[i]]=arr[arr[i]],arr[i]\n            i=i-1\n      \
    \  end\n    end\n    return true\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2]) == true)\n\t@test(candidate([3,\
    \ 5, 10, 1, 2]) == true)\n\t@test(candidate([4, 3, 1, 2]) == false)\n\t@test(candidate([3,\
    \ 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([])) == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpep9ckv6e.jl:48\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\n   Evaluated: false == true\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpep9ckv6e.jl:48\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpep9ckv6e.jl:47\ntest set: Test Failed at /tmp/tmpep9ckv6e.jl:49\n\
    \  Expression: candidate([3, 5, 10, 1, 2]) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpep9ckv6e.jl:49\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpep9ckv6e.jl:47\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpep9ckv6e.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr)==0\n        return\
    \ true\n    end\n    if length(arr)==1\n        return true\n    end\n    if length(arr)==2\n\
    \        if arr[1]<=arr[2]\n            return true\n        else\n          \
    \  return false\n        end\n    end\n    if length(arr)==3\n        if arr[1]<=arr[2]\
    \ && arr[2]<=arr[3]\n            return true\n        elseif arr[1]<=arr[3] &&\
    \ arr[3]<=arr[2]\n            return true\n        elseif arr[2]<=arr[1] && arr[1]<=arr[3]\n\
    \            return true\n        elseif arr[2]<=arr[3] && arr[3]<=arr[1]\n  \
    \          return true\n        elseif arr[3]<=arr[1] && arr[1]<=arr[2]\n    \
    \        return true\n        elseif arr[3]<=arr[2] && arr[2]<=arr[1]\n      \
    \      return true\n        else\n            return false\n        end\n    end\n\
    \    if length(arr)>3\n        if arr[1]<=arr[2] && arr[2]<=arr[3]\n         \
    \   return true\n        elseif arr[1]<=arr[3] && arr[3]<=arr[2]\n           \
    \ return true\n        elseif arr[2]<=arr[1] && arr[1]<=arr[3]\n            return\
    \ true\n        elseif arr[2]<=arr[3] && arr[3]<=arr[1]\n            return true\n\
    \        elseif arr[3]<=arr[1] && arr[1]<=arr[2]\n            return true\n  \
    \      elseif arr[3]<=arr[2] && arr[2]<=arr[1]\n            return true\n    \
    \    else\n            return false\n        end\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2])\
    \ == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpjsoks7dw.jl:83\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpjsoks7dw.jl:83\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpjsoks7dw.jl:80\ntest set: Test Failed at /tmp/tmpjsoks7dw.jl:84\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpjsoks7dw.jl:84\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpjsoks7dw.jl:80\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpjsoks7dw.jl:78\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # YOUR CODE HERE\n    return true\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpocxkggs4.jl:38\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpocxkggs4.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpocxkggs4.jl:35\ntest set: Test Failed at /tmp/tmpocxkggs4.jl:39\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpocxkggs4.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpocxkggs4.jl:35\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpocxkggs4.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr) == 0\n        return\
    \ true\n    end\n    min_val = minimum(arr)\n    min_index = findall(arr .== min_val)[1]\n\
    \    if min_index == 1\n        return true\n    end\n    return false\nend\n\
    using Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpcpzj7dmx.jl:43\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\n   Evaluated: false == true\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpcpzj7dmx.jl:43\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpcpzj7dmx.jl:42\ntest set: Test Failed at /tmp/tmpcpzj7dmx.jl:44\n\
    \  Expression: candidate([3, 5, 10, 1, 2]) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpcpzj7dmx.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpcpzj7dmx.jl:42\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpcpzj7dmx.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    return true\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp8vpz4clg.jl:38\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp8vpz4clg.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8vpz4clg.jl:35\ntest set: Test Failed at /tmp/tmp8vpz4clg.jl:39\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp8vpz4clg.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8vpz4clg.jl:35\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8vpz4clg.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1,\
    \ 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpy47358m9.jl:35\n  Test threw exception\n\
    \  Expression: candidate([3, 4, 5, 1, 2]) == true\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Bool\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpy47358m9.jl:29\n   [2] top-level scope at /tmp/tmpy47358m9.jl:35\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpy47358m9.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmpy47358m9.jl:36\n  Test threw exception\n  Expression: candidate([3,\
    \ 5, 10, 1, 2]) == true\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpy47358m9.jl:29\n   [2] top-level scope at /tmp/tmpy47358m9.jl:36\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpy47358m9.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmpy47358m9.jl:37\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpy47358m9.jl:29\n   [2] top-level scope at /tmp/tmpy47358m9.jl:37\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpy47358m9.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmpy47358m9.jl:38\n  Test threw exception\n  Expression: candidate([3,\
    \ 5, 4, 1, 2]) == false\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpy47358m9.jl:29\n   [2] top-level scope at /tmp/tmpy47358m9.jl:38\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpy47358m9.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmpy47358m9.jl:39\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == true\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Bool\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpy47358m9.jl:29\n   [2] top-level scope at /tmp/tmpy47358m9.jl:39\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpy47358m9.jl:34\n  \nTest Summary: | Error \
    \ Total\ntest set      |     5      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpy47358m9.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    return true\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp1x1uff_u.jl:38\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp1x1uff_u.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1x1uff_u.jl:35\ntest set: Test Failed at /tmp/tmp1x1uff_u.jl:39\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp1x1uff_u.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1x1uff_u.jl:35\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1x1uff_u.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1,\
    \ 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp0suayt78.jl:35\n  Test threw exception\n\
    \  Expression: candidate([3, 4, 5, 1, 2]) == true\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Bool\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmp0suayt78.jl:29\n   [2] top-level scope at /tmp/tmp0suayt78.jl:35\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0suayt78.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmp0suayt78.jl:36\n  Test threw exception\n  Expression: candidate([3,\
    \ 5, 10, 1, 2]) == true\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmp0suayt78.jl:29\n   [2] top-level scope at /tmp/tmp0suayt78.jl:36\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0suayt78.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmp0suayt78.jl:37\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmp0suayt78.jl:29\n   [2] top-level scope at /tmp/tmp0suayt78.jl:37\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0suayt78.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmp0suayt78.jl:38\n  Test threw exception\n  Expression: candidate([3,\
    \ 5, 4, 1, 2]) == false\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmp0suayt78.jl:29\n   [2] top-level scope at /tmp/tmp0suayt78.jl:38\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0suayt78.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmp0suayt78.jl:39\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == true\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Bool\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmp0suayt78.jl:29\n   [2] top-level scope at /tmp/tmp0suayt78.jl:39\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0suayt78.jl:34\n  \nTest Summary: | Error \
    \ Total\ntest set      |     5      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0suayt78.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr)==0\n        return\
    \ true\n    end\n    if length(arr)==1\n        return true\n    end\n    if length(arr)==2\n\
    \        if arr[1]<=arr[2]\n            return true\n        else\n          \
    \  return false\n        end\n    end\n    if length(arr)==3\n        if arr[1]<=arr[2]\
    \ && arr[2]<=arr[3]\n            return true\n        elseif arr[1]<=arr[3] &&\
    \ arr[3]<=arr[2]\n            return true\n        elseif arr[2]<=arr[1] && arr[1]<=arr[3]\n\
    \            return true\n        elseif arr[2]<=arr[3] && arr[3]<=arr[1]\n  \
    \          return true\n        elseif arr[3]<=arr[1] && arr[1]<=arr[2]\n    \
    \        return true\n        elseif arr[3]<=arr[2] && arr[2]<=arr[1]\n      \
    \      return true\n        else\n            return false\n        end\n    end\n\
    \    if length(arr)>3\n        if arr[1]<=arr[2] && arr[2]<=arr[3]\n         \
    \   return true\n        elseif arr[1]<=arr[3] && arr[3]<=arr[2]\n           \
    \ return true\n        elseif arr[2]<=arr[1] && arr[1]<=arr[3]\n            return\
    \ true\n        elseif arr[2]<=arr[3] && arr[3]<=arr[1]\n            return true\n\
    \        elseif arr[3]<=arr[1] && arr[1]<=arr[2]\n            return true\n  \
    \      elseif arr[3]<=arr[2] && arr[2]<=arr[1]\n            return true\n    \
    \    else\n            return false\n        end\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2])\
    \ == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpa1vq6_tt.jl:83\\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\\n   Evaluated: true == false\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmpa1vq6_tt.jl:83\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpa1vq6_tt.jl:80\\ntest set: Test Failed at /tmp/tmpa1vq6_tt.jl:84\\\
    n  Expression: candidate([3, 5, 4, 1, 2]) == false\\n   Evaluated: true == false\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpa1vq6_tt.jl:84\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpa1vq6_tt.jl:80\\nTest Summary: | Pass  Fail \
    \ Total\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    return false\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpx7evv6q3.jl:36\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\n   Evaluated: false == true\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpx7evv6q3.jl:36\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpx7evv6q3.jl:35\ntest set: Test Failed at /tmp/tmpx7evv6q3.jl:37\n\
    \  Expression: candidate([3, 5, 10, 1, 2]) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpx7evv6q3.jl:37\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpx7evv6q3.jl:35\ntest set: Test Failed at /tmp/tmpx7evv6q3.jl:40\n\
    \  Expression: candidate(Vector{Int64}([])) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpx7evv6q3.jl:40\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpx7evv6q3.jl:35\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     3      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpx7evv6q3.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr) == 0\n        return\
    \ true\n    end\n    if length(arr) == 1\n        return true\n    end\n    if\
    \ length(arr) == 2\n        if arr[1] <= arr[2]\n            return true\n   \
    \     else\n            return false\n        end\n    end\n    if length(arr)\
    \ == 3\n        if arr[1] <= arr[2] <= arr[3]\n            return true\n     \
    \   elseif arr[1] <= arr[3] <= arr[2]\n            return true\n        elseif\
    \ arr[2] <= arr[1] <= arr[3]\n            return true\n        elseif arr[2] <=\
    \ arr[3] <= arr[1]\n            return true\n        elseif arr[3] <= arr[1] <=\
    \ arr[2]\n            return true\n        elseif arr[3] <= arr[2] <= arr[1]\n\
    \            return true\n        else\n            return false\n        end\n\
    \    end\n    if length(arr) > 3\n        if arr[1] <= arr[2] <= arr[3]\n    \
    \        return move_one_ball(arr[2:end])\n        elseif arr[1] <= arr[3] <=\
    \ arr[2]\n            return move_one_ball(arr[2:end])\n        elseif arr[2]\
    \ <= arr[1] <= arr[3]\n            return move_one_ball(arr[2:end])\n        elseif\
    \ arr[2] <= arr[3] <= arr[1]\n            return move_one_ball(arr[2:end])\n \
    \       elseif arr[3] <= arr[1] <= arr[2]\n            return move_one_ball(arr[2:end])\n\
    \        elseif arr[3] <= arr[2] <= arr[1]\n            return move_one_ball(arr[2:end])\n\
    \        else\n            return false\n        end\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1,\
    \ 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp1gkhf54m.jl:83\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp1gkhf54m.jl:83\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1gkhf54m.jl:80\ntest set: Test Failed at /tmp/tmp1gkhf54m.jl:84\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp1gkhf54m.jl:84\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1gkhf54m.jl:80\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1gkhf54m.jl:78\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr)==0\n        return\
    \ true\n    end\n    for i in 1:length(arr)\n        if arr[i]==i\n          \
    \  continue\n        elseif arr[i]==i+1\n            arr[i],arr[i+1]=arr[i+1],arr[i]\n\
    \        else\n            return false\n        end\n    end\n    return true\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpb4u47740.jl:47\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\n   Evaluated: false == true\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpb4u47740.jl:47\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpb4u47740.jl:46\ntest set: Test Failed at /tmp/tmpb4u47740.jl:48\n\
    \  Expression: candidate([3, 5, 10, 1, 2]) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpb4u47740.jl:48\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpb4u47740.jl:46\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpb4u47740.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr)==0\n        return\
    \ true\n    end\n    for i in 1:length(arr)\n        if arr[i]==i\n          \
    \  continue\n        elseif arr[i]>i\n            return false\n        else\n\
    \            return true\n        end\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2]) == true)\n\t\
    @test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4, 3, 1, 2]) ==\
    \ false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpue_or5tx.jl:46\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\n   Evaluated: false == true\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpue_or5tx.jl:46\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpue_or5tx.jl:45\ntest set: Test Failed at /tmp/tmpue_or5tx.jl:47\n\
    \  Expression: candidate([3, 5, 10, 1, 2]) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpue_or5tx.jl:47\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpue_or5tx.jl:45\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpue_or5tx.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr)==0\n        return\
    \ true\n    end\n    if length(arr)==1\n        return true\n    end\n    if length(arr)==2\n\
    \        if arr[1]>arr[2]\n            return false\n        else\n          \
    \  return true\n        end\n    end\n    for i in 1:length(arr)-1\n        if\
    \ arr[i]>arr[i+1]\n            return false\n        end\n    end\n    return\
    \ true\nend\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpfqi7fzps.jl:53\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\n   Evaluated: false == true\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpfqi7fzps.jl:53\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfqi7fzps.jl:52\ntest set: Test Failed at /tmp/tmpfqi7fzps.jl:54\n\
    \  Expression: candidate([3, 5, 10, 1, 2]) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpfqi7fzps.jl:54\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfqi7fzps.jl:52\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpfqi7fzps.jl:50\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    return true\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpkkk5j62b.jl:38\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpkkk5j62b.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpkkk5j62b.jl:35\ntest set: Test Failed at /tmp/tmpkkk5j62b.jl:39\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpkkk5j62b.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpkkk5j62b.jl:35\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpkkk5j62b.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    return true\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp94h41cec.jl:38\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp94h41cec.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp94h41cec.jl:35\ntest set: Test Failed at /tmp/tmp94h41cec.jl:39\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp94h41cec.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp94h41cec.jl:35\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp94h41cec.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr)==0\n        return\
    \ true\n    end\n    if length(arr)==1\n        return true\n    end\n    if length(arr)==2\n\
    \        if arr[1]>arr[2]\n            return false\n        else\n          \
    \  return true\n        end\n    end\n    if length(arr)==3\n        if arr[1]>arr[2]\n\
    \            if arr[2]>arr[3]\n                return false\n            else\n\
    \                return true\n            end\n        else\n            if arr[1]>arr[3]\n\
    \                return false\n            else\n                return true\n\
    \            end\n        end\n    end\n    if length(arr)>3\n        if arr[1]>arr[2]\n\
    \            if arr[2]>arr[3]\n                return false\n            else\n\
    \                return true\n            end\n        else\n            if arr[1]>arr[3]\n\
    \                return false\n            else\n                return true\n\
    \            end\n        end\n    end\nend\nusing Test\n\n@testset begin\n\n\
    candidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2]) == true)\n\t@test(candidate([3,\
    \ 5, 10, 1, 2]) == true)\n\t@test(candidate([4, 3, 1, 2]) == false)\n\t@test(candidate([3,\
    \ 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([])) == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp02sr83n4.jl:80\n  Expression: candidate([3,\
    \ 5, 4, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp02sr83n4.jl:80\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp02sr83n4.jl:76\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp02sr83n4.jl:74\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr) == 0\n        return\
    \ true\n    end\n    if length(arr) == 1\n        return true\n    end\n    if\
    \ length(arr) == 2\n        return true\n    end\n    if length(arr) == 3\n  \
    \      if arr[1] < arr[2] && arr[2] < arr[3]\n            return true\n      \
    \  elseif arr[1] > arr[2] && arr[2] > arr[3]\n            return true\n      \
    \  else\n            return false\n        end\n    end\n    if length(arr) ==\
    \ 4\n        if arr[1] < arr[2] && arr[2] < arr[3] && arr[3] < arr[4]\n      \
    \      return true\n        elseif arr[1] > arr[2] && arr[2] > arr[3] && arr[3]\
    \ > arr[4]\n            return true\n        else\n            return false\n\
    \        end\n    end\n    if length(arr) == 5\n        if arr[1] < arr[2] &&\
    \ arr[2] < arr[3] && arr[3] < arr[4] && arr[4] < arr[5]\n            return true\n\
    \        elseif arr[1] > arr[2] && arr[2] > arr[3] && arr[3] > arr[4] && arr[4]\
    \ > arr[5]\n            return true\n        else\n            return false\n\
    \        end\n    end\n    if length(arr) == 6\n        if arr[1] < arr[2] &&\
    \ arr[2] < arr[3] && arr[3] < arr[4] && arr[4] < arr[5] && arr[5] < arr[6]\n \
    \           return true\n        elseif arr[1] > arr[2] && arr[2] > arr[3] &&\
    \ arr[3] > arr[4] && arr[4] > arr[5] && arr[5] > arr[6]\n            return true\n\
    \        else\n            return false\n        end\n    end\n    if length(arr)\
    \ == 7\n        if arr[1] < arr[2] && arr[2] < arr[3] && arr[3] < arr[4] && arr[\n\
    using Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpw7lohh40.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpw7lohh40.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr) == 0\n        return\
    \ true\n    end\n    if length(arr) == 1\n        return true\n    end\n    if\
    \ length(arr) == 2\n        return true\n    end\n    if length(arr) == 3\n  \
    \      return true\n    end\n    if length(arr) == 4\n        return true\n  \
    \  end\n    if length(arr) == 5\n        return true\n    end\n    if length(arr)\
    \ == 6\n        return true\n    end\n    if length(arr) == 7\n        return\
    \ true\n    end\n    if length(arr) == 8\n        return true\n    end\n    if\
    \ length(arr) == 9\n        return true\n    end\n    if length(arr) == 10\n \
    \       return true\n    end\n    if length(arr) == 11\n        return true\n\
    \    end\n    if length(arr) == 12\n        return true\n    end\n    if length(arr)\
    \ == 13\n        return true\n    end\n    if length(arr) == 14\n        return\
    \ true\n    end\n    if length(arr) == 15\n        return true\n    end\n    if\
    \ length(arr) == 16\n        return true\n    end\n    if length(arr) == 17\n\
    \        return true\n    end\n    if length(arr) == 18\n        return true\n\
    \    end\n    if length(arr) == 19\n        return true\n    end\n    if length(arr)\
    \ == 20\n        return true\n    end\n    if length(arr) == 21\n        return\
    \ true\n    end\n    if length(arr) == 22\n        return true\n    end\n    if\
    \ length(arr) == 23\n        return true\n    end\n    if length(arr) == 24\n\
    \        return true\n    end\n    if length(arr) == 25\n        return true\n\
    \    end\n    if length(arr) == 26\n        return true\n    end\n    if length(arr)\
    \ == 27\n        return true\n    end\n    if length(arr) == 28\n        return\
    \ true\n    end\n    if length(arr) == 29\n        return true\n    end\n    if\
    \ length(arr) == 30\n        return true\n    end\n    if length(arr) == 31\n\
    \        return true\n    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\
    \t@test(candidate([3, 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2])\
    \ == true)\n\t@test(candidate([4, 3, 1, 2]) == false)\n\t@test(candidate([3, 5,\
    \ 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([])) == true)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpyb7cmm6m.jl:27\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpyb7cmm6m.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpyb7cmm6m.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr)==0\n        return\
    \ true\n    end\n    if length(arr)==1\n        return true\n    end\n    if length(arr)==2\n\
    \        if arr[1]<=arr[2]\n            return true\n        else\n          \
    \  return false\n        end\n    end\n    if length(arr)==3\n        if arr[1]<=arr[2]\
    \ && arr[2]<=arr[3]\n            return true\n        elseif arr[1]<=arr[3] &&\
    \ arr[3]<=arr[2]\n            return true\n        elseif arr[2]<=arr[1] && arr[1]<=arr[3]\n\
    \            return true\n        elseif arr[2]<=arr[3] && arr[3]<=arr[1]\n  \
    \          return true\n        elseif arr[3]<=arr[1] && arr[1]<=arr[2]\n    \
    \        return true\n        elseif arr[3]<=arr[2] && arr[2]<=arr[1]\n      \
    \      return true\n        else\n            return false\n        end\n    end\n\
    \    if length(arr)>3\n        if arr[1]<=arr[2] && arr[2]<=arr[3]\n         \
    \   return true\n        elseif arr[1]<=arr[3] && arr[3]<=arr[2]\n           \
    \ return true\n        elseif arr[2]<=arr[1] && arr[1]<=arr[3]\n            return\
    \ true\n        elseif arr[2]<=arr[3] && arr[3]<=arr[1]\n            return true\n\
    \        elseif arr[3]<=arr[1] && arr[1]<=arr[2]\n            return true\n  \
    \      elseif arr[3]<=arr[2] && arr[2]<=arr[1]\n            return true\n    \
    \    else\n            return false\n        end\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2])\
    \ == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpbmo3t_fa.jl:83\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpbmo3t_fa.jl:83\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbmo3t_fa.jl:80\ntest set: Test Failed at /tmp/tmpbmo3t_fa.jl:84\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpbmo3t_fa.jl:84\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbmo3t_fa.jl:80\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbmo3t_fa.jl:78\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1,\
    \ 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpp9m4uant.jl:35\n  Test threw exception\n\
    \  Expression: candidate([3, 4, 5, 1, 2]) == true\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Bool\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpp9m4uant.jl:29\n   [2] top-level scope at /tmp/tmpp9m4uant.jl:35\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpp9m4uant.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmpp9m4uant.jl:36\n  Test threw exception\n  Expression: candidate([3,\
    \ 5, 10, 1, 2]) == true\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpp9m4uant.jl:29\n   [2] top-level scope at /tmp/tmpp9m4uant.jl:36\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpp9m4uant.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmpp9m4uant.jl:37\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpp9m4uant.jl:29\n   [2] top-level scope at /tmp/tmpp9m4uant.jl:37\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpp9m4uant.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmpp9m4uant.jl:38\n  Test threw exception\n  Expression: candidate([3,\
    \ 5, 4, 1, 2]) == false\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpp9m4uant.jl:29\n   [2] top-level scope at /tmp/tmpp9m4uant.jl:38\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpp9m4uant.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmpp9m4uant.jl:39\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == true\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Bool\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpp9m4uant.jl:29\n   [2] top-level scope at /tmp/tmpp9m4uant.jl:39\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpp9m4uant.jl:34\n  \nTest Summary: | Error \
    \ Total\ntest set      |     5      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpp9m4uant.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    return false\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpo668yo8l.jl:36\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\n   Evaluated: false == true\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpo668yo8l.jl:36\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpo668yo8l.jl:35\ntest set: Test Failed at /tmp/tmpo668yo8l.jl:37\n\
    \  Expression: candidate([3, 5, 10, 1, 2]) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpo668yo8l.jl:37\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpo668yo8l.jl:35\ntest set: Test Failed at /tmp/tmpo668yo8l.jl:40\n\
    \  Expression: candidate(Vector{Int64}([])) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpo668yo8l.jl:40\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpo668yo8l.jl:35\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     3      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpo668yo8l.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1,\
    \ 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp69w4c95x.jl:35\n  Test threw exception\n\
    \  Expression: candidate([3, 4, 5, 1, 2]) == true\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Bool\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmp69w4c95x.jl:29\n   [2] top-level scope at /tmp/tmp69w4c95x.jl:35\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp69w4c95x.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmp69w4c95x.jl:36\n  Test threw exception\n  Expression: candidate([3,\
    \ 5, 10, 1, 2]) == true\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmp69w4c95x.jl:29\n   [2] top-level scope at /tmp/tmp69w4c95x.jl:36\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp69w4c95x.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmp69w4c95x.jl:37\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmp69w4c95x.jl:29\n   [2] top-level scope at /tmp/tmp69w4c95x.jl:37\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp69w4c95x.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmp69w4c95x.jl:38\n  Test threw exception\n  Expression: candidate([3,\
    \ 5, 4, 1, 2]) == false\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmp69w4c95x.jl:29\n   [2] top-level scope at /tmp/tmp69w4c95x.jl:38\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp69w4c95x.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmp69w4c95x.jl:39\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == true\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Bool\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmp69w4c95x.jl:29\n   [2] top-level scope at /tmp/tmp69w4c95x.jl:39\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp69w4c95x.jl:34\n  \nTest Summary: | Error \
    \ Total\ntest set      |     5      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp69w4c95x.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    return true\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpu302iwe5.jl:38\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpu302iwe5.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpu302iwe5.jl:35\ntest set: Test Failed at /tmp/tmpu302iwe5.jl:39\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpu302iwe5.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpu302iwe5.jl:35\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpu302iwe5.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr)==0\n        return\
    \ true\n    end\n    if length(arr)==1\n        return true\n    end\n    if length(arr)==2\n\
    \        if arr[1]>arr[2]\n            return false\n        else\n          \
    \  return true\n        end\n    end\n    if length(arr)==3\n        if arr[1]>arr[2]\n\
    \            if arr[2]>arr[3]\n                return false\n            else\n\
    \                return true\n            end\n        else\n            if arr[1]>arr[3]\n\
    \                return false\n            else\n                return true\n\
    \            end\n        end\n    end\n    if length(arr)>3\n        if arr[1]>arr[2]\n\
    \            if arr[2]>arr[3]\n                return false\n            else\n\
    \                return true\n            end\n        else\n            if arr[1]>arr[3]\n\
    \                return false\n            else\n                return true\n\
    \            end\n        end\n    end\nend\nusing Test\n\n@testset begin\n\n\
    candidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2]) == true)\n\t@test(candidate([3,\
    \ 5, 10, 1, 2]) == true)\n\t@test(candidate([4, 3, 1, 2]) == false)\n\t@test(candidate([3,\
    \ 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([])) == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpqaa3fe1x.jl:80\n  Expression: candidate([3,\
    \ 5, 4, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpqaa3fe1x.jl:80\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpqaa3fe1x.jl:76\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqaa3fe1x.jl:74\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    if length(arr)\
    \ == 0\n        return true\n    end\n    if length(arr) == 1\n        return\
    \ true\n    end\n    if length(arr) == 2\n        if arr[1] > arr[2]\n       \
    \     return false\n        else\n            return true\n        end\n    end\n\
    \    if length(arr) == 3\n        if arr[1] > arr[2]\n            if arr[2] >\
    \ arr[3]\n                return false\n            else\n                return\
    \ true\n            end\n        else\n            if arr[1] > arr[3]\n      \
    \          return false\n            else\n                return true\n     \
    \       end\n        end\n    end\n    if length(arr) > 3\n        if arr[1] >\
    \ arr[2]\n            if arr[2] > arr[3]\n                return false\n     \
    \       else\n                return true\n            end\n        else\n   \
    \         if arr[1] > arr[3]\n                return false\n            else\n\
    \                return true\n            end\n        end\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpw5sqxtax.jl:81\n  Expression: candidate([3,\
    \ 5, 4, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpw5sqxtax.jl:81\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw5sqxtax.jl:77\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpw5sqxtax.jl:75\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    return true\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmppjug8sld.jl:38\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmppjug8sld.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmppjug8sld.jl:35\ntest set: Test Failed at /tmp/tmppjug8sld.jl:39\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmppjug8sld.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmppjug8sld.jl:35\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmppjug8sld.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code goes here\n    return\
    \ false\nend\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpae5tqa83.jl:36\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\n   Evaluated: false == true\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpae5tqa83.jl:36\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpae5tqa83.jl:35\ntest set: Test Failed at /tmp/tmpae5tqa83.jl:37\n\
    \  Expression: candidate([3, 5, 10, 1, 2]) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpae5tqa83.jl:37\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpae5tqa83.jl:35\ntest set: Test Failed at /tmp/tmpae5tqa83.jl:40\n\
    \  Expression: candidate(Vector{Int64}([])) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpae5tqa83.jl:40\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpae5tqa83.jl:35\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     3      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpae5tqa83.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr)==0\n        return\
    \ true\n    end\n    for i in 1:length(arr)\n        if arr[i]==i\n          \
    \  continue\n        elseif arr[i]==i+1\n            arr[i],arr[i+1]=arr[i+1],arr[i]\n\
    \        else\n            return false\n        end\n    end\n    return true\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp5wr11_7b.jl:47\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\n   Evaluated: false == true\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp5wr11_7b.jl:47\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5wr11_7b.jl:46\ntest set: Test Failed at /tmp/tmp5wr11_7b.jl:48\n\
    \  Expression: candidate([3, 5, 10, 1, 2]) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp5wr11_7b.jl:48\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5wr11_7b.jl:46\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5wr11_7b.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    return true\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp2gbsgay6.jl:38\\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\\n   Evaluated: true == false\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmp2gbsgay6.jl:38\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp2gbsgay6.jl:35\\ntest set: Test Failed at /tmp/tmp2gbsgay6.jl:39\\\
    n  Expression: candidate([3, 5, 4, 1, 2]) == false\\n   Evaluated: true == false\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp2gbsgay6.jl:39\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp2gbsgay6.jl:35\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    3     2      5\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code goes here\n    # You\
    \ can add functions as well\n    # You can return anything\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2])\
    \ == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpmp_sehgo.jl:37\n  Test threw exception\n\
    \  Expression: candidate([3, 4, 5, 1, 2]) == true\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Bool\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpmp_sehgo.jl:31\n   [2] top-level scope at /tmp/tmpmp_sehgo.jl:37\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmp_sehgo.jl:36\n  \ntest set: Error During\
    \ Test at /tmp/tmpmp_sehgo.jl:38\n  Test threw exception\n  Expression: candidate([3,\
    \ 5, 10, 1, 2]) == true\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpmp_sehgo.jl:31\n   [2] top-level scope at /tmp/tmpmp_sehgo.jl:38\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmp_sehgo.jl:36\n  \ntest set: Error During\
    \ Test at /tmp/tmpmp_sehgo.jl:39\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpmp_sehgo.jl:31\n   [2] top-level scope at /tmp/tmpmp_sehgo.jl:39\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmp_sehgo.jl:36\n  \ntest set: Error During\
    \ Test at /tmp/tmpmp_sehgo.jl:40\n  Test threw exception\n  Expression: candidate([3,\
    \ 5, 4, 1, 2]) == false\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpmp_sehgo.jl:31\n   [2] top-level scope at /tmp/tmpmp_sehgo.jl:40\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmp_sehgo.jl:36\n  \ntest set: Error During\
    \ Test at /tmp/tmpmp_sehgo.jl:41\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == true\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Bool\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpmp_sehgo.jl:31\n   [2] top-level scope at /tmp/tmpmp_sehgo.jl:41\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmp_sehgo.jl:36\n  \nTest Summary: | Error \
    \ Total\ntest set      |     5      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmp_sehgo.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr) == 0\n        return\
    \ true\n    end\n    if length(arr) == 1\n        return true\n    end\n    if\
    \ length(arr) == 2\n        return true\n    end\n    for i in 1:length(arr)\n\
    \        if i == 1\n            if arr[i] > arr[i+1]\n                return false\n\
    \            end\n        elseif i == length(arr)\n            if arr[i] < arr[i-1]\n\
    \                return false\n            end\n        else\n            if arr[i]\
    \ < arr[i-1] || arr[i] > arr[i+1]\n                return false\n            end\n\
    \        end\n    end\n    return true\nend\nusing Test\n\n@testset begin\n\n\
    candidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2]) == true)\n\t@test(candidate([3,\
    \ 5, 10, 1, 2]) == true)\n\t@test(candidate([4, 3, 1, 2]) == false)\n\t@test(candidate([3,\
    \ 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([])) == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpbgkfab6l.jl:59\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\n   Evaluated: false == true\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpbgkfab6l.jl:59\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbgkfab6l.jl:58\ntest set: Test Failed at /tmp/tmpbgkfab6l.jl:60\n\
    \  Expression: candidate([3, 5, 10, 1, 2]) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpbgkfab6l.jl:60\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbgkfab6l.jl:58\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbgkfab6l.jl:56\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # YOUR CODE HERE\n    if length(arr)\
    \ == 0\n        return true\n    end\n    for i in 1:length(arr)\n        if i\
    \ == length(arr)\n            return true\n        end\n        if arr[i] > arr[i+1]\n\
    \            return false\n        end\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2]) == true)\n\t\
    @test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4, 3, 1, 2]) ==\
    \ false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp008bm41_.jl:46\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\n   Evaluated: false == true\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp008bm41_.jl:46\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp008bm41_.jl:45\ntest set: Test Failed at /tmp/tmp008bm41_.jl:47\n\
    \  Expression: candidate([3, 5, 10, 1, 2]) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp008bm41_.jl:47\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp008bm41_.jl:45\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp008bm41_.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr)==0\n        return\
    \ true\n    end\n    if length(arr)==1\n        return true\n    end\n    if length(arr)==2\n\
    \        if arr[1]<=arr[2]\n            return true\n        else\n          \
    \  return false\n        end\n    end\n    if length(arr)==3\n        if arr[1]<=arr[2]\
    \ && arr[2]<=arr[3]\n            return true\n        elseif arr[1]<=arr[3] &&\
    \ arr[3]<=arr[2]\n            return true\n        elseif arr[2]<=arr[1] && arr[1]<=arr[3]\n\
    \            return true\n        elseif arr[2]<=arr[3] && arr[3]<=arr[1]\n  \
    \          return true\n        elseif arr[3]<=arr[1] && arr[1]<=arr[2]\n    \
    \        return true\n        elseif arr[3]<=arr[2] && arr[2]<=arr[1]\n      \
    \      return true\n        else\n            return false\n        end\n    end\n\
    \    if length(arr)>3\n        if arr[1]<=arr[2] && arr[2]<=arr[3]\n         \
    \   return true\n        elseif arr[1]<=arr[3] && arr[3]<=arr[2]\n           \
    \ return true\n        elseif arr[2]<=arr[1] && arr[1]<=arr[3]\n            return\
    \ true\n        elseif arr[2]<=arr[3] && arr[3]<=arr[1]\n            return true\n\
    \        elseif arr[3]<=arr[1] && arr[1]<=arr[2]\n            return true\n  \
    \      elseif arr[3]<=arr[2] && arr[2]<=arr[1]\n            return true\n    \
    \    else\n            return false\n        end\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2])\
    \ == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp49k9fa35.jl:83\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp49k9fa35.jl:83\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp49k9fa35.jl:80\ntest set: Test Failed at /tmp/tmp49k9fa35.jl:84\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp49k9fa35.jl:84\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp49k9fa35.jl:80\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp49k9fa35.jl:78\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    return true\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp8ccueh71.jl:38\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp8ccueh71.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8ccueh71.jl:35\ntest set: Test Failed at /tmp/tmp8ccueh71.jl:39\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp8ccueh71.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8ccueh71.jl:35\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8ccueh71.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr) == 0\n        return\
    \ true\n    end\n    min_val = minimum(arr)\n    min_idx = findall(arr .== min_val)[1]\n\
    \    if min_idx == 1\n        return true\n    else\n        return false\n  \
    \  end\nend\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpgbhekgrk.jl:44\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\n   Evaluated: false == true\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpgbhekgrk.jl:44\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgbhekgrk.jl:43\ntest set: Test Failed at /tmp/tmpgbhekgrk.jl:45\n\
    \  Expression: candidate([3, 5, 10, 1, 2]) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpgbhekgrk.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgbhekgrk.jl:43\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgbhekgrk.jl:41\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr) == 0\n        return\
    \ true\n    end\n    for i in 1:length(arr)\n        if arr[i] == i\n        \
    \    continue\n        elseif arr[i] == i+1\n            arr[i], arr[i+1] = arr[i+1],\
    \ arr[i]\n        else\n            return false\n        end\n    end\n    return\
    \ true\nend\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp6fozgbmf.jl:47\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\n   Evaluated: false == true\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp6fozgbmf.jl:47\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6fozgbmf.jl:46\ntest set: Test Failed at /tmp/tmp6fozgbmf.jl:48\n\
    \  Expression: candidate([3, 5, 10, 1, 2]) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp6fozgbmf.jl:48\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6fozgbmf.jl:46\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6fozgbmf.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    n = length(arr)\n    if n == 0\n\
    \        return true\n    end\n    if n == 1\n        return true\n    end\n \
    \   if n == 2\n        return true\n    end\n    if n == 3\n        if arr[1]\
    \ > arr[2]\n            if arr[2] > arr[3]\n                return true\n    \
    \        else\n                return false\n            end\n        else\n \
    \           if arr[1] > arr[3]\n                return true\n            else\n\
    \                return false\n            end\n        end\n    end\n    if arr[1]\
    \ > arr[2]\n        if arr[2] > arr[3]\n            return true\n        else\n\
    \            return false\n        end\n    else\n        if arr[1] > arr[3]\n\
    \            return true\n        else\n            return false\n        end\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t\
    @test(candidate([3, 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2])\
    \ == true)\n\t@test(candidate([4, 3, 1, 2]) == false)\n\t@test(candidate([3, 5,\
    \ 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([])) == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp1d0dcnlb.jl:72\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\n   Evaluated: false == true\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp1d0dcnlb.jl:72\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1d0dcnlb.jl:71\ntest set: Test Failed at /tmp/tmp1d0dcnlb.jl:73\n\
    \  Expression: candidate([3, 5, 10, 1, 2]) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp1d0dcnlb.jl:73\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1d0dcnlb.jl:71\ntest set: Test Failed at /tmp/tmp1d0dcnlb.jl:74\n\
    \  Expression: candidate([4, 3, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp1d0dcnlb.jl:74\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1d0dcnlb.jl:71\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     3      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1d0dcnlb.jl:69\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Write your code here\n    #\
    \ You can add helper functions as needed\n    if length(arr) == 0\n        return\
    \ true\n    end\n    if length(arr) == 1\n        return true\n    end\n    if\
    \ length(arr) == 2\n        if arr[1] > arr[2]\n            return false\n   \
    \     else\n            return true\n        end\n    end\n    if length(arr)\
    \ == 3\n        if arr[1] > arr[2]\n            if arr[2] > arr[3]\n         \
    \       return false\n            else\n                return true\n        \
    \    end\n        else\n            if arr[1] > arr[3]\n                return\
    \ false\n            else\n                return true\n            end\n    \
    \    end\n    end\n    if length(arr) == 4\n        if arr[1] > arr[2]\n     \
    \       if arr[2] > arr[3]\n                if arr[3] > arr[4]\n             \
    \       return false\n                else\n                    return true\n\
    \                end\n            else\n                if arr[1] > arr[3]\n \
    \                   if arr[3] > arr[4]\n                        return false\n\
    \                    else\n                        return true\n             \
    \       end\n                else\n                    if arr[1] > arr[4]\n  \
    \                      return false\n                    else\n              \
    \          return true\n                    end\n                end\n       \
    \     end\n        else\n            if arr[1] > arr[3]\n                if arr[3]\
    \ > arr[4]\n                    return false\n                else\n         \
    \           return true\n                end\n            else\n             \
    \   if arr[1] > arr[4]\n                    if arr[2] > arr[4]\n             \
    \           return false\n                    else\n                        return\
    \ true\n                    end\n                else\n                    return\
    \ true\n                end\n            end\n        end\n    end\n    if length(arr)\
    \ == 5\n        if arr[1] > arr[2]\n            if arr[2] > arr[3]\n         \
    \       if arr[3] > arr[4]\n                    if arr[4] > arr[5]\n         \
    \               return false\n                    else\n                     \
    \   return true\n                    end\n                else\n             \
    \       if arr[1] > arr[4]\n                        if arr[4] > arr[5]\n     \
    \                       return false\n                        else\n\nusing Test\n\
    \n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1,\
    \ 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"if\" at /tmp/tmp8tfetwxg.jl:112\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp8tfetwxg.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp8tfetwxg.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Write your code here\n    #\
    \ You can add helper functions as needed\n    return true\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2])\
    \ == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpb43wiquw.jl:39\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpb43wiquw.jl:39\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpb43wiquw.jl:36\ntest set: Test Failed at /tmp/tmpb43wiquw.jl:40\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpb43wiquw.jl:40\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpb43wiquw.jl:36\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpb43wiquw.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    return false\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpeasmhy7n.jl:36\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\n   Evaluated: false == true\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpeasmhy7n.jl:36\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpeasmhy7n.jl:35\ntest set: Test Failed at /tmp/tmpeasmhy7n.jl:37\n\
    \  Expression: candidate([3, 5, 10, 1, 2]) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpeasmhy7n.jl:37\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpeasmhy7n.jl:35\ntest set: Test Failed at /tmp/tmpeasmhy7n.jl:40\n\
    \  Expression: candidate(Vector{Int64}([])) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpeasmhy7n.jl:40\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpeasmhy7n.jl:35\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     3      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpeasmhy7n.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    return true\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp4i9m9qcw.jl:38\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp4i9m9qcw.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4i9m9qcw.jl:35\ntest set: Test Failed at /tmp/tmp4i9m9qcw.jl:39\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp4i9m9qcw.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4i9m9qcw.jl:35\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4i9m9qcw.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1,\
    \ 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpn01j65r8.jl:35\n  Test threw exception\n\
    \  Expression: candidate([3, 4, 5, 1, 2]) == true\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Bool\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpn01j65r8.jl:29\n   [2] top-level scope at /tmp/tmpn01j65r8.jl:35\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpn01j65r8.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmpn01j65r8.jl:36\n  Test threw exception\n  Expression: candidate([3,\
    \ 5, 10, 1, 2]) == true\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpn01j65r8.jl:29\n   [2] top-level scope at /tmp/tmpn01j65r8.jl:36\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpn01j65r8.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmpn01j65r8.jl:37\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpn01j65r8.jl:29\n   [2] top-level scope at /tmp/tmpn01j65r8.jl:37\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpn01j65r8.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmpn01j65r8.jl:38\n  Test threw exception\n  Expression: candidate([3,\
    \ 5, 4, 1, 2]) == false\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpn01j65r8.jl:29\n   [2] top-level scope at /tmp/tmpn01j65r8.jl:38\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpn01j65r8.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmpn01j65r8.jl:39\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == true\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Bool\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpn01j65r8.jl:29\n   [2] top-level scope at /tmp/tmpn01j65r8.jl:39\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpn01j65r8.jl:34\n  \nTest Summary: | Error \
    \ Total\ntest set      |     5      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpn01j65r8.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    if length(arr)\
    \ == 0\n        return true\n    end\n    if length(arr) == 1\n        return\
    \ true\n    end\n    if length(arr) == 2\n        if arr[1] > arr[2]\n       \
    \     return false\n        else\n            return true\n        end\n    end\n\
    \    for i in 1:length(arr)\n        if arr[i] > arr[i+1]\n            return\
    \ false\n        end\n    end\n    return true\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2]) == true)\n\t\
    @test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4, 3, 1, 2]) ==\
    \ false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmplemf29xp.jl:54\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\n   Evaluated: false == true\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmplemf29xp.jl:54\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplemf29xp.jl:53\ntest set: Test Failed at /tmp/tmplemf29xp.jl:55\n\
    \  Expression: candidate([3, 5, 10, 1, 2]) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmplemf29xp.jl:55\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplemf29xp.jl:53\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmplemf29xp.jl:51\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    return true\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp9aazfbgg.jl:38\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp9aazfbgg.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9aazfbgg.jl:35\ntest set: Test Failed at /tmp/tmp9aazfbgg.jl:39\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp9aazfbgg.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9aazfbgg.jl:35\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9aazfbgg.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    return true\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpytqhi7zh.jl:38\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpytqhi7zh.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpytqhi7zh.jl:35\ntest set: Test Failed at /tmp/tmpytqhi7zh.jl:39\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpytqhi7zh.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpytqhi7zh.jl:35\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpytqhi7zh.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # YOUR CODE HERE\n    if length(arr)==0\n\
    \        return true\n    end\n    if length(arr)==1\n        return true\n  \
    \  end\n    if length(arr)==2\n        if arr[1]<=arr[2]\n            return true\n\
    \        else\n            return false\n        end\n    end\n    if length(arr)==3\n\
    \        if arr[1]<=arr[2] && arr[2]<=arr[3]\n            return true\n      \
    \  elseif arr[1]<=arr[3] && arr[3]<=arr[2]\n            return true\n        elseif\
    \ arr[2]<=arr[1] && arr[1]<=arr[3]\n            return true\n        elseif arr[2]<=arr[3]\
    \ && arr[3]<=arr[1]\n            return true\n        elseif arr[3]<=arr[1] &&\
    \ arr[1]<=arr[2]\n            return true\n        elseif arr[3]<=arr[2] && arr[2]<=arr[1]\n\
    \            return true\n        else\n            return false\n        end\n\
    \    end\n    if length(arr)>3\n        if arr[1]<=arr[2] && arr[2]<=arr[3]\n\
    \            return true\n        elseif arr[1]<=arr[3] && arr[3]<=arr[2]\n  \
    \          return true\n        elseif arr[2]<=arr[1] && arr[1]<=arr[3]\n    \
    \        return true\n        elseif arr[2]<=arr[3] && arr[3]<=arr[1]\n      \
    \      return true\n        elseif arr[3]<=arr[1] && arr[1]<=arr[2]\n        \
    \    return true\n        elseif arr[3]<=arr[2] && arr[2]<=arr[1]\n          \
    \  return true\n        else\n            return false\n        end\n    end\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmphj6lfeor.jl:84\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmphj6lfeor.jl:84\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphj6lfeor.jl:81\ntest set: Test Failed at /tmp/tmphj6lfeor.jl:85\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmphj6lfeor.jl:85\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphj6lfeor.jl:81\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphj6lfeor.jl:79\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    return true\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp1u5hq9cb.jl:38\\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\\n   Evaluated: true == false\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmp1u5hq9cb.jl:38\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp1u5hq9cb.jl:35\\ntest set: Test Failed at /tmp/tmp1u5hq9cb.jl:39\\\
    n  Expression: candidate([3, 5, 4, 1, 2]) == false\\n   Evaluated: true == false\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp1u5hq9cb.jl:39\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp1u5hq9cb.jl:35\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    3     2      5\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr)==0\n        return\
    \ true\n    end\n    for i in 1:length(arr)\n        if arr[i]==i\n          \
    \  continue\n        elseif arr[i]==i+1\n            arr[i],arr[i+1]=arr[i+1],arr[i]\n\
    \        else\n            return false\n        end\n    end\n    return true\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpo103__gj.jl:47\\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\\n   Evaluated: false == true\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmpo103__gj.jl:47\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpo103__gj.jl:46\\ntest set: Test Failed at /tmp/tmpo103__gj.jl:48\\\
    n  Expression: candidate([3, 5, 10, 1, 2]) == true\\n   Evaluated: false == true\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpo103__gj.jl:48\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpo103__gj.jl:46\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    3     2      5\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    n = length(arr)\n    if n == 0\n\
    \        return true\n    end\n    for i in 1:n-1\n        if arr[i] > arr[i+1]\n\
    \            return false\n        end\n    end\n    return true\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1,\
    \ 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpi_8e69sf.jl:44\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\n   Evaluated: false == true\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpi_8e69sf.jl:44\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpi_8e69sf.jl:43\ntest set: Test Failed at /tmp/tmpi_8e69sf.jl:45\n\
    \  Expression: candidate([3, 5, 10, 1, 2]) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpi_8e69sf.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpi_8e69sf.jl:43\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpi_8e69sf.jl:41\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    return true\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp6rjn4nmb.jl:38\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp6rjn4nmb.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6rjn4nmb.jl:35\ntest set: Test Failed at /tmp/tmp6rjn4nmb.jl:39\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp6rjn4nmb.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6rjn4nmb.jl:35\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6rjn4nmb.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr)==0\n        return\
    \ true\n    end\n    if length(arr)==1\n        return true\n    end\n    if length(arr)==2\n\
    \        if arr[1]<=arr[2]\n            return true\n        else\n          \
    \  return false\n        end\n    end\n    if length(arr)==3\n        if arr[1]<=arr[2]\
    \ && arr[2]<=arr[3]\n            return true\n        elseif arr[1]<=arr[3] &&\
    \ arr[3]<=arr[2]\n            return true\n        elseif arr[2]<=arr[1] && arr[1]<=arr[3]\n\
    \            return true\n        elseif arr[2]<=arr[3] && arr[3]<=arr[1]\n  \
    \          return true\n        elseif arr[3]<=arr[1] && arr[1]<=arr[2]\n    \
    \        return true\n        elseif arr[3]<=arr[2] && arr[2]<=arr[1]\n      \
    \      return true\n        else\n            return false\n        end\n    end\n\
    \    if length(arr)>3\n        if arr[1]<=arr[2] && arr[2]<=arr[3]\n         \
    \   return true\n        elseif arr[1]<=arr[3] && arr[3]<=arr[2]\n           \
    \ return true\n        elseif arr[2]<=arr[1] && arr[1]<=arr[3]\n            return\
    \ true\n        elseif arr[2]<=arr[3] && arr[3]<=arr[1]\n            return true\n\
    \        elseif arr[3]<=arr[1] && arr[1]<=arr[2]\n            return true\n  \
    \      elseif arr[3]<=arr[2] && arr[2]<=arr[1]\n            return true\n    \
    \    else\n            return false\n        end\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2])\
    \ == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpjgo623vy.jl:83\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpjgo623vy.jl:83\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpjgo623vy.jl:80\ntest set: Test Failed at /tmp/tmpjgo623vy.jl:84\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpjgo623vy.jl:84\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpjgo623vy.jl:80\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpjgo623vy.jl:78\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr)==0\n        return\
    \ true\n    end\n    for i in 1:length(arr)\n        if i==1\n            if arr[i]>arr[i+1]\n\
    \                return false\n            end\n        elseif i==length(arr)\n\
    \            if arr[i]<arr[i-1]\n                return false\n            end\n\
    \        else\n            if arr[i]>arr[i+1] || arr[i]<arr[i-1]\n           \
    \     return false\n            end\n        end\n    end\n    return true\nend\n\
    using Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpmc5p8hxi.jl:53\\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\\n   Evaluated: false == true\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmpmc5p8hxi.jl:53\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpmc5p8hxi.jl:52\\ntest set: Test Failed at /tmp/tmpmc5p8hxi.jl:54\\\
    n  Expression: candidate([3, 5, 10, 1, 2]) == true\\n   Evaluated: false == true\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpmc5p8hxi.jl:54\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpmc5p8hxi.jl:52\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    3     2      5\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    # You can\
    \ add helper functions as needed\n    if length(arr) == 0\n        return true\n\
    \    end\n    if length(arr) == 1\n        return true\n    end\n    if length(arr)\
    \ == 2\n        return true\n    end\n    if length(arr) == 3\n        if arr[1]\
    \ > arr[2]\n            if arr[2] > arr[3]\n                return true\n    \
    \        else\n                return false\n            end\n        else\n \
    \           if arr[1] > arr[3]\n                return true\n            else\n\
    \                return false\n            end\n        end\n    end\n    if length(arr)\
    \ == 4\n        if arr[1] > arr[2]\n            if arr[2] > arr[3]\n         \
    \       if arr[3] > arr[4]\n                    return true\n                else\n\
    \                    return false\n                end\n            else\n   \
    \             if arr[1] > arr[3]\n                    if arr[3] > arr[4]\n   \
    \                     return true\n                    else\n                \
    \        return false\n                    end\n                else\n       \
    \             if arr[1] > arr[4]\n                        return true\n      \
    \              else\n                        return false\n                  \
    \  end\n                end\n            end\n        else\n            if arr[1]\
    \ > arr[3]\n                if arr[3] > arr[4]\n                    return true\n\
    \                else\n                    return false\n                end\n\
    \            else\n                if arr[1] > arr[4]\n                    return\
    \ true\n                else\n                    return false\n             \
    \   end\n            end\n        end\n    end\n    if length(arr) == 5\n    \
    \    if arr[1] > arr[2]\n            if arr[2] > arr[3]\n                if arr[3]\
    \ > arr[4]\n                    if arr[4] > arr[5]\n                        return\
    \ true\n                    else\n                        return false\n     \
    \               end\n                else\n                    if arr[1] > arr[4]\n\
    \                        if arr[4] > arr[5]\n                            return\
    \ true\n                        else\n                            return false\n\
    \                        end\n                    else\n                     \
    \   if arr[1] > arr[5]\n                            return true\n            \
    \            else\n                            return false\n                \
    \        end\n                    end\n                end\n\nusing Test\n\n@testset\
    \ begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2]) == true)\n\
    \t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4, 3, 1, 2])\
    \ == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpjg6f719b.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpjg6f719b.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr) == 0\n        return\
    \ true\n    end\n    if length(arr) == 1\n        return true\n    end\n    if\
    \ length(arr) == 2\n        if arr[1] > arr[2]\n            return false\n   \
    \     else\n            return true\n        end\n    end\n    for i in 1:length(arr)\n\
    \        if arr[i] > arr[i+1]\n            return false\n        end\n    end\n\
    \    return true\nend\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\
    \t@test(candidate([3, 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2])\
    \ == true)\n\t@test(candidate([4, 3, 1, 2]) == false)\n\t@test(candidate([3, 5,\
    \ 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([])) == true)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpg81i4u71.jl:53\\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\\n   Evaluated: false == true\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmpg81i4u71.jl:53\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpg81i4u71.jl:52\\ntest set: Test Failed at /tmp/tmpg81i4u71.jl:54\\\
    n  Expression: candidate([3, 5, 10, 1, 2]) == true\\n   Evaluated: false == true\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpg81i4u71.jl:54\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpg81i4u71.jl:52\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    3     2      5\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr) == 0\n        return\
    \ true\n    end\n    if length(arr) == 1\n        return true\n    end\n    if\
    \ length(arr) == 2\n        if arr[1] > arr[2]\n            return false\n   \
    \     else\n            return true\n        end\n    end\n    for i in 1:length(arr)\n\
    \        if i == 1\n            if arr[i] > arr[i+1]\n                return false\n\
    \            end\n        elseif i == length(arr)\n            if arr[i] < arr[i-1]\n\
    \                return false\n            end\n        else\n            if arr[i]\
    \ < arr[i-1] || arr[i] > arr[i+1]\n                return false\n            end\n\
    \        end\n    end\n    return true\nend\nusing Test\n\n@testset begin\n\n\
    candidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2]) == true)\n\t@test(candidate([3,\
    \ 5, 10, 1, 2]) == true)\n\t@test(candidate([4, 3, 1, 2]) == false)\n\t@test(candidate([3,\
    \ 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([])) == true)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpvngefrub.jl:63\\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\\n   Evaluated: false == true\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmpvngefrub.jl:63\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpvngefrub.jl:62\\ntest set: Test Failed at /tmp/tmpvngefrub.jl:64\\\
    n  Expression: candidate([3, 5, 10, 1, 2]) == true\\n   Evaluated: false == true\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpvngefrub.jl:64\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpvngefrub.jl:62\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    3     2      5\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    # You can\
    \ add helper functions as needed\n    return true\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2]) == true)\n\
    \t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4, 3, 1, 2])\
    \ == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpbbtq4x7l.jl:39\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpbbtq4x7l.jl:39\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbbtq4x7l.jl:36\ntest set: Test Failed at /tmp/tmpbbtq4x7l.jl:40\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpbbtq4x7l.jl:40\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbbtq4x7l.jl:36\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbbtq4x7l.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr) == 0\n        return\
    \ true\n    end\n    if length(arr) == 1\n        return true\n    end\n    if\
    \ length(arr) == 2\n        if arr[1] > arr[2]\n            return false\n   \
    \     else\n            return true\n        end\n    end\n    if length(arr)\
    \ == 3\n        if arr[1] > arr[2]\n            if arr[2] > arr[3]\n         \
    \       return false\n            else\n                return true\n        \
    \    end\n        else\n            if arr[1] > arr[3]\n                return\
    \ false\n            else\n                return true\n            end\n    \
    \    end\n    end\n    if length(arr) == 4\n        if arr[1] > arr[2]\n     \
    \       if arr[2] > arr[3]\n                if arr[3] > arr[4]\n             \
    \       return false\n                else\n                    return true\n\
    \                end\n            else\n                if arr[1] > arr[3]\n \
    \                   if arr[3] > arr[4]\n                        return false\n\
    \                    else\n                        return true\n             \
    \       end\n                else\n                    if arr[1] > arr[4]\n  \
    \                      return false\n                    else\n              \
    \          return true\n                    end\n                end\n       \
    \     end\n        else\n            if arr[1] > arr[3]\n                if arr[3]\
    \ > arr[4]\n                    return false\n                else\n         \
    \           return true\n                end\n            else\n             \
    \   if arr[1] > arr[4]\n                    if arr[2] > arr[4]\n             \
    \           return false\n                    else\n                        return\
    \ true\n                    end\n                else\n                    if\
    \ arr[2] > arr[3]\n                        if arr[3] > arr[4]\n              \
    \              return false\n                        else\n                  \
    \          return true\n                        end\n                    else\n\
    \                        return true\n                    end\n              \
    \  end\n            end\n        end\n    end\n    if length(arr) == 5\n     \
    \   if arr[1] > arr[2]\n            if arr[2] > arr[3]\n                if arr[3]\
    \ > arr[4]\n                    if arr[4] > arr[5]\n                        return\
    \ false\n                    else\n                        return true\n     \
    \               end\n                else\n                    if arr\nusing Test\n\
    \n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1,\
    \ 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp364kw7h1.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp364kw7h1.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr) == 0\n        return\
    \ true\n    end\n    if length(arr) == 1\n        return true\n    end\n    if\
    \ length(arr) == 2\n        return true\n    end\n    if length(arr) == 3\n  \
    \      if arr[1] <= arr[2] && arr[2] <= arr[3]\n            return true\n    \
    \    else\n            return false\n        end\n    end\n    if length(arr)\
    \ == 4\n        if arr[1] <= arr[2] && arr[2] <= arr[3] && arr[3] <= arr[4]\n\
    \            return true\n        else\n            return false\n        end\n\
    \    end\n    if length(arr) == 5\n        if arr[1] <= arr[2] && arr[2] <= arr[3]\
    \ && arr[3] <= arr[4] && arr[4] <= arr[5]\n            return true\n        else\n\
    \            return false\n        end\n    end\n    if length(arr) == 6\n   \
    \     if arr[1] <= arr[2] && arr[2] <= arr[3] && arr[3] <= arr[4] && arr[4] <=\
    \ arr[5] && arr[5] <= arr[6]\n            return true\n        else\n        \
    \    return false\n        end\n    end\n    if length(arr) == 7\n        if arr[1]\
    \ <= arr[2] && arr[2] <= arr[3] && arr[3] <= arr[4] && arr[4] <= arr[5] && arr[5]\
    \ <= arr[6] && arr[6] <= arr[7]\n            return true\n        else\n     \
    \       return false\n        end\n    end\n    if length(arr) == 8\n        if\
    \ arr[1] <= arr[2] && arr[2] <= arr[3] && arr[3] <= arr[4] && arr[4] <= arr[5]\
    \ && arr[5] <= arr[6] && arr[6] <= arr[7] && arr[7] <= arr[8]\n            return\
    \ true\n        else\n            return false\n        end\n    end\n    if length(arr)\
    \ == 9\n        if arr[1] <= arr[2] && arr[2]\nusing Test\n\n@testset begin\n\n\
    candidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2]) == true)\n\t@test(candidate([3,\
    \ 5, 10, 1, 2]) == true)\n\t@test(candidate([4, 3, 1, 2]) == false)\n\t@test(candidate([3,\
    \ 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([])) == true)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp9h9j4m6n.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp9h9j4m6n.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    return true\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp8j5plxw5.jl:38\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp8j5plxw5.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8j5plxw5.jl:35\ntest set: Test Failed at /tmp/tmp8j5plxw5.jl:39\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp8j5plxw5.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8j5plxw5.jl:35\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8j5plxw5.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr)==0\n        return\
    \ true\n    end\n    if length(arr)==1\n        return true\n    end\n    sorted_arr=sort(arr)\n\
    \    if sorted_arr==arr\n        return true\n    end\n    for i in 1:length(arr)\n\
    \        if arr[i]==sorted_arr[1]\n            if i==length(arr)\n           \
    \     return true\n            end\n            if arr[i+1]==sorted_arr[2]\n \
    \               return true\n            end\n        end\n    end\n    return\
    \ false\nend\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpt0bm5ex6.jl:57\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpt0bm5ex6.jl:57\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpt0bm5ex6.jl:54\ntest set: Test Failed at /tmp/tmpt0bm5ex6.jl:58\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpt0bm5ex6.jl:58\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpt0bm5ex6.jl:54\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpt0bm5ex6.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    return true\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpeoar38fo.jl:38\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpeoar38fo.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpeoar38fo.jl:35\ntest set: Test Failed at /tmp/tmpeoar38fo.jl:39\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpeoar38fo.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpeoar38fo.jl:35\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpeoar38fo.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr)==0\n        return\
    \ true\n    end\n    if length(arr)==1\n        return true\n    end\n    if length(arr)==2\n\
    \        if arr[1]>arr[2]\n            return false\n        else\n          \
    \  return true\n        end\n    end\n    if length(arr)==3\n        if arr[1]>arr[2]\n\
    \            if arr[2]>arr[3]\n                return false\n            else\n\
    \                return true\n            end\n        else\n            if arr[1]>arr[3]\n\
    \                return false\n            else\n                return true\n\
    \            end\n        end\n    end\n    if length(arr)>3\n        if arr[1]>arr[2]\n\
    \            if arr[2]>arr[3]\n                return false\n            else\n\
    \                return true\n            end\n        else\n            if arr[1]>arr[3]\n\
    \                return false\n            else\n                return true\n\
    \            end\n        end\n    end\nend\nusing Test\n\n@testset begin\n\n\
    candidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2]) == true)\n\t@test(candidate([3,\
    \ 5, 10, 1, 2]) == true)\n\t@test(candidate([4, 3, 1, 2]) == false)\n\t@test(candidate([3,\
    \ 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([])) == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpfg6x7boi.jl:80\n  Expression: candidate([3,\
    \ 5, 4, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpfg6x7boi.jl:80\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfg6x7boi.jl:76\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpfg6x7boi.jl:74\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr) == 0\n        return\
    \ true\n    end\n    if length(arr) == 1\n        return true\n    end\n    if\
    \ length(arr) == 2\n        if arr[1] > arr[2]\n            return false\n   \
    \     else\n            return true\n        end\n    end\n    for i in 1:length(arr)\n\
    \        if arr[i] > arr[i+1]\n            return false\n        end\n    end\n\
    \    return true\nend\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\
    \t@test(candidate([3, 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2])\
    \ == true)\n\t@test(candidate([4, 3, 1, 2]) == false)\n\t@test(candidate([3, 5,\
    \ 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([])) == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp3_0zboxz.jl:53\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\n   Evaluated: false == true\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp3_0zboxz.jl:53\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3_0zboxz.jl:52\ntest set: Test Failed at /tmp/tmp3_0zboxz.jl:54\n\
    \  Expression: candidate([3, 5, 10, 1, 2]) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp3_0zboxz.jl:54\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3_0zboxz.jl:52\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3_0zboxz.jl:50\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr) == 0\n        return\
    \ true\n    end\n    if length(arr) == 1\n        return true\n    end\n    if\
    \ length(arr) == 2\n        if arr[1] <= arr[2]\n            return true\n   \
    \     else\n            return false\n        end\n    end\n    if length(arr)\
    \ == 3\n        if arr[1] <= arr[2]\n            if arr[2] <= arr[3]\n       \
    \         return true\n            else\n                return false\n      \
    \      end\n        else\n            if arr[1] <= arr[3]\n                return\
    \ true\n            else\n                return false\n            end\n    \
    \    end\n    end\n    if length(arr) == 4\n        if arr[1] <= arr[2]\n    \
    \        if arr[2] <= arr[3]\n                if arr[3] <= arr[4]\n          \
    \          return true\n                else\n                    return false\n\
    \                end\n            else\n                if arr[1] <= arr[3]\n\
    \                    if arr[3] <= arr[4]\n                        return true\n\
    \                    else\n                        return false\n            \
    \        end\n                else\n                    return false\n       \
    \         end\n            end\n        else\n            if arr[1] <= arr[3]\n\
    \                if arr[3] <= arr[4]\n                    return true\n      \
    \          else\n                    return false\n                end\n     \
    \       else\n                return false\n            end\n        end\n   \
    \ end\n    if length(arr) == 5\n        if arr[1] <= arr[2]\n            if arr[2]\
    \ <= arr[3]\n                if arr[3] <= arr[4]\n                    if arr[4]\
    \ <= arr[5]\n                        return true\n                    else\n \
    \                       return false\n                    end\n              \
    \  else\n                    if arr[1] <= arr[4]\n                        if arr[4]\
    \ <= arr[5]\n                            return true\n                       \
    \ else\n                            return false\n                        end\n\
    \                    else\n                        return false\n            \
    \        end\n                end\n            else\n                if arr[1]\
    \ <= arr[3]\n                    if arr[3] <= arr[4]\n                       \
    \ if arr[4] <= arr[5]\n                            return true\n             \
    \           else\n                            return false\n                 \
    \       end\n                    else\n                        return false\n\n\
    using Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"if\" at /tmp/tmpfgmrfuiz.jl:109\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpfgmrfuiz.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpfgmrfuiz.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    # You can\
    \ add helper functions as needed\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2]) == true)\n\t@test(candidate([3,\
    \ 5, 10, 1, 2]) == true)\n\t@test(candidate([4, 3, 1, 2]) == false)\n\t@test(candidate([3,\
    \ 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([])) == true)\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp8hwdy9ns.jl:36\\n  Test threw\
    \ exception\\n  Expression: candidate([3, 4, 5, 1, 2]) == true\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Bool\\n  Closest\
    \ candidates are:\\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\\\
    n    convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\\n  \
    \  convert(::Type{T}, !Matched::Ptr) where T<:Integer at pointer.jl:23\\n    ...\\\
    n  Stacktrace:\\n   [1] move_one_ball(::Array{Int64,1}) at /tmp/tmp8hwdy9ns.jl:30\\\
    n   [2] top-level scope at /tmp/tmp8hwdy9ns.jl:36\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp8hwdy9ns.jl:35\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp8hwdy9ns.jl:37\\n  Test threw exception\\n  Expression: candidate([3,\
    \ 5, 10, 1, 2]) == true\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmp8hwdy9ns.jl:30\\n   [2] top-level scope at /tmp/tmp8hwdy9ns.jl:37\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp8hwdy9ns.jl:35\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp8hwdy9ns.jl:38\\n  Test threw exception\\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmp8hwdy9ns.jl:30\\n   [2] top-level scope at /tmp/tmp8hwdy9ns.jl:38\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp8hwdy9ns.jl:35\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp8hwdy9ns.jl:39\\n  Test threw exception\\n  Expression: candidate([3,\
    \ 5, 4, 1, 2]) == false\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmp8hwdy9ns.jl:30\\n   [2] top-level scope at /tmp/tmp8hwdy9ns.jl:39\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp8hwdy9ns.jl:35\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp8hwdy9ns.jl:40\\n  Test threw exception\\n  Expression: candidate(Vector{Int64}([]))\
    \ == true\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Bool\\n  Closest candidates are:\\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmp8hwdy9ns.jl:30\\n   [2] top-level scope at /tmp/tmp8hwdy9ns.jl:40\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp8hwdy9ns.jl:35\\n  \\nTest Summary: | Error\
    \  Total\\ntest set      |     5      5\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1,\
    \ 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpixwpjerr.jl:35\n  Test threw exception\n\
    \  Expression: candidate([3, 4, 5, 1, 2]) == true\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Bool\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpixwpjerr.jl:29\n   [2] top-level scope at /tmp/tmpixwpjerr.jl:35\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpixwpjerr.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmpixwpjerr.jl:36\n  Test threw exception\n  Expression: candidate([3,\
    \ 5, 10, 1, 2]) == true\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpixwpjerr.jl:29\n   [2] top-level scope at /tmp/tmpixwpjerr.jl:36\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpixwpjerr.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmpixwpjerr.jl:37\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpixwpjerr.jl:29\n   [2] top-level scope at /tmp/tmpixwpjerr.jl:37\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpixwpjerr.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmpixwpjerr.jl:38\n  Test threw exception\n  Expression: candidate([3,\
    \ 5, 4, 1, 2]) == false\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpixwpjerr.jl:29\n   [2] top-level scope at /tmp/tmpixwpjerr.jl:38\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpixwpjerr.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmpixwpjerr.jl:39\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == true\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Bool\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpixwpjerr.jl:29\n   [2] top-level scope at /tmp/tmpixwpjerr.jl:39\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpixwpjerr.jl:34\n  \nTest Summary: | Error \
    \ Total\ntest set      |     5      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpixwpjerr.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1,\
    \ 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp2vje2018.jl:35\n  Test threw exception\n\
    \  Expression: candidate([3, 4, 5, 1, 2]) == true\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Bool\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmp2vje2018.jl:29\n   [2] top-level scope at /tmp/tmp2vje2018.jl:35\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2vje2018.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmp2vje2018.jl:36\n  Test threw exception\n  Expression: candidate([3,\
    \ 5, 10, 1, 2]) == true\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmp2vje2018.jl:29\n   [2] top-level scope at /tmp/tmp2vje2018.jl:36\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2vje2018.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmp2vje2018.jl:37\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmp2vje2018.jl:29\n   [2] top-level scope at /tmp/tmp2vje2018.jl:37\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2vje2018.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmp2vje2018.jl:38\n  Test threw exception\n  Expression: candidate([3,\
    \ 5, 4, 1, 2]) == false\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmp2vje2018.jl:29\n   [2] top-level scope at /tmp/tmp2vje2018.jl:38\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2vje2018.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmp2vje2018.jl:39\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == true\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Bool\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmp2vje2018.jl:29\n   [2] top-level scope at /tmp/tmp2vje2018.jl:39\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2vje2018.jl:34\n  \nTest Summary: | Error \
    \ Total\ntest set      |     5      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2vje2018.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1,\
    \ 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpq8t63g0u.jl:35\n  Test threw exception\n\
    \  Expression: candidate([3, 4, 5, 1, 2]) == true\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Bool\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpq8t63g0u.jl:29\n   [2] top-level scope at /tmp/tmpq8t63g0u.jl:35\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq8t63g0u.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmpq8t63g0u.jl:36\n  Test threw exception\n  Expression: candidate([3,\
    \ 5, 10, 1, 2]) == true\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpq8t63g0u.jl:29\n   [2] top-level scope at /tmp/tmpq8t63g0u.jl:36\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq8t63g0u.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmpq8t63g0u.jl:37\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpq8t63g0u.jl:29\n   [2] top-level scope at /tmp/tmpq8t63g0u.jl:37\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq8t63g0u.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmpq8t63g0u.jl:38\n  Test threw exception\n  Expression: candidate([3,\
    \ 5, 4, 1, 2]) == false\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpq8t63g0u.jl:29\n   [2] top-level scope at /tmp/tmpq8t63g0u.jl:38\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq8t63g0u.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmpq8t63g0u.jl:39\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == true\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Bool\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpq8t63g0u.jl:29\n   [2] top-level scope at /tmp/tmpq8t63g0u.jl:39\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq8t63g0u.jl:34\n  \nTest Summary: | Error \
    \ Total\ntest set      |     5      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpq8t63g0u.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # your code goes here\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp9dx0z6oq.jl:35\n  Test threw exception\n\
    \  Expression: candidate([3, 4, 5, 1, 2]) == true\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Bool\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmp9dx0z6oq.jl:29\n   [2] top-level scope at /tmp/tmp9dx0z6oq.jl:35\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9dx0z6oq.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmp9dx0z6oq.jl:36\n  Test threw exception\n  Expression: candidate([3,\
    \ 5, 10, 1, 2]) == true\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmp9dx0z6oq.jl:29\n   [2] top-level scope at /tmp/tmp9dx0z6oq.jl:36\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9dx0z6oq.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmp9dx0z6oq.jl:37\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmp9dx0z6oq.jl:29\n   [2] top-level scope at /tmp/tmp9dx0z6oq.jl:37\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9dx0z6oq.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmp9dx0z6oq.jl:38\n  Test threw exception\n  Expression: candidate([3,\
    \ 5, 4, 1, 2]) == false\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmp9dx0z6oq.jl:29\n   [2] top-level scope at /tmp/tmp9dx0z6oq.jl:38\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9dx0z6oq.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmp9dx0z6oq.jl:39\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == true\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Bool\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmp9dx0z6oq.jl:29\n   [2] top-level scope at /tmp/tmp9dx0z6oq.jl:39\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9dx0z6oq.jl:34\n  \nTest Summary: | Error \
    \ Total\ntest set      |     5      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9dx0z6oq.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr) == 0\n        return\
    \ true\n    end\n    if length(arr) == 1\n        return true\n    end\n    if\
    \ length(arr) == 2\n        return true\n    end\n    if length(arr) == 3\n  \
    \      if arr[1] <= arr[2] && arr[2] <= arr[3]\n            return true\n    \
    \    elseif arr[1] <= arr[3] && arr[3] <= arr[2]\n            return true\n  \
    \      elseif arr[2] <= arr[1] && arr[1] <= arr[3]\n            return true\n\
    \        elseif arr[2] <= arr[3] && arr[3] <= arr[1]\n            return true\n\
    \        elseif arr[3] <= arr[1] && arr[1] <= arr[2]\n            return true\n\
    \        elseif arr[3] <= arr[2] && arr[2] <= arr[1]\n            return true\n\
    \        else\n            return false\n        end\n    end\n    if arr[1] <=\
    \ arr[2] && arr[2] <= arr[3]\n        return move_one_ball(arr[2:end])\n    elseif\
    \ arr[1] <= arr[3] && arr[3] <= arr[2]\n        return move_one_ball(arr[2:end])\n\
    \    elseif arr[2] <= arr[1] && arr[1] <= arr[3]\n        return move_one_ball(arr[2:end])\n\
    \    elseif arr[2] <= arr[3] && arr[3] <= arr[1]\n        return move_one_ball(arr[2:end])\n\
    \    elseif arr[3] <= arr[1] && arr[1] <= arr[2]\n        return move_one_ball(arr[2:end])\n\
    \    elseif arr[3] <= arr[2] && arr[2] <= arr[1]\n        return move_one_ball(arr[2:end])\n\
    \    else\n        return false\n    end\nend\nusing Test\n\n@testset begin\n\n\
    candidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2]) == true)\n\t@test(candidate([3,\
    \ 5, 10, 1, 2]) == true)\n\t@test(candidate([4, 3, 1, 2]) == false)\n\t@test(candidate([3,\
    \ 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([])) == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpoafxp96t.jl:77\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpoafxp96t.jl:77\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpoafxp96t.jl:74\ntest set: Test Failed at /tmp/tmpoafxp96t.jl:78\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpoafxp96t.jl:78\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpoafxp96t.jl:74\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpoafxp96t.jl:72\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr) == 0\n        return\
    \ true\n    end\n    if length(arr) == 1\n        return true\n    end\n    if\
    \ length(arr) == 2\n        if arr[1] > arr[2]\n            return false\n   \
    \     else\n            return true\n        end\n    end\n    for i in 1:length(arr)\n\
    \        if i == 1\n            if arr[i] > arr[i+1]\n                return false\n\
    \            end\n        elseif i == length(arr)\n            if arr[i] < arr[i-1]\n\
    \                return false\n            end\n        else\n            if arr[i]\
    \ < arr[i-1] || arr[i] > arr[i+1]\n                return false\n            end\n\
    \        end\n    end\n    return true\nend\nusing Test\n\n@testset begin\n\n\
    candidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2]) == true)\n\t@test(candidate([3,\
    \ 5, 10, 1, 2]) == true)\n\t@test(candidate([4, 3, 1, 2]) == false)\n\t@test(candidate([3,\
    \ 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([])) == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpwqmp9q0u.jl:63\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\n   Evaluated: false == true\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpwqmp9q0u.jl:63\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwqmp9q0u.jl:62\ntest set: Test Failed at /tmp/tmpwqmp9q0u.jl:64\n\
    \  Expression: candidate([3, 5, 10, 1, 2]) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpwqmp9q0u.jl:64\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwqmp9q0u.jl:62\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwqmp9q0u.jl:60\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    if length(arr)==0\n\
    \        return true\n    end\n    if length(arr)==1\n        return true\n  \
    \  end\n    if length(arr)==2\n        if arr[1]<=arr[2]\n            return true\n\
    \        else\n            return false\n        end\n    end\n    if length(arr)==3\n\
    \        if arr[1]<=arr[2] && arr[2]<=arr[3]\n            return true\n      \
    \  elseif arr[1]<=arr[3] && arr[3]<=arr[2]\n            return true\n        elseif\
    \ arr[2]<=arr[1] && arr[1]<=arr[3]\n            return true\n        elseif arr[2]<=arr[3]\
    \ && arr[3]<=arr[1]\n            return true\n        elseif arr[3]<=arr[1] &&\
    \ arr[1]<=arr[2]\n            return true\n        elseif arr[3]<=arr[2] && arr[2]<=arr[1]\n\
    \            return true\n        else\n            return false\n        end\n\
    \    end\n    if length(arr)>3\n        if arr[1]<=arr[2] && arr[2]<=arr[3]\n\
    \            return true\n        elseif arr[1]<=arr[3] && arr[3]<=arr[2]\n  \
    \          return true\n        elseif arr[2]<=arr[1] && arr[1]<=arr[3]\n    \
    \        return true\n        elseif arr[2]<=arr[3] && arr[3]<=arr[1]\n      \
    \      return true\n        elseif arr[3]<=arr[1] && arr[1]<=arr[2]\n        \
    \    return true\n        elseif arr[3]<=arr[2] && arr[2]<=arr[1]\n          \
    \  return true\n        else\n            return false\n        end\n    end\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpzxuzfclh.jl:84\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpzxuzfclh.jl:84\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzxuzfclh.jl:81\ntest set: Test Failed at /tmp/tmpzxuzfclh.jl:85\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpzxuzfclh.jl:85\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzxuzfclh.jl:81\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzxuzfclh.jl:79\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    return true\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpeoocqzqw.jl:38\\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\\n   Evaluated: true == false\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmpeoocqzqw.jl:38\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpeoocqzqw.jl:35\\ntest set: Test Failed at /tmp/tmpeoocqzqw.jl:39\\\
    n  Expression: candidate([3, 5, 4, 1, 2]) == false\\n   Evaluated: true == false\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpeoocqzqw.jl:39\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpeoocqzqw.jl:35\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr) == 0\n        return\
    \ true\n    end\n    if length(arr) == 1\n        return true\n    end\n    if\
    \ length(arr) == 2\n        if arr[1] <= arr[2]\n            return true\n   \
    \     else\n            return false\n        end\n    end\n    for i in 1:length(arr)\n\
    \        if i == 1\n            if arr[i] <= arr[i+1]\n                continue\n\
    \            else\n                return false\n            end\n        end\n\
    \        if i == length(arr)\n            if arr[i] >= arr[i-1]\n            \
    \    continue\n            else\n                return false\n            end\n\
    \        end\n        if arr[i] >= arr[i-1] && arr[i] <= arr[i+1]\n          \
    \  continue\n        else\n            return false\n        end\n    end\n  \
    \  return true\nend\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\
    \t@test(candidate([3, 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2])\
    \ == true)\n\t@test(candidate([4, 3, 1, 2]) == false)\n\t@test(candidate([3, 5,\
    \ 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([])) == true)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpau61u1ru.jl:69\\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\\n   Evaluated: false == true\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmpau61u1ru.jl:69\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpau61u1ru.jl:68\\ntest set: Test Failed at /tmp/tmpau61u1ru.jl:70\\\
    n  Expression: candidate([3, 5, 10, 1, 2]) == true\\n   Evaluated: false == true\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpau61u1ru.jl:70\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpau61u1ru.jl:68\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    3     2      5\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr) == 0\n        return\
    \ true\n    end\n    if length(arr) == 1\n        return true\n    end\n    if\
    \ length(arr) == 2\n        return true\n    end\n    if length(arr) == 3\n  \
    \      if arr[1] <= arr[2] <= arr[3]\n            return true\n        else\n\
    \            return false\n        end\n    end\n    if length(arr) == 4\n   \
    \     if arr[1] <= arr[2] <= arr[3] <= arr[4]\n            return true\n     \
    \   else\n            return false\n        end\n    end\n    if length(arr) ==\
    \ 5\n        if arr[1] <= arr[2] <= arr[3] <= arr[4] <= arr[5]\n            return\
    \ true\n        else\n            return false\n        end\n    end\n    if length(arr)\
    \ == 6\n        if arr[1] <= arr[2] <= arr[3] <= arr[4] <= arr[5] <= arr[6]\n\
    \            return true\n        else\n            return false\n        end\n\
    \    end\n    if length(arr) == 7\n        if arr[1] <= arr[2] <= arr[3] <= arr[4]\
    \ <= arr[5] <= arr[6] <= arr[7]\n            return true\n        else\n     \
    \       return false\n        end\n    end\n    if length(arr) == 8\n        if\
    \ arr[1] <= arr[2] <= arr[3] <= arr[4] <= arr[5] <= arr[6] <= arr[7] <= arr[8]\n\
    \            return true\n        else\n            return false\n        end\n\
    \    end\n    if length(arr) == 9\n        if arr[1] <= arr[2] <= arr[3] <= arr[4]\
    \ <= arr[5] <= arr[6] <= arr[7] <= arr[8] <= arr[9]\n            return true\n\
    \        else\n            return false\n        end\n    end\n    if length(arr)\
    \ == 10\n        if arr[1] <= arr[2] <= arr[3] <= arr[4] <= arr[5] <= arr[6] <=\
    \ arr[7] <= arr[8] <= arr[9] <= arr\nusing Test\n\n@testset begin\n\ncandidate\
    \ = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2]) == true)\n\t@test(candidate([3,\
    \ 5, 10, 1, 2]) == true)\n\t@test(candidate([4, 3, 1, 2]) == false)\n\t@test(candidate([3,\
    \ 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([])) == true)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpg84xhy06.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpg84xhy06.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    return true\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp8f4z1px9.jl:38\\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\\n   Evaluated: true == false\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmp8f4z1px9.jl:38\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp8f4z1px9.jl:35\\ntest set: Test Failed at /tmp/tmp8f4z1px9.jl:39\\\
    n  Expression: candidate([3, 5, 4, 1, 2]) == false\\n   Evaluated: true == false\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp8f4z1px9.jl:39\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp8f4z1px9.jl:35\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    3     2      5\\n'"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr) == 0\n        return\
    \ true\n    end\n    if length(arr) == 1\n        return true\n    end\n    if\
    \ length(arr) == 2\n        if arr[1] > arr[2]\n            return false\n   \
    \     else\n            return true\n        end\n    end\n    for i in 1:length(arr)\n\
    \        if arr[i] > arr[i+1]\n            return false\n        end\n    end\n\
    \    return true\nend\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\
    \t@test(candidate([3, 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2])\
    \ == true)\n\t@test(candidate([4, 3, 1, 2]) == false)\n\t@test(candidate([3, 5,\
    \ 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([])) == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpzimhvl4t.jl:53\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\n   Evaluated: false == true\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpzimhvl4t.jl:53\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzimhvl4t.jl:52\ntest set: Test Failed at /tmp/tmpzimhvl4t.jl:54\n\
    \  Expression: candidate([3, 5, 10, 1, 2]) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpzimhvl4t.jl:54\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzimhvl4t.jl:52\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzimhvl4t.jl:50\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr) == 0\n        return\
    \ true\n    end\n    if length(arr) == 1\n        return true\n    end\n    if\
    \ length(arr) == 2\n        if arr[1] <= arr[2]\n            return true\n   \
    \     else\n            return false\n        end\n    end\n    if length(arr)\
    \ == 3\n        if arr[1] <= arr[2] && arr[2] <= arr[3]\n            return true\n\
    \        elseif arr[1] <= arr[3] && arr[3] <= arr[2]\n            return true\n\
    \        elseif arr[2] <= arr[1] && arr[1] <= arr[3]\n            return true\n\
    \        elseif arr[2] <= arr[3] && arr[3] <= arr[1]\n            return true\n\
    \        elseif arr[3] <= arr[1] && arr[1] <= arr[2]\n            return true\n\
    \        elseif arr[3] <= arr[2] && arr[2] <= arr[1]\n            return true\n\
    \        else\n            return false\n        end\n    end\n    if length(arr)\
    \ > 3\n        if arr[1] <= arr[2] && arr[2] <= arr[3]\n            return true\n\
    \        elseif arr[1] <= arr[3] && arr[3] <= arr[2]\n            return true\n\
    \        elseif arr[2] <= arr[1] && arr[1] <= arr[3]\n            return true\n\
    \        elseif arr[2] <= arr[3] && arr[3] <= arr[1]\n            return true\n\
    \        elseif arr[3] <= arr[1] && arr[1] <= arr[2]\n            return true\n\
    \        elseif arr[3] <= arr[2] && arr[2] <= arr[1]\n            return true\n\
    \        else\n            return false\n        end\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1,\
    \ 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp16tx9hdj.jl:83\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp16tx9hdj.jl:83\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp16tx9hdj.jl:80\ntest set: Test Failed at /tmp/tmp16tx9hdj.jl:84\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp16tx9hdj.jl:84\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp16tx9hdj.jl:80\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp16tx9hdj.jl:78\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    return true\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp8khcdgjq.jl:38\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp8khcdgjq.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8khcdgjq.jl:35\ntest set: Test Failed at /tmp/tmp8khcdgjq.jl:39\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp8khcdgjq.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8khcdgjq.jl:35\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8khcdgjq.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr)==0\n        return\
    \ true\n    end\n    if length(arr)==1\n        return true\n    end\n    if length(arr)==2\n\
    \        if arr[1]<=arr[2]\n            return true\n        else\n          \
    \  return false\n        end\n    end\n    for i in 1:length(arr)\n        if\
    \ arr[i]>arr[i+1]\n            return false\n        end\n    end\n    return\
    \ true\nend\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp634jg923.jl:53\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\n   Evaluated: false == true\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp634jg923.jl:53\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp634jg923.jl:52\ntest set: Test Failed at /tmp/tmp634jg923.jl:54\n\
    \  Expression: candidate([3, 5, 10, 1, 2]) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp634jg923.jl:54\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp634jg923.jl:52\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp634jg923.jl:50\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    return true\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpix65v_g5.jl:38\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpix65v_g5.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpix65v_g5.jl:35\ntest set: Test Failed at /tmp/tmpix65v_g5.jl:39\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpix65v_g5.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpix65v_g5.jl:35\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpix65v_g5.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Write your code here\n    #\
    \ Return True if it is possible to get the sorted array by performing\n    # the\
    \ above operation else return False.\n    # If the given array is empty then return\
    \ True.\n    return true\nend\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\
    \t@test(candidate([3, 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2])\
    \ == true)\n\t@test(candidate([4, 3, 1, 2]) == false)\n\t@test(candidate([3, 5,\
    \ 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([])) == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpaok8fnmj.jl:41\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpaok8fnmj.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpaok8fnmj.jl:38\ntest set: Test Failed at /tmp/tmpaok8fnmj.jl:42\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpaok8fnmj.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpaok8fnmj.jl:38\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpaok8fnmj.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # YOUR CODE HERE\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1,\
    \ 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp1gr5sgml.jl:35\n  Test threw exception\n\
    \  Expression: candidate([3, 4, 5, 1, 2]) == true\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Bool\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmp1gr5sgml.jl:29\n   [2] top-level scope at /tmp/tmp1gr5sgml.jl:35\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1gr5sgml.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmp1gr5sgml.jl:36\n  Test threw exception\n  Expression: candidate([3,\
    \ 5, 10, 1, 2]) == true\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmp1gr5sgml.jl:29\n   [2] top-level scope at /tmp/tmp1gr5sgml.jl:36\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1gr5sgml.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmp1gr5sgml.jl:37\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmp1gr5sgml.jl:29\n   [2] top-level scope at /tmp/tmp1gr5sgml.jl:37\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1gr5sgml.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmp1gr5sgml.jl:38\n  Test threw exception\n  Expression: candidate([3,\
    \ 5, 4, 1, 2]) == false\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmp1gr5sgml.jl:29\n   [2] top-level scope at /tmp/tmp1gr5sgml.jl:38\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1gr5sgml.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmp1gr5sgml.jl:39\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == true\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Bool\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmp1gr5sgml.jl:29\n   [2] top-level scope at /tmp/tmp1gr5sgml.jl:39\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1gr5sgml.jl:34\n  \nTest Summary: | Error \
    \ Total\ntest set      |     5      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1gr5sgml.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr)==0\n        return\
    \ true\n    end\n    if length(arr)==1\n        return true\n    end\n    if length(arr)==2\n\
    \        if arr[1]>arr[2]\n            return false\n        else\n          \
    \  return true\n        end\n    end\n    #find the minimum element in the array\n\
    \    min_index=1\n    for i in 2:length(arr)\n        if arr[i]<arr[min_index]\n\
    \            min_index=i\n        end\n    end\n    #check if the minimum element\
    \ is at the end of the array\n    if min_index==length(arr)\n        return true\n\
    \    end\n    #check if the minimum element is at the beginning of the array\n\
    \    if min_index==1\n        return false\n    end\n    #check if the minimum\
    \ element is at the middle of the array\n    if min_index>1 && min_index<length(arr)\n\
    \        if arr[min_index-1]<arr[min_index+1]\n            return true\n     \
    \   else\n            return false\n        end\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2])\
    \ == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmps55ieyvf.jl:70\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\n   Evaluated: false == true\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmps55ieyvf.jl:70\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmps55ieyvf.jl:69\ntest set: Test Failed at /tmp/tmps55ieyvf.jl:71\n\
    \  Expression: candidate([3, 5, 10, 1, 2]) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmps55ieyvf.jl:71\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmps55ieyvf.jl:69\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmps55ieyvf.jl:67\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr) == 0\n        return\
    \ true\n    end\n    if length(arr) == 1\n        return true\n    end\n    if\
    \ length(arr) == 2\n        if arr[1] > arr[2]\n            return false\n   \
    \     else\n            return true\n        end\n    end\n    if length(arr)\
    \ == 3\n        if arr[1] > arr[2]\n            if arr[2] > arr[3]\n         \
    \       return false\n            else\n                return true\n        \
    \    end\n        else\n            if arr[1] > arr[3]\n                return\
    \ false\n            else\n                return true\n            end\n    \
    \    end\n    end\n    if length(arr) > 3\n        if arr[1] > arr[2]\n      \
    \      if arr[2] > arr[3]\n                return false\n            else\n  \
    \              return true\n            end\n        else\n            if arr[1]\
    \ > arr[3]\n                return false\n            else\n                return\
    \ true\n            end\n        end\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2]) == true)\n\t\
    @test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4, 3, 1, 2]) ==\
    \ false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpubt4ueun.jl:80\n  Expression: candidate([3,\
    \ 5, 4, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpubt4ueun.jl:80\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpubt4ueun.jl:76\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpubt4ueun.jl:74\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr)==0\n        return\
    \ true\n    end\n    if length(arr)==1\n        return true\n    end\n    if length(arr)==2\n\
    \        if arr[1]<=arr[2]\n            return true\n        else\n          \
    \  return false\n        end\n    end\n    if length(arr)==3\n        if arr[1]<=arr[2]\
    \ && arr[2]<=arr[3]\n            return true\n        elseif arr[1]<=arr[3] &&\
    \ arr[3]<=arr[2]\n            return true\n        elseif arr[2]<=arr[1] && arr[1]<=arr[3]\n\
    \            return true\n        elseif arr[2]<=arr[3] && arr[3]<=arr[1]\n  \
    \          return true\n        elseif arr[3]<=arr[1] && arr[1]<=arr[2]\n    \
    \        return true\n        elseif arr[3]<=arr[2] && arr[2]<=arr[1]\n      \
    \      return true\n        else\n            return false\n        end\n    end\n\
    \    if length(arr)>3\n        if arr[1]<=arr[2] && arr[2]<=arr[3]\n         \
    \   return true\n        elseif arr[1]<=arr[3] && arr[3]<=arr[2]\n           \
    \ return true\n        elseif arr[2]<=arr[1] && arr[1]<=arr[3]\n            return\
    \ true\n        elseif arr[2]<=arr[3] && arr[3]<=arr[1]\n            return true\n\
    \        elseif arr[3]<=arr[1] && arr[1]<=arr[2]\n            return true\n  \
    \      elseif arr[3]<=arr[2] && arr[2]<=arr[1]\n            return true\n    \
    \    else\n            return false\n        end\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2])\
    \ == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpajwcvpcs.jl:83\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpajwcvpcs.jl:83\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpajwcvpcs.jl:80\ntest set: Test Failed at /tmp/tmpajwcvpcs.jl:84\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpajwcvpcs.jl:84\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpajwcvpcs.jl:80\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpajwcvpcs.jl:78\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # YOUR CODE HERE\n    return true\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp38by5l0p.jl:38\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp38by5l0p.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp38by5l0p.jl:35\ntest set: Test Failed at /tmp/tmp38by5l0p.jl:39\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp38by5l0p.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp38by5l0p.jl:35\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp38by5l0p.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    return true\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp_u7ah9p8.jl:38\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp_u7ah9p8.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_u7ah9p8.jl:35\ntest set: Test Failed at /tmp/tmp_u7ah9p8.jl:39\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp_u7ah9p8.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_u7ah9p8.jl:35\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_u7ah9p8.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    return false\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpmw1gbvd9.jl:36\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\n   Evaluated: false == true\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpmw1gbvd9.jl:36\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmw1gbvd9.jl:35\ntest set: Test Failed at /tmp/tmpmw1gbvd9.jl:37\n\
    \  Expression: candidate([3, 5, 10, 1, 2]) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpmw1gbvd9.jl:37\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmw1gbvd9.jl:35\ntest set: Test Failed at /tmp/tmpmw1gbvd9.jl:40\n\
    \  Expression: candidate(Vector{Int64}([])) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpmw1gbvd9.jl:40\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmw1gbvd9.jl:35\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     3      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmw1gbvd9.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    return false\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmph1ip48tj.jl:36\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\n   Evaluated: false == true\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmph1ip48tj.jl:36\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmph1ip48tj.jl:35\ntest set: Test Failed at /tmp/tmph1ip48tj.jl:37\n\
    \  Expression: candidate([3, 5, 10, 1, 2]) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmph1ip48tj.jl:37\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmph1ip48tj.jl:35\ntest set: Test Failed at /tmp/tmph1ip48tj.jl:40\n\
    \  Expression: candidate(Vector{Int64}([])) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmph1ip48tj.jl:40\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmph1ip48tj.jl:35\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     3      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmph1ip48tj.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr)==0\n        return\
    \ true\n    end\n    if length(arr)==1\n        return true\n    end\n    if length(arr)==2\n\
    \        if arr[1]<=arr[2]\n            return true\n        else\n          \
    \  return false\n        end\n    end\n    if length(arr)==3\n        if arr[1]<=arr[2]\n\
    \            if arr[2]<=arr[3]\n                return true\n            else\n\
    \                return false\n            end\n        else\n            if arr[1]<=arr[3]\n\
    \                return true\n            else\n                return false\n\
    \            end\n        end\n    end\n    if length(arr)>3\n        if arr[1]<=arr[2]\n\
    \            if arr[2]<=arr[3]\n                return move_one_ball(arr[2:end])\n\
    \            else\n                return move_one_ball([arr[2],arr[1],arr[3:end]])\n\
    \            end\n        else\n            if arr[1]<=arr[3]\n              \
    \  return move_one_ball([arr[2],arr[1],arr[3:end]])\n            else\n      \
    \          return false\n            end\n        end\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1,\
    \ 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp3_r8q288.jl:77\n  Test threw exception\n\
    \  Expression: candidate([3, 4, 5, 1, 2]) == true\n  MethodError: no method matching\
    \ move_one_ball(::Array{Any,1})\n  Closest candidates are:\n    move_one_ball(!Matched::Array{Int64,1})\
    \ at /tmp/tmp3_r8q288.jl:28\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmp3_r8q288.jl:61\n   [2] move_one_ball(::Array{Int64,1}) at /tmp/tmp3_r8q288.jl:59\n\
    \   [3] top-level scope at /tmp/tmp3_r8q288.jl:77\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp3_r8q288.jl:76\n  \ntest set: Error During\
    \ Test at /tmp/tmp3_r8q288.jl:78\n  Test threw exception\n  Expression: candidate([3,\
    \ 5, 10, 1, 2]) == true\n  MethodError: no method matching move_one_ball(::Array{Any,1})\n\
    \  Closest candidates are:\n    move_one_ball(!Matched::Array{Int64,1}) at /tmp/tmp3_r8q288.jl:28\n\
    \  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1}) at /tmp/tmp3_r8q288.jl:61\n\
    \   [2] move_one_ball(::Array{Int64,1}) at /tmp/tmp3_r8q288.jl:59\n   [3] top-level\
    \ scope at /tmp/tmp3_r8q288.jl:78\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp3_r8q288.jl:76\n  \ntest set: Error During\
    \ Test at /tmp/tmp3_r8q288.jl:80\n  Test threw exception\n  Expression: candidate([3,\
    \ 5, 4, 1, 2]) == false\n  MethodError: no method matching move_one_ball(::Array{Any,1})\n\
    \  Closest candidates are:\n    move_one_ball(!Matched::Array{Int64,1}) at /tmp/tmp3_r8q288.jl:28\n\
    \  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1}) at /tmp/tmp3_r8q288.jl:61\n\
    \   [2] top-level scope at /tmp/tmp3_r8q288.jl:80\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3_r8q288.jl:76\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      3      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3_r8q288.jl:74\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    # You can\
    \ add helper functions as needed\n    return true\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2]) == true)\n\
    \t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4, 3, 1, 2])\
    \ == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpzlno7q68.jl:39\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpzlno7q68.jl:39\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzlno7q68.jl:36\ntest set: Test Failed at /tmp/tmpzlno7q68.jl:40\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpzlno7q68.jl:40\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzlno7q68.jl:36\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzlno7q68.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr)==0\n        return\
    \ true\n    end\n    if length(arr)==1\n        return true\n    end\n    if length(arr)==2\n\
    \        if arr[1]>arr[2]\n            return false\n        else\n          \
    \  return true\n        end\n    end\n    if length(arr)==3\n        if arr[1]>arr[2]\
    \ && arr[2]>arr[3]\n            return false\n        else\n            return\
    \ true\n        end\n    end\n    if length(arr)>3\n        if arr[1]>arr[2] &&\
    \ arr[2]>arr[3]\n            return false\n        else\n            return true\n\
    \        end\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\
    \t@test(candidate([3, 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2])\
    \ == true)\n\t@test(candidate([4, 3, 1, 2]) == false)\n\t@test(candidate([3, 5,\
    \ 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([])) == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpfqsyea28.jl:64\n  Expression: candidate([3,\
    \ 5, 4, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpfqsyea28.jl:64\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfqsyea28.jl:60\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpfqsyea28.jl:58\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr) == 0\n        return\
    \ true\n    end\n    if length(arr) == 1\n        return true\n    end\n    if\
    \ length(arr) == 2\n        return true\n    end\n    if length(arr) == 3\n  \
    \      return true\n    end\n    if length(arr) == 4\n        return true\n  \
    \  end\n    if length(arr) == 5\n        return true\n    end\n    if length(arr)\
    \ == 6\n        return true\n    end\n    if length(arr) == 7\n        return\
    \ true\n    end\n    if length(arr) == 8\n        return true\n    end\n    if\
    \ length(arr) == 9\n        return true\n    end\n    if length(arr) == 10\n \
    \       return true\n    end\n    if length(arr) == 11\n        return true\n\
    \    end\n    if length(arr) == 12\n        return true\n    end\n    if length(arr)\
    \ == 13\n        return true\n    end\n    if length(arr) == 14\n        return\
    \ true\n    end\n    if length(arr) == 15\n        return true\n    end\n    if\
    \ length(arr) == 16\n        return true\n    end\n    if length(arr) == 17\n\
    \        return true\n    end\n    if length(arr) == 18\n        return true\n\
    \    end\n    if length(arr) == 19\n        return true\n    end\n    if length(arr)\
    \ == 20\n        return true\n    end\n    if length(arr) == 21\n        return\
    \ true\n    end\n    if length(arr) == 22\n        return true\n    end\n    if\
    \ length(arr) == 23\n        return true\n    end\n    if length(arr) == 24\n\
    \        return true\n    end\n    if length(arr) == 25\n        return true\n\
    \    end\n    if length(arr) == 26\n        return true\n    end\n    if length(arr)\
    \ == 27\n        return true\n    end\n    if length(arr) == 28\n        return\
    \ true\n    end\n    if length(arr) == 29\n        return true\n    end\n    if\
    \ length(arr) == 30\n        return true\n    end\n    if length(arr) == 31\n\
    \        return true\n    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\
    \t@test(candidate([3, 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2])\
    \ == true)\n\t@test(candidate([4, 3, 1, 2]) == false)\n\t@test(candidate([3, 5,\
    \ 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([])) == true)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp977wydfj.jl:27\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp977wydfj.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp977wydfj.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # your code here\n    return true\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpwsmzk226.jl:38\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpwsmzk226.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwsmzk226.jl:35\ntest set: Test Failed at /tmp/tmpwsmzk226.jl:39\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpwsmzk226.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwsmzk226.jl:35\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwsmzk226.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr)==0\n        return\
    \ true\n    end\n    for i in 1:length(arr)\n        if arr[i]==i\n          \
    \  continue\n        elseif arr[i]==i+1\n            arr[i],arr[i+1]=arr[i+1],arr[i]\n\
    \        else\n            return false\n        end\n    end\n    return true\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp_60nfddu.jl:47\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\n   Evaluated: false == true\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp_60nfddu.jl:47\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_60nfddu.jl:46\ntest set: Test Failed at /tmp/tmp_60nfddu.jl:48\n\
    \  Expression: candidate([3, 5, 10, 1, 2]) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp_60nfddu.jl:48\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_60nfddu.jl:46\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_60nfddu.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    # You can\
    \ add helper functions as you wish\n    # You can also change the function signature\
    \ as you wish\n    # You are not allowed to use any inbuilt functions\n    # You\
    \ are not allowed to use any mutable data structures\n    # You are not allowed\
    \ to use any sorting functions\n    # You are not allowed to use any for loops\n\
    \    # You are not allowed to use any while loops\n    # You are not allowed to\
    \ use any do-while loops\n    # You are not allowed to use any if-else statements\n\
    \    # You are not allowed to use any switch-case statements\n    # You are not\
    \ allowed to use any try-catch statements\n    # You are not allowed to use any\
    \ break statements\n    # You are not allowed to use any continue statements\n\
    \    # You are not allowed to use any goto statements\n    # You are not allowed\
    \ to use any labels\n    # You are not allowed to use any goto statements\n  \
    \  # You are not allowed to use any goto statements\n    # You are not allowed\
    \ to use any goto statements\n    # You are not allowed to use any goto statements\n\
    \    # You are not allowed to use any goto statements\n    # You are not allowed\
    \ to use any goto statements\n    # You are not allowed to use any goto statements\n\
    \    # You are not allowed to use any goto statements\n    # You are not allowed\
    \ to use any goto statements\n    # You are not allowed to use any goto statements\n\
    \    # You are not allowed to use any goto statements\n    # You are not allowed\
    \ to use any goto statements\n    # You are not allowed to use any goto statements\n\
    \    # You are not allowed to use any goto statements\n    # You are not allowed\
    \ to use any goto statements\n    # You are not allowed to use any goto statements\n\
    \    # You are not allowed to use any goto statements\n    # You are not allowed\
    \ to use any goto statements\n    # You are not allowed to use any goto statements\n\
    \    # You are not allowed to use any goto statements\n    # You are not allowed\
    \ to use any goto statements\n    # You are not allowed to use any goto statements\n\
    \    # You are not allowed to use any goto statements\n    # You are not allowed\
    \ to use any goto statements\n    # You are not allowed to use any goto statements\n\
    \    # You are not allowed to use any goto statements\n    # You\nusing Test\n\
    \n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1,\
    \ 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpqkx0jbtd.jl:27\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpqkx0jbtd.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpqkx0jbtd.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    return true\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpicjozmun.jl:38\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpicjozmun.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpicjozmun.jl:35\ntest set: Test Failed at /tmp/tmpicjozmun.jl:39\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpicjozmun.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpicjozmun.jl:35\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpicjozmun.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1,\
    \ 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp13d3ftkb.jl:35\n  Test threw exception\n\
    \  Expression: candidate([3, 4, 5, 1, 2]) == true\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Bool\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmp13d3ftkb.jl:29\n   [2] top-level scope at /tmp/tmp13d3ftkb.jl:35\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp13d3ftkb.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmp13d3ftkb.jl:36\n  Test threw exception\n  Expression: candidate([3,\
    \ 5, 10, 1, 2]) == true\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmp13d3ftkb.jl:29\n   [2] top-level scope at /tmp/tmp13d3ftkb.jl:36\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp13d3ftkb.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmp13d3ftkb.jl:37\n  Test threw exception\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmp13d3ftkb.jl:29\n   [2] top-level scope at /tmp/tmp13d3ftkb.jl:37\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp13d3ftkb.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmp13d3ftkb.jl:38\n  Test threw exception\n  Expression: candidate([3,\
    \ 5, 4, 1, 2]) == false\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Bool\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmp13d3ftkb.jl:29\n   [2] top-level scope at /tmp/tmp13d3ftkb.jl:38\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp13d3ftkb.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmp13d3ftkb.jl:39\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == true\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Bool\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number) where\
    \ T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where T<:Integer\
    \ at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmp13d3ftkb.jl:29\n   [2] top-level scope at /tmp/tmp13d3ftkb.jl:39\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp13d3ftkb.jl:34\n  \nTest Summary: | Error \
    \ Total\ntest set      |     5      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp13d3ftkb.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr) == 0\n        return\
    \ true\n    end\n    for i in 1:length(arr)\n        if arr[i] == i\n        \
    \    continue\n        elseif arr[i] == i + 1\n            arr[i], arr[i + 1]\
    \ = arr[i + 1], arr[i]\n        else\n            return false\n        end\n\
    \    end\n    return true\nend\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\
    \t@test(candidate([3, 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2])\
    \ == true)\n\t@test(candidate([4, 3, 1, 2]) == false)\n\t@test(candidate([3, 5,\
    \ 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([])) == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpd1265lqg.jl:47\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\n   Evaluated: false == true\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpd1265lqg.jl:47\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpd1265lqg.jl:46\ntest set: Test Failed at /tmp/tmpd1265lqg.jl:48\n\
    \  Expression: candidate([3, 5, 10, 1, 2]) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpd1265lqg.jl:48\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpd1265lqg.jl:46\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpd1265lqg.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr)==0\n        return\
    \ true\n    end\n    if length(arr)==1\n        return true\n    end\n    if length(arr)==2\n\
    \        if arr[1]<=arr[2]\n            return true\n        else\n          \
    \  return false\n        end\n    end\n    if length(arr)==3\n        if arr[1]<=arr[2]\n\
    \            if arr[2]<=arr[3]\n                return true\n            else\n\
    \                return false\n            end\n        else\n            if arr[1]<=arr[3]\n\
    \                return true\n            else\n                return false\n\
    \            end\n        end\n    end\n    if length(arr)>3\n        if arr[1]<=arr[2]\n\
    \            if arr[2]<=arr[3]\n                return move_one_ball(arr[2:end])\n\
    \            else\n                return move_one_ball([arr[2],arr[1],arr[3:end]])\n\
    \            end\n        else\n            if arr[1]<=arr[3]\n              \
    \  return move_one_ball([arr[2],arr[1],arr[3:end]])\n            else\n      \
    \          return false\n            end\n        end\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1,\
    \ 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpn0tigfez.jl:77\n  Test threw exception\n\
    \  Expression: candidate([3, 4, 5, 1, 2]) == true\n  MethodError: no method matching\
    \ move_one_ball(::Array{Any,1})\n  Closest candidates are:\n    move_one_ball(!Matched::Array{Int64,1})\
    \ at /tmp/tmpn0tigfez.jl:28\n  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1})\
    \ at /tmp/tmpn0tigfez.jl:61\n   [2] move_one_ball(::Array{Int64,1}) at /tmp/tmpn0tigfez.jl:59\n\
    \   [3] top-level scope at /tmp/tmpn0tigfez.jl:77\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpn0tigfez.jl:76\n  \ntest set: Error During\
    \ Test at /tmp/tmpn0tigfez.jl:78\n  Test threw exception\n  Expression: candidate([3,\
    \ 5, 10, 1, 2]) == true\n  MethodError: no method matching move_one_ball(::Array{Any,1})\n\
    \  Closest candidates are:\n    move_one_ball(!Matched::Array{Int64,1}) at /tmp/tmpn0tigfez.jl:28\n\
    \  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1}) at /tmp/tmpn0tigfez.jl:61\n\
    \   [2] move_one_ball(::Array{Int64,1}) at /tmp/tmpn0tigfez.jl:59\n   [3] top-level\
    \ scope at /tmp/tmpn0tigfez.jl:78\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpn0tigfez.jl:76\n  \ntest set: Error During\
    \ Test at /tmp/tmpn0tigfez.jl:80\n  Test threw exception\n  Expression: candidate([3,\
    \ 5, 4, 1, 2]) == false\n  MethodError: no method matching move_one_ball(::Array{Any,1})\n\
    \  Closest candidates are:\n    move_one_ball(!Matched::Array{Int64,1}) at /tmp/tmpn0tigfez.jl:28\n\
    \  Stacktrace:\n   [1] move_one_ball(::Array{Int64,1}) at /tmp/tmpn0tigfez.jl:61\n\
    \   [2] top-level scope at /tmp/tmpn0tigfez.jl:80\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpn0tigfez.jl:76\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    2      3      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpn0tigfez.jl:74\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr) == 0\n        return\
    \ true\n    end\n    if length(arr) == 1\n        return true\n    end\n    if\
    \ length(arr) == 2\n        return true\n    end\n    if length(arr) == 3\n  \
    \      if arr[1] > arr[2]\n            arr[1], arr[2] = arr[2], arr[1]\n     \
    \       return true\n        end\n        if arr[2] > arr[3]\n            arr[2],\
    \ arr[3] = arr[3], arr[2]\n            return true\n        end\n        return\
    \ true\n    end\n    for i in 1:length(arr)\n        if arr[i] > arr[i+1]\n  \
    \          arr[i], arr[i+1] = arr[i+1], arr[i]\n            return true\n    \
    \    end\n    end\n    return false\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2]) == true)\n\t@test(candidate([3,\
    \ 5, 10, 1, 2]) == true)\n\t@test(candidate([4, 3, 1, 2]) == false)\n\t@test(candidate([3,\
    \ 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([])) == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpu8s0wf92.jl:63\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpu8s0wf92.jl:63\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpu8s0wf92.jl:60\ntest set: Test Failed at /tmp/tmpu8s0wf92.jl:64\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpu8s0wf92.jl:64\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpu8s0wf92.jl:60\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpu8s0wf92.jl:58\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code goes here\n    if\
    \ length(arr) == 0\n        return true\n    end\n    if length(arr) == 1\n  \
    \      return true\n    end\n    if length(arr) == 2\n        if arr[1] > arr[2]\n\
    \            return false\n        else\n            return true\n        end\n\
    \    end\n    if length(arr) == 3\n        if arr[1] > arr[2]\n            if\
    \ arr[2] > arr[3]\n                return false\n            else\n          \
    \      return true\n            end\n        else\n            if arr[1] > arr[3]\n\
    \                return false\n            else\n                return true\n\
    \            end\n        end\n    end\n    if length(arr) == 4\n        if arr[1]\
    \ > arr[2]\n            if arr[2] > arr[3]\n                if arr[3] > arr[4]\n\
    \                    return false\n                else\n                    return\
    \ true\n                end\n            else\n                if arr[1] > arr[3]\n\
    \                    if arr[3] > arr[4]\n                        return false\n\
    \                    else\n                        return true\n             \
    \       end\n                else\n                    if arr[1] > arr[4]\n  \
    \                      return false\n                    else\n              \
    \          return true\n                    end\n                end\n       \
    \     end\n        else\n            if arr[1] > arr[3]\n                if arr[3]\
    \ > arr[4]\n                    return false\n                else\n         \
    \           return true\n                end\n            else\n             \
    \   if arr[1] > arr[4]\n                    if arr[2] > arr[4]\n             \
    \           return false\n                    else\n                        return\
    \ true\n                    end\n                else\n                    if\
    \ arr[2] > arr[3]\n                        if arr[3] > arr[4]\n              \
    \              return false\n                        else\n                  \
    \          return true\n                        end\n                    else\n\
    \                        return true\n                    end\n              \
    \  end\n            end\n        end\n    end\n    if length(arr) == 5\n     \
    \   if arr[1] > arr[2]\n            if arr[2] > arr[3]\n                if arr[3]\
    \ > arr[4]\n                    if arr[4] > arr[5]\n                        return\
    \ false\n                    else\n                        return true\n     \
    \               end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\
    \t@test(candidate([3, 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2])\
    \ == true)\n\t@test(candidate([4, 3, 1, 2]) == false)\n\t@test(candidate([3, 5,\
    \ 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([])) == true)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp4gwqbh40.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp4gwqbh40.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    return true\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpodtht6e3.jl:38\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpodtht6e3.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpodtht6e3.jl:35\ntest set: Test Failed at /tmp/tmpodtht6e3.jl:39\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpodtht6e3.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpodtht6e3.jl:35\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpodtht6e3.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr)==0\n        return\
    \ true\n    end\n    if length(arr)==1\n        return true\n    end\n    if length(arr)==2\n\
    \        if arr[1]>arr[2]\n            return false\n        else\n          \
    \  return true\n        end\n    end\n    for i in 1:length(arr)-1\n        if\
    \ arr[i]>arr[i+1]\n            return false\n        end\n    end\n    return\
    \ true\nend\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3,\
    \ 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp6dp677qa.jl:53\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\n   Evaluated: false == true\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp6dp677qa.jl:53\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6dp677qa.jl:52\ntest set: Test Failed at /tmp/tmp6dp677qa.jl:54\n\
    \  Expression: candidate([3, 5, 10, 1, 2]) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp6dp677qa.jl:54\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6dp677qa.jl:52\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6dp677qa.jl:50\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr) == 0\n        return\
    \ true\n    end\n    for i in 1:length(arr)\n        if arr[i] == i\n        \
    \    return true\n        end\n    end\n    return false\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2])\
    \ == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp5kt7c7px.jl:43\n  Expression: candidate([3,\
    \ 4, 5, 1, 2]) == true\n   Evaluated: false == true\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp5kt7c7px.jl:43\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5kt7c7px.jl:42\ntest set: Test Failed at /tmp/tmp5kt7c7px.jl:44\n\
    \  Expression: candidate([3, 5, 10, 1, 2]) == true\n   Evaluated: false == true\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp5kt7c7px.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5kt7c7px.jl:42\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5kt7c7px.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    # Your code here\n    if length(arr)\
    \ == 0\n        return true\n    end\n    if length(arr) == 1\n        return\
    \ true\n    end\n    if length(arr) == 2\n        return true\n    end\n    if\
    \ length(arr) == 3\n        return true\n    end\n    if length(arr) == 4\n  \
    \      return true\n    end\n    if length(arr) == 5\n        return true\n  \
    \  end\n    if length(arr) == 6\n        return true\n    end\n    if length(arr)\
    \ == 7\n        return true\n    end\n    if length(arr) == 8\n        return\
    \ true\n    end\n    if length(arr) == 9\n        return true\n    end\n    if\
    \ length(arr) == 10\n        return true\n    end\n    if length(arr) == 11\n\
    \        return true\n    end\n    if length(arr) == 12\n        return true\n\
    \    end\n    if length(arr) == 13\n        return true\n    end\n    if length(arr)\
    \ == 14\n        return true\n    end\n    if length(arr) == 15\n        return\
    \ true\n    end\n    if length(arr) == 16\n        return true\n    end\n    if\
    \ length(arr) == 17\n        return true\n    end\n    if length(arr) == 18\n\
    \        return true\n    end\n    if length(arr) == 19\n        return true\n\
    \    end\n    if length(arr) == 20\n        return true\n    end\n    if length(arr)\
    \ == 21\n        return true\n    end\n    if length(arr) == 22\n        return\
    \ true\n    end\n    if length(arr) == 23\n        return true\n    end\n    if\
    \ length(arr) == 24\n        return true\n    end\n    if length(arr) == 25\n\
    \        return true\n    end\n    if length(arr) == 26\n        return true\n\
    \    end\n    if length(arr) == 27\n        return true\n    end\n    if length(arr)\
    \ == 28\n        return true\n    end\n    if length(arr) == 29\n        return\
    \ true\n    end\n    if length(arr) == 30\n        return true\n    end\n    if\
    \ length(arr) == 31\n\nusing Test\n\n@testset begin\n\ncandidate = move_one_ball;\n\
    \t@test(candidate([3, 4, 5, 1, 2]) == true)\n\t@test(candidate([3, 5, 10, 1, 2])\
    \ == true)\n\t@test(candidate([4, 3, 1, 2]) == false)\n\t@test(candidate([3, 5,\
    \ 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([])) == true)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpt9f4p01_.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpt9f4p01_.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    it is possible to get an array sorted in non-decreasing order by performing\
    \ \n    the following operation on the given array:\n        You are allowed to\
    \ perform right shift operation any number of times.\n    \n    One right shift\
    \ operation means shifting all elements of the array by one\n    position in the\
    \ right direction. The last element of the array will be moved to\n    the starting\
    \ position in the array i.e. 0th index. \n\n    If it is possible to obtain the\
    \ sorted array by performing the above operation\n    then return True else return\
    \ False.\n    If the given array is empty then return True.\n\n    Note: The given\
    \ list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3,\
    \ 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations,\
    \ non-decreasing order can\n                 be achieved for the given array.\n\
    \    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible\
    \ to get non-decreasing order for the given\n                array by performing\
    \ any number of right shift operations.\n                \n    \"\"\"\nfunction\
    \ move_one_ball(arr::Vector{Int64})::Bool \n    if length(arr)==0\n        return\
    \ true\n    end\n    if length(arr)==1\n        return true\n    end\n    if length(arr)==2\n\
    \        if arr[1]<=arr[2]\n            return true\n        else\n          \
    \  return false\n        end\n    end\n    if length(arr)==3\n        if arr[1]<=arr[2]\
    \ && arr[2]<=arr[3]\n            return true\n        elseif arr[1]<=arr[3] &&\
    \ arr[3]<=arr[2]\n            return true\n        elseif arr[2]<=arr[1] && arr[1]<=arr[3]\n\
    \            return true\n        elseif arr[2]<=arr[3] && arr[3]<=arr[1]\n  \
    \          return true\n        elseif arr[3]<=arr[1] && arr[1]<=arr[2]\n    \
    \        return true\n        elseif arr[3]<=arr[2] && arr[2]<=arr[1]\n      \
    \      return true\n        else\n            return false\n        end\n    end\n\
    \    if length(arr)>3\n        if arr[1]<=arr[2] && arr[2]<=arr[3]\n         \
    \   return true\n        elseif arr[1]<=arr[3] && arr[3]<=arr[2]\n           \
    \ return true\n        elseif arr[2]<=arr[1] && arr[1]<=arr[3]\n            return\
    \ true\n        elseif arr[2]<=arr[3] && arr[3]<=arr[1]\n            return true\n\
    \        elseif arr[3]<=arr[1] && arr[1]<=arr[2]\n            return true\n  \
    \      elseif arr[3]<=arr[2] && arr[2]<=arr[1]\n            return true\n    \
    \    else\n            return false\n        end\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = move_one_ball;\n\t@test(candidate([3, 4, 5, 1, 2])\
    \ == true)\n\t@test(candidate([3, 5, 10, 1, 2]) == true)\n\t@test(candidate([4,\
    \ 3, 1, 2]) == false)\n\t@test(candidate([3, 5, 4, 1, 2]) == false)\n\t@test(candidate(Vector{Int64}([]))\
    \ == true)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmps27skmxb.jl:83\n  Expression: candidate([4,\
    \ 3, 1, 2]) == false\n   Evaluated: true == false\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmps27skmxb.jl:83\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmps27skmxb.jl:80\ntest set: Test Failed at /tmp/tmps27skmxb.jl:84\n\
    \  Expression: candidate([3, 5, 4, 1, 2]) == false\n   Evaluated: true == false\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmps27skmxb.jl:84\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmps27skmxb.jl:80\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmps27skmxb.jl:78\n"
  exit_code: 1
  status: SyntaxError
