name: HumanEval_123_get_odd_collatz
language: julia
results:
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    collatz = [n]\n    while n\
    \ != 1\n        if n % 2 == 0\n            n = n \xF7 2\n        else\n      \
    \      n = 3n + 1\n        end\n        push!(collatz, n)\n    end\n    return\
    \ filter(x -> x % 2 != 0, collatz)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpee75azp3.jl:37\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] top-level scope at /tmp/tmpee75azp3.jl:37\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpee75azp3.jl:36\ntest set: Test Failed at /tmp/tmpee75azp3.jl:38\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: [5, 1] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpee75azp3.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpee75azp3.jl:36\ntest set: Test Failed at /tmp/tmpee75azp3.jl:39\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: [3, 5, 1] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpee75azp3.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpee75azp3.jl:36\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpee75azp3.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    collatz = [n]\n    while n\
    \ != 1\n        if n % 2 == 0\n            n = n / 2\n        else\n         \
    \   n = 3 * n + 1\n        end\n        push!(collatz, n)\n    end\n    return\
    \ filter(x -> x % 2 != 0, collatz)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp0ef2ownu.jl:37\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] top-level scope at /tmp/tmp0ef2ownu.jl:37\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0ef2ownu.jl:36\ntest set: Test Failed at /tmp/tmp0ef2ownu.jl:38\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: [5, 1] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp0ef2ownu.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0ef2ownu.jl:36\ntest set: Test Failed at /tmp/tmp0ef2ownu.jl:39\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: [3, 5, 1] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp0ef2ownu.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0ef2ownu.jl:36\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0ef2ownu.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpa32tr7zn.jl:26\\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpa32tr7zn.jl:26\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpa32tr7zn.jl:25\\ntest set: Test Failed at /tmp/tmpa32tr7zn.jl:27\\\
    n  Expression: candidate(5) == [1, 5]\\n   Evaluated: Int64[] == [1, 5]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpa32tr7zn.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpa32tr7zn.jl:25\\ntest set: Test Failed at /tmp/tmpa32tr7zn.jl:28\\\
    n  Expression: candidate(12) == [1, 3, 5]\\n   Evaluated: Int64[] == [1, 3, 5]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpa32tr7zn.jl:28\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpa32tr7zn.jl:25\\ntest set: Test Failed at /tmp/tmpa32tr7zn.jl:29\\\
    n  Expression: candidate(1) == [1]\\n   Evaluated: Int64[] == [1]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpa32tr7zn.jl:29\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpa32tr7zn.jl:25\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    collatz = [n]\n    while n\
    \ != 1\n        if n % 2 == 0\n            n = n / 2\n        else\n         \
    \   n = 3 * n + 1\n        end\n        push!(collatz, n)\n    end\n    return\
    \ filter(x -> x % 2 != 0, collatz)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: "b'test set: Test Failed at /tmp/tmp932x_8pr.jl:37\\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7,\
    \ 11, 13, 17]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp932x_8pr.jl:37\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp932x_8pr.jl:36\\ntest set: Test Failed at /tmp/tmp932x_8pr.jl:38\\\
    n  Expression: candidate(5) == [1, 5]\\n   Evaluated: [5, 1] == [1, 5]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp932x_8pr.jl:38\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp932x_8pr.jl:36\\ntest set: Test Failed at /tmp/tmp932x_8pr.jl:39\\\
    n  Expression: candidate(12) == [1, 3, 5]\\n   Evaluated: [3, 5, 1] == [1, 3,\
    \ 5]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp932x_8pr.jl:39\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp932x_8pr.jl:36\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmprztupon7.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmprztupon7.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprztupon7.jl:25\ntest set: Test Failed at /tmp/tmprztupon7.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmprztupon7.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprztupon7.jl:25\ntest set: Test Failed at /tmp/tmprztupon7.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmprztupon7.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprztupon7.jl:25\ntest set: Test Failed at /tmp/tmprztupon7.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmprztupon7.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprztupon7.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmprztupon7.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp2jqza_c2.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp2jqza_c2.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2jqza_c2.jl:25\ntest set: Test Failed at /tmp/tmp2jqza_c2.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp2jqza_c2.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2jqza_c2.jl:25\ntest set: Test Failed at /tmp/tmp2jqza_c2.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp2jqza_c2.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2jqza_c2.jl:25\ntest set: Test Failed at /tmp/tmp2jqza_c2.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp2jqza_c2.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2jqza_c2.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2jqza_c2.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpere6b1if.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpere6b1if.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpere6b1if.jl:25\ntest set: Test Failed at /tmp/tmpere6b1if.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpere6b1if.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpere6b1if.jl:25\ntest set: Test Failed at /tmp/tmpere6b1if.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpere6b1if.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpere6b1if.jl:25\ntest set: Test Failed at /tmp/tmpere6b1if.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpere6b1if.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpere6b1if.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpere6b1if.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    collatz = [n]\n    while n\
    \ != 1\n        if n % 2 == 0\n            n = n / 2\n        else\n         \
    \   n = 3 * n + 1\n        end\n        push!(collatz, n)\n    end\n    return\
    \ filter(x -> x % 2 != 0, collatz)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp09e5btm0.jl:37\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] top-level scope at /tmp/tmp09e5btm0.jl:37\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp09e5btm0.jl:36\ntest set: Test Failed at /tmp/tmp09e5btm0.jl:38\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: [5, 1] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp09e5btm0.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp09e5btm0.jl:36\ntest set: Test Failed at /tmp/tmp09e5btm0.jl:39\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: [3, 5, 1] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp09e5btm0.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp09e5btm0.jl:36\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp09e5btm0.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    odd_numbers = []\n    while\
    \ n != 1\n        push!(odd_numbers, n)\n        if n % 2 == 0\n            n\
    \ = n / 2\n        else\n            n = 3 * n + 1\n        end\n    end\n   \
    \ push!(odd_numbers, 1)\n    return odd_numbers\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpmgkhar2b.jl:38\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [14, 7, 22, 11, 34, 17, 52, 26, 13,\
    \ 40, 20, 10, 5, 16, 8, 4, 2, 1] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpmgkhar2b.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmgkhar2b.jl:37\ntest set: Test Failed at /tmp/tmpmgkhar2b.jl:39\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: [5, 16, 8, 4, 2, 1] == [1,\
    \ 5]\nStacktrace:\n [1] top-level scope at /tmp/tmpmgkhar2b.jl:39\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmgkhar2b.jl:37\ntest set: Test Failed at /tmp/tmpmgkhar2b.jl:40\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: [12, 6, 3, 10, 5, 16,\
    \ 8, 4, 2, 1] == [1, 3, 5]\nStacktrace:\n [1] top-level scope at /tmp/tmpmgkhar2b.jl:40\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmgkhar2b.jl:37\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmgkhar2b.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    odd_collatz = [n]\n    while\
    \ n != 1\n        if n % 2 == 0\n            n = n / 2\n        else\n       \
    \     n = 3 * n + 1\n        end\n        if n % 2 != 0\n            push!(odd_collatz,\
    \ n)\n        end\n    end\n    return sort(odd_collatz)\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5,\
    \ 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1,\
    \ 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp9ziya54m.jl:39\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1, 5, 7, 11, 13, 14, 17] == [1, 5,\
    \ 7, 11, 13, 17]\nStacktrace:\n [1] top-level scope at /tmp/tmp9ziya54m.jl:39\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9ziya54m.jl:38\ntest set: Test Failed at /tmp/tmp9ziya54m.jl:41\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: [1, 3, 5, 12] == [1,\
    \ 3, 5]\nStacktrace:\n [1] top-level scope at /tmp/tmp9ziya54m.jl:41\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9ziya54m.jl:38\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     2      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9ziya54m.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp9ywdve3s.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp9ywdve3s.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9ywdve3s.jl:25\ntest set: Test Failed at /tmp/tmp9ywdve3s.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp9ywdve3s.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9ywdve3s.jl:25\ntest set: Test Failed at /tmp/tmp9ywdve3s.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp9ywdve3s.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9ywdve3s.jl:25\ntest set: Test Failed at /tmp/tmp9ywdve3s.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp9ywdve3s.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9ywdve3s.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9ywdve3s.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpclae5yp0.jl:25\n  Test threw exception\n\
    \  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpclae5yp0.jl:19\n\
    \   [2] top-level scope at /tmp/tmpclae5yp0.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpclae5yp0.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpclae5yp0.jl:26\n  Test threw exception\n  Expression: candidate(5)\
    \ == [1, 5]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpclae5yp0.jl:19\n\
    \   [2] top-level scope at /tmp/tmpclae5yp0.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpclae5yp0.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpclae5yp0.jl:27\n  Test threw exception\n  Expression: candidate(12)\
    \ == [1, 3, 5]\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpclae5yp0.jl:19\n\
    \   [2] top-level scope at /tmp/tmpclae5yp0.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpclae5yp0.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpclae5yp0.jl:28\n  Test threw exception\n  Expression: candidate(1)\
    \ == [1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpclae5yp0.jl:19\n\
    \   [2] top-level scope at /tmp/tmpclae5yp0.jl:28\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpclae5yp0.jl:24\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpclae5yp0.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpxrmbr7qd.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpxrmbr7qd.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxrmbr7qd.jl:25\ntest set: Test Failed at /tmp/tmpxrmbr7qd.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpxrmbr7qd.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxrmbr7qd.jl:25\ntest set: Test Failed at /tmp/tmpxrmbr7qd.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpxrmbr7qd.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxrmbr7qd.jl:25\ntest set: Test Failed at /tmp/tmpxrmbr7qd.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpxrmbr7qd.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxrmbr7qd.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxrmbr7qd.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    result = [n]\n    while n\
    \ != 1\n        if n % 2 == 0\n            n = n / 2\n        else\n         \
    \   n = 3 * n + 1\n        end\n        if n % 2 != 0\n            push!(result,\
    \ n)\n        end\n    end\n    return sort(result)\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11,\
    \ 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\
    \t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp9bb_j6h7.jl:39\\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\\n   Evaluated: [1, 5, 7, 11, 13, 14, 17] == [1, 5,\
    \ 7, 11, 13, 17]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp9bb_j6h7.jl:39\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp9bb_j6h7.jl:38\\ntest set: Test Failed at /tmp/tmp9bb_j6h7.jl:41\\\
    n  Expression: candidate(12) == [1, 3, 5]\\n   Evaluated: [1, 3, 5, 12] == [1,\
    \ 3, 5]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp9bb_j6h7.jl:41\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp9bb_j6h7.jl:38\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    collatz_seq = [n]\n    while n != 1\n        if n % 2 == 0\n         \
    \   n = n / 2\n        else\n            n = 3 * n + 1\n        end\n        push!(collatz_seq,\
    \ n)\n    end\n    return sort(filter(x -> x % 2 != 0, collatz_seq))\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp_h0tqh5n.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_h0tqh5n.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_h0tqh5n.jl:25\ntest set: Test Failed at /tmp/tmp_h0tqh5n.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_h0tqh5n.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_h0tqh5n.jl:25\ntest set: Test Failed at /tmp/tmp_h0tqh5n.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp_h0tqh5n.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_h0tqh5n.jl:25\ntest set: Test Failed at /tmp/tmp_h0tqh5n.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_h0tqh5n.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_h0tqh5n.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_h0tqh5n.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp6stiotw_.jl:25\n  Test threw exception\n\
    \  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmp6stiotw_.jl:19\n\
    \   [2] top-level scope at /tmp/tmp6stiotw_.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6stiotw_.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmp6stiotw_.jl:26\n  Test threw exception\n  Expression: candidate(5)\
    \ == [1, 5]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmp6stiotw_.jl:19\n\
    \   [2] top-level scope at /tmp/tmp6stiotw_.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6stiotw_.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmp6stiotw_.jl:27\n  Test threw exception\n  Expression: candidate(12)\
    \ == [1, 3, 5]\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmp6stiotw_.jl:19\n\
    \   [2] top-level scope at /tmp/tmp6stiotw_.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6stiotw_.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmp6stiotw_.jl:28\n  Test threw exception\n  Expression: candidate(1)\
    \ == [1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmp6stiotw_.jl:19\n\
    \   [2] top-level scope at /tmp/tmp6stiotw_.jl:28\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6stiotw_.jl:24\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6stiotw_.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    collatz_seq = [n]\n    while\
    \ n != 1\n        if n % 2 == 0\n            n = n / 2\n        else\n       \
    \     n = 3 * n + 1\n        end\n        push!(collatz_seq, n)\n    end\n   \
    \ return filter(x -> x % 2 != 0, collatz_seq)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp9e8fb0f9.jl:37\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] top-level scope at /tmp/tmp9e8fb0f9.jl:37\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9e8fb0f9.jl:36\ntest set: Test Failed at /tmp/tmp9e8fb0f9.jl:38\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: [5, 1] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp9e8fb0f9.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9e8fb0f9.jl:36\ntest set: Test Failed at /tmp/tmp9e8fb0f9.jl:39\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: [3, 5, 1] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp9e8fb0f9.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9e8fb0f9.jl:36\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9e8fb0f9.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    seq = [n]\n    while n != 1\n        if n % 2 == 0\n            n = n\
    \ / 2\n        else\n            n = 3 * n + 1\n        end\n        push!(seq,\
    \ n)\n    end\n    return filter(x -> x % 2 != 0, seq)\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11,\
    \ 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\
    \t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp303tj00b.jl:34\\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7,\
    \ 11, 13, 17]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp303tj00b.jl:34\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp303tj00b.jl:33\\ntest set: Test Failed at /tmp/tmp303tj00b.jl:35\\\
    n  Expression: candidate(5) == [1, 5]\\n   Evaluated: [5, 1] == [1, 5]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp303tj00b.jl:35\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp303tj00b.jl:33\\ntest set: Test Failed at /tmp/tmp303tj00b.jl:36\\\
    n  Expression: candidate(12) == [1, 3, 5]\\n   Evaluated: [3, 5, 1] == [1, 3,\
    \ 5]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp303tj00b.jl:36\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp303tj00b.jl:33\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    1     3      4\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmplkmteme6.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmplkmteme6.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplkmteme6.jl:25\ntest set: Test Failed at /tmp/tmplkmteme6.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmplkmteme6.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplkmteme6.jl:25\ntest set: Test Failed at /tmp/tmplkmteme6.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmplkmteme6.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplkmteme6.jl:25\ntest set: Test Failed at /tmp/tmplkmteme6.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmplkmteme6.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplkmteme6.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmplkmteme6.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp67olsbkx.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp67olsbkx.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp67olsbkx.jl:25\ntest set: Test Failed at /tmp/tmp67olsbkx.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp67olsbkx.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp67olsbkx.jl:25\ntest set: Test Failed at /tmp/tmp67olsbkx.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp67olsbkx.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp67olsbkx.jl:25\ntest set: Test Failed at /tmp/tmp67olsbkx.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp67olsbkx.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp67olsbkx.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp67olsbkx.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpfa6quonv.jl:26\\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpfa6quonv.jl:26\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpfa6quonv.jl:25\\ntest set: Test Failed at /tmp/tmpfa6quonv.jl:27\\\
    n  Expression: candidate(5) == [1, 5]\\n   Evaluated: Int64[] == [1, 5]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpfa6quonv.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpfa6quonv.jl:25\\ntest set: Test Failed at /tmp/tmpfa6quonv.jl:28\\\
    n  Expression: candidate(12) == [1, 3, 5]\\n   Evaluated: Int64[] == [1, 3, 5]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpfa6quonv.jl:28\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpfa6quonv.jl:25\\ntest set: Test Failed at /tmp/tmpfa6quonv.jl:29\\\
    n  Expression: candidate(1) == [1]\\n   Evaluated: Int64[] == [1]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpfa6quonv.jl:29\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpfa6quonv.jl:25\\nTest Summary: | Fail  Total\\\
    ntest set      |    4      4\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpsbsrm9u4.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpsbsrm9u4.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpsbsrm9u4.jl:25\ntest set: Test Failed at /tmp/tmpsbsrm9u4.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpsbsrm9u4.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpsbsrm9u4.jl:25\ntest set: Test Failed at /tmp/tmpsbsrm9u4.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpsbsrm9u4.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpsbsrm9u4.jl:25\ntest set: Test Failed at /tmp/tmpsbsrm9u4.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpsbsrm9u4.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpsbsrm9u4.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpsbsrm9u4.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpt2qltics.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpt2qltics.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpt2qltics.jl:25\ntest set: Test Failed at /tmp/tmpt2qltics.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpt2qltics.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpt2qltics.jl:25\ntest set: Test Failed at /tmp/tmpt2qltics.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpt2qltics.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpt2qltics.jl:25\ntest set: Test Failed at /tmp/tmpt2qltics.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpt2qltics.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpt2qltics.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpt2qltics.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    collatz = [n]\n    while n != 1\n        if n % 2 == 0\n            n\
    \ = n/2\n        else\n            n = 3*n + 1\n        end\n        push!(collatz,\
    \ n)\n    end\n    return filter(x -> x % 2 != 0, collatz)\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5,\
    \ 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1,\
    \ 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp_1ohdi_q.jl:34\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] top-level scope at /tmp/tmp_1ohdi_q.jl:34\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_1ohdi_q.jl:33\ntest set: Test Failed at /tmp/tmp_1ohdi_q.jl:35\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: [5, 1] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_1ohdi_q.jl:35\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_1ohdi_q.jl:33\ntest set: Test Failed at /tmp/tmp_1ohdi_q.jl:36\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: [3, 5, 1] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp_1ohdi_q.jl:36\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_1ohdi_q.jl:33\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_1ohdi_q.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp72ir934o.jl:26\\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp72ir934o.jl:26\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp72ir934o.jl:25\\ntest set: Test Failed at /tmp/tmp72ir934o.jl:27\\\
    n  Expression: candidate(5) == [1, 5]\\n   Evaluated: Int64[] == [1, 5]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp72ir934o.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp72ir934o.jl:25\\ntest set: Test Failed at /tmp/tmp72ir934o.jl:28\\\
    n  Expression: candidate(12) == [1, 3, 5]\\n   Evaluated: Int64[] == [1, 3, 5]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp72ir934o.jl:28\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp72ir934o.jl:25\\ntest set: Test Failed at /tmp/tmp72ir934o.jl:29\\\
    n  Expression: candidate(1) == [1]\\n   Evaluated: Int64[] == [1]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp72ir934o.jl:29\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp72ir934o.jl:25\\nTest Summary: | Fail  Total\\\
    ntest set      |    4      4\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpwp_38yc9.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpwp_38yc9.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwp_38yc9.jl:25\ntest set: Test Failed at /tmp/tmpwp_38yc9.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpwp_38yc9.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwp_38yc9.jl:25\ntest set: Test Failed at /tmp/tmpwp_38yc9.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpwp_38yc9.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwp_38yc9.jl:25\ntest set: Test Failed at /tmp/tmpwp_38yc9.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpwp_38yc9.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwp_38yc9.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwp_38yc9.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    collatz_seq = [n]\n    while\
    \ n != 1\n        if n % 2 == 0\n            n = n / 2\n        else\n       \
    \     n = 3 * n + 1\n        end\n        push!(collatz_seq, n)\n    end\n   \
    \ return filter(x -> x % 2 != 0, collatz_seq)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmplupcofdz.jl:37\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] top-level scope at /tmp/tmplupcofdz.jl:37\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplupcofdz.jl:36\ntest set: Test Failed at /tmp/tmplupcofdz.jl:38\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: [5, 1] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmplupcofdz.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplupcofdz.jl:36\ntest set: Test Failed at /tmp/tmplupcofdz.jl:39\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: [3, 5, 1] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmplupcofdz.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplupcofdz.jl:36\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmplupcofdz.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpes1s9qk6.jl:25\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] get_odd_collatz(::Int64) at /tmp/tmpes1s9qk6.jl:19\\\
    n   [2] top-level scope at /tmp/tmpes1s9qk6.jl:25\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpes1s9qk6.jl:24\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpes1s9qk6.jl:26\\n  Test threw exception\\n  Expression: candidate(5)\
    \ == [1, 5]\\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] get_odd_collatz(::Int64) at /tmp/tmpes1s9qk6.jl:19\\\
    n   [2] top-level scope at /tmp/tmpes1s9qk6.jl:26\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpes1s9qk6.jl:24\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpes1s9qk6.jl:27\\n  Test threw exception\\n  Expression: candidate(12)\
    \ == [1, 3, 5]\\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] get_odd_collatz(::Int64) at /tmp/tmpes1s9qk6.jl:19\\\
    n   [2] top-level scope at /tmp/tmpes1s9qk6.jl:27\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpes1s9qk6.jl:24\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpes1s9qk6.jl:28\\n  Test threw exception\\n  Expression: candidate(1)\
    \ == [1]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] get_odd_collatz(::Int64) at /tmp/tmpes1s9qk6.jl:19\\\
    n   [2] top-level scope at /tmp/tmpes1s9qk6.jl:28\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpes1s9qk6.jl:24\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpfovln8n5.jl:26\\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpfovln8n5.jl:26\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpfovln8n5.jl:25\\ntest set: Test Failed at /tmp/tmpfovln8n5.jl:27\\\
    n  Expression: candidate(5) == [1, 5]\\n   Evaluated: Int64[] == [1, 5]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpfovln8n5.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpfovln8n5.jl:25\\ntest set: Test Failed at /tmp/tmpfovln8n5.jl:28\\\
    n  Expression: candidate(12) == [1, 3, 5]\\n   Evaluated: Int64[] == [1, 3, 5]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpfovln8n5.jl:28\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpfovln8n5.jl:25\\ntest set: Test Failed at /tmp/tmpfovln8n5.jl:29\\\
    n  Expression: candidate(1) == [1]\\n   Evaluated: Int64[] == [1]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpfovln8n5.jl:29\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpfovln8n5.jl:25\\nTest Summary: | Fail  Total\\\
    ntest set      |    4      4\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmps061wuj7.jl:26\\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmps061wuj7.jl:26\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmps061wuj7.jl:25\\ntest set: Test Failed at /tmp/tmps061wuj7.jl:27\\\
    n  Expression: candidate(5) == [1, 5]\\n   Evaluated: Int64[] == [1, 5]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmps061wuj7.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmps061wuj7.jl:25\\ntest set: Test Failed at /tmp/tmps061wuj7.jl:28\\\
    n  Expression: candidate(12) == [1, 3, 5]\\n   Evaluated: Int64[] == [1, 3, 5]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmps061wuj7.jl:28\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmps061wuj7.jl:25\\ntest set: Test Failed at /tmp/tmps061wuj7.jl:29\\\
    n  Expression: candidate(1) == [1]\\n   Evaluated: Int64[] == [1]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmps061wuj7.jl:29\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmps061wuj7.jl:25\\nTest Summary: | Fail  Total\\\
    ntest set      |    4      4\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    collatz = [n]\n    while n\
    \ != 1\n        if n % 2 == 0\n            n = n / 2\n        else\n         \
    \   n = 3 * n + 1\n        end\n        push!(collatz, n)\n    end\n    return\
    \ filter(x -> x % 2 != 0, collatz)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpplv7pauf.jl:37\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] top-level scope at /tmp/tmpplv7pauf.jl:37\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpplv7pauf.jl:36\ntest set: Test Failed at /tmp/tmpplv7pauf.jl:38\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: [5, 1] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpplv7pauf.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpplv7pauf.jl:36\ntest set: Test Failed at /tmp/tmpplv7pauf.jl:39\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: [3, 5, 1] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpplv7pauf.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpplv7pauf.jl:36\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpplv7pauf.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpk8sweno1.jl:26\\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpk8sweno1.jl:26\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpk8sweno1.jl:25\\ntest set: Test Failed at /tmp/tmpk8sweno1.jl:27\\\
    n  Expression: candidate(5) == [1, 5]\\n   Evaluated: Int64[] == [1, 5]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpk8sweno1.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpk8sweno1.jl:25\\ntest set: Test Failed at /tmp/tmpk8sweno1.jl:28\\\
    n  Expression: candidate(12) == [1, 3, 5]\\n   Evaluated: Int64[] == [1, 3, 5]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpk8sweno1.jl:28\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpk8sweno1.jl:25\\ntest set: Test Failed at /tmp/tmpk8sweno1.jl:29\\\
    n  Expression: candidate(1) == [1]\\n   Evaluated: Int64[] == [1]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpk8sweno1.jl:29\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpk8sweno1.jl:25\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpgl7_d7du.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpgl7_d7du.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgl7_d7du.jl:25\ntest set: Test Failed at /tmp/tmpgl7_d7du.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpgl7_d7du.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgl7_d7du.jl:25\ntest set: Test Failed at /tmp/tmpgl7_d7du.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpgl7_d7du.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgl7_d7du.jl:25\ntest set: Test Failed at /tmp/tmpgl7_d7du.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpgl7_d7du.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgl7_d7du.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgl7_d7du.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpb74ynbwd.jl:25\n  Test threw exception\n\
    \  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpb74ynbwd.jl:19\n\
    \   [2] top-level scope at /tmp/tmpb74ynbwd.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpb74ynbwd.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpb74ynbwd.jl:26\n  Test threw exception\n  Expression: candidate(5)\
    \ == [1, 5]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpb74ynbwd.jl:19\n\
    \   [2] top-level scope at /tmp/tmpb74ynbwd.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpb74ynbwd.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpb74ynbwd.jl:27\n  Test threw exception\n  Expression: candidate(12)\
    \ == [1, 3, 5]\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpb74ynbwd.jl:19\n\
    \   [2] top-level scope at /tmp/tmpb74ynbwd.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpb74ynbwd.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpb74ynbwd.jl:28\n  Test threw exception\n  Expression: candidate(1)\
    \ == [1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpb74ynbwd.jl:19\n\
    \   [2] top-level scope at /tmp/tmpb74ynbwd.jl:28\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpb74ynbwd.jl:24\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpb74ynbwd.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    collatz = [n]\n    while n\
    \ != 1\n        if n % 2 == 0\n            n = n / 2\n        else\n         \
    \   n = 3 * n + 1\n        end\n        push!(collatz, n)\n    end\n    return\
    \ filter(x -> x % 2 != 0, collatz)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpb2ybb9mn.jl:37\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] top-level scope at /tmp/tmpb2ybb9mn.jl:37\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpb2ybb9mn.jl:36\ntest set: Test Failed at /tmp/tmpb2ybb9mn.jl:38\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: [5, 1] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpb2ybb9mn.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpb2ybb9mn.jl:36\ntest set: Test Failed at /tmp/tmpb2ybb9mn.jl:39\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: [3, 5, 1] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpb2ybb9mn.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpb2ybb9mn.jl:36\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpb2ybb9mn.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp8hiamu31.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp8hiamu31.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8hiamu31.jl:25\ntest set: Test Failed at /tmp/tmp8hiamu31.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp8hiamu31.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8hiamu31.jl:25\ntest set: Test Failed at /tmp/tmp8hiamu31.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp8hiamu31.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8hiamu31.jl:25\ntest set: Test Failed at /tmp/tmp8hiamu31.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp8hiamu31.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8hiamu31.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8hiamu31.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpsre0pasw.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpsre0pasw.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpsre0pasw.jl:25\ntest set: Test Failed at /tmp/tmpsre0pasw.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpsre0pasw.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpsre0pasw.jl:25\ntest set: Test Failed at /tmp/tmpsre0pasw.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpsre0pasw.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpsre0pasw.jl:25\ntest set: Test Failed at /tmp/tmpsre0pasw.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpsre0pasw.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpsre0pasw.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpsre0pasw.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpduowes6i.jl:25\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] get_odd_collatz(::Int64) at /tmp/tmpduowes6i.jl:19\\\
    n   [2] top-level scope at /tmp/tmpduowes6i.jl:25\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpduowes6i.jl:24\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpduowes6i.jl:26\\n  Test threw exception\\n  Expression: candidate(5)\
    \ == [1, 5]\\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] get_odd_collatz(::Int64) at /tmp/tmpduowes6i.jl:19\\\
    n   [2] top-level scope at /tmp/tmpduowes6i.jl:26\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpduowes6i.jl:24\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpduowes6i.jl:27\\n  Test threw exception\\n  Expression: candidate(12)\
    \ == [1, 3, 5]\\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] get_odd_collatz(::Int64) at /tmp/tmpduowes6i.jl:19\\\
    n   [2] top-level scope at /tmp/tmpduowes6i.jl:27\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpduowes6i.jl:24\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpduowes6i.jl:28\\n  Test threw exception\\n  Expression: candidate(1)\
    \ == [1]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] get_odd_collatz(::Int64) at /tmp/tmpduowes6i.jl:19\\\
    n   [2] top-level scope at /tmp/tmpduowes6i.jl:28\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpduowes6i.jl:24\\n  \\nTest Summary: | Error\
    \  Total\\ntest set      |     4      4\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    odd_collatz = [n]\n    while\
    \ n != 1\n        if n % 2 == 0\n            n = n / 2\n        else\n       \
    \     n = 3 * n + 1\n        end\n        if n % 2 != 0\n            push!(odd_collatz,\
    \ n)\n        end\n    end\n    return sort(odd_collatz)\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5,\
    \ 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1,\
    \ 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpkb8hdlds.jl:39\\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\\n   Evaluated: [1, 5, 7, 11, 13, 14, 17] == [1, 5,\
    \ 7, 11, 13, 17]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpkb8hdlds.jl:39\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpkb8hdlds.jl:38\\ntest set: Test Failed at /tmp/tmpkb8hdlds.jl:41\\\
    n  Expression: candidate(12) == [1, 3, 5]\\n   Evaluated: [1, 3, 5, 12] == [1,\
    \ 3, 5]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpkb8hdlds.jl:41\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpkb8hdlds.jl:38\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    collatz = [n]\n    while n\
    \ != 1\n        if n % 2 == 0\n            n = n / 2\n        else\n         \
    \   n = 3 * n + 1\n        end\n        push!(collatz, n)\n    end\n    return\
    \ filter(x -> x % 2 != 0, collatz)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpxfsqd_c9.jl:37\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] top-level scope at /tmp/tmpxfsqd_c9.jl:37\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxfsqd_c9.jl:36\ntest set: Test Failed at /tmp/tmpxfsqd_c9.jl:38\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: [5, 1] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpxfsqd_c9.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxfsqd_c9.jl:36\ntest set: Test Failed at /tmp/tmpxfsqd_c9.jl:39\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: [3, 5, 1] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpxfsqd_c9.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxfsqd_c9.jl:36\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxfsqd_c9.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    collatz = [n]\n    while n != 1\n        if n % 2 == 0\n            n\
    \ = n \xF7 2\n        else\n            n = 3n + 1\n        end\n        push!(collatz,\
    \ n)\n    end\n    return filter(x -> x % 2 != 0, collatz)\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5,\
    \ 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1,\
    \ 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpzt8n3wt5.jl:34\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] top-level scope at /tmp/tmpzt8n3wt5.jl:34\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzt8n3wt5.jl:33\ntest set: Test Failed at /tmp/tmpzt8n3wt5.jl:35\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: [5, 1] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpzt8n3wt5.jl:35\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzt8n3wt5.jl:33\ntest set: Test Failed at /tmp/tmpzt8n3wt5.jl:36\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: [3, 5, 1] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpzt8n3wt5.jl:36\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzt8n3wt5.jl:33\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzt8n3wt5.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpk6q90qy1.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpk6q90qy1.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpk6q90qy1.jl:25\ntest set: Test Failed at /tmp/tmpk6q90qy1.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpk6q90qy1.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpk6q90qy1.jl:25\ntest set: Test Failed at /tmp/tmpk6q90qy1.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpk6q90qy1.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpk6q90qy1.jl:25\ntest set: Test Failed at /tmp/tmpk6q90qy1.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpk6q90qy1.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpk6q90qy1.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpk6q90qy1.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    collatz_seq = [n]\n    while n != 1\n        if n % 2 == 0\n         \
    \   n = n / 2\n        else\n            n = 3 * n + 1\n        end\n        push!(collatz_seq,\
    \ n)\n    end\n    return sort(filter(x -> x % 2 != 0, collatz_seq))\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpjkghtiu_.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpjkghtiu_.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpjkghtiu_.jl:25\ntest set: Test Failed at /tmp/tmpjkghtiu_.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpjkghtiu_.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpjkghtiu_.jl:25\ntest set: Test Failed at /tmp/tmpjkghtiu_.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpjkghtiu_.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpjkghtiu_.jl:25\ntest set: Test Failed at /tmp/tmpjkghtiu_.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpjkghtiu_.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpjkghtiu_.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpjkghtiu_.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpydvn8l41.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpydvn8l41.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpydvn8l41.jl:25\ntest set: Test Failed at /tmp/tmpydvn8l41.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpydvn8l41.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpydvn8l41.jl:25\ntest set: Test Failed at /tmp/tmpydvn8l41.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpydvn8l41.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpydvn8l41.jl:25\ntest set: Test Failed at /tmp/tmpydvn8l41.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpydvn8l41.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpydvn8l41.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpydvn8l41.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpogbr8p9o.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpogbr8p9o.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpogbr8p9o.jl:25\ntest set: Test Failed at /tmp/tmpogbr8p9o.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpogbr8p9o.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpogbr8p9o.jl:25\ntest set: Test Failed at /tmp/tmpogbr8p9o.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpogbr8p9o.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpogbr8p9o.jl:25\ntest set: Test Failed at /tmp/tmpogbr8p9o.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpogbr8p9o.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpogbr8p9o.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpogbr8p9o.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpreevo0le.jl:25\n  Test threw exception\n\
    \  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpreevo0le.jl:19\n\
    \   [2] top-level scope at /tmp/tmpreevo0le.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpreevo0le.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpreevo0le.jl:26\n  Test threw exception\n  Expression: candidate(5)\
    \ == [1, 5]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpreevo0le.jl:19\n\
    \   [2] top-level scope at /tmp/tmpreevo0le.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpreevo0le.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpreevo0le.jl:27\n  Test threw exception\n  Expression: candidate(12)\
    \ == [1, 3, 5]\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpreevo0le.jl:19\n\
    \   [2] top-level scope at /tmp/tmpreevo0le.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpreevo0le.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpreevo0le.jl:28\n  Test threw exception\n  Expression: candidate(1)\
    \ == [1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpreevo0le.jl:19\n\
    \   [2] top-level scope at /tmp/tmpreevo0le.jl:28\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpreevo0le.jl:24\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpreevo0le.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpaok3yuk8.jl:26\\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpaok3yuk8.jl:26\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpaok3yuk8.jl:25\\ntest set: Test Failed at /tmp/tmpaok3yuk8.jl:27\\\
    n  Expression: candidate(5) == [1, 5]\\n   Evaluated: Int64[] == [1, 5]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpaok3yuk8.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpaok3yuk8.jl:25\\ntest set: Test Failed at /tmp/tmpaok3yuk8.jl:28\\\
    n  Expression: candidate(12) == [1, 3, 5]\\n   Evaluated: Int64[] == [1, 3, 5]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpaok3yuk8.jl:28\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpaok3yuk8.jl:25\\ntest set: Test Failed at /tmp/tmpaok3yuk8.jl:29\\\
    n  Expression: candidate(1) == [1]\\n   Evaluated: Int64[] == [1]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpaok3yuk8.jl:29\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpaok3yuk8.jl:25\\nTest Summary: | Fail  Total\\\
    ntest set      |    4      4\\n'"
  stderr: "b'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\\nin expression starting at /tmp/tmpaok3yuk8.jl:23\\n'"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp6dx0kqsx.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp6dx0kqsx.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6dx0kqsx.jl:25\ntest set: Test Failed at /tmp/tmp6dx0kqsx.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp6dx0kqsx.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6dx0kqsx.jl:25\ntest set: Test Failed at /tmp/tmp6dx0kqsx.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp6dx0kqsx.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6dx0kqsx.jl:25\ntest set: Test Failed at /tmp/tmp6dx0kqsx.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp6dx0kqsx.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6dx0kqsx.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6dx0kqsx.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpzemcz_nh.jl:26\\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpzemcz_nh.jl:26\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpzemcz_nh.jl:25\\ntest set: Test Failed at /tmp/tmpzemcz_nh.jl:27\\\
    n  Expression: candidate(5) == [1, 5]\\n   Evaluated: Int64[] == [1, 5]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpzemcz_nh.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpzemcz_nh.jl:25\\ntest set: Test Failed at /tmp/tmpzemcz_nh.jl:28\\\
    n  Expression: candidate(12) == [1, 3, 5]\\n   Evaluated: Int64[] == [1, 3, 5]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpzemcz_nh.jl:28\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpzemcz_nh.jl:25\\ntest set: Test Failed at /tmp/tmpzemcz_nh.jl:29\\\
    n  Expression: candidate(1) == [1]\\n   Evaluated: Int64[] == [1]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpzemcz_nh.jl:29\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpzemcz_nh.jl:25\\nTest Summary: | Fail  Total\\\
    ntest set      |    4      4\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpq2bnskho.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpq2bnskho.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpq2bnskho.jl:25\ntest set: Test Failed at /tmp/tmpq2bnskho.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpq2bnskho.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpq2bnskho.jl:25\ntest set: Test Failed at /tmp/tmpq2bnskho.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpq2bnskho.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpq2bnskho.jl:25\ntest set: Test Failed at /tmp/tmpq2bnskho.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpq2bnskho.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpq2bnskho.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpq2bnskho.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp1nrbvmjq.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp1nrbvmjq.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1nrbvmjq.jl:25\ntest set: Test Failed at /tmp/tmp1nrbvmjq.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp1nrbvmjq.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1nrbvmjq.jl:25\ntest set: Test Failed at /tmp/tmp1nrbvmjq.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp1nrbvmjq.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1nrbvmjq.jl:25\ntest set: Test Failed at /tmp/tmp1nrbvmjq.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp1nrbvmjq.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1nrbvmjq.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1nrbvmjq.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpz0h__sbt.jl:25\n  Test threw exception\n\
    \  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpz0h__sbt.jl:19\n\
    \   [2] top-level scope at /tmp/tmpz0h__sbt.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpz0h__sbt.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpz0h__sbt.jl:26\n  Test threw exception\n  Expression: candidate(5)\
    \ == [1, 5]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpz0h__sbt.jl:19\n\
    \   [2] top-level scope at /tmp/tmpz0h__sbt.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpz0h__sbt.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpz0h__sbt.jl:27\n  Test threw exception\n  Expression: candidate(12)\
    \ == [1, 3, 5]\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpz0h__sbt.jl:19\n\
    \   [2] top-level scope at /tmp/tmpz0h__sbt.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpz0h__sbt.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpz0h__sbt.jl:28\n  Test threw exception\n  Expression: candidate(1)\
    \ == [1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpz0h__sbt.jl:19\n\
    \   [2] top-level scope at /tmp/tmpz0h__sbt.jl:28\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpz0h__sbt.jl:24\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpz0h__sbt.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp4ulaup7t.jl:26\\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp4ulaup7t.jl:26\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp4ulaup7t.jl:25\\ntest set: Test Failed at /tmp/tmp4ulaup7t.jl:27\\\
    n  Expression: candidate(5) == [1, 5]\\n   Evaluated: Int64[] == [1, 5]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp4ulaup7t.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp4ulaup7t.jl:25\\ntest set: Test Failed at /tmp/tmp4ulaup7t.jl:28\\\
    n  Expression: candidate(12) == [1, 3, 5]\\n   Evaluated: Int64[] == [1, 3, 5]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp4ulaup7t.jl:28\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp4ulaup7t.jl:25\\ntest set: Test Failed at /tmp/tmp4ulaup7t.jl:29\\\
    n  Expression: candidate(1) == [1]\\n   Evaluated: Int64[] == [1]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp4ulaup7t.jl:29\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp4ulaup7t.jl:25\\nTest Summary: | Fail  Total\\\
    ntest set      |    4      4\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpgo0rodob.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpgo0rodob.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgo0rodob.jl:25\ntest set: Test Failed at /tmp/tmpgo0rodob.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpgo0rodob.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgo0rodob.jl:25\ntest set: Test Failed at /tmp/tmpgo0rodob.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpgo0rodob.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgo0rodob.jl:25\ntest set: Test Failed at /tmp/tmpgo0rodob.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpgo0rodob.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgo0rodob.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgo0rodob.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpds1tbtog.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpds1tbtog.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpds1tbtog.jl:25\ntest set: Test Failed at /tmp/tmpds1tbtog.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpds1tbtog.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpds1tbtog.jl:25\ntest set: Test Failed at /tmp/tmpds1tbtog.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpds1tbtog.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpds1tbtog.jl:25\ntest set: Test Failed at /tmp/tmpds1tbtog.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpds1tbtog.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpds1tbtog.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpds1tbtog.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp6pk1fhlm.jl:26\\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp6pk1fhlm.jl:26\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp6pk1fhlm.jl:25\\ntest set: Test Failed at /tmp/tmp6pk1fhlm.jl:27\\\
    n  Expression: candidate(5) == [1, 5]\\n   Evaluated: Int64[] == [1, 5]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp6pk1fhlm.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp6pk1fhlm.jl:25\\ntest set: Test Failed at /tmp/tmp6pk1fhlm.jl:28\\\
    n  Expression: candidate(12) == [1, 3, 5]\\n   Evaluated: Int64[] == [1, 3, 5]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp6pk1fhlm.jl:28\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp6pk1fhlm.jl:25\\ntest set: Test Failed at /tmp/tmp6pk1fhlm.jl:29\\\
    n  Expression: candidate(1) == [1]\\n   Evaluated: Int64[] == [1]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp6pk1fhlm.jl:29\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp6pk1fhlm.jl:25\\nTest Summary: | Fail  Total\\\
    ntest set      |    4      4\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp7xoog5iq.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp7xoog5iq.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7xoog5iq.jl:25\ntest set: Test Failed at /tmp/tmp7xoog5iq.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp7xoog5iq.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7xoog5iq.jl:25\ntest set: Test Failed at /tmp/tmp7xoog5iq.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp7xoog5iq.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7xoog5iq.jl:25\ntest set: Test Failed at /tmp/tmp7xoog5iq.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp7xoog5iq.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7xoog5iq.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7xoog5iq.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return [1]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpeujpboek.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpeujpboek.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpeujpboek.jl:25\ntest set: Test Failed at /tmp/tmpeujpboek.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: [1] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpeujpboek.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpeujpboek.jl:25\ntest set: Test Failed at /tmp/tmpeujpboek.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: [1] == [1, 3, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpeujpboek.jl:28\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpeujpboek.jl:25\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpeujpboek.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp0lem_mnz.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp0lem_mnz.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0lem_mnz.jl:25\ntest set: Test Failed at /tmp/tmp0lem_mnz.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp0lem_mnz.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0lem_mnz.jl:25\ntest set: Test Failed at /tmp/tmp0lem_mnz.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp0lem_mnz.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0lem_mnz.jl:25\ntest set: Test Failed at /tmp/tmp0lem_mnz.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp0lem_mnz.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0lem_mnz.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0lem_mnz.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    collatz = [n]\n    while n != 1\n        if n % 2 == 0\n            n\
    \ = n \xF7 2\n        else\n            n = 3*n + 1\n        end\n        push!(collatz,\
    \ n)\n    end\n    return sort(filter(x -> x % 2 != 0, collatz))\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1,\
    \ 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) ==\
    \ [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    collatz = [n]\n    while n\
    \ != 1\n        if n % 2 == 0\n            n = n / 2\n        else\n         \
    \   n = 3 * n + 1\n        end\n        push!(collatz, n)\n    end\n    return\
    \ filter(x -> x % 2 != 0, collatz)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpqr3_2tpq.jl:37\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] top-level scope at /tmp/tmpqr3_2tpq.jl:37\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpqr3_2tpq.jl:36\ntest set: Test Failed at /tmp/tmpqr3_2tpq.jl:38\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: [5, 1] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpqr3_2tpq.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpqr3_2tpq.jl:36\ntest set: Test Failed at /tmp/tmpqr3_2tpq.jl:39\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: [3, 5, 1] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpqr3_2tpq.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpqr3_2tpq.jl:36\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqr3_2tpq.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    collatz = [n]\n    while n\
    \ != 1\n        if n % 2 == 0\n            n = n / 2\n        else\n         \
    \   n = 3 * n + 1\n        end\n        push!(collatz, n)\n    end\n    return\
    \ filter(x -> x % 2 != 0, collatz)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpxr6w8pbw.jl:37\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] top-level scope at /tmp/tmpxr6w8pbw.jl:37\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxr6w8pbw.jl:36\ntest set: Test Failed at /tmp/tmpxr6w8pbw.jl:38\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: [5, 1] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpxr6w8pbw.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxr6w8pbw.jl:36\ntest set: Test Failed at /tmp/tmpxr6w8pbw.jl:39\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: [3, 5, 1] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpxr6w8pbw.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxr6w8pbw.jl:36\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxr6w8pbw.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return [1]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpwm1d36x1.jl:26\\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\\n   Evaluated: [1] == [1, 5, 7, 11, 13, 17]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpwm1d36x1.jl:26\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpwm1d36x1.jl:25\\ntest set: Test Failed at /tmp/tmpwm1d36x1.jl:27\\\
    n  Expression: candidate(5) == [1, 5]\\n   Evaluated: [1] == [1, 5]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpwm1d36x1.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpwm1d36x1.jl:25\\ntest set: Test Failed at /tmp/tmpwm1d36x1.jl:28\\\
    n  Expression: candidate(12) == [1, 3, 5]\\n   Evaluated: [1] == [1, 3, 5]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpwm1d36x1.jl:28\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpwm1d36x1.jl:25\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    1     3      4\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    collatz = [n]\n    while n\
    \ != 1\n        if n % 2 == 0\n            n = n / 2\n        else\n         \
    \   n = 3 * n + 1\n        end\n        push!(collatz, n)\n    end\n    return\
    \ filter(x -> x % 2 != 0, collatz)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp6gzchzxm.jl:37\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] top-level scope at /tmp/tmp6gzchzxm.jl:37\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6gzchzxm.jl:36\ntest set: Test Failed at /tmp/tmp6gzchzxm.jl:38\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: [5, 1] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp6gzchzxm.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6gzchzxm.jl:36\ntest set: Test Failed at /tmp/tmp6gzchzxm.jl:39\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: [3, 5, 1] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp6gzchzxm.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6gzchzxm.jl:36\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6gzchzxm.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmplsb5wesc.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmplsb5wesc.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplsb5wesc.jl:25\ntest set: Test Failed at /tmp/tmplsb5wesc.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmplsb5wesc.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplsb5wesc.jl:25\ntest set: Test Failed at /tmp/tmplsb5wesc.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmplsb5wesc.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplsb5wesc.jl:25\ntest set: Test Failed at /tmp/tmplsb5wesc.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmplsb5wesc.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplsb5wesc.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmplsb5wesc.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp9bj00466.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp9bj00466.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9bj00466.jl:25\ntest set: Test Failed at /tmp/tmp9bj00466.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp9bj00466.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9bj00466.jl:25\ntest set: Test Failed at /tmp/tmp9bj00466.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp9bj00466.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9bj00466.jl:25\ntest set: Test Failed at /tmp/tmp9bj00466.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp9bj00466.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9bj00466.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9bj00466.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpies29fx6.jl:26\\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpies29fx6.jl:26\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpies29fx6.jl:25\\ntest set: Test Failed at /tmp/tmpies29fx6.jl:27\\\
    n  Expression: candidate(5) == [1, 5]\\n   Evaluated: Int64[] == [1, 5]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpies29fx6.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpies29fx6.jl:25\\ntest set: Test Failed at /tmp/tmpies29fx6.jl:28\\\
    n  Expression: candidate(12) == [1, 3, 5]\\n   Evaluated: Int64[] == [1, 3, 5]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpies29fx6.jl:28\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpies29fx6.jl:25\\ntest set: Test Failed at /tmp/tmpies29fx6.jl:29\\\
    n  Expression: candidate(1) == [1]\\n   Evaluated: Int64[] == [1]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpies29fx6.jl:29\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpies29fx6.jl:25\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmptscq2t5c.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmptscq2t5c.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmptscq2t5c.jl:25\ntest set: Test Failed at /tmp/tmptscq2t5c.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmptscq2t5c.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmptscq2t5c.jl:25\ntest set: Test Failed at /tmp/tmptscq2t5c.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmptscq2t5c.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmptscq2t5c.jl:25\ntest set: Test Failed at /tmp/tmptscq2t5c.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmptscq2t5c.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmptscq2t5c.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmptscq2t5c.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp8t4sxrxw.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp8t4sxrxw.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8t4sxrxw.jl:25\ntest set: Test Failed at /tmp/tmp8t4sxrxw.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp8t4sxrxw.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8t4sxrxw.jl:25\ntest set: Test Failed at /tmp/tmp8t4sxrxw.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp8t4sxrxw.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8t4sxrxw.jl:25\ntest set: Test Failed at /tmp/tmp8t4sxrxw.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp8t4sxrxw.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8t4sxrxw.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8t4sxrxw.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpc_pjaw7o.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpc_pjaw7o.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpc_pjaw7o.jl:25\ntest set: Test Failed at /tmp/tmpc_pjaw7o.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpc_pjaw7o.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpc_pjaw7o.jl:25\ntest set: Test Failed at /tmp/tmpc_pjaw7o.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpc_pjaw7o.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpc_pjaw7o.jl:25\ntest set: Test Failed at /tmp/tmpc_pjaw7o.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpc_pjaw7o.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpc_pjaw7o.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpc_pjaw7o.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpceu1jlpd.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpceu1jlpd.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpceu1jlpd.jl:25\ntest set: Test Failed at /tmp/tmpceu1jlpd.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpceu1jlpd.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpceu1jlpd.jl:25\ntest set: Test Failed at /tmp/tmpceu1jlpd.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpceu1jlpd.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpceu1jlpd.jl:25\ntest set: Test Failed at /tmp/tmpceu1jlpd.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpceu1jlpd.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpceu1jlpd.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpceu1jlpd.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpiop29593.jl:26\\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpiop29593.jl:26\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpiop29593.jl:25\\ntest set: Test Failed at /tmp/tmpiop29593.jl:27\\\
    n  Expression: candidate(5) == [1, 5]\\n   Evaluated: Int64[] == [1, 5]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpiop29593.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpiop29593.jl:25\\ntest set: Test Failed at /tmp/tmpiop29593.jl:28\\\
    n  Expression: candidate(12) == [1, 3, 5]\\n   Evaluated: Int64[] == [1, 3, 5]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpiop29593.jl:28\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpiop29593.jl:25\\ntest set: Test Failed at /tmp/tmpiop29593.jl:29\\\
    n  Expression: candidate(1) == [1]\\n   Evaluated: Int64[] == [1]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpiop29593.jl:29\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpiop29593.jl:25\\nTest Summary: | Fail  Total\\\
    ntest set      |    4      4\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    odd_numbers = Int64[]\n  \
    \  while n != 1\n        if n % 2 == 1\n            push!(odd_numbers, n)\n  \
    \      end\n        n = collatz(n)\n    end\n    push!(odd_numbers, 1)\n    return\
    \ sort(odd_numbers)\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp2fy7rxd9.jl:36\n  Test threw exception\n\
    \  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\n  UndefVarError: collatz\
    \ not defined\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmp2fy7rxd9.jl:26\n\
    \   [2] top-level scope at /tmp/tmp2fy7rxd9.jl:36\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2fy7rxd9.jl:35\n  \ntest set: Error During\
    \ Test at /tmp/tmp2fy7rxd9.jl:37\n  Test threw exception\n  Expression: candidate(5)\
    \ == [1, 5]\n  UndefVarError: collatz not defined\n  Stacktrace:\n   [1] get_odd_collatz(::Int64)\
    \ at /tmp/tmp2fy7rxd9.jl:26\n   [2] top-level scope at /tmp/tmp2fy7rxd9.jl:37\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2fy7rxd9.jl:35\n  \ntest set: Error During\
    \ Test at /tmp/tmp2fy7rxd9.jl:38\n  Test threw exception\n  Expression: candidate(12)\
    \ == [1, 3, 5]\n  UndefVarError: collatz not defined\n  Stacktrace:\n   [1] get_odd_collatz(::Int64)\
    \ at /tmp/tmp2fy7rxd9.jl:26\n   [2] top-level scope at /tmp/tmp2fy7rxd9.jl:38\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2fy7rxd9.jl:35\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    1      3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2fy7rxd9.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp3mawybot.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp3mawybot.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3mawybot.jl:25\ntest set: Test Failed at /tmp/tmp3mawybot.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp3mawybot.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3mawybot.jl:25\ntest set: Test Failed at /tmp/tmp3mawybot.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp3mawybot.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3mawybot.jl:25\ntest set: Test Failed at /tmp/tmp3mawybot.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp3mawybot.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3mawybot.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3mawybot.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpdf10aun5.jl:25\n  Test threw exception\n\
    \  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpdf10aun5.jl:19\n\
    \   [2] top-level scope at /tmp/tmpdf10aun5.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpdf10aun5.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpdf10aun5.jl:26\n  Test threw exception\n  Expression: candidate(5)\
    \ == [1, 5]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpdf10aun5.jl:19\n\
    \   [2] top-level scope at /tmp/tmpdf10aun5.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpdf10aun5.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpdf10aun5.jl:27\n  Test threw exception\n  Expression: candidate(12)\
    \ == [1, 3, 5]\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpdf10aun5.jl:19\n\
    \   [2] top-level scope at /tmp/tmpdf10aun5.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpdf10aun5.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpdf10aun5.jl:28\n  Test threw exception\n  Expression: candidate(1)\
    \ == [1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpdf10aun5.jl:19\n\
    \   [2] top-level scope at /tmp/tmpdf10aun5.jl:28\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpdf10aun5.jl:24\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpdf10aun5.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpeeobkwt_.jl:26\\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpeeobkwt_.jl:26\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpeeobkwt_.jl:25\\ntest set: Test Failed at /tmp/tmpeeobkwt_.jl:27\\\
    n  Expression: candidate(5) == [1, 5]\\n   Evaluated: Int64[] == [1, 5]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpeeobkwt_.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpeeobkwt_.jl:25\\ntest set: Test Failed at /tmp/tmpeeobkwt_.jl:28\\\
    n  Expression: candidate(12) == [1, 3, 5]\\n   Evaluated: Int64[] == [1, 3, 5]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpeeobkwt_.jl:28\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpeeobkwt_.jl:25\\ntest set: Test Failed at /tmp/tmpeeobkwt_.jl:29\\\
    n  Expression: candidate(1) == [1]\\n   Evaluated: Int64[] == [1]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpeeobkwt_.jl:29\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpeeobkwt_.jl:25\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpo3uizukf.jl:25\n  Test threw exception\n\
    \  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpo3uizukf.jl:19\n\
    \   [2] top-level scope at /tmp/tmpo3uizukf.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpo3uizukf.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpo3uizukf.jl:26\n  Test threw exception\n  Expression: candidate(5)\
    \ == [1, 5]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpo3uizukf.jl:19\n\
    \   [2] top-level scope at /tmp/tmpo3uizukf.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpo3uizukf.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpo3uizukf.jl:27\n  Test threw exception\n  Expression: candidate(12)\
    \ == [1, 3, 5]\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpo3uizukf.jl:19\n\
    \   [2] top-level scope at /tmp/tmpo3uizukf.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpo3uizukf.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpo3uizukf.jl:28\n  Test threw exception\n  Expression: candidate(1)\
    \ == [1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpo3uizukf.jl:19\n\
    \   [2] top-level scope at /tmp/tmpo3uizukf.jl:28\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpo3uizukf.jl:24\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpo3uizukf.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp3k6h2i28.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp3k6h2i28.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3k6h2i28.jl:25\ntest set: Test Failed at /tmp/tmp3k6h2i28.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp3k6h2i28.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3k6h2i28.jl:25\ntest set: Test Failed at /tmp/tmp3k6h2i28.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp3k6h2i28.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3k6h2i28.jl:25\ntest set: Test Failed at /tmp/tmp3k6h2i28.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp3k6h2i28.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3k6h2i28.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3k6h2i28.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpim199pm5.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpim199pm5.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpim199pm5.jl:25\ntest set: Test Failed at /tmp/tmpim199pm5.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpim199pm5.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpim199pm5.jl:25\ntest set: Test Failed at /tmp/tmpim199pm5.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpim199pm5.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpim199pm5.jl:25\ntest set: Test Failed at /tmp/tmpim199pm5.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpim199pm5.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpim199pm5.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpim199pm5.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    collatz = [n]\n    while n\
    \ != 1\n        if n % 2 == 0\n            n = n / 2\n        else\n         \
    \   n = 3 * n + 1\n        end\n        push!(collatz, n)\n    end\n    return\
    \ collatz[collatz .% 2 .!= 0]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpm2d00w15.jl:37\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] top-level scope at /tmp/tmpm2d00w15.jl:37\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpm2d00w15.jl:36\ntest set: Test Failed at /tmp/tmpm2d00w15.jl:38\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: [5, 1] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpm2d00w15.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpm2d00w15.jl:36\ntest set: Test Failed at /tmp/tmpm2d00w15.jl:39\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: [3, 5, 1] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpm2d00w15.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpm2d00w15.jl:36\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpm2d00w15.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpwe28h0ix.jl:25\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] get_odd_collatz(::Int64) at /tmp/tmpwe28h0ix.jl:19\\\
    n   [2] top-level scope at /tmp/tmpwe28h0ix.jl:25\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpwe28h0ix.jl:24\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpwe28h0ix.jl:26\\n  Test threw exception\\n  Expression: candidate(5)\
    \ == [1, 5]\\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] get_odd_collatz(::Int64) at /tmp/tmpwe28h0ix.jl:19\\\
    n   [2] top-level scope at /tmp/tmpwe28h0ix.jl:26\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpwe28h0ix.jl:24\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpwe28h0ix.jl:27\\n  Test threw exception\\n  Expression: candidate(12)\
    \ == [1, 3, 5]\\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] get_odd_collatz(::Int64) at /tmp/tmpwe28h0ix.jl:19\\\
    n   [2] top-level scope at /tmp/tmpwe28h0ix.jl:27\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpwe28h0ix.jl:24\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpwe28h0ix.jl:28\\n  Test threw exception\\n  Expression: candidate(1)\
    \ == [1]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] get_odd_collatz(::Int64) at /tmp/tmpwe28h0ix.jl:19\\\
    n   [2] top-level scope at /tmp/tmpwe28h0ix.jl:28\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpwe28h0ix.jl:24\\n  \\nTest Summary: | Error\
    \  Total\\ntest set      |     4      4\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    collatz_seq = [n]\n    while n != 1\n        if n % 2 == 0\n         \
    \   n = n / 2\n        else\n            n = 3 * n + 1\n        end\n        push!(collatz_seq,\
    \ n)\n    end\n    odd_collatz = []\n    for i in collatz_seq\n        if i %\
    \ 2 != 0\n            push!(odd_collatz, i)\n        end\n    end\n    return\
    \ odd_collatz\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpmydouw0f.jl:40\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] top-level scope at /tmp/tmpmydouw0f.jl:40\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmydouw0f.jl:39\ntest set: Test Failed at /tmp/tmpmydouw0f.jl:41\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: [5, 1] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpmydouw0f.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmydouw0f.jl:39\ntest set: Test Failed at /tmp/tmpmydouw0f.jl:42\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: [3, 5, 1] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpmydouw0f.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmydouw0f.jl:39\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmydouw0f.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpxo1gfdyf.jl:26\\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpxo1gfdyf.jl:26\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpxo1gfdyf.jl:25\\ntest set: Test Failed at /tmp/tmpxo1gfdyf.jl:27\\\
    n  Expression: candidate(5) == [1, 5]\\n   Evaluated: Int64[] == [1, 5]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpxo1gfdyf.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpxo1gfdyf.jl:25\\ntest set: Test Failed at /tmp/tmpxo1gfdyf.jl:28\\\
    n  Expression: candidate(12) == [1, 3, 5]\\n   Evaluated: Int64[] == [1, 3, 5]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpxo1gfdyf.jl:28\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpxo1gfdyf.jl:25\\ntest set: Test Failed at /tmp/tmpxo1gfdyf.jl:29\\\
    n  Expression: candidate(1) == [1]\\n   Evaluated: Int64[] == [1]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpxo1gfdyf.jl:29\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpxo1gfdyf.jl:25\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpfv72z4mz.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpfv72z4mz.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfv72z4mz.jl:25\ntest set: Test Failed at /tmp/tmpfv72z4mz.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpfv72z4mz.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfv72z4mz.jl:25\ntest set: Test Failed at /tmp/tmpfv72z4mz.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpfv72z4mz.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfv72z4mz.jl:25\ntest set: Test Failed at /tmp/tmpfv72z4mz.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpfv72z4mz.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfv72z4mz.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpfv72z4mz.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    collatz = [n]\n    while n\
    \ != 1\n        if n % 2 == 0\n            n = n/2\n        else\n           \
    \ n = 3*n + 1\n        end\n        push!(collatz, n)\n    end\n    return sort(filter(x\
    \ -> x % 2 != 0, collatz))\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpuambnc43.jl:26\\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpuambnc43.jl:26\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpuambnc43.jl:25\\ntest set: Test Failed at /tmp/tmpuambnc43.jl:27\\\
    n  Expression: candidate(5) == [1, 5]\\n   Evaluated: Int64[] == [1, 5]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpuambnc43.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpuambnc43.jl:25\\ntest set: Test Failed at /tmp/tmpuambnc43.jl:28\\\
    n  Expression: candidate(12) == [1, 3, 5]\\n   Evaluated: Int64[] == [1, 3, 5]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpuambnc43.jl:28\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpuambnc43.jl:25\\ntest set: Test Failed at /tmp/tmpuambnc43.jl:29\\\
    n  Expression: candidate(1) == [1]\\n   Evaluated: Int64[] == [1]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpuambnc43.jl:29\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpuambnc43.jl:25\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpot0l04q3.jl:25\n  Test threw exception\n\
    \  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpot0l04q3.jl:19\n\
    \   [2] top-level scope at /tmp/tmpot0l04q3.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpot0l04q3.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpot0l04q3.jl:26\n  Test threw exception\n  Expression: candidate(5)\
    \ == [1, 5]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpot0l04q3.jl:19\n\
    \   [2] top-level scope at /tmp/tmpot0l04q3.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpot0l04q3.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpot0l04q3.jl:27\n  Test threw exception\n  Expression: candidate(12)\
    \ == [1, 3, 5]\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpot0l04q3.jl:19\n\
    \   [2] top-level scope at /tmp/tmpot0l04q3.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpot0l04q3.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpot0l04q3.jl:28\n  Test threw exception\n  Expression: candidate(1)\
    \ == [1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpot0l04q3.jl:19\n\
    \   [2] top-level scope at /tmp/tmpot0l04q3.jl:28\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpot0l04q3.jl:24\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpot0l04q3.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpabeco_4q.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpabeco_4q.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpabeco_4q.jl:25\ntest set: Test Failed at /tmp/tmpabeco_4q.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpabeco_4q.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpabeco_4q.jl:25\ntest set: Test Failed at /tmp/tmpabeco_4q.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpabeco_4q.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpabeco_4q.jl:25\ntest set: Test Failed at /tmp/tmpabeco_4q.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpabeco_4q.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpabeco_4q.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpabeco_4q.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmph3hr3075.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmph3hr3075.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmph3hr3075.jl:25\ntest set: Test Failed at /tmp/tmph3hr3075.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmph3hr3075.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmph3hr3075.jl:25\ntest set: Test Failed at /tmp/tmph3hr3075.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmph3hr3075.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmph3hr3075.jl:25\ntest set: Test Failed at /tmp/tmph3hr3075.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmph3hr3075.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmph3hr3075.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmph3hr3075.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpmuhnegkb.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpmuhnegkb.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmuhnegkb.jl:25\ntest set: Test Failed at /tmp/tmpmuhnegkb.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpmuhnegkb.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmuhnegkb.jl:25\ntest set: Test Failed at /tmp/tmpmuhnegkb.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpmuhnegkb.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmuhnegkb.jl:25\ntest set: Test Failed at /tmp/tmpmuhnegkb.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpmuhnegkb.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmuhnegkb.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmuhnegkb.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpf1bv3x1y.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpf1bv3x1y.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpf1bv3x1y.jl:25\ntest set: Test Failed at /tmp/tmpf1bv3x1y.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpf1bv3x1y.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpf1bv3x1y.jl:25\ntest set: Test Failed at /tmp/tmpf1bv3x1y.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpf1bv3x1y.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpf1bv3x1y.jl:25\ntest set: Test Failed at /tmp/tmpf1bv3x1y.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpf1bv3x1y.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpf1bv3x1y.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpf1bv3x1y.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp24shra1d.jl:26\\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp24shra1d.jl:26\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp24shra1d.jl:25\\ntest set: Test Failed at /tmp/tmp24shra1d.jl:27\\\
    n  Expression: candidate(5) == [1, 5]\\n   Evaluated: Int64[] == [1, 5]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp24shra1d.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp24shra1d.jl:25\\ntest set: Test Failed at /tmp/tmp24shra1d.jl:28\\\
    n  Expression: candidate(12) == [1, 3, 5]\\n   Evaluated: Int64[] == [1, 3, 5]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp24shra1d.jl:28\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp24shra1d.jl:25\\ntest set: Test Failed at /tmp/tmp24shra1d.jl:29\\\
    n  Expression: candidate(1) == [1]\\n   Evaluated: Int64[] == [1]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp24shra1d.jl:29\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp24shra1d.jl:25\\nTest Summary: | Fail  Total\\\
    ntest set      |    4      4\\n'"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp2_u6sm7t.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp2_u6sm7t.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2_u6sm7t.jl:25\ntest set: Test Failed at /tmp/tmp2_u6sm7t.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp2_u6sm7t.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2_u6sm7t.jl:25\ntest set: Test Failed at /tmp/tmp2_u6sm7t.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp2_u6sm7t.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2_u6sm7t.jl:25\ntest set: Test Failed at /tmp/tmp2_u6sm7t.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp2_u6sm7t.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2_u6sm7t.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2_u6sm7t.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp6xvwickl.jl:25\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] get_odd_collatz(::Int64) at /tmp/tmp6xvwickl.jl:19\\\
    n   [2] top-level scope at /tmp/tmp6xvwickl.jl:25\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp6xvwickl.jl:24\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp6xvwickl.jl:26\\n  Test threw exception\\n  Expression: candidate(5)\
    \ == [1, 5]\\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] get_odd_collatz(::Int64) at /tmp/tmp6xvwickl.jl:19\\\
    n   [2] top-level scope at /tmp/tmp6xvwickl.jl:26\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp6xvwickl.jl:24\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp6xvwickl.jl:27\\n  Test threw exception\\n  Expression: candidate(12)\
    \ == [1, 3, 5]\\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] get_odd_collatz(::Int64) at /tmp/tmp6xvwickl.jl:19\\\
    n   [2] top-level scope at /tmp/tmp6xvwickl.jl:27\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp6xvwickl.jl:24\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp6xvwickl.jl:28\\n  Test threw exception\\n  Expression: candidate(1)\
    \ == [1]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] get_odd_collatz(::Int64) at /tmp/tmp6xvwickl.jl:19\\\
    n   [2] top-level scope at /tmp/tmp6xvwickl.jl:28\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp6xvwickl.jl:24\\n  \\nTest Summary: | Error\
    \  Total\\ntest set      |     4      4\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    collatz = [n]\n    while n\
    \ != 1\n        if n % 2 == 0\n            n = n / 2\n        else\n         \
    \   n = 3 * n + 1\n        end\n        push!(collatz, n)\n    end\n    return\
    \ filter(x -> x % 2 != 0, collatz)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: "b'test set: Test Failed at /tmp/tmpsmn5y01a.jl:37\\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7,\
    \ 11, 13, 17]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpsmn5y01a.jl:37\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpsmn5y01a.jl:36\\ntest set: Test Failed at /tmp/tmpsmn5y01a.jl:38\\\
    n  Expression: candidate(5) == [1, 5]\\n   Evaluated: [5, 1] == [1, 5]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpsmn5y01a.jl:38\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpsmn5y01a.jl:36\\ntest set: Test Failed at /tmp/tmpsmn5y01a.jl:39\\\
    n  Expression: candidate(12) == [1, 3, 5]\\n   Evaluated: [3, 5, 1] == [1, 3,\
    \ 5]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpsmn5y01a.jl:39\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpsmn5y01a.jl:36\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    1     3      4\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpbv4wjetf.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpbv4wjetf.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbv4wjetf.jl:25\ntest set: Test Failed at /tmp/tmpbv4wjetf.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpbv4wjetf.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbv4wjetf.jl:25\ntest set: Test Failed at /tmp/tmpbv4wjetf.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpbv4wjetf.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbv4wjetf.jl:25\ntest set: Test Failed at /tmp/tmpbv4wjetf.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpbv4wjetf.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbv4wjetf.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbv4wjetf.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpiyw_ct7r.jl:25\n  Test threw exception\n\
    \  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpiyw_ct7r.jl:19\n\
    \   [2] top-level scope at /tmp/tmpiyw_ct7r.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpiyw_ct7r.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpiyw_ct7r.jl:26\n  Test threw exception\n  Expression: candidate(5)\
    \ == [1, 5]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpiyw_ct7r.jl:19\n\
    \   [2] top-level scope at /tmp/tmpiyw_ct7r.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpiyw_ct7r.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpiyw_ct7r.jl:27\n  Test threw exception\n  Expression: candidate(12)\
    \ == [1, 3, 5]\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpiyw_ct7r.jl:19\n\
    \   [2] top-level scope at /tmp/tmpiyw_ct7r.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpiyw_ct7r.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpiyw_ct7r.jl:28\n  Test threw exception\n  Expression: candidate(1)\
    \ == [1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpiyw_ct7r.jl:19\n\
    \   [2] top-level scope at /tmp/tmpiyw_ct7r.jl:28\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpiyw_ct7r.jl:24\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpiyw_ct7r.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    odd_collatz = [n]\n    while\
    \ n != 1\n        if n % 2 == 0\n            n = n / 2\n        else\n       \
    \     n = 3 * n + 1\n        end\n        if n % 2 != 0\n            push!(odd_collatz,\
    \ n)\n        end\n    end\n    return sort(odd_collatz)\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5,\
    \ 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1,\
    \ 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp7v3ay2kf.jl:39\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1, 5, 7, 11, 13, 14, 17] == [1, 5,\
    \ 7, 11, 13, 17]\nStacktrace:\n [1] top-level scope at /tmp/tmp7v3ay2kf.jl:39\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7v3ay2kf.jl:38\ntest set: Test Failed at /tmp/tmp7v3ay2kf.jl:41\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: [1, 3, 5, 12] == [1,\
    \ 3, 5]\nStacktrace:\n [1] top-level scope at /tmp/tmp7v3ay2kf.jl:41\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7v3ay2kf.jl:38\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     2      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7v3ay2kf.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpq8x_m0r_.jl:25\n  Test threw exception\n\
    \  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpq8x_m0r_.jl:19\n\
    \   [2] top-level scope at /tmp/tmpq8x_m0r_.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq8x_m0r_.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpq8x_m0r_.jl:26\n  Test threw exception\n  Expression: candidate(5)\
    \ == [1, 5]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpq8x_m0r_.jl:19\n\
    \   [2] top-level scope at /tmp/tmpq8x_m0r_.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq8x_m0r_.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpq8x_m0r_.jl:27\n  Test threw exception\n  Expression: candidate(12)\
    \ == [1, 3, 5]\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpq8x_m0r_.jl:19\n\
    \   [2] top-level scope at /tmp/tmpq8x_m0r_.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq8x_m0r_.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpq8x_m0r_.jl:28\n  Test threw exception\n  Expression: candidate(1)\
    \ == [1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpq8x_m0r_.jl:19\n\
    \   [2] top-level scope at /tmp/tmpq8x_m0r_.jl:28\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq8x_m0r_.jl:24\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpq8x_m0r_.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpeiedl1qy.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpeiedl1qy.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpeiedl1qy.jl:25\ntest set: Test Failed at /tmp/tmpeiedl1qy.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpeiedl1qy.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpeiedl1qy.jl:25\ntest set: Test Failed at /tmp/tmpeiedl1qy.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpeiedl1qy.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpeiedl1qy.jl:25\ntest set: Test Failed at /tmp/tmpeiedl1qy.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpeiedl1qy.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpeiedl1qy.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpeiedl1qy.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpx3c1s5uz.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpx3c1s5uz.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpx3c1s5uz.jl:25\ntest set: Test Failed at /tmp/tmpx3c1s5uz.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpx3c1s5uz.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpx3c1s5uz.jl:25\ntest set: Test Failed at /tmp/tmpx3c1s5uz.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpx3c1s5uz.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpx3c1s5uz.jl:25\ntest set: Test Failed at /tmp/tmpx3c1s5uz.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpx3c1s5uz.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpx3c1s5uz.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpx3c1s5uz.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp7jflmi2j.jl:26\\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp7jflmi2j.jl:26\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp7jflmi2j.jl:25\\ntest set: Test Failed at /tmp/tmp7jflmi2j.jl:27\\\
    n  Expression: candidate(5) == [1, 5]\\n   Evaluated: Int64[] == [1, 5]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp7jflmi2j.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp7jflmi2j.jl:25\\ntest set: Test Failed at /tmp/tmp7jflmi2j.jl:28\\\
    n  Expression: candidate(12) == [1, 3, 5]\\n   Evaluated: Int64[] == [1, 3, 5]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp7jflmi2j.jl:28\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp7jflmi2j.jl:25\\ntest set: Test Failed at /tmp/tmp7jflmi2j.jl:29\\\
    n  Expression: candidate(1) == [1]\\n   Evaluated: Int64[] == [1]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp7jflmi2j.jl:29\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp7jflmi2j.jl:25\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp8v16z8_p.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp8v16z8_p.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8v16z8_p.jl:25\ntest set: Test Failed at /tmp/tmp8v16z8_p.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp8v16z8_p.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8v16z8_p.jl:25\ntest set: Test Failed at /tmp/tmp8v16z8_p.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp8v16z8_p.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8v16z8_p.jl:25\ntest set: Test Failed at /tmp/tmp8v16z8_p.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp8v16z8_p.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8v16z8_p.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8v16z8_p.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpzxb3sp_4.jl:26\\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpzxb3sp_4.jl:26\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpzxb3sp_4.jl:25\\ntest set: Test Failed at /tmp/tmpzxb3sp_4.jl:27\\\
    n  Expression: candidate(5) == [1, 5]\\n   Evaluated: Int64[] == [1, 5]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpzxb3sp_4.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpzxb3sp_4.jl:25\\ntest set: Test Failed at /tmp/tmpzxb3sp_4.jl:28\\\
    n  Expression: candidate(12) == [1, 3, 5]\\n   Evaluated: Int64[] == [1, 3, 5]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpzxb3sp_4.jl:28\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpzxb3sp_4.jl:25\\ntest set: Test Failed at /tmp/tmpzxb3sp_4.jl:29\\\
    n  Expression: candidate(1) == [1]\\n   Evaluated: Int64[] == [1]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpzxb3sp_4.jl:29\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpzxb3sp_4.jl:25\\nTest Summary: | Fail  Total\\\
    ntest set      |    4      4\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    collatz = [n]\n    while n != 1\n        if n % 2 == 0\n            n\
    \ = n / 2\n        else\n            n = 3 * n + 1\n        end\n        push!(collatz,\
    \ n)\n    end\n    return filter(x -> x % 2 != 0, collatz)\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5,\
    \ 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1,\
    \ 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp5tqpmgk7.jl:34\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] top-level scope at /tmp/tmp5tqpmgk7.jl:34\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5tqpmgk7.jl:33\ntest set: Test Failed at /tmp/tmp5tqpmgk7.jl:35\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: [5, 1] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp5tqpmgk7.jl:35\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5tqpmgk7.jl:33\ntest set: Test Failed at /tmp/tmp5tqpmgk7.jl:36\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: [3, 5, 1] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp5tqpmgk7.jl:36\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5tqpmgk7.jl:33\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5tqpmgk7.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp_wnsv8de.jl:26\\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp_wnsv8de.jl:26\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp_wnsv8de.jl:25\\ntest set: Test Failed at /tmp/tmp_wnsv8de.jl:27\\\
    n  Expression: candidate(5) == [1, 5]\\n   Evaluated: Int64[] == [1, 5]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp_wnsv8de.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp_wnsv8de.jl:25\\ntest set: Test Failed at /tmp/tmp_wnsv8de.jl:28\\\
    n  Expression: candidate(12) == [1, 3, 5]\\n   Evaluated: Int64[] == [1, 3, 5]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp_wnsv8de.jl:28\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp_wnsv8de.jl:25\\ntest set: Test Failed at /tmp/tmp_wnsv8de.jl:29\\\
    n  Expression: candidate(1) == [1]\\n   Evaluated: Int64[] == [1]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp_wnsv8de.jl:29\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp_wnsv8de.jl:25\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpyq8ui9nx.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpyq8ui9nx.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpyq8ui9nx.jl:25\ntest set: Test Failed at /tmp/tmpyq8ui9nx.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpyq8ui9nx.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpyq8ui9nx.jl:25\ntest set: Test Failed at /tmp/tmpyq8ui9nx.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpyq8ui9nx.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpyq8ui9nx.jl:25\ntest set: Test Failed at /tmp/tmpyq8ui9nx.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpyq8ui9nx.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpyq8ui9nx.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpyq8ui9nx.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    odd_collatz = [n]\n    while\
    \ n != 1\n        if n % 2 == 0\n            n = n / 2\n        else\n       \
    \     n = 3 * n + 1\n        end\n        if n % 2 != 0\n            push!(odd_collatz,\
    \ n)\n        end\n    end\n    return sort(odd_collatz)\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5,\
    \ 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1,\
    \ 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpfofwzd50.jl:39\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1, 5, 7, 11, 13, 14, 17] == [1, 5,\
    \ 7, 11, 13, 17]\nStacktrace:\n [1] top-level scope at /tmp/tmpfofwzd50.jl:39\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfofwzd50.jl:38\ntest set: Test Failed at /tmp/tmpfofwzd50.jl:41\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: [1, 3, 5, 12] == [1,\
    \ 3, 5]\nStacktrace:\n [1] top-level scope at /tmp/tmpfofwzd50.jl:41\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfofwzd50.jl:38\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     2      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpfofwzd50.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp9hu85dti.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp9hu85dti.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9hu85dti.jl:25\ntest set: Test Failed at /tmp/tmp9hu85dti.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp9hu85dti.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9hu85dti.jl:25\ntest set: Test Failed at /tmp/tmp9hu85dti.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp9hu85dti.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9hu85dti.jl:25\ntest set: Test Failed at /tmp/tmp9hu85dti.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp9hu85dti.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9hu85dti.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9hu85dti.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpyi6siblv.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpyi6siblv.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpyi6siblv.jl:25\ntest set: Test Failed at /tmp/tmpyi6siblv.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpyi6siblv.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpyi6siblv.jl:25\ntest set: Test Failed at /tmp/tmpyi6siblv.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpyi6siblv.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpyi6siblv.jl:25\ntest set: Test Failed at /tmp/tmpyi6siblv.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpyi6siblv.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpyi6siblv.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpyi6siblv.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp7pig6vg7.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp7pig6vg7.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7pig6vg7.jl:25\ntest set: Test Failed at /tmp/tmp7pig6vg7.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp7pig6vg7.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7pig6vg7.jl:25\ntest set: Test Failed at /tmp/tmp7pig6vg7.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp7pig6vg7.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7pig6vg7.jl:25\ntest set: Test Failed at /tmp/tmp7pig6vg7.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp7pig6vg7.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7pig6vg7.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7pig6vg7.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpl494ia_z.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpl494ia_z.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpl494ia_z.jl:25\ntest set: Test Failed at /tmp/tmpl494ia_z.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpl494ia_z.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpl494ia_z.jl:25\ntest set: Test Failed at /tmp/tmpl494ia_z.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpl494ia_z.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpl494ia_z.jl:25\ntest set: Test Failed at /tmp/tmpl494ia_z.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpl494ia_z.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpl494ia_z.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpl494ia_z.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpdrlpkd8q.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpdrlpkd8q.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdrlpkd8q.jl:25\ntest set: Test Failed at /tmp/tmpdrlpkd8q.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpdrlpkd8q.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdrlpkd8q.jl:25\ntest set: Test Failed at /tmp/tmpdrlpkd8q.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpdrlpkd8q.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdrlpkd8q.jl:25\ntest set: Test Failed at /tmp/tmpdrlpkd8q.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpdrlpkd8q.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdrlpkd8q.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpdrlpkd8q.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp3sk_into.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp3sk_into.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3sk_into.jl:25\ntest set: Test Failed at /tmp/tmp3sk_into.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp3sk_into.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3sk_into.jl:25\ntest set: Test Failed at /tmp/tmp3sk_into.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp3sk_into.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3sk_into.jl:25\ntest set: Test Failed at /tmp/tmp3sk_into.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp3sk_into.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3sk_into.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3sk_into.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpg6oj_mad.jl:26\\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpg6oj_mad.jl:26\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpg6oj_mad.jl:25\\ntest set: Test Failed at /tmp/tmpg6oj_mad.jl:27\\\
    n  Expression: candidate(5) == [1, 5]\\n   Evaluated: Int64[] == [1, 5]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpg6oj_mad.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpg6oj_mad.jl:25\\ntest set: Test Failed at /tmp/tmpg6oj_mad.jl:28\\\
    n  Expression: candidate(12) == [1, 3, 5]\\n   Evaluated: Int64[] == [1, 3, 5]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpg6oj_mad.jl:28\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpg6oj_mad.jl:25\\ntest set: Test Failed at /tmp/tmpg6oj_mad.jl:29\\\
    n  Expression: candidate(1) == [1]\\n   Evaluated: Int64[] == [1]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpg6oj_mad.jl:29\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpg6oj_mad.jl:25\\nTest Summary: | Fail  Total\\\
    ntest set      |    4      4\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp7xsbjwh6.jl:25\n  Test threw exception\n\
    \  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmp7xsbjwh6.jl:19\n\
    \   [2] top-level scope at /tmp/tmp7xsbjwh6.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7xsbjwh6.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmp7xsbjwh6.jl:26\n  Test threw exception\n  Expression: candidate(5)\
    \ == [1, 5]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmp7xsbjwh6.jl:19\n\
    \   [2] top-level scope at /tmp/tmp7xsbjwh6.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7xsbjwh6.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmp7xsbjwh6.jl:27\n  Test threw exception\n  Expression: candidate(12)\
    \ == [1, 3, 5]\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmp7xsbjwh6.jl:19\n\
    \   [2] top-level scope at /tmp/tmp7xsbjwh6.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7xsbjwh6.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmp7xsbjwh6.jl:28\n  Test threw exception\n  Expression: candidate(1)\
    \ == [1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmp7xsbjwh6.jl:19\n\
    \   [2] top-level scope at /tmp/tmp7xsbjwh6.jl:28\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7xsbjwh6.jl:24\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7xsbjwh6.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpj5ipoaj7.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpj5ipoaj7.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpj5ipoaj7.jl:25\ntest set: Test Failed at /tmp/tmpj5ipoaj7.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpj5ipoaj7.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpj5ipoaj7.jl:25\ntest set: Test Failed at /tmp/tmpj5ipoaj7.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpj5ipoaj7.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpj5ipoaj7.jl:25\ntest set: Test Failed at /tmp/tmpj5ipoaj7.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpj5ipoaj7.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpj5ipoaj7.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpj5ipoaj7.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmphs90rh3r.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmphs90rh3r.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphs90rh3r.jl:25\ntest set: Test Failed at /tmp/tmphs90rh3r.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmphs90rh3r.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphs90rh3r.jl:25\ntest set: Test Failed at /tmp/tmphs90rh3r.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmphs90rh3r.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphs90rh3r.jl:25\ntest set: Test Failed at /tmp/tmphs90rh3r.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmphs90rh3r.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphs90rh3r.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphs90rh3r.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    v = [n]\n    while n != 1\n\
    \        if n % 2 == 0\n            n = n / 2\n        else\n            n = 3\
    \ * n + 1\n        end\n        push!(v, n)\n    end\n    return filter(x -> x\
    \ % 2 != 0, v)\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpqrij2z0w.jl:37\\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7,\
    \ 11, 13, 17]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpqrij2z0w.jl:37\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpqrij2z0w.jl:36\\ntest set: Test Failed at /tmp/tmpqrij2z0w.jl:38\\\
    n  Expression: candidate(5) == [1, 5]\\n   Evaluated: [5, 1] == [1, 5]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpqrij2z0w.jl:38\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpqrij2z0w.jl:36\\ntest set: Test Failed at /tmp/tmpqrij2z0w.jl:39\\\
    n  Expression: candidate(12) == [1, 3, 5]\\n   Evaluated: [3, 5, 1] == [1, 3,\
    \ 5]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpqrij2z0w.jl:39\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpqrij2z0w.jl:36\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    1     3      4\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpwcysauqc.jl:25\n  Test threw exception\n\
    \  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpwcysauqc.jl:19\n\
    \   [2] top-level scope at /tmp/tmpwcysauqc.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwcysauqc.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpwcysauqc.jl:26\n  Test threw exception\n  Expression: candidate(5)\
    \ == [1, 5]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpwcysauqc.jl:19\n\
    \   [2] top-level scope at /tmp/tmpwcysauqc.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwcysauqc.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpwcysauqc.jl:27\n  Test threw exception\n  Expression: candidate(12)\
    \ == [1, 3, 5]\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpwcysauqc.jl:19\n\
    \   [2] top-level scope at /tmp/tmpwcysauqc.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwcysauqc.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpwcysauqc.jl:28\n  Test threw exception\n  Expression: candidate(1)\
    \ == [1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpwcysauqc.jl:19\n\
    \   [2] top-level scope at /tmp/tmpwcysauqc.jl:28\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwcysauqc.jl:24\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwcysauqc.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpi2fso7yr.jl:26\\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpi2fso7yr.jl:26\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpi2fso7yr.jl:25\\ntest set: Test Failed at /tmp/tmpi2fso7yr.jl:27\\\
    n  Expression: candidate(5) == [1, 5]\\n   Evaluated: Int64[] == [1, 5]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpi2fso7yr.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpi2fso7yr.jl:25\\ntest set: Test Failed at /tmp/tmpi2fso7yr.jl:28\\\
    n  Expression: candidate(12) == [1, 3, 5]\\n   Evaluated: Int64[] == [1, 3, 5]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpi2fso7yr.jl:28\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpi2fso7yr.jl:25\\ntest set: Test Failed at /tmp/tmpi2fso7yr.jl:29\\\
    n  Expression: candidate(1) == [1]\\n   Evaluated: Int64[] == [1]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpi2fso7yr.jl:29\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpi2fso7yr.jl:25\\nTest Summary: | Fail  Total\\\
    ntest set      |    4      4\\n'"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    collatz_seq = [n]\n    while n != 1\n        if n % 2 == 0\n         \
    \   n = n / 2\n        else\n            n = 3 * n + 1\n        end\n        push!(collatz_seq,\
    \ n)\n    end\n    return filter(x -> x % 2 != 0, collatz_seq)\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1,\
    \ 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) ==\
    \ [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpb8vxlx1q.jl:34\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] top-level scope at /tmp/tmpb8vxlx1q.jl:34\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpb8vxlx1q.jl:33\ntest set: Test Failed at /tmp/tmpb8vxlx1q.jl:35\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: [5, 1] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpb8vxlx1q.jl:35\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpb8vxlx1q.jl:33\ntest set: Test Failed at /tmp/tmpb8vxlx1q.jl:36\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: [3, 5, 1] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpb8vxlx1q.jl:36\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpb8vxlx1q.jl:33\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpb8vxlx1q.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpgrf0s7nw.jl:26\\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpgrf0s7nw.jl:26\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpgrf0s7nw.jl:25\\ntest set: Test Failed at /tmp/tmpgrf0s7nw.jl:27\\\
    n  Expression: candidate(5) == [1, 5]\\n   Evaluated: Int64[] == [1, 5]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpgrf0s7nw.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpgrf0s7nw.jl:25\\ntest set: Test Failed at /tmp/tmpgrf0s7nw.jl:28\\\
    n  Expression: candidate(12) == [1, 3, 5]\\n   Evaluated: Int64[] == [1, 3, 5]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpgrf0s7nw.jl:28\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpgrf0s7nw.jl:25\\ntest set: Test Failed at /tmp/tmpgrf0s7nw.jl:29\\\
    n  Expression: candidate(1) == [1]\\n   Evaluated: Int64[] == [1]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpgrf0s7nw.jl:29\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpgrf0s7nw.jl:25\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpbwznv5ju.jl:26\\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpbwznv5ju.jl:26\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpbwznv5ju.jl:25\\ntest set: Test Failed at /tmp/tmpbwznv5ju.jl:27\\\
    n  Expression: candidate(5) == [1, 5]\\n   Evaluated: Int64[] == [1, 5]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpbwznv5ju.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpbwznv5ju.jl:25\\ntest set: Test Failed at /tmp/tmpbwznv5ju.jl:28\\\
    n  Expression: candidate(12) == [1, 3, 5]\\n   Evaluated: Int64[] == [1, 3, 5]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpbwznv5ju.jl:28\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpbwznv5ju.jl:25\\ntest set: Test Failed at /tmp/tmpbwznv5ju.jl:29\\\
    n  Expression: candidate(1) == [1]\\n   Evaluated: Int64[] == [1]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpbwznv5ju.jl:29\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpbwznv5ju.jl:25\\nTest Summary: | Fail  Total\\\
    ntest set      |    4      4\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    result = [n]\n    while n\
    \ != 1\n        if n % 2 == 0\n            n = n / 2\n        else\n         \
    \   n = 3 * n + 1\n        end\n        if n % 2 != 0\n            push!(result,\
    \ n)\n        end\n    end\n    return sort(result)\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11,\
    \ 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\
    \t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpvudgpckb.jl:39\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1, 5, 7, 11, 13, 14, 17] == [1, 5,\
    \ 7, 11, 13, 17]\nStacktrace:\n [1] top-level scope at /tmp/tmpvudgpckb.jl:39\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvudgpckb.jl:38\ntest set: Test Failed at /tmp/tmpvudgpckb.jl:41\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: [1, 3, 5, 12] == [1,\
    \ 3, 5]\nStacktrace:\n [1] top-level scope at /tmp/tmpvudgpckb.jl:41\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvudgpckb.jl:38\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     2      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpvudgpckb.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpwax6ffr4.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpwax6ffr4.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwax6ffr4.jl:25\ntest set: Test Failed at /tmp/tmpwax6ffr4.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpwax6ffr4.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwax6ffr4.jl:25\ntest set: Test Failed at /tmp/tmpwax6ffr4.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpwax6ffr4.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwax6ffr4.jl:25\ntest set: Test Failed at /tmp/tmpwax6ffr4.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpwax6ffr4.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwax6ffr4.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwax6ffr4.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpqctmhad8.jl:26\\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpqctmhad8.jl:26\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpqctmhad8.jl:25\\ntest set: Test Failed at /tmp/tmpqctmhad8.jl:27\\\
    n  Expression: candidate(5) == [1, 5]\\n   Evaluated: Int64[] == [1, 5]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpqctmhad8.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpqctmhad8.jl:25\\ntest set: Test Failed at /tmp/tmpqctmhad8.jl:28\\\
    n  Expression: candidate(12) == [1, 3, 5]\\n   Evaluated: Int64[] == [1, 3, 5]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpqctmhad8.jl:28\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpqctmhad8.jl:25\\ntest set: Test Failed at /tmp/tmpqctmhad8.jl:29\\\
    n  Expression: candidate(1) == [1]\\n   Evaluated: Int64[] == [1]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpqctmhad8.jl:29\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpqctmhad8.jl:25\\nTest Summary: | Fail  Total\\\
    ntest set      |    4      4\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp56qk5nlg.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp56qk5nlg.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp56qk5nlg.jl:25\ntest set: Test Failed at /tmp/tmp56qk5nlg.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp56qk5nlg.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp56qk5nlg.jl:25\ntest set: Test Failed at /tmp/tmp56qk5nlg.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp56qk5nlg.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp56qk5nlg.jl:25\ntest set: Test Failed at /tmp/tmp56qk5nlg.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp56qk5nlg.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp56qk5nlg.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp56qk5nlg.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    seq = [n]\n    while n !=\
    \ 1\n        if n % 2 == 0\n            n = n / 2\n        else\n            n\
    \ = 3 * n + 1\n        end\n        push!(seq, n)\n    end\n    return [x for\
    \ x in seq if x % 2 != 0]\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp3e_cgjxs.jl:37\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] top-level scope at /tmp/tmp3e_cgjxs.jl:37\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3e_cgjxs.jl:36\ntest set: Test Failed at /tmp/tmp3e_cgjxs.jl:38\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: [5, 1] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp3e_cgjxs.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3e_cgjxs.jl:36\ntest set: Test Failed at /tmp/tmp3e_cgjxs.jl:39\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: [3, 5, 1] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp3e_cgjxs.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3e_cgjxs.jl:36\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3e_cgjxs.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmplohnmoni.jl:25\n  Test threw exception\n\
    \  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmplohnmoni.jl:19\n\
    \   [2] top-level scope at /tmp/tmplohnmoni.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmplohnmoni.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmplohnmoni.jl:26\n  Test threw exception\n  Expression: candidate(5)\
    \ == [1, 5]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmplohnmoni.jl:19\n\
    \   [2] top-level scope at /tmp/tmplohnmoni.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmplohnmoni.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmplohnmoni.jl:27\n  Test threw exception\n  Expression: candidate(12)\
    \ == [1, 3, 5]\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmplohnmoni.jl:19\n\
    \   [2] top-level scope at /tmp/tmplohnmoni.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmplohnmoni.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmplohnmoni.jl:28\n  Test threw exception\n  Expression: candidate(1)\
    \ == [1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmplohnmoni.jl:19\n\
    \   [2] top-level scope at /tmp/tmplohnmoni.jl:28\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmplohnmoni.jl:24\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmplohnmoni.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmps0e5ds2d.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmps0e5ds2d.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmps0e5ds2d.jl:25\ntest set: Test Failed at /tmp/tmps0e5ds2d.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmps0e5ds2d.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmps0e5ds2d.jl:25\ntest set: Test Failed at /tmp/tmps0e5ds2d.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmps0e5ds2d.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmps0e5ds2d.jl:25\ntest set: Test Failed at /tmp/tmps0e5ds2d.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmps0e5ds2d.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmps0e5ds2d.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmps0e5ds2d.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    collatz = [n]\n    while n != 1\n        if n % 2 == 0\n            n\
    \ = n / 2\n        else\n            n = 3 * n + 1\n        end\n        push!(collatz,\
    \ n)\n    end\n    return filter(x -> x % 2 != 0, collatz)\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5,\
    \ 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1,\
    \ 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmplwx4is4v.jl:34\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] top-level scope at /tmp/tmplwx4is4v.jl:34\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplwx4is4v.jl:33\ntest set: Test Failed at /tmp/tmplwx4is4v.jl:35\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: [5, 1] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmplwx4is4v.jl:35\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplwx4is4v.jl:33\ntest set: Test Failed at /tmp/tmplwx4is4v.jl:36\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: [3, 5, 1] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmplwx4is4v.jl:36\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplwx4is4v.jl:33\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmplwx4is4v.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpkco2730w.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpkco2730w.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpkco2730w.jl:25\ntest set: Test Failed at /tmp/tmpkco2730w.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpkco2730w.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpkco2730w.jl:25\ntest set: Test Failed at /tmp/tmpkco2730w.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpkco2730w.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpkco2730w.jl:25\ntest set: Test Failed at /tmp/tmpkco2730w.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpkco2730w.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpkco2730w.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpkco2730w.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpc7p34yp3.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpc7p34yp3.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpc7p34yp3.jl:25\ntest set: Test Failed at /tmp/tmpc7p34yp3.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpc7p34yp3.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpc7p34yp3.jl:25\ntest set: Test Failed at /tmp/tmpc7p34yp3.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpc7p34yp3.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpc7p34yp3.jl:25\ntest set: Test Failed at /tmp/tmpc7p34yp3.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpc7p34yp3.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpc7p34yp3.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpc7p34yp3.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpgozws5j7.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpgozws5j7.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgozws5j7.jl:25\ntest set: Test Failed at /tmp/tmpgozws5j7.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpgozws5j7.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgozws5j7.jl:25\ntest set: Test Failed at /tmp/tmpgozws5j7.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpgozws5j7.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgozws5j7.jl:25\ntest set: Test Failed at /tmp/tmpgozws5j7.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpgozws5j7.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgozws5j7.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgozws5j7.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    collatz_seq = [n]\n    while\
    \ n != 1\n        if n % 2 == 0\n            n = n / 2\n        else\n       \
    \     n = 3 * n + 1\n        end\n        push!(collatz_seq, n)\n    end\n   \
    \ return filter(x -> x % 2 != 0, collatz_seq)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp7zw4lnt8.jl:37\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] top-level scope at /tmp/tmp7zw4lnt8.jl:37\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7zw4lnt8.jl:36\ntest set: Test Failed at /tmp/tmp7zw4lnt8.jl:38\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: [5, 1] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp7zw4lnt8.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7zw4lnt8.jl:36\ntest set: Test Failed at /tmp/tmp7zw4lnt8.jl:39\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: [3, 5, 1] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp7zw4lnt8.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7zw4lnt8.jl:36\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7zw4lnt8.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    collatz_sequence = [n]\n    while n != 1\n        if n % 2 == 0\n    \
    \        n = n / 2\n        else\n            n = 3 * n + 1\n        end\n   \
    \     push!(collatz_sequence, n)\n    end\n    return filter(x -> x % 2 != 0,\
    \ collatz_sequence)\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp9imkou6k.jl:34\\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7,\
    \ 11, 13, 17]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp9imkou6k.jl:34\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp9imkou6k.jl:33\\ntest set: Test Failed at /tmp/tmp9imkou6k.jl:35\\\
    n  Expression: candidate(5) == [1, 5]\\n   Evaluated: [5, 1] == [1, 5]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp9imkou6k.jl:35\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp9imkou6k.jl:33\\ntest set: Test Failed at /tmp/tmp9imkou6k.jl:36\\\
    n  Expression: candidate(12) == [1, 3, 5]\\n   Evaluated: [3, 5, 1] == [1, 3,\
    \ 5]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp9imkou6k.jl:36\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp9imkou6k.jl:33\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp5dycm81s.jl:26\\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp5dycm81s.jl:26\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp5dycm81s.jl:25\\ntest set: Test Failed at /tmp/tmp5dycm81s.jl:27\\\
    n  Expression: candidate(5) == [1, 5]\\n   Evaluated: Int64[] == [1, 5]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp5dycm81s.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp5dycm81s.jl:25\\ntest set: Test Failed at /tmp/tmp5dycm81s.jl:28\\\
    n  Expression: candidate(12) == [1, 3, 5]\\n   Evaluated: Int64[] == [1, 3, 5]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp5dycm81s.jl:28\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp5dycm81s.jl:25\\ntest set: Test Failed at /tmp/tmp5dycm81s.jl:29\\\
    n  Expression: candidate(1) == [1]\\n   Evaluated: Int64[] == [1]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp5dycm81s.jl:29\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp5dycm81s.jl:25\\nTest Summary: | Fail  Total\\\
    n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpxwm72je7.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpxwm72je7.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxwm72je7.jl:25\ntest set: Test Failed at /tmp/tmpxwm72je7.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpxwm72je7.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxwm72je7.jl:25\ntest set: Test Failed at /tmp/tmpxwm72je7.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpxwm72je7.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxwm72je7.jl:25\ntest set: Test Failed at /tmp/tmpxwm72je7.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpxwm72je7.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxwm72je7.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxwm72je7.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpplk22q_x.jl:26\\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpplk22q_x.jl:26\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpplk22q_x.jl:25\\ntest set: Test Failed at /tmp/tmpplk22q_x.jl:27\\\
    n  Expression: candidate(5) == [1, 5]\\n   Evaluated: Int64[] == [1, 5]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpplk22q_x.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpplk22q_x.jl:25\\ntest set: Test Failed at /tmp/tmpplk22q_x.jl:28\\\
    n  Expression: candidate(12) == [1, 3, 5]\\n   Evaluated: Int64[] == [1, 3, 5]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpplk22q_x.jl:28\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpplk22q_x.jl:25\\ntest set: Test Failed at /tmp/tmpplk22q_x.jl:29\\\
    n  Expression: candidate(1) == [1]\\n   Evaluated: Int64[] == [1]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpplk22q_x.jl:29\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpplk22q_x.jl:25\\nTest Summary: | Fail  Total\\\
    ntest set      |    4      4\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpthgojqq9.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpthgojqq9.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpthgojqq9.jl:25\ntest set: Test Failed at /tmp/tmpthgojqq9.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpthgojqq9.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpthgojqq9.jl:25\ntest set: Test Failed at /tmp/tmpthgojqq9.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpthgojqq9.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpthgojqq9.jl:25\ntest set: Test Failed at /tmp/tmpthgojqq9.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpthgojqq9.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpthgojqq9.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpthgojqq9.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpv6xfru1_.jl:26\\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpv6xfru1_.jl:26\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpv6xfru1_.jl:25\\ntest set: Test Failed at /tmp/tmpv6xfru1_.jl:27\\\
    n  Expression: candidate(5) == [1, 5]\\n   Evaluated: Int64[] == [1, 5]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpv6xfru1_.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpv6xfru1_.jl:25\\ntest set: Test Failed at /tmp/tmpv6xfru1_.jl:28\\\
    n  Expression: candidate(12) == [1, 3, 5]\\n   Evaluated: Int64[] == [1, 3, 5]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpv6xfru1_.jl:28\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpv6xfru1_.jl:25\\ntest set: Test Failed at /tmp/tmpv6xfru1_.jl:29\\\
    n  Expression: candidate(1) == [1]\\n   Evaluated: Int64[] == [1]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpv6xfru1_.jl:29\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpv6xfru1_.jl:25\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmplmq_o2d1.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmplmq_o2d1.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplmq_o2d1.jl:25\ntest set: Test Failed at /tmp/tmplmq_o2d1.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmplmq_o2d1.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplmq_o2d1.jl:25\ntest set: Test Failed at /tmp/tmplmq_o2d1.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmplmq_o2d1.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplmq_o2d1.jl:25\ntest set: Test Failed at /tmp/tmplmq_o2d1.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmplmq_o2d1.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplmq_o2d1.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmplmq_o2d1.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp_1hd7mmx.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_1hd7mmx.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_1hd7mmx.jl:25\ntest set: Test Failed at /tmp/tmp_1hd7mmx.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_1hd7mmx.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_1hd7mmx.jl:25\ntest set: Test Failed at /tmp/tmp_1hd7mmx.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp_1hd7mmx.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_1hd7mmx.jl:25\ntest set: Test Failed at /tmp/tmp_1hd7mmx.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_1hd7mmx.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_1hd7mmx.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_1hd7mmx.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    collatz_seq = [n]\n    while\
    \ n != 1\n        if n % 2 == 0\n            n = n / 2\n        else\n       \
    \     n = 3 * n + 1\n        end\n        push!(collatz_seq, n)\n    end\n   \
    \ return filter(x -> x % 2 != 0, collatz_seq)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmplq3r3f4l.jl:37\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] top-level scope at /tmp/tmplq3r3f4l.jl:37\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplq3r3f4l.jl:36\ntest set: Test Failed at /tmp/tmplq3r3f4l.jl:38\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: [5, 1] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmplq3r3f4l.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplq3r3f4l.jl:36\ntest set: Test Failed at /tmp/tmplq3r3f4l.jl:39\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: [3, 5, 1] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmplq3r3f4l.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplq3r3f4l.jl:36\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmplq3r3f4l.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpkfi_pqfw.jl:25\n  Test threw exception\n\
    \  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpkfi_pqfw.jl:19\n\
    \   [2] top-level scope at /tmp/tmpkfi_pqfw.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkfi_pqfw.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpkfi_pqfw.jl:26\n  Test threw exception\n  Expression: candidate(5)\
    \ == [1, 5]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpkfi_pqfw.jl:19\n\
    \   [2] top-level scope at /tmp/tmpkfi_pqfw.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkfi_pqfw.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpkfi_pqfw.jl:27\n  Test threw exception\n  Expression: candidate(12)\
    \ == [1, 3, 5]\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpkfi_pqfw.jl:19\n\
    \   [2] top-level scope at /tmp/tmpkfi_pqfw.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkfi_pqfw.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpkfi_pqfw.jl:28\n  Test threw exception\n  Expression: candidate(1)\
    \ == [1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpkfi_pqfw.jl:19\n\
    \   [2] top-level scope at /tmp/tmpkfi_pqfw.jl:28\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkfi_pqfw.jl:24\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpkfi_pqfw.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpw6oph8a1.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpw6oph8a1.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw6oph8a1.jl:25\ntest set: Test Failed at /tmp/tmpw6oph8a1.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpw6oph8a1.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw6oph8a1.jl:25\ntest set: Test Failed at /tmp/tmpw6oph8a1.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpw6oph8a1.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw6oph8a1.jl:25\ntest set: Test Failed at /tmp/tmpw6oph8a1.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpw6oph8a1.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw6oph8a1.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpw6oph8a1.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpc0h620re.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpc0h620re.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpc0h620re.jl:25\ntest set: Test Failed at /tmp/tmpc0h620re.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpc0h620re.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpc0h620re.jl:25\ntest set: Test Failed at /tmp/tmpc0h620re.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpc0h620re.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpc0h620re.jl:25\ntest set: Test Failed at /tmp/tmpc0h620re.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpc0h620re.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpc0h620re.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpc0h620re.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    odd_collatz = []\n    while\
    \ n != 1\n        if n % 2 == 1\n            push!(odd_collatz, n)\n        end\n\
    \        n = next_collatz(n)\n    end\n    push!(odd_collatz, 1)\n    return odd_collatz\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpzojp4i1t.jl:36\n  Test threw exception\n\
    \  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\n  UndefVarError: next_collatz\
    \ not defined\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpzojp4i1t.jl:26\n\
    \   [2] top-level scope at /tmp/tmpzojp4i1t.jl:36\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzojp4i1t.jl:35\n  \ntest set: Error During\
    \ Test at /tmp/tmpzojp4i1t.jl:37\n  Test threw exception\n  Expression: candidate(5)\
    \ == [1, 5]\n  UndefVarError: next_collatz not defined\n  Stacktrace:\n   [1]\
    \ get_odd_collatz(::Int64) at /tmp/tmpzojp4i1t.jl:26\n   [2] top-level scope at\
    \ /tmp/tmpzojp4i1t.jl:37\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzojp4i1t.jl:35\n  \ntest set: Error During\
    \ Test at /tmp/tmpzojp4i1t.jl:38\n  Test threw exception\n  Expression: candidate(12)\
    \ == [1, 3, 5]\n  UndefVarError: next_collatz not defined\n  Stacktrace:\n   [1]\
    \ get_odd_collatz(::Int64) at /tmp/tmpzojp4i1t.jl:26\n   [2] top-level scope at\
    \ /tmp/tmpzojp4i1t.jl:38\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzojp4i1t.jl:35\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    1      3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzojp4i1t.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    collatz = [n]\n    while n\
    \ != 1\n        if n % 2 == 0\n            n = n / 2\n        else\n         \
    \   n = 3 * n + 1\n        end\n        push!(collatz, n)\n    end\n    return\
    \ filter(x -> x % 2 != 0, collatz)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpbj68cotr.jl:37\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] top-level scope at /tmp/tmpbj68cotr.jl:37\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbj68cotr.jl:36\ntest set: Test Failed at /tmp/tmpbj68cotr.jl:38\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: [5, 1] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpbj68cotr.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbj68cotr.jl:36\ntest set: Test Failed at /tmp/tmpbj68cotr.jl:39\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: [3, 5, 1] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpbj68cotr.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbj68cotr.jl:36\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbj68cotr.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpurwkzjk7.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpurwkzjk7.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpurwkzjk7.jl:25\ntest set: Test Failed at /tmp/tmpurwkzjk7.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpurwkzjk7.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpurwkzjk7.jl:25\ntest set: Test Failed at /tmp/tmpurwkzjk7.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpurwkzjk7.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpurwkzjk7.jl:25\ntest set: Test Failed at /tmp/tmpurwkzjk7.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpurwkzjk7.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpurwkzjk7.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpurwkzjk7.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpdgjub9o2.jl:26\\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpdgjub9o2.jl:26\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpdgjub9o2.jl:25\\ntest set: Test Failed at /tmp/tmpdgjub9o2.jl:27\\\
    n  Expression: candidate(5) == [1, 5]\\n   Evaluated: Int64[] == [1, 5]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpdgjub9o2.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpdgjub9o2.jl:25\\ntest set: Test Failed at /tmp/tmpdgjub9o2.jl:28\\\
    n  Expression: candidate(12) == [1, 3, 5]\\n   Evaluated: Int64[] == [1, 3, 5]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpdgjub9o2.jl:28\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpdgjub9o2.jl:25\\ntest set: Test Failed at /tmp/tmpdgjub9o2.jl:29\\\
    n  Expression: candidate(1) == [1]\\n   Evaluated: Int64[] == [1]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpdgjub9o2.jl:29\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpdgjub9o2.jl:25\\nTest Summary: | Fail  Total\\\
    ntest set      |    4      4\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp1c2kjis2.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp1c2kjis2.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1c2kjis2.jl:25\ntest set: Test Failed at /tmp/tmp1c2kjis2.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp1c2kjis2.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1c2kjis2.jl:25\ntest set: Test Failed at /tmp/tmp1c2kjis2.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp1c2kjis2.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1c2kjis2.jl:25\ntest set: Test Failed at /tmp/tmp1c2kjis2.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp1c2kjis2.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1c2kjis2.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1c2kjis2.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpgasrwksr.jl:25\n  Test threw exception\n\
    \  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpgasrwksr.jl:19\n\
    \   [2] top-level scope at /tmp/tmpgasrwksr.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpgasrwksr.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpgasrwksr.jl:26\n  Test threw exception\n  Expression: candidate(5)\
    \ == [1, 5]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpgasrwksr.jl:19\n\
    \   [2] top-level scope at /tmp/tmpgasrwksr.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpgasrwksr.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpgasrwksr.jl:27\n  Test threw exception\n  Expression: candidate(12)\
    \ == [1, 3, 5]\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpgasrwksr.jl:19\n\
    \   [2] top-level scope at /tmp/tmpgasrwksr.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpgasrwksr.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpgasrwksr.jl:28\n  Test threw exception\n  Expression: candidate(1)\
    \ == [1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpgasrwksr.jl:19\n\
    \   [2] top-level scope at /tmp/tmpgasrwksr.jl:28\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpgasrwksr.jl:24\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgasrwksr.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpcjbc512a.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpcjbc512a.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpcjbc512a.jl:25\ntest set: Test Failed at /tmp/tmpcjbc512a.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpcjbc512a.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpcjbc512a.jl:25\ntest set: Test Failed at /tmp/tmpcjbc512a.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpcjbc512a.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpcjbc512a.jl:25\ntest set: Test Failed at /tmp/tmpcjbc512a.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpcjbc512a.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpcjbc512a.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpcjbc512a.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpdy2fupg1.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpdy2fupg1.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdy2fupg1.jl:25\ntest set: Test Failed at /tmp/tmpdy2fupg1.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpdy2fupg1.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdy2fupg1.jl:25\ntest set: Test Failed at /tmp/tmpdy2fupg1.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpdy2fupg1.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdy2fupg1.jl:25\ntest set: Test Failed at /tmp/tmpdy2fupg1.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpdy2fupg1.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdy2fupg1.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpdy2fupg1.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    collatz = [n]\n    while n\
    \ != 1\n        if n % 2 == 0\n            n = n / 2\n        else\n         \
    \   n = 3 * n + 1\n        end\n        push!(collatz, n)\n    end\n    return\
    \ filter(x -> x % 2 != 0, collatz)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpxtsr7qy6.jl:37\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] top-level scope at /tmp/tmpxtsr7qy6.jl:37\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxtsr7qy6.jl:36\ntest set: Test Failed at /tmp/tmpxtsr7qy6.jl:38\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: [5, 1] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpxtsr7qy6.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxtsr7qy6.jl:36\ntest set: Test Failed at /tmp/tmpxtsr7qy6.jl:39\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: [3, 5, 1] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpxtsr7qy6.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxtsr7qy6.jl:36\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxtsr7qy6.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpty6cjpar.jl:25\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{Int64,1}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] get_odd_collatz(::Int64) at /tmp/tmpty6cjpar.jl:19\\\
    n   [2] top-level scope at /tmp/tmpty6cjpar.jl:25\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpty6cjpar.jl:24\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpty6cjpar.jl:26\\n  Test threw exception\\n  Expression: candidate(5)\
    \ == [1, 5]\\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] get_odd_collatz(::Int64) at /tmp/tmpty6cjpar.jl:19\\\
    n   [2] top-level scope at /tmp/tmpty6cjpar.jl:26\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpty6cjpar.jl:24\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpty6cjpar.jl:27\\n  Test threw exception\\n  Expression: candidate(12)\
    \ == [1, 3, 5]\\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] get_odd_collatz(::Int64) at /tmp/tmpty6cjpar.jl:19\\\
    n   [2] top-level scope at /tmp/tmpty6cjpar.jl:27\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpty6cjpar.jl:24\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpty6cjpar.jl:28\\n  Test threw exception\\n  Expression: candidate(1)\
    \ == [1]\\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] get_odd_collatz(::Int64) at /tmp/tmpty6cjpar.jl:19\\\
    n   [2] top-level scope at /tmp/tmpty6cjpar.jl:28\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpty6cjpar.jl:24\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpv4jrr_al.jl:26\\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpv4jrr_al.jl:26\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpv4jrr_al.jl:25\\ntest set: Test Failed at /tmp/tmpv4jrr_al.jl:27\\\
    n  Expression: candidate(5) == [1, 5]\\n   Evaluated: Int64[] == [1, 5]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpv4jrr_al.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpv4jrr_al.jl:25\\ntest set: Test Failed at /tmp/tmpv4jrr_al.jl:28\\\
    n  Expression: candidate(12) == [1, 3, 5]\\n   Evaluated: Int64[] == [1, 3, 5]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpv4jrr_al.jl:28\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpv4jrr_al.jl:25\\ntest set: Test Failed at /tmp/tmpv4jrr_al.jl:29\\\
    n  Expression: candidate(1) == [1]\\n   Evaluated: Int64[] == [1]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpv4jrr_al.jl:29\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpv4jrr_al.jl:25\\nTest Summary: | Fail  Total\\\
    ntest set      |    4      4\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    odd_collatz = [n]\n    while\
    \ n != 1\n        if n % 2 == 0\n            n = n / 2\n        else\n       \
    \     n = 3 * n + 1\n        end\n        if n % 2 != 0\n            push!(odd_collatz,\
    \ n)\n        end\n    end\n    return sort(odd_collatz)\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5,\
    \ 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1,\
    \ 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpf8g4eohm.jl:39\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1, 5, 7, 11, 13, 14, 17] == [1, 5,\
    \ 7, 11, 13, 17]\nStacktrace:\n [1] top-level scope at /tmp/tmpf8g4eohm.jl:39\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpf8g4eohm.jl:38\ntest set: Test Failed at /tmp/tmpf8g4eohm.jl:41\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: [1, 3, 5, 12] == [1,\
    \ 3, 5]\nStacktrace:\n [1] top-level scope at /tmp/tmpf8g4eohm.jl:41\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpf8g4eohm.jl:38\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     2      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpf8g4eohm.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    collatz = [n]\n    while n != 1\n        if n % 2 == 0\n            n\
    \ = n \xF7 2\n        else\n            n = 3n + 1\n        end\n        push!(collatz,\
    \ n)\n    end\n    return filter(x -> x % 2 != 0, collatz)\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5,\
    \ 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1,\
    \ 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp0ogjaufy.jl:34\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] top-level scope at /tmp/tmp0ogjaufy.jl:34\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0ogjaufy.jl:33\ntest set: Test Failed at /tmp/tmp0ogjaufy.jl:35\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: [5, 1] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp0ogjaufy.jl:35\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0ogjaufy.jl:33\ntest set: Test Failed at /tmp/tmp0ogjaufy.jl:36\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: [3, 5, 1] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp0ogjaufy.jl:36\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0ogjaufy.jl:33\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0ogjaufy.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    odd_numbers = [n]\n    while\
    \ n != 1\n        if n % 2 == 0\n            n = n / 2\n        else\n       \
    \     n = 3 * n + 1\n            push!(odd_numbers, n)\n        end\n    end\n\
    \    return sort(odd_numbers)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: "b'test set: Test Failed at /tmp/tmp0upl5hnf.jl:37\\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\\n   Evaluated: [14, 16, 22, 34, 40, 52] == [1, 5,\
    \ 7, 11, 13, 17]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp0upl5hnf.jl:37\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp0upl5hnf.jl:36\\ntest set: Test Failed at /tmp/tmp0upl5hnf.jl:38\\\
    n  Expression: candidate(5) == [1, 5]\\n   Evaluated: [5, 16] == [1, 5]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp0upl5hnf.jl:38\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp0upl5hnf.jl:36\\ntest set: Test Failed at /tmp/tmp0upl5hnf.jl:39\\\
    n  Expression: candidate(12) == [1, 3, 5]\\n   Evaluated: [10, 12, 16] == [1,\
    \ 3, 5]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp0upl5hnf.jl:39\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp0upl5hnf.jl:36\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    1     3      4\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp1dp8syf_.jl:26\\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp1dp8syf_.jl:26\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp1dp8syf_.jl:25\\ntest set: Test Failed at /tmp/tmp1dp8syf_.jl:27\\\
    n  Expression: candidate(5) == [1, 5]\\n   Evaluated: Int64[] == [1, 5]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp1dp8syf_.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp1dp8syf_.jl:25\\ntest set: Test Failed at /tmp/tmp1dp8syf_.jl:28\\\
    n  Expression: candidate(12) == [1, 3, 5]\\n   Evaluated: Int64[] == [1, 3, 5]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp1dp8syf_.jl:28\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp1dp8syf_.jl:25\\ntest set: Test Failed at /tmp/tmp1dp8syf_.jl:29\\\
    n  Expression: candidate(1) == [1]\\n   Evaluated: Int64[] == [1]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp1dp8syf_.jl:29\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp1dp8syf_.jl:25\\nTest Summary: | Fail  Total\\\
    ntest set      |    4      4\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    collatz_seq = [n]\n    while\
    \ n != 1\n        if n % 2 == 0\n            n = n / 2\n        else\n       \
    \     n = 3 * n + 1\n        end\n        push!(collatz_seq, n)\n    end\n   \
    \ return filter(x -> x % 2 != 0, collatz_seq)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpkckuq6x_.jl:37\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] top-level scope at /tmp/tmpkckuq6x_.jl:37\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpkckuq6x_.jl:36\ntest set: Test Failed at /tmp/tmpkckuq6x_.jl:38\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: [5, 1] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpkckuq6x_.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpkckuq6x_.jl:36\ntest set: Test Failed at /tmp/tmpkckuq6x_.jl:39\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: [3, 5, 1] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpkckuq6x_.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpkckuq6x_.jl:36\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpkckuq6x_.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpl_ovi7dm.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpl_ovi7dm.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpl_ovi7dm.jl:25\ntest set: Test Failed at /tmp/tmpl_ovi7dm.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpl_ovi7dm.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpl_ovi7dm.jl:25\ntest set: Test Failed at /tmp/tmpl_ovi7dm.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpl_ovi7dm.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpl_ovi7dm.jl:25\ntest set: Test Failed at /tmp/tmpl_ovi7dm.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpl_ovi7dm.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpl_ovi7dm.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpl_ovi7dm.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    odd_numbers = [n]\n    while\
    \ n != 1\n        if n % 2 == 0\n            n = n / 2\n        else\n       \
    \     n = 3 * n + 1\n            push!(odd_numbers, n)\n        end\n    end\n\
    \    sort(odd_numbers)\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpn7gx1g8v.jl:37\\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\\n   Evaluated: [14, 16, 22, 34, 40, 52] == [1, 5,\
    \ 7, 11, 13, 17]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpn7gx1g8v.jl:37\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpn7gx1g8v.jl:36\\ntest set: Test Failed at /tmp/tmpn7gx1g8v.jl:38\\\
    n  Expression: candidate(5) == [1, 5]\\n   Evaluated: [5, 16] == [1, 5]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpn7gx1g8v.jl:38\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpn7gx1g8v.jl:36\\ntest set: Test Failed at /tmp/tmpn7gx1g8v.jl:39\\\
    n  Expression: candidate(12) == [1, 3, 5]\\n   Evaluated: [10, 12, 16] == [1,\
    \ 3, 5]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpn7gx1g8v.jl:39\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpn7gx1g8v.jl:36\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    1     3      4\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp8pd2xibe.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp8pd2xibe.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8pd2xibe.jl:25\ntest set: Test Failed at /tmp/tmp8pd2xibe.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp8pd2xibe.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8pd2xibe.jl:25\ntest set: Test Failed at /tmp/tmp8pd2xibe.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp8pd2xibe.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8pd2xibe.jl:25\ntest set: Test Failed at /tmp/tmp8pd2xibe.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp8pd2xibe.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8pd2xibe.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8pd2xibe.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpajo2ml5n.jl:25\n  Test threw exception\n\
    \  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpajo2ml5n.jl:19\n\
    \   [2] top-level scope at /tmp/tmpajo2ml5n.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpajo2ml5n.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpajo2ml5n.jl:26\n  Test threw exception\n  Expression: candidate(5)\
    \ == [1, 5]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpajo2ml5n.jl:19\n\
    \   [2] top-level scope at /tmp/tmpajo2ml5n.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpajo2ml5n.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpajo2ml5n.jl:27\n  Test threw exception\n  Expression: candidate(12)\
    \ == [1, 3, 5]\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpajo2ml5n.jl:19\n\
    \   [2] top-level scope at /tmp/tmpajo2ml5n.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpajo2ml5n.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpajo2ml5n.jl:28\n  Test threw exception\n  Expression: candidate(1)\
    \ == [1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpajo2ml5n.jl:19\n\
    \   [2] top-level scope at /tmp/tmpajo2ml5n.jl:28\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpajo2ml5n.jl:24\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpajo2ml5n.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp94hi4m0k.jl:26\\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp94hi4m0k.jl:26\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp94hi4m0k.jl:25\\ntest set: Test Failed at /tmp/tmp94hi4m0k.jl:27\\\
    n  Expression: candidate(5) == [1, 5]\\n   Evaluated: Int64[] == [1, 5]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp94hi4m0k.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp94hi4m0k.jl:25\\ntest set: Test Failed at /tmp/tmp94hi4m0k.jl:28\\\
    n  Expression: candidate(12) == [1, 3, 5]\\n   Evaluated: Int64[] == [1, 3, 5]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp94hi4m0k.jl:28\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp94hi4m0k.jl:25\\ntest set: Test Failed at /tmp/tmp94hi4m0k.jl:29\\\
    n  Expression: candidate(1) == [1]\\n   Evaluated: Int64[] == [1]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp94hi4m0k.jl:29\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp94hi4m0k.jl:25\\nTest Summary: | Fail  Total\\\
    ntest set      |    4      4\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmppuekb6q3.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmppuekb6q3.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmppuekb6q3.jl:25\ntest set: Test Failed at /tmp/tmppuekb6q3.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmppuekb6q3.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmppuekb6q3.jl:25\ntest set: Test Failed at /tmp/tmppuekb6q3.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmppuekb6q3.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmppuekb6q3.jl:25\ntest set: Test Failed at /tmp/tmppuekb6q3.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmppuekb6q3.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmppuekb6q3.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmppuekb6q3.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpi_8ifize.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpi_8ifize.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpi_8ifize.jl:25\ntest set: Test Failed at /tmp/tmpi_8ifize.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpi_8ifize.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpi_8ifize.jl:25\ntest set: Test Failed at /tmp/tmpi_8ifize.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpi_8ifize.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpi_8ifize.jl:25\ntest set: Test Failed at /tmp/tmpi_8ifize.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpi_8ifize.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpi_8ifize.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpi_8ifize.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    collatz = [n]\n    while n\
    \ != 1\n        if n % 2 == 0\n            n = n / 2\n        else\n         \
    \   n = 3 * n + 1\n        end\n        push!(collatz, n)\n    end\n    return\
    \ filter(x -> x % 2 != 0, collatz)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp57omgik6.jl:37\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] top-level scope at /tmp/tmp57omgik6.jl:37\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp57omgik6.jl:36\ntest set: Test Failed at /tmp/tmp57omgik6.jl:38\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: [5, 1] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp57omgik6.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp57omgik6.jl:36\ntest set: Test Failed at /tmp/tmp57omgik6.jl:39\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: [3, 5, 1] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp57omgik6.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp57omgik6.jl:36\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp57omgik6.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    collatz = [n]\n    while n\
    \ != 1\n        if n % 2 == 0\n            n = n / 2\n        else\n         \
    \   n = 3 * n + 1\n        end\n        push!(collatz, n)\n    end\n    return\
    \ filter(x -> x % 2 != 0, collatz)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpzcnnyzhk.jl:37\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] top-level scope at /tmp/tmpzcnnyzhk.jl:37\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzcnnyzhk.jl:36\ntest set: Test Failed at /tmp/tmpzcnnyzhk.jl:38\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: [5, 1] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpzcnnyzhk.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzcnnyzhk.jl:36\ntest set: Test Failed at /tmp/tmpzcnnyzhk.jl:39\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: [3, 5, 1] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpzcnnyzhk.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzcnnyzhk.jl:36\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzcnnyzhk.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp1h01ny9b.jl:26\\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp1h01ny9b.jl:26\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp1h01ny9b.jl:25\\ntest set: Test Failed at /tmp/tmp1h01ny9b.jl:27\\\
    n  Expression: candidate(5) == [1, 5]\\n   Evaluated: Int64[] == [1, 5]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp1h01ny9b.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp1h01ny9b.jl:25\\ntest set: Test Failed at /tmp/tmp1h01ny9b.jl:28\\\
    n  Expression: candidate(12) == [1, 3, 5]\\n   Evaluated: Int64[] == [1, 3, 5]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp1h01ny9b.jl:28\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp1h01ny9b.jl:25\\ntest set: Test Failed at /tmp/tmp1h01ny9b.jl:29\\\
    n  Expression: candidate(1) == [1]\\n   Evaluated: Int64[] == [1]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmp1h01ny9b.jl:29\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp1h01ny9b.jl:25\\nTest Summary: | Fail  Total\\\
    ntest set      |    4      4\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpfsfnz6rz.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpfsfnz6rz.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfsfnz6rz.jl:25\ntest set: Test Failed at /tmp/tmpfsfnz6rz.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpfsfnz6rz.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfsfnz6rz.jl:25\ntest set: Test Failed at /tmp/tmpfsfnz6rz.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpfsfnz6rz.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfsfnz6rz.jl:25\ntest set: Test Failed at /tmp/tmpfsfnz6rz.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpfsfnz6rz.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfsfnz6rz.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpfsfnz6rz.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpdohjtwet.jl:25\n  Test threw exception\n\
    \  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpdohjtwet.jl:19\n\
    \   [2] top-level scope at /tmp/tmpdohjtwet.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpdohjtwet.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpdohjtwet.jl:26\n  Test threw exception\n  Expression: candidate(5)\
    \ == [1, 5]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpdohjtwet.jl:19\n\
    \   [2] top-level scope at /tmp/tmpdohjtwet.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpdohjtwet.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpdohjtwet.jl:27\n  Test threw exception\n  Expression: candidate(12)\
    \ == [1, 3, 5]\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpdohjtwet.jl:19\n\
    \   [2] top-level scope at /tmp/tmpdohjtwet.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpdohjtwet.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmpdohjtwet.jl:28\n  Test threw exception\n  Expression: candidate(1)\
    \ == [1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmpdohjtwet.jl:19\n\
    \   [2] top-level scope at /tmp/tmpdohjtwet.jl:28\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpdohjtwet.jl:24\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpdohjtwet.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    collatz = [n]\n    while n != 1\n        if n % 2 == 0\n            n\
    \ = n / 2\n        else\n            n = 3 * n + 1\n        end\n        push!(collatz,\
    \ n)\n    end\n    return filter(x -> x % 2 != 0, collatz)\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5,\
    \ 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1,\
    \ 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmps3lm84ic.jl:34\\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7,\
    \ 11, 13, 17]\\nStacktrace:\\n [1] top-level scope at /tmp/tmps3lm84ic.jl:34\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmps3lm84ic.jl:33\\ntest set: Test Failed at /tmp/tmps3lm84ic.jl:35\\\
    n  Expression: candidate(5) == [1, 5]\\n   Evaluated: [5, 1] == [1, 5]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmps3lm84ic.jl:35\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmps3lm84ic.jl:33\\ntest set: Test Failed at /tmp/tmps3lm84ic.jl:36\\\
    n  Expression: candidate(12) == [1, 3, 5]\\n   Evaluated: [3, 5, 1] == [1, 3,\
    \ 5]\\nStacktrace:\\n [1] top-level scope at /tmp/tmps3lm84ic.jl:36\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmps3lm84ic.jl:33\\nTest Summary: | Pass  Fail \
    \ Total\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpqhu4xggk.jl:26\\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpqhu4xggk.jl:26\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpqhu4xggk.jl:25\\ntest set: Test Failed at /tmp/tmpqhu4xggk.jl:27\\\
    n  Expression: candidate(5) == [1, 5]\\n   Evaluated: Int64[] == [1, 5]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpqhu4xggk.jl:27\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpqhu4xggk.jl:25\\ntest set: Test Failed at /tmp/tmpqhu4xggk.jl:28\\\
    n  Expression: candidate(12) == [1, 3, 5]\\n   Evaluated: Int64[] == [1, 3, 5]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpqhu4xggk.jl:28\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpqhu4xggk.jl:25\\ntest set: Test Failed at /tmp/tmpqhu4xggk.jl:29\\\
    n  Expression: candidate(1) == [1]\\n   Evaluated: Int64[] == [1]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpqhu4xggk.jl:29\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpqhu4xggk.jl:25\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmptg8_ot5q.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmptg8_ot5q.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmptg8_ot5q.jl:25\ntest set: Test Failed at /tmp/tmptg8_ot5q.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmptg8_ot5q.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmptg8_ot5q.jl:25\ntest set: Test Failed at /tmp/tmptg8_ot5q.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmptg8_ot5q.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmptg8_ot5q.jl:25\ntest set: Test Failed at /tmp/tmptg8_ot5q.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmptg8_ot5q.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmptg8_ot5q.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmptg8_ot5q.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpv6fciy38.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpv6fciy38.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpv6fciy38.jl:25\ntest set: Test Failed at /tmp/tmpv6fciy38.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpv6fciy38.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpv6fciy38.jl:25\ntest set: Test Failed at /tmp/tmpv6fciy38.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpv6fciy38.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpv6fciy38.jl:25\ntest set: Test Failed at /tmp/tmpv6fciy38.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpv6fciy38.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpv6fciy38.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpv6fciy38.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpdriyrx_r.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpdriyrx_r.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdriyrx_r.jl:25\ntest set: Test Failed at /tmp/tmpdriyrx_r.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpdriyrx_r.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdriyrx_r.jl:25\ntest set: Test Failed at /tmp/tmpdriyrx_r.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpdriyrx_r.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdriyrx_r.jl:25\ntest set: Test Failed at /tmp/tmpdriyrx_r.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpdriyrx_r.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdriyrx_r.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpdriyrx_r.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    collatz = [n]\n    while n\
    \ != 1\n        if n % 2 == 0\n            n = n / 2\n        else\n         \
    \   n = 3 * n + 1\n        end\n        push!(collatz, n)\n    end\n    return\
    \ filter(x -> x % 2 != 0, collatz)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpa820mwb4.jl:37\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] top-level scope at /tmp/tmpa820mwb4.jl:37\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpa820mwb4.jl:36\ntest set: Test Failed at /tmp/tmpa820mwb4.jl:38\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: [5, 1] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpa820mwb4.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpa820mwb4.jl:36\ntest set: Test Failed at /tmp/tmpa820mwb4.jl:39\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: [3, 5, 1] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpa820mwb4.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpa820mwb4.jl:36\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpa820mwb4.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    collatz_seq = [n]\n    while n != 1\n        if n % 2 == 0\n         \
    \   n = n / 2\n        else\n            n = 3 * n + 1\n        end\n        push!(collatz_seq,\
    \ n)\n    end\n    return sort(filter(x -> x % 2 != 0, collatz_seq))\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpgakgyg03.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpgakgyg03.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgakgyg03.jl:25\ntest set: Test Failed at /tmp/tmpgakgyg03.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpgakgyg03.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgakgyg03.jl:25\ntest set: Test Failed at /tmp/tmpgakgyg03.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpgakgyg03.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgakgyg03.jl:25\ntest set: Test Failed at /tmp/tmpgakgyg03.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpgakgyg03.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgakgyg03.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgakgyg03.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp0n_7dtuz.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp0n_7dtuz.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0n_7dtuz.jl:25\ntest set: Test Failed at /tmp/tmp0n_7dtuz.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp0n_7dtuz.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0n_7dtuz.jl:25\ntest set: Test Failed at /tmp/tmp0n_7dtuz.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp0n_7dtuz.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0n_7dtuz.jl:25\ntest set: Test Failed at /tmp/tmp0n_7dtuz.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp0n_7dtuz.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0n_7dtuz.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0n_7dtuz.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    collatz = [n]\n    while n\
    \ != 1\n        if n % 2 == 0\n            n = n/2\n        else\n           \
    \ n = 3*n + 1\n        end\n        push!(collatz, n)\n    end\n    return filter(x\
    \ -> x % 2 != 0, collatz)\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp9nho7hy_.jl:37\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] top-level scope at /tmp/tmp9nho7hy_.jl:37\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9nho7hy_.jl:36\ntest set: Test Failed at /tmp/tmp9nho7hy_.jl:38\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: [5, 1] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp9nho7hy_.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9nho7hy_.jl:36\ntest set: Test Failed at /tmp/tmp9nho7hy_.jl:39\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: [3, 5, 1] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp9nho7hy_.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9nho7hy_.jl:36\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9nho7hy_.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpzeb5tzro.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpzeb5tzro.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzeb5tzro.jl:25\ntest set: Test Failed at /tmp/tmpzeb5tzro.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpzeb5tzro.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzeb5tzro.jl:25\ntest set: Test Failed at /tmp/tmpzeb5tzro.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpzeb5tzro.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzeb5tzro.jl:25\ntest set: Test Failed at /tmp/tmpzeb5tzro.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpzeb5tzro.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzeb5tzro.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzeb5tzro.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpiqsjxm0e.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpiqsjxm0e.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpiqsjxm0e.jl:25\ntest set: Test Failed at /tmp/tmpiqsjxm0e.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpiqsjxm0e.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpiqsjxm0e.jl:25\ntest set: Test Failed at /tmp/tmpiqsjxm0e.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpiqsjxm0e.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpiqsjxm0e.jl:25\ntest set: Test Failed at /tmp/tmpiqsjxm0e.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpiqsjxm0e.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpiqsjxm0e.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpiqsjxm0e.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp_w5djnjc.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_w5djnjc.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_w5djnjc.jl:25\ntest set: Test Failed at /tmp/tmp_w5djnjc.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_w5djnjc.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_w5djnjc.jl:25\ntest set: Test Failed at /tmp/tmp_w5djnjc.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp_w5djnjc.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_w5djnjc.jl:25\ntest set: Test Failed at /tmp/tmp_w5djnjc.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp_w5djnjc.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_w5djnjc.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_w5djnjc.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp23zzhah3.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp23zzhah3.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp23zzhah3.jl:25\ntest set: Test Failed at /tmp/tmp23zzhah3.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp23zzhah3.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp23zzhah3.jl:25\ntest set: Test Failed at /tmp/tmp23zzhah3.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp23zzhah3.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp23zzhah3.jl:25\ntest set: Test Failed at /tmp/tmp23zzhah3.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp23zzhah3.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp23zzhah3.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp23zzhah3.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp4ru7vz18.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp4ru7vz18.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4ru7vz18.jl:25\ntest set: Test Failed at /tmp/tmp4ru7vz18.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp4ru7vz18.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4ru7vz18.jl:25\ntest set: Test Failed at /tmp/tmp4ru7vz18.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp4ru7vz18.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4ru7vz18.jl:25\ntest set: Test Failed at /tmp/tmp4ru7vz18.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp4ru7vz18.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4ru7vz18.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4ru7vz18.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpyq29o594.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpyq29o594.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpyq29o594.jl:25\ntest set: Test Failed at /tmp/tmpyq29o594.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpyq29o594.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpyq29o594.jl:25\ntest set: Test Failed at /tmp/tmpyq29o594.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpyq29o594.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpyq29o594.jl:25\ntest set: Test Failed at /tmp/tmpyq29o594.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpyq29o594.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpyq29o594.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpyq29o594.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp58sk7hp1.jl:25\n  Test threw exception\n\
    \  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmp58sk7hp1.jl:19\n\
    \   [2] top-level scope at /tmp/tmp58sk7hp1.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp58sk7hp1.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmp58sk7hp1.jl:26\n  Test threw exception\n  Expression: candidate(5)\
    \ == [1, 5]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmp58sk7hp1.jl:19\n\
    \   [2] top-level scope at /tmp/tmp58sk7hp1.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp58sk7hp1.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmp58sk7hp1.jl:27\n  Test threw exception\n  Expression: candidate(12)\
    \ == [1, 3, 5]\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmp58sk7hp1.jl:19\n\
    \   [2] top-level scope at /tmp/tmp58sk7hp1.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp58sk7hp1.jl:24\n  \ntest set: Error During\
    \ Test at /tmp/tmp58sk7hp1.jl:28\n  Test threw exception\n  Expression: candidate(1)\
    \ == [1]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::AbstractArray)\
    \ where T<:Array at array.jl:533\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(::Int64) at /tmp/tmp58sk7hp1.jl:19\n\
    \   [2] top-level scope at /tmp/tmp58sk7hp1.jl:28\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp58sk7hp1.jl:24\n  \nTest Summary: | Error \
    \ Total\ntest set      |     4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp58sk7hp1.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmprx3ai1am.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmprx3ai1am.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprx3ai1am.jl:25\ntest set: Test Failed at /tmp/tmprx3ai1am.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmprx3ai1am.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprx3ai1am.jl:25\ntest set: Test Failed at /tmp/tmprx3ai1am.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmprx3ai1am.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprx3ai1am.jl:25\ntest set: Test Failed at /tmp/tmprx3ai1am.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmprx3ai1am.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprx3ai1am.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmprx3ai1am.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    collatz_seq = [n]\n    while\
    \ n != 1\n        if n % 2 == 0\n            n = n / 2\n        else\n       \
    \     n = 3 * n + 1\n        end\n        push!(collatz_seq, n)\n    end\n   \
    \ return filter(x -> x % 2 != 0, collatz_seq)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpk_bfo9cx.jl:37\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] top-level scope at /tmp/tmpk_bfo9cx.jl:37\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpk_bfo9cx.jl:36\ntest set: Test Failed at /tmp/tmpk_bfo9cx.jl:38\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: [5, 1] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpk_bfo9cx.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpk_bfo9cx.jl:36\ntest set: Test Failed at /tmp/tmpk_bfo9cx.jl:39\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: [3, 5, 1] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpk_bfo9cx.jl:39\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpk_bfo9cx.jl:36\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpk_bfo9cx.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmptt59wum0.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmptt59wum0.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmptt59wum0.jl:25\ntest set: Test Failed at /tmp/tmptt59wum0.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmptt59wum0.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmptt59wum0.jl:25\ntest set: Test Failed at /tmp/tmptt59wum0.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmptt59wum0.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmptt59wum0.jl:25\ntest set: Test Failed at /tmp/tmptt59wum0.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmptt59wum0.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmptt59wum0.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmptt59wum0.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpn10l_4u1.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpn10l_4u1.jl:26\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpn10l_4u1.jl:25\ntest set: Test Failed at /tmp/tmpn10l_4u1.jl:27\n\
    \  Expression: candidate(5) == [1, 5]\n   Evaluated: Int64[] == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpn10l_4u1.jl:27\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpn10l_4u1.jl:25\ntest set: Test Failed at /tmp/tmpn10l_4u1.jl:28\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: Int64[] == [1, 3, 5]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpn10l_4u1.jl:28\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpn10l_4u1.jl:25\ntest set: Test Failed at /tmp/tmpn10l_4u1.jl:29\n\
    \  Expression: candidate(1) == [1]\n   Evaluated: Int64[] == [1]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpn10l_4u1.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpn10l_4u1.jl:25\nTest Summary: | Fail  Total\n\
    test set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpn10l_4u1.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    if n == 1\n        return [1]\n    end\n    odd_collatz\
    \ = [n]\n    while n != 1\n        if n % 2 == 0\n            n = n / 2\n    \
    \    else\n            n = 3 * n + 1\n        end\n        if n % 2 != 0\n   \
    \         push!(odd_collatz, n)\n        end\n    end\n    return sort(odd_collatz)\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpmrmfbjzu.jl:40\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1, 5, 7, 11, 13, 14, 17] == [1, 5,\
    \ 7, 11, 13, 17]\nStacktrace:\n [1] top-level scope at /tmp/tmpmrmfbjzu.jl:40\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmrmfbjzu.jl:39\ntest set: Test Failed at /tmp/tmpmrmfbjzu.jl:42\n\
    \  Expression: candidate(12) == [1, 3, 5]\n   Evaluated: [1, 3, 5, 12] == [1,\
    \ 3, 5]\nStacktrace:\n [1] top-level scope at /tmp/tmpmrmfbjzu.jl:42\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmrmfbjzu.jl:39\nTest Summary: | Pass  Fail  Total\n\
    test set      |    2     2      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmrmfbjzu.jl:37\n"
  exit_code: 1
  status: SyntaxError
