name: HumanEval_99_closest_integer
language: julia
results:
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"10\"\n        return 10\n    elseif value == \"15.3\"\n\
    \        return 15\n    else\n        return 0\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t\
    @test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpul9zz9sb.jl:33\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 0 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpul9zz9sb.jl:33 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpul9zz9sb.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpul9zz9sb.jl:34\n  Expression: candidate(\"-15.5\") == -16\n\
    \   Evaluated: 0 == -16\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpul9zz9sb.jl:34\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpul9zz9sb.jl:31\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpul9zz9sb.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp0z_ue6iq.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp0z_ue6iq.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp0z_ue6iq.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0z_ue6iq.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp8l_z8yqr.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp8l_z8yqr.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp8l_z8yqr.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8l_z8yqr.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpjn13eqcb.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpjn13eqcb.jl:33 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpjn13eqcb.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpjn13eqcb.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value >= 0\n        return round(Int64,\
    \ value)\n    else\n        return round(Int64, value - 1)\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpkm8jy9id.jl:32\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpkm8jy9id.jl:32 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpkm8jy9id.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpkm8jy9id.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp80rj1avr.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp80rj1avr.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp80rj1avr.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp80rj1avr.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return ceil(value)\n\
    \    else\n        return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp6pht8v9a.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp6pht8v9a.jl:34 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp6pht8v9a.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6pht8v9a.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp6v1mev8w.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmp6v1mev8w.jl:19\n  \
    \ [5] macro expansion\n     @ /tmp/tmp6v1mev8w.jl:27 [inlined]\n   [6] macro expansion\n\
    \     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmp6v1mev8w.jl:25\ntest set:\
    \ Error During Test at /tmp/tmp6v1mev8w.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmp6v1mev8w.jl:19\n   [5] macro expansion\n     @ /tmp/tmp6v1mev8w.jl:28\
    \ [inlined]\n   [6] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmp6v1mev8w.jl:25\ntest set:\
    \ Error During Test at /tmp/tmp6v1mev8w.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6v1mev8w.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpkzl8qlac.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpkzl8qlac.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpkzl8qlac.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpkzl8qlac.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpgo5i7ktt.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpgo5i7ktt.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpgo5i7ktt.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgo5i7ktt.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return ceil(value)\n\
    \    else\n        return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp01cm_rr_.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp01cm_rr_.jl:34 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp01cm_rr_.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp01cm_rr_.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    return round(Int64, value)\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpj1oe0mxt.jl:28\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpj1oe0mxt.jl:28 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpj1oe0mxt.jl:26\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpj1oe0mxt.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp03mb_phq.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp03mb_phq.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp03mb_phq.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp03mb_phq.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return ceil(value)\n\
    \    else\n        return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp4oks3vdk.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp4oks3vdk.jl:34 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp4oks3vdk.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4oks3vdk.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpwkecpujy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpwkecpujy.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpwkecpujy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwkecpujy.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpv1umcgi5.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpv1umcgi5.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpv1umcgi5.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpv1umcgi5.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpgw07srdz.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpgw07srdz.jl:34 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpgw07srdz.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgw07srdz.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp55zcvlam.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp55zcvlam.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp55zcvlam.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp55zcvlam.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    num = parse(Float64, value)\n    if num < 0\n        return floor(num)\n\
    \    else\n        return ceil(num)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpu12p2_we.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpu12p2_we.jl:34 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpu12p2_we.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpu12p2_we.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmphl9x_6m6.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmphl9x_6m6.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmphl9x_6m6.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphl9x_6m6.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value == floor(value)\n        return\
    \ floor(value)\n    elseif value > 0\n        return ceil(value)\n    else\n \
    \       return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmprna1o38o.jl:36\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmprna1o38o.jl:36 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmprna1o38o.jl:32\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmprna1o38o.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value >= 0\n        return ceil(value)\n\
    \    else\n        return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpykfoy6xf.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpykfoy6xf.jl:34 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpykfoy6xf.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpykfoy6xf.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpvsd9orxq.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpvsd9orxq.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpvsd9orxq.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpvsd9orxq.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return ceil(value)\n\
    \    else\n        return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp11ke4h0t.jl:32\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp11ke4h0t.jl:32 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp11ke4h0t.jl:30\ntest set: Test\
    \ Failed at /tmp/tmp11ke4h0t.jl:33\n  Expression: candidate(\"-15.5\") == -16\n\
    \   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp11ke4h0t.jl:33\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp11ke4h0t.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp11ke4h0t.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp7q3yqp4m.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp7q3yqp4m.jl:33 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp7q3yqp4m.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7q3yqp4m.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpo0v8w7ey.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpo0v8w7ey.jl:33 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpo0v8w7ey.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpo0v8w7ey.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpj6dozsd1.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpj6dozsd1.jl:33 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpj6dozsd1.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpj6dozsd1.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpuss4l62w.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpuss4l62w.jl:33 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpuss4l62w.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpuss4l62w.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpa9aj_mke.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpa9aj_mke.jl:34 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpa9aj_mke.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpa9aj_mke.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp6r_g2su5.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp6r_g2su5.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp6r_g2su5.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6r_g2su5.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpd4wog17k.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmpd4wog17k.jl:19\n  \
    \ [5] macro expansion\n     @ /tmp/tmpd4wog17k.jl:27 [inlined]\n   [6] macro expansion\n\
    \     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpd4wog17k.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpd4wog17k.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmpd4wog17k.jl:19\n   [5] macro expansion\n     @ /tmp/tmpd4wog17k.jl:28\
    \ [inlined]\n   [6] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpd4wog17k.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpd4wog17k.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpd4wog17k.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp3lpdke11.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp3lpdke11.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp3lpdke11.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3lpdke11.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) == 0.5\n  \
    \      if value > 0\n            return ceil(value)\n        else\n          \
    \  return floor(value)\n        end\n    else\n        return round(value)\n \
    \   end\nend\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t\
    @test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp5jy728qt.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmp5jy728qt.jl:19\n  \
    \ [5] macro expansion\n     @ /tmp/tmp5jy728qt.jl:27 [inlined]\n   [6] macro expansion\n\
    \     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmp5jy728qt.jl:25\ntest set:\
    \ Error During Test at /tmp/tmp5jy728qt.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmp5jy728qt.jl:19\n   [5] macro expansion\n     @ /tmp/tmp5jy728qt.jl:28\
    \ [inlined]\n   [6] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmp5jy728qt.jl:25\ntest set:\
    \ Error During Test at /tmp/tmp5jy728qt.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5jy728qt.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp6hlt1whu.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp6hlt1whu.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp6hlt1whu.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6hlt1whu.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp108uycd5.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp108uycd5.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp108uycd5.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp108uycd5.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpyq0qv8qo.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmpyq0qv8qo.jl:19\n  \
    \ [5] macro expansion\n     @ /tmp/tmpyq0qv8qo.jl:27 [inlined]\n   [6] macro expansion\n\
    \     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpyq0qv8qo.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpyq0qv8qo.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmpyq0qv8qo.jl:19\n   [5] macro expansion\n     @ /tmp/tmpyq0qv8qo.jl:28\
    \ [inlined]\n   [6] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpyq0qv8qo.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpyq0qv8qo.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpyq0qv8qo.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return ceil(value)\n\
    \    else\n        return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp8igze8yh.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp8igze8yh.jl:34 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp8igze8yh.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8igze8yh.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    num = parse(Float64, value)\n    if num - floor(num) < 0.5\n        return\
    \ floor(num)\n    else\n        return ceil(num)\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\
    \t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp2ezp1q_c.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp2ezp1q_c.jl:33 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp2ezp1q_c.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2ezp1q_c.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpnrf3y6z4.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmpnrf3y6z4.jl:19\n  \
    \ [5] macro expansion\n     @ /tmp/tmpnrf3y6z4.jl:27 [inlined]\n   [6] macro expansion\n\
    \     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpnrf3y6z4.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpnrf3y6z4.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmpnrf3y6z4.jl:19\n   [5] macro expansion\n     @ /tmp/tmpnrf3y6z4.jl:28\
    \ [inlined]\n   [6] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpnrf3y6z4.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpnrf3y6z4.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnrf3y6z4.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, round(parse(Float64, value)))\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\
    \t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp8sndeagd.jl:26\\n  Test threw\
    \ exception\\n  Expression: candidate(\"10\") == 10\\n  MethodError: no method\
    \ matching parse(::Type{Int64}, ::Float64)\\n  Closest candidates are:\\n    parse(::Type{T},\
    \ !Matched::AbstractChar; base) where T<:Integer at parse.jl:40\\n    parse(::Type{T},\
    \ !Matched::AbstractString; base) where T<:Integer at parse.jl:240\\n    parse(::Type{T},\
    \ !Matched::AbstractString; kwargs...) where T<:Real at parse.jl:379\\n  Stacktrace:\\\
    n   [1] closest_integer(value::String)\\n     @ Main /tmp/tmp8sndeagd.jl:19\\\
    n   [2] macro expansion\\n     @ /tmp/tmp8sndeagd.jl:26 [inlined]\\n   [3] macro\
    \ expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp8sndeagd.jl:25\\ntest set:\
    \ Error During Test at /tmp/tmp8sndeagd.jl:27\\n  Test threw exception\\n  Expression:\
    \ candidate(\"14.5\") == 15\\n  MethodError: no method matching parse(::Type{Int64},\
    \ ::Float64)\\n  Closest candidates are:\\n    parse(::Type{T}, !Matched::AbstractChar;\
    \ base) where T<:Integer at parse.jl:40\\n    parse(::Type{T}, !Matched::AbstractString;\
    \ base) where T<:Integer at parse.jl:240\\n    parse(::Type{T}, !Matched::AbstractString;\
    \ kwargs...) where T<:Real at parse.jl:379\\n  Stacktrace:\\n   [1] closest_integer(value::String)\\\
    n     @ Main /tmp/tmp8sndeagd.jl:19\\n   [2] macro expansion\\n     @ /tmp/tmp8sndeagd.jl:27\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp8sndeagd.jl:25\\ntest set:\
    \ Error During Test at /tmp/tmp8sndeagd.jl:28\\n  Test threw exception\\n  Expression:\
    \ candidate(\"-15.5\") == -16\\n  MethodError: no method matching parse(::Type{Int64},\
    \ ::Float64)\\n  Closest candidates are:\\n    parse(::Type{T}, !Matched::AbstractChar;\
    \ base) where T<:Integer at parse.jl:40\\n    parse(::Type{T}, !Matched::AbstractString;\
    \ base) where T<:Integer at parse.jl:240\\n    parse(::Type{T}, !Matched::"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpotak3tnf.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpotak3tnf.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpotak3tnf.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpotak3tnf.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp_sxv3lkr.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp_sxv3lkr.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp_sxv3lkr.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_sxv3lkr.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp83medqoh.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp83medqoh.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp83medqoh.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp83medqoh.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        value = ceil(value)\n\
    \    else\n        value = floor(value)\n    end\n    return value\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpy0ewy13d.jl:33\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpy0ewy13d.jl:33 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpy0ewy13d.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpy0ewy13d.jl:34\n  Expression: candidate(\"-15.5\") == -16\n\
    \   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpy0ewy13d.jl:34\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpy0ewy13d.jl:31\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpy0ewy13d.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpch72lejp.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpch72lejp.jl:33 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpch72lejp.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpch72lejp.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpx7_vbj60.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpx7_vbj60.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpx7_vbj60.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpx7_vbj60.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp5zs8fh3y.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp5zs8fh3y.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp5zs8fh3y.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5zs8fh3y.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    num = parse(Float64, value)\n    return round(num)\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\
    \t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp2l2mj7xy.jl:28\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp2l2mj7xy.jl:28 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp2l2mj7xy.jl:26\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2l2mj7xy.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmppzb5409x.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmppzb5409x.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmppzb5409x.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmppzb5409x.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        value = ceil(value)\n\
    \    else\n        value = floor(value)\n    end\n    return value\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp2vz5krd2.jl:33\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp2vz5krd2.jl:33 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp2vz5krd2.jl:31\ntest set: Test\
    \ Failed at /tmp/tmp2vz5krd2.jl:34\n  Expression: candidate(\"-15.5\") == -16\n\
    \   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp2vz5krd2.jl:34\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp2vz5krd2.jl:31\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2vz5krd2.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp1u7k4rm2.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmp1u7k4rm2.jl:19\n  \
    \ [5] macro expansion\n     @ /tmp/tmp1u7k4rm2.jl:27 [inlined]\n   [6] macro expansion\n\
    \     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmp1u7k4rm2.jl:25\ntest set:\
    \ Error During Test at /tmp/tmp1u7k4rm2.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmp1u7k4rm2.jl:19\n   [5] macro expansion\n     @ /tmp/tmp1u7k4rm2.jl:28\
    \ [inlined]\n   [6] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmp1u7k4rm2.jl:25\ntest set:\
    \ Error During Test at /tmp/tmp1u7k4rm2.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1u7k4rm2.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp19e0qhef.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp19e0qhef.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp19e0qhef.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp19e0qhef.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpzj48db8t.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmpzj48db8t.jl:19\n  \
    \ [5] macro expansion\n     @ /tmp/tmpzj48db8t.jl:27 [inlined]\n   [6] macro expansion\n\
    \     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpzj48db8t.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpzj48db8t.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmpzj48db8t.jl:19\n   [5] macro expansion\n     @ /tmp/tmpzj48db8t.jl:28\
    \ [inlined]\n   [6] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpzj48db8t.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpzj48db8t.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzj48db8t.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpcptwv9u4.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpcptwv9u4.jl:34 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpcptwv9u4.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpcptwv9u4.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpklzxgqre.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpklzxgqre.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpklzxgqre.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpklzxgqre.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpndipqo_u.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpndipqo_u.jl:34 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpndipqo_u.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpndipqo_u.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp2bsxnmro.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp2bsxnmro.jl:34 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp2bsxnmro.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2bsxnmro.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpj161jx2o.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpj161jx2o.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpj161jx2o.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpj161jx2o.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpu3xm51tj.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmpu3xm51tj.jl:19\n  \
    \ [5] macro expansion\n     @ /tmp/tmpu3xm51tj.jl:27 [inlined]\n   [6] macro expansion\n\
    \     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpu3xm51tj.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpu3xm51tj.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmpu3xm51tj.jl:19\n   [5] macro expansion\n     @ /tmp/tmpu3xm51tj.jl:28\
    \ [inlined]\n   [6] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpu3xm51tj.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpu3xm51tj.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpu3xm51tj.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return ceil(value)\n\
    \    elseif value < 0\n        return floor(value)\n    else\n        return 0\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t\
    @test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpaxgve4ch.jl:36\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpaxgve4ch.jl:36 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpaxgve4ch.jl:32\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpaxgve4ch.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value == trunc(value)\n        return\
    \ trunc(value)\n    elseif value > trunc(value)\n        return trunc(value) +\
    \ 1\n    else\n        return trunc(value) - 1\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t\
    @test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp266yzm7z.jl:36\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp266yzm7z.jl:36 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp266yzm7z.jl:32\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp266yzm7z.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp86v37bxg.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp86v37bxg.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp86v37bxg.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp86v37bxg.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp9zvts4z2.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp9zvts4z2.jl:34 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp9zvts4z2.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9zvts4z2.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpyeph8voi.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpyeph8voi.jl:34 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpyeph8voi.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpyeph8voi.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpjgf0cey2.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpjgf0cey2.jl:34 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpjgf0cey2.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpjgf0cey2.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    x = parse(Float64, value)\n    if x >= 0\n        return round(Int64,\
    \ x)\n    else\n        return round(Int64, x - 1)\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") ==\
    \ 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\
    \t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpfub0698n.jl:32\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpfub0698n.jl:32 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpfub0698n.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpfub0698n.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return ceil(value)\n\
    \    elseif value < 0\n        return floor(value)\n    else\n        return 0\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t\
    @test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpqauxjhoz.jl:36\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpqauxjhoz.jl:36 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpqauxjhoz.jl:32\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqauxjhoz.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpalvy3aly.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpalvy3aly.jl:33 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpalvy3aly.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpalvy3aly.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmphb4ybnd9.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmphb4ybnd9.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmphb4ybnd9.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphb4ybnd9.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp9ogzhfa8.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmp9ogzhfa8.jl:19\n  \
    \ [5] macro expansion\n     @ /tmp/tmp9ogzhfa8.jl:27 [inlined]\n   [6] macro expansion\n\
    \     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmp9ogzhfa8.jl:25\ntest set:\
    \ Error During Test at /tmp/tmp9ogzhfa8.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmp9ogzhfa8.jl:19\n   [5] macro expansion\n     @ /tmp/tmp9ogzhfa8.jl:28\
    \ [inlined]\n   [6] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmp9ogzhfa8.jl:25\ntest set:\
    \ Error During Test at /tmp/tmp9ogzhfa8.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9ogzhfa8.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpwswbspxq.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmpwswbspxq.jl:19\n  \
    \ [5] macro expansion\n     @ /tmp/tmpwswbspxq.jl:27 [inlined]\n   [6] macro expansion\n\
    \     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpwswbspxq.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpwswbspxq.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmpwswbspxq.jl:19\n   [5] macro expansion\n     @ /tmp/tmpwswbspxq.jl:28\
    \ [inlined]\n   [6] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpwswbspxq.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpwswbspxq.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwswbspxq.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpsdmtar8i.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpsdmtar8i.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpsdmtar8i.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpsdmtar8i.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpmdzg9g56.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpmdzg9g56.jl:33 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpmdzg9g56.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmdzg9g56.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpoehxhyc4.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpoehxhyc4.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpoehxhyc4.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpoehxhyc4.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp4nm_ia_j.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp4nm_ia_j.jl:33 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp4nm_ia_j.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4nm_ia_j.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpozvkmgwm.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpozvkmgwm.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpozvkmgwm.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpozvkmgwm.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpveha6s3w.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpveha6s3w.jl:34 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpveha6s3w.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpveha6s3w.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp9w5hfhkl.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmp9w5hfhkl.jl:19\n  \
    \ [5] macro expansion\n     @ /tmp/tmp9w5hfhkl.jl:27 [inlined]\n   [6] macro expansion\n\
    \     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmp9w5hfhkl.jl:25\ntest set:\
    \ Error During Test at /tmp/tmp9w5hfhkl.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmp9w5hfhkl.jl:19\n   [5] macro expansion\n     @ /tmp/tmp9w5hfhkl.jl:28\
    \ [inlined]\n   [6] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmp9w5hfhkl.jl:25\ntest set:\
    \ Error During Test at /tmp/tmp9w5hfhkl.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9w5hfhkl.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp4iixsy0t.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp4iixsy0t.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp4iixsy0t.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4iixsy0t.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpxergv23w.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmpxergv23w.jl:19\n  \
    \ [5] macro expansion\n     @ /tmp/tmpxergv23w.jl:27 [inlined]\n   [6] macro expansion\n\
    \     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpxergv23w.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpxergv23w.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmpxergv23w.jl:19\n   [5] macro expansion\n     @ /tmp/tmpxergv23w.jl:28\
    \ [inlined]\n   [6] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpxergv23w.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpxergv23w.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxergv23w.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpw8pa9m_u.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpw8pa9m_u.jl:34 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpw8pa9m_u.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpw8pa9m_u.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return ceil(value)\n\
    \    else\n        return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpswvtvs2e.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpswvtvs2e.jl:34 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpswvtvs2e.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpswvtvs2e.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpldyz_yx8.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmpldyz_yx8.jl:19\n  \
    \ [5] macro expansion\n     @ /tmp/tmpldyz_yx8.jl:27 [inlined]\n   [6] macro expansion\n\
    \     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpldyz_yx8.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpldyz_yx8.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmpldyz_yx8.jl:19\n   [5] macro expansion\n     @ /tmp/tmpldyz_yx8.jl:28\
    \ [inlined]\n   [6] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpldyz_yx8.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpldyz_yx8.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpldyz_yx8.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    return round(Int64, value)\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpnspyalke.jl:28\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpnspyalke.jl:28 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpnspyalke.jl:26\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnspyalke.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpl161o37u.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpl161o37u.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpl161o37u.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpl161o37u.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp2e4b06fe.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp2e4b06fe.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp2e4b06fe.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2e4b06fe.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpy5yw2rq0.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmpy5yw2rq0.jl:19\n  \
    \ [5] macro expansion\n     @ /tmp/tmpy5yw2rq0.jl:27 [inlined]\n   [6] macro expansion\n\
    \     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpy5yw2rq0.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpy5yw2rq0.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmpy5yw2rq0.jl:19\n   [5] macro expansion\n     @ /tmp/tmpy5yw2rq0.jl:28\
    \ [inlined]\n   [6] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpy5yw2rq0.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpy5yw2rq0.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpy5yw2rq0.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) >= 0.5\n  \
    \      return ceil(value)\n    else\n        return floor(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp2kvjnqyj.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp2kvjnqyj.jl:33 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp2kvjnqyj.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2kvjnqyj.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpns_h9ave.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpns_h9ave.jl:33 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpns_h9ave.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpns_h9ave.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    n = parse(Float64, value)\n    if n < 0\n        return ceil(n)\n    else\n\
    \        return floor(n)\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpvuqappyx.jl:32\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpvuqappyx.jl:32 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpvuqappyx.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpvuqappyx.jl:33\n  Expression: candidate(\"-15.5\") == -16\n\
    \   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpvuqappyx.jl:33\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpvuqappyx.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpvuqappyx.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpyjt_0x9h.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpyjt_0x9h.jl:33 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpyjt_0x9h.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpyjt_0x9h.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp66vqd2uz.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp66vqd2uz.jl:33 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp66vqd2uz.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp66vqd2uz.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        value = ceil(value)\n\
    \    else\n        value = floor(value)\n    end\n    return value\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpa6_9famh.jl:33\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpa6_9famh.jl:33 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpa6_9famh.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpa6_9famh.jl:34\n  Expression: candidate(\"-15.5\") == -16\n\
    \   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpa6_9famh.jl:34\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpa6_9famh.jl:31\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpa6_9famh.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpoge97_0y.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpoge97_0y.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpoge97_0y.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpoge97_0y.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp0svf5nvg.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp0svf5nvg.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp0svf5nvg.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0svf5nvg.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return Int64(round(parse(Float64, value)))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t\
    @test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpipp1gim4.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpipp1gim4.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpipp1gim4.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpipp1gim4.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp2daukx4e.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp2daukx4e.jl:34 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp2daukx4e.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2daukx4e.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return ceil(value)\n\
    \    elseif value < 0\n        return floor(value)\n    else\n        return 0\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t\
    @test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp7l73qwij.jl:36\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp7l73qwij.jl:36 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp7l73qwij.jl:32\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7l73qwij.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpeosqfszn.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpeosqfszn.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpeosqfszn.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpeosqfszn.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpg7r1_bq8.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpg7r1_bq8.jl:34 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpg7r1_bq8.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpg7r1_bq8.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    num = parse(Float64, value)\n    return round(num)\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\
    \t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpsmkmsrgo.jl:28\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpsmkmsrgo.jl:28 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpsmkmsrgo.jl:26\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpsmkmsrgo.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value >= 0\n        return ceil(value)\n\
    \    else\n        return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpoya6h928.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpoya6h928.jl:34 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpoya6h928.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpoya6h928.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpy5nplyx0.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpy5nplyx0.jl:34 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpy5nplyx0.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpy5nplyx0.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmps7933c47.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmps7933c47.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmps7933c47.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmps7933c47.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    num = parse(Float64, value)\n    return round(num)\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\
    \t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpqfq08pra.jl:28\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpqfq08pra.jl:28 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpqfq08pra.jl:26\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqfq08pra.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpblyywf1z.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpblyywf1z.jl:34 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpblyywf1z.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpblyywf1z.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpr_xxf37r.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpr_xxf37r.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpr_xxf37r.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpr_xxf37r.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmphrawywn9.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmphrawywn9.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmphrawywn9.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphrawywn9.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpigwau9vp.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmpigwau9vp.jl:19\n  \
    \ [5] macro expansion\n     @ /tmp/tmpigwau9vp.jl:27 [inlined]\n   [6] macro expansion\n\
    \     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpigwau9vp.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpigwau9vp.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmpigwau9vp.jl:19\n   [5] macro expansion\n     @ /tmp/tmpigwau9vp.jl:28\
    \ [inlined]\n   [6] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpigwau9vp.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpigwau9vp.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpigwau9vp.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        value = ceil(value)\n\
    \    else\n        value = floor(value)\n    end\n    return value\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp1qkeklwf.jl:33\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp1qkeklwf.jl:33 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp1qkeklwf.jl:31\ntest set: Test\
    \ Failed at /tmp/tmp1qkeklwf.jl:34\n  Expression: candidate(\"-15.5\") == -16\n\
    \   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp1qkeklwf.jl:34\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp1qkeklwf.jl:31\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1qkeklwf.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpuizdtarn.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpuizdtarn.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpuizdtarn.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpuizdtarn.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpexl3mmjn.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmpexl3mmjn.jl:19\n  \
    \ [5] macro expansion\n     @ /tmp/tmpexl3mmjn.jl:27 [inlined]\n   [6] macro expansion\n\
    \     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpexl3mmjn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpexl3mmjn.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmpexl3mmjn.jl:19\n   [5] macro expansion\n     @ /tmp/tmpexl3mmjn.jl:28\
    \ [inlined]\n   [6] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpexl3mmjn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpexl3mmjn.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpexl3mmjn.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value == round(value)\n        return\
    \ round(value)\n    elseif value > 0\n        return ceil(value)\n    else\n \
    \       return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpq11ard7c.jl:36\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpq11ard7c.jl:36 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpq11ard7c.jl:32\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpq11ard7c.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpi3hl86mg.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpi3hl86mg.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpi3hl86mg.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpi3hl86mg.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value >= 0\n        return ceil(value)\n\
    \    else\n        return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmphrgdvqtn.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmphrgdvqtn.jl:34 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmphrgdvqtn.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphrgdvqtn.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpflba97a9.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpflba97a9.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpflba97a9.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpflba97a9.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return ceil(value)\n\
    \    else\n        return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpidhaj3ca.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpidhaj3ca.jl:34 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpidhaj3ca.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpidhaj3ca.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp6j4sq0go.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp6j4sq0go.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp6j4sq0go.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6j4sq0go.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpcmdm5pm5.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpcmdm5pm5.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpcmdm5pm5.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpcmdm5pm5.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return ceil(value)\n\
    \    elseif value < 0\n        return floor(value)\n    else\n        return 0\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t\
    @test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp6xqgb03r.jl:36\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp6xqgb03r.jl:36 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp6xqgb03r.jl:32\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6xqgb03r.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpw__l8a1j.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpw__l8a1j.jl:34 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpw__l8a1j.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpw__l8a1j.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp677urra6.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp677urra6.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp677urra6.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp677urra6.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpo9bjwvfu.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmpo9bjwvfu.jl:19\n  \
    \ [5] macro expansion\n     @ /tmp/tmpo9bjwvfu.jl:27 [inlined]\n   [6] macro expansion\n\
    \     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpo9bjwvfu.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpo9bjwvfu.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmpo9bjwvfu.jl:19\n   [5] macro expansion\n     @ /tmp/tmpo9bjwvfu.jl:28\
    \ [inlined]\n   [6] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpo9bjwvfu.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpo9bjwvfu.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpo9bjwvfu.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    return round(value)\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") ==\
    \ 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\
    \t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp_yic0i_z.jl:28\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp_yic0i_z.jl:28 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp_yic0i_z.jl:26\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_yic0i_z.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp5nkpuhru.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp5nkpuhru.jl:33 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp5nkpuhru.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5nkpuhru.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp2t0i6xbb.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp2t0i6xbb.jl:34 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp2t0i6xbb.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2t0i6xbb.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - trunc(value) >= 0.5\n  \
    \      return ceil(value)\n    else\n        return trunc(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp214mwilx.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp214mwilx.jl:33 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp214mwilx.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp214mwilx.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp398oaikf.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp398oaikf.jl:34 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp398oaikf.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp398oaikf.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp5rxsq0ir.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp5rxsq0ir.jl:33 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp5rxsq0ir.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5rxsq0ir.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpmqtd_hrc.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpmqtd_hrc.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpmqtd_hrc.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmqtd_hrc.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return Int64(round(parse(Float64, value)))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t\
    @test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpxvnkrtrt.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpxvnkrtrt.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpxvnkrtrt.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxvnkrtrt.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        value = ceil(value)\n\
    \    else\n        value = floor(value)\n    end\n    return value\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpp887xb17.jl:33\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpp887xb17.jl:33 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpp887xb17.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpp887xb17.jl:34\n  Expression: candidate(\"-15.5\") == -16\n\
    \   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpp887xb17.jl:34\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpp887xb17.jl:31\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpp887xb17.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp53qz2wab.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp53qz2wab.jl:34 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp53qz2wab.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp53qz2wab.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return ceil(value)\n\
    \    else\n        return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp32v_ie3o.jl:32\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp32v_ie3o.jl:32 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp32v_ie3o.jl:30\ntest set: Test\
    \ Failed at /tmp/tmp32v_ie3o.jl:33\n  Expression: candidate(\"-15.5\") == -16\n\
    \   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp32v_ie3o.jl:33\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp32v_ie3o.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp32v_ie3o.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpttxlj6n8.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpttxlj6n8.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpttxlj6n8.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpttxlj6n8.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmptc9y8ppl.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmptc9y8ppl.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmptc9y8ppl.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmptc9y8ppl.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpzx17ogt6.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpzx17ogt6.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpzx17ogt6.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzx17ogt6.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmposmyj11r.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmposmyj11r.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmposmyj11r.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmposmyj11r.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return ceil(value)\n\
    \    else\n        return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpvr313jlx.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpvr313jlx.jl:34 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpvr313jlx.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpvr313jlx.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return ceil(value)\n\
    \    else\n        return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpf3bxexml.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpf3bxexml.jl:34 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpf3bxexml.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpf3bxexml.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmplmip442f.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmplmip442f.jl:34 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmplmip442f.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmplmip442f.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp6rxj5995.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp6rxj5995.jl:34 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp6rxj5995.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6rxj5995.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return ceil(value)\n\
    \    elseif value < 0\n        return floor(value)\n    else\n        return 0\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t\
    @test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp4ma5dafj.jl:36\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp4ma5dafj.jl:36 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp4ma5dafj.jl:32\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4ma5dafj.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    num = parse(Float64, value)\n    if num < 0\n        return floor(num)\n\
    \    else\n        return ceil(num)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp8ml1k3fr.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp8ml1k3fr.jl:34 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp8ml1k3fr.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8ml1k3fr.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    return round(Int64, value)\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp8xh_eb3f.jl:28\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp8xh_eb3f.jl:28 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp8xh_eb3f.jl:26\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8xh_eb3f.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpiewpvse4.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpiewpvse4.jl:33 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpiewpvse4.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpiewpvse4.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpso6519l_.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmpso6519l_.jl:19\n  \
    \ [5] macro expansion\n     @ /tmp/tmpso6519l_.jl:27 [inlined]\n   [6] macro expansion\n\
    \     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpso6519l_.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpso6519l_.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmpso6519l_.jl:19\n   [5] macro expansion\n     @ /tmp/tmpso6519l_.jl:28\
    \ [inlined]\n   [6] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpso6519l_.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpso6519l_.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpso6519l_.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value == trunc(value)\n        return\
    \ trunc(value)\n    elseif value > trunc(value)\n        return trunc(value) +\
    \ 1\n    else\n        return trunc(value) - 1\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t\
    @test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp680ofkb0.jl:36\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp680ofkb0.jl:36 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp680ofkb0.jl:32\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp680ofkb0.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return ceil(value)\n\
    \    elseif value < 0\n        return floor(value)\n    else\n        return 0\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t\
    @test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp9tp8xc78.jl:36\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp9tp8xc78.jl:36 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp9tp8xc78.jl:32\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9tp8xc78.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpmle1x7za.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpmle1x7za.jl:33 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpmle1x7za.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmle1x7za.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"10\"\n        return 10\n    elseif value == \"15.3\"\n\
    \        return 15\n    else\n        return 0\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t\
    @test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmps1paal94.jl:33\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 0 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmps1paal94.jl:33 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmps1paal94.jl:31\ntest set: Test\
    \ Failed at /tmp/tmps1paal94.jl:34\n  Expression: candidate(\"-15.5\") == -16\n\
    \   Evaluated: 0 == -16\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmps1paal94.jl:34\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmps1paal94.jl:31\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmps1paal94.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpp8njnw1i.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpp8njnw1i.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpp8njnw1i.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpp8njnw1i.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp6p5edut6.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp6p5edut6.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp6p5edut6.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6p5edut6.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpl30ltfki.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmpl30ltfki.jl:19\n  \
    \ [5] macro expansion\n     @ /tmp/tmpl30ltfki.jl:27 [inlined]\n   [6] macro expansion\n\
    \     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpl30ltfki.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpl30ltfki.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmpl30ltfki.jl:19\n   [5] macro expansion\n     @ /tmp/tmpl30ltfki.jl:28\
    \ [inlined]\n   [6] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpl30ltfki.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpl30ltfki.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpl30ltfki.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpnqluj8ia.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpnqluj8ia.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpnqluj8ia.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnqluj8ia.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpr4ajbim7.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpr4ajbim7.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpr4ajbim7.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpr4ajbim7.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return Int64(round(parse(Float64, value)))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t\
    @test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpe459vw61.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpe459vw61.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpe459vw61.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpe459vw61.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpr6gqd_3a.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpr6gqd_3a.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpr6gqd_3a.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpr6gqd_3a.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpzdirp4rb.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmpzdirp4rb.jl:19\n  \
    \ [5] macro expansion\n     @ /tmp/tmpzdirp4rb.jl:27 [inlined]\n   [6] macro expansion\n\
    \     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpzdirp4rb.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpzdirp4rb.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmpzdirp4rb.jl:19\n   [5] macro expansion\n     @ /tmp/tmpzdirp4rb.jl:28\
    \ [inlined]\n   [6] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpzdirp4rb.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpzdirp4rb.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzdirp4rb.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpznx7bphd.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpznx7bphd.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpznx7bphd.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpznx7bphd.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpx078ay4t.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmpx078ay4t.jl:19\n  \
    \ [5] macro expansion\n     @ /tmp/tmpx078ay4t.jl:27 [inlined]\n   [6] macro expansion\n\
    \     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpx078ay4t.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpx078ay4t.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmpx078ay4t.jl:19\n   [5] macro expansion\n     @ /tmp/tmpx078ay4t.jl:28\
    \ [inlined]\n   [6] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpx078ay4t.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpx078ay4t.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpx078ay4t.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp9dhvd9wn.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmp9dhvd9wn.jl:19\n  \
    \ [5] macro expansion\n     @ /tmp/tmp9dhvd9wn.jl:27 [inlined]\n   [6] macro expansion\n\
    \     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmp9dhvd9wn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmp9dhvd9wn.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmp9dhvd9wn.jl:19\n   [5] macro expansion\n     @ /tmp/tmp9dhvd9wn.jl:28\
    \ [inlined]\n   [6] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmp9dhvd9wn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmp9dhvd9wn.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9dhvd9wn.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value == round(value)\n        return\
    \ round(value)\n    elseif value > 0\n        return round(value) + 1\n    else\n\
    \        return round(value) - 1\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp84d0yjev.jl:35\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -17 == -16\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp84d0yjev.jl:35 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp84d0yjev.jl:32\ntest set: Test\
    \ Failed at /tmp/tmp84d0yjev.jl:36\n  Expression: candidate(\"15.3\") == 15\n\
    \   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp84d0yjev.jl:36\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp84d0yjev.jl:32\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp84d0yjev.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpwsrz7vmf.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmpwsrz7vmf.jl:19\n  \
    \ [5] macro expansion\n     @ /tmp/tmpwsrz7vmf.jl:27 [inlined]\n   [6] macro expansion\n\
    \     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpwsrz7vmf.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpwsrz7vmf.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmpwsrz7vmf.jl:19\n   [5] macro expansion\n     @ /tmp/tmpwsrz7vmf.jl:28\
    \ [inlined]\n   [6] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpwsrz7vmf.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpwsrz7vmf.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwsrz7vmf.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp9ipydwws.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp9ipydwws.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp9ipydwws.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9ipydwws.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    # convert the string to a float\n    value = parse(Float64, value)\n \
    \   # round the float to the nearest integer\n    return round(value)\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp4ukapl2b.jl:30\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp4ukapl2b.jl:30 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp4ukapl2b.jl:28\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4ukapl2b.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return ceil(value)\n\
    \    else\n        return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp455jft2s.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp455jft2s.jl:34 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp455jft2s.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp455jft2s.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmph1ijuwq2.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmph1ijuwq2.jl:19\n  \
    \ [5] macro expansion\n     @ /tmp/tmph1ijuwq2.jl:27 [inlined]\n   [6] macro expansion\n\
    \     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmph1ijuwq2.jl:25\ntest set:\
    \ Error During Test at /tmp/tmph1ijuwq2.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmph1ijuwq2.jl:19\n   [5] macro expansion\n     @ /tmp/tmph1ijuwq2.jl:28\
    \ [inlined]\n   [6] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmph1ijuwq2.jl:25\ntest set:\
    \ Error During Test at /tmp/tmph1ijuwq2.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmph1ijuwq2.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    num = parse(Float64, value)\n    if num - floor(num) == 0.5\n        return\
    \ round(num)\n    else\n        return round(Int64, num)\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpk3t4d6at.jl:32\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpk3t4d6at.jl:32 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpk3t4d6at.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpk3t4d6at.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpyzb_hkzz.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpyzb_hkzz.jl:34 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpyzb_hkzz.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpyzb_hkzz.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value >= 0\n        return ceil(value)\n\
    \    else\n        return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpcucc9gxa.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpcucc9gxa.jl:34 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpcucc9gxa.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpcucc9gxa.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp45qent9i.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmp45qent9i.jl:19\n  \
    \ [5] macro expansion\n     @ /tmp/tmp45qent9i.jl:27 [inlined]\n   [6] macro expansion\n\
    \     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmp45qent9i.jl:25\ntest set:\
    \ Error During Test at /tmp/tmp45qent9i.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmp45qent9i.jl:19\n   [5] macro expansion\n     @ /tmp/tmp45qent9i.jl:28\
    \ [inlined]\n   [6] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmp45qent9i.jl:25\ntest set:\
    \ Error During Test at /tmp/tmp45qent9i.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp45qent9i.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpvupu19bb.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpvupu19bb.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpvupu19bb.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpvupu19bb.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return Int64(round(parse(Float64, value)))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t\
    @test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpvb07lcdh.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpvb07lcdh.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpvb07lcdh.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpvb07lcdh.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value >= 0\n        return ceil(value)\n\
    \    else\n        return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpn7p5_6dg.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpn7p5_6dg.jl:34 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpn7p5_6dg.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpn7p5_6dg.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return Int64(round(parse(Float64, value)))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t\
    @test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpybz21cpf.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpybz21cpf.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpybz21cpf.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpybz21cpf.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return ceil(value)\n\
    \    elseif value < 0\n        return floor(value)\n    else\n        return 0\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t\
    @test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpe1nb2j_5.jl:36\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpe1nb2j_5.jl:36 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpe1nb2j_5.jl:32\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpe1nb2j_5.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpugi8syf1.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpugi8syf1.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpugi8syf1.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpugi8syf1.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    num = parse(Float64, value)\n    return round(num)\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\
    \t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp7itfh98d.jl:28\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp7itfh98d.jl:28 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp7itfh98d.jl:26\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7itfh98d.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp7t9nraif.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp7t9nraif.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp7t9nraif.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7t9nraif.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return round(Int64,\
    \ value)\n    else\n        return round(Int64, value - 1)\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpiy8cp3x5.jl:32\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpiy8cp3x5.jl:32 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpiy8cp3x5.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpiy8cp3x5.jl:35\n  Expression: candidate(\"0\") == 0\n   Evaluated:\
    \ -1 == 0\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpiy8cp3x5.jl:35 [inlined]\n\
    \ [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpiy8cp3x5.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpiy8cp3x5.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    value = round(value)\n    return value\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpzgncu6d1.jl:29\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpzgncu6d1.jl:29 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpzgncu6d1.jl:27\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzgncu6d1.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value == round(value)\n        return\
    \ round(value)\n    elseif value > 0\n        return round(value) + 1\n    else\n\
    \        return round(value) - 1\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpa1hv91rb.jl:35\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -17 == -16\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpa1hv91rb.jl:35 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpa1hv91rb.jl:32\ntest set: Test\
    \ Failed at /tmp/tmpa1hv91rb.jl:36\n  Expression: candidate(\"15.3\") == 15\n\
    \   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpa1hv91rb.jl:36\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpa1hv91rb.jl:32\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpa1hv91rb.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpy7ucypk3.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpy7ucypk3.jl:34 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpy7ucypk3.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpy7ucypk3.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpufnze958.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpufnze958.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpufnze958.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpufnze958.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpas_8qst0.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpas_8qst0.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpas_8qst0.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpas_8qst0.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpi8kz7w68.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpi8kz7w68.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpi8kz7w68.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpi8kz7w68.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    # convert the string to a float\n    value = parse(Float64, value)\n \
    \   # round the float to the nearest integer\n    value = round(value)\n    #\
    \ convert the float to an integer\n    value = Int64(value)\n    # return the\
    \ integer\n    return value\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpxzm6ar9c.jl:34\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpxzm6ar9c.jl:34 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpxzm6ar9c.jl:32\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxzm6ar9c.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpu9ev_xnx.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpu9ev_xnx.jl:33 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpu9ev_xnx.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpu9ev_xnx.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp317scl_9.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp317scl_9.jl:33 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp317scl_9.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp317scl_9.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return ceil(value)\n\
    \    else\n        return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpvehvudwz.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpvehvudwz.jl:34 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpvehvudwz.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpvehvudwz.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpmq5vlykd.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpmq5vlykd.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpmq5vlykd.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmq5vlykd.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpnw6j17x9.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpnw6j17x9.jl:34 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpnw6j17x9.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnw6j17x9.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp5fobkba6.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmp5fobkba6.jl:19\n  \
    \ [5] macro expansion\n     @ /tmp/tmp5fobkba6.jl:27 [inlined]\n   [6] macro expansion\n\
    \     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmp5fobkba6.jl:25\ntest set:\
    \ Error During Test at /tmp/tmp5fobkba6.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmp5fobkba6.jl:19\n   [5] macro expansion\n     @ /tmp/tmp5fobkba6.jl:28\
    \ [inlined]\n   [6] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmp5fobkba6.jl:25\ntest set:\
    \ Error During Test at /tmp/tmp5fobkba6.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5fobkba6.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp6eo1zb5n.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp6eo1zb5n.jl:33 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp6eo1zb5n.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6eo1zb5n.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp1d8s2781.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp1d8s2781.jl:33 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp1d8s2781.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1d8s2781.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmprdeoj_ac.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmprdeoj_ac.jl:27 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmprdeoj_ac.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmprdeoj_ac.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) == 0.5\n  \
    \      if value > 0\n            return floor(value) + 1\n        else\n     \
    \       return floor(value) - 1\n        end\n    else\n        return floor(value\
    \ + 0.5)\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\
    \t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpqq9nkjgu.jl:37\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -17 == -16\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpqq9nkjgu.jl:37 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpqq9nkjgu.jl:34\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqq9nkjgu.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpq7bablsl.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmpq7bablsl.jl:19\n  \
    \ [5] macro expansion\n     @ /tmp/tmpq7bablsl.jl:27 [inlined]\n   [6] macro expansion\n\
    \     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpq7bablsl.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpq7bablsl.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmpq7bablsl.jl:19\n   [5] macro expansion\n     @ /tmp/tmpq7bablsl.jl:28\
    \ [inlined]\n   [6] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpq7bablsl.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpq7bablsl.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpq7bablsl.jl:23\n"
  exit_code: 1
  status: SyntaxError
