name: HumanEval_6_parse_nested_parens
language: julia
results:
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Split the string into groups\n    groups = split(paren_string, \" \"\
    )\n    # Initialize a vector to store the maximum nesting level for each group\n\
    \    max_nesting = zeros(Int64, length(groups))\n    # Loop through each group\n\
    \    for i in 1:length(groups)\n        # Initialize a counter for the current\
    \ nesting level\n        curr_nesting = 0\n        # Initialize a counter for\
    \ the maximum nesting level\n        max_nesting[i] = 0\n        # Loop through\
    \ each character in the current group\n        for j in 1:length(groups[i])\n\
    \            # If the current character is an opening parenthesis, increment the\
    \ current nesting level\n            if groups[i][j] == '('\n                curr_nesting\
    \ += 1\n            # If the current character is a closing parenthesis, decrement\
    \ the current nesting level\n            elseif groups[i][j] == ')'\n        \
    \        curr_nesting -= 1\n            end\n            # If the current nesting\
    \ level is greater than the maximum nesting level, update the maximum nesting\
    \ level\n            if curr_nesting > max_nesting[i]\n                max_nesting[i]\
    \ = curr_nesting\n            end\n        end\n    end\n    # Return the maximum\
    \ nesting level for each group\n    return max_nesting\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = []\n    for\
    \ group in paren_groups\n        max_nesting_level = 0\n        current_nesting_level\
    \ = 0\n        for paren in group\n            if paren == '('\n             \
    \   current_nesting_level += 1\n            elseif paren == ')'\n            \
    \    current_nesting_level -= 1\n            end\n            if current_nesting_level\
    \ > max_nesting_level\n                max_nesting_level = current_nesting_level\n\
    \            end\n        end\n        push!(max_nesting, max_nesting_level)\n\
    \    end\n    return max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = Vector{Int64}(undef,\
    \ length(paren_groups))\n    for (i, group) in enumerate(paren_groups)\n     \
    \   max_nesting[i] = parse_nested_parens_helper(group)\n    end\n    return max_nesting\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp8a8i401t.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_nested_parens_helper not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmp8a8i401t.jl:12\n   [2] top-level scope at /tmp/tmp8a8i401t.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8a8i401t.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp8a8i401t.jl:22\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_nested_parens_helper\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmp8a8i401t.jl:12\n\
    \   [2] top-level scope at /tmp/tmp8a8i401t.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8a8i401t.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp8a8i401t.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: parse_nested_parens_helper not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmp8a8i401t.jl:12\n\
    \   [2] top-level scope at /tmp/tmp8a8i401t.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8a8i401t.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8a8i401t.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    paren_levels = []\n   \
    \ for paren_group in paren_groups\n        paren_levels = [push!(paren_levels,\
    \ paren_level(paren_group))]\n    end\n    return paren_levels\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmplfhls7lm.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ paren_level not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmplfhls7lm.jl:12\n   [2] top-level scope at /tmp/tmplfhls7lm.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmplfhls7lm.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmplfhls7lm.jl:22\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: paren_level not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmplfhls7lm.jl:12\n\
    \   [2] top-level scope at /tmp/tmplfhls7lm.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmplfhls7lm.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmplfhls7lm.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: paren_level not defined\n  Stacktrace:\n\
    \   [1] parse_nested_parens(::String) at /tmp/tmplfhls7lm.jl:12\n   [2] top-level\
    \ scope at /tmp/tmplfhls7lm.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmplfhls7lm.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmplfhls7lm.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize a vector to store the result\n    result = Vector{Int64}()\n\
    \    # Split the string by spaces\n    paren_groups = split(paren_string, \" \"\
    )\n    # Loop through each group\n    for group in paren_groups\n        # Initialize\
    \ the maximum depth to zero\n        max_depth = 0\n        # Initialize the current\
    \ depth to zero\n        current_depth = 0\n        # Loop through each character\
    \ in the group\n        for char in group\n            # If the character is a\
    \ left parenthesis, increment the current depth\n            if char == '('\n\
    \                current_depth += 1\n            # If the character is a right\
    \ parenthesis, decrement the current depth\n            elseif char == ')'\n \
    \               current_depth -= 1\n            end\n            # Update the\
    \ maximum depth if the current depth is greater\n            if current_depth\
    \ > max_depth\n                max_depth = current_depth\n            end\n  \
    \      end\n        # Append the maximum depth to the result\n        push!(result,\
    \ max_depth)\n    end\n    # Return the result\n    return result\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = Vector{Int64}(undef,\
    \ length(paren_groups))\n    for i in 1:length(paren_groups)\n        max_nesting[i]\
    \ = parse_nested_parens_helper(paren_groups[i])\n    end\n    return max_nesting\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp4_zvv7jx.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_nested_parens_helper not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmp4_zvv7jx.jl:12\n   [2] top-level scope at /tmp/tmp4_zvv7jx.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4_zvv7jx.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp4_zvv7jx.jl:22\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_nested_parens_helper\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmp4_zvv7jx.jl:12\n\
    \   [2] top-level scope at /tmp/tmp4_zvv7jx.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4_zvv7jx.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp4_zvv7jx.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: parse_nested_parens_helper not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmp4_zvv7jx.jl:12\n\
    \   [2] top-level scope at /tmp/tmp4_zvv7jx.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4_zvv7jx.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4_zvv7jx.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize a vector to store the output\n    output = Vector{Int64}()\n\
    \    # Split the string by spaces\n    paren_groups = split(paren_string, \" \"\
    )\n    # For each group, find the maximum level of nesting\n    for group in paren_groups\n\
    \        # Initialize a counter to keep track of the level of nesting\n      \
    \  counter = 0\n        # Initialize a variable to keep track of the maximum level\
    \ of nesting\n        max_counter = 0\n        # Loop through each character in\
    \ the group\n        for char in group\n            # If the character is an opening\
    \ parenthesis, increment the counter\n            if char == '('\n           \
    \     counter += 1\n            # If the character is a closing parenthesis, decrement\
    \ the counter\n            elseif char == ')'\n                counter -= 1\n\
    \            end\n            # Update the maximum level of nesting\n        \
    \    if counter > max_counter\n                max_counter = counter\n       \
    \     end\n        end\n        # Add the maximum level of nesting to the output\
    \ vector\n        push!(output, max_counter)\n    end\n    # Return the output\
    \ vector\n    return output\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = zeros(Int64,\
    \ length(paren_groups))\n    for (i, paren_group) in enumerate(paren_groups)\n\
    \        paren_count = 0\n        max_nesting[i] = 0\n        for c in paren_group\n\
    \            if c == '('\n                paren_count += 1\n                max_nesting[i]\
    \ = max(max_nesting[i], paren_count)\n            elseif c == ')'\n          \
    \      paren_count -= 1\n            end\n        end\n    end\n    return max_nesting\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_depth = []\n    for\
    \ paren_group in paren_groups\n        depth = 0\n        max_depth_in_group =\
    \ 0\n        for c in paren_group\n            if c == '('\n                depth\
    \ += 1\n            elseif c == ')'\n                depth -= 1\n            end\n\
    \            if depth > max_depth_in_group\n                max_depth_in_group\
    \ = depth\n            end\n        end\n        push!(max_depth, max_depth_in_group)\n\
    \    end\n    return max_depth\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = []\n    for\
    \ group in paren_groups\n        max_nesting_in_group = 0\n        current_nesting\
    \ = 0\n        for paren in group\n            if paren == '('\n             \
    \   current_nesting += 1\n            elseif paren == ')'\n                current_nesting\
    \ -= 1\n            end\n            if current_nesting > max_nesting_in_group\n\
    \                max_nesting_in_group = current_nesting\n            end\n   \
    \     end\n        push!(max_nesting, max_nesting_in_group)\n    end\n    return\
    \ max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = Vector{Int64}(undef,\
    \ length(paren_groups))\n    for (i, paren_group) in enumerate(paren_groups)\n\
    \        max_nesting[i] = parse_nested_parens_helper(paren_group)\n    end\n \
    \   return max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpwuee7o9z.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_nested_parens_helper not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmpwuee7o9z.jl:12\n   [2] top-level scope at /tmp/tmpwuee7o9z.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwuee7o9z.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpwuee7o9z.jl:22\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_nested_parens_helper\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmpwuee7o9z.jl:12\n\
    \   [2] top-level scope at /tmp/tmpwuee7o9z.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwuee7o9z.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpwuee7o9z.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: parse_nested_parens_helper not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmpwuee7o9z.jl:12\n\
    \   [2] top-level scope at /tmp/tmpwuee7o9z.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwuee7o9z.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwuee7o9z.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_list = split(paren_string, \" \")\n    max_nesting = []\n    for\
    \ paren in paren_list\n        max_nesting_level = 0\n        current_nesting_level\
    \ = 0\n        for char in paren\n            if char == '('\n               \
    \ current_nesting_level += 1\n            elseif char == ')'\n               \
    \ current_nesting_level -= 1\n            end\n            if current_nesting_level\
    \ > max_nesting_level\n                max_nesting_level = current_nesting_level\n\
    \            end\n        end\n        push!(max_nesting, max_nesting_level)\n\
    \    end\n    return max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_list = split(paren_string, \" \")\n    paren_list = map(x -> parse_parens(x),\
    \ paren_list)\n    return paren_list\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpc2i9dy2_.jl:18\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3]\\n  UndefVarError: parse_parens not defined\\n  Stacktrace:\\n   [1]\
    \ (::var\"#3#4\")(::SubString{String}) at /tmp/tmpc2i9dy2_.jl:10\\n   [2] iterate\
    \ at ./generator.jl:47 [inlined]\\n   [3] _collect(::Array{SubString{String},1},\
    \ ::Base.Generator{Array{SubString{String},1},var\"#3#4\"}, ::Base.EltypeUnknown,\
    \ ::Base.HasShape{1}) at ./array.jl:678\\n   [4] collect_similar at ./array.jl:607\
    \ [inlined]\\n   [5] map at ./abstractarray.jl:2072 [inlined]\\n   [6] parse_nested_parens(::String)\
    \ at /tmp/tmpc2i9dy2_.jl:10\\n   [7] top-level scope at /tmp/tmpc2i9dy2_.jl:18\\\
    n   [8] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [9] top-level scope at /tmp/tmpc2i9dy2_.jl:17\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpc2i9dy2_.jl:19\\n  Test threw exception\\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\\n  UndefVarError: parse_parens not\
    \ defined\\n  Stacktrace:\\n   [1] (::var\"#3#4\")(::SubString{String}) at /tmp/tmpc2i9dy2_.jl:10\\\
    n   [2] iterate at ./generator.jl:47 [inlined]\\n   [3] _collect(::Array{SubString{String},1},\
    \ ::Base.Generator{Array{SubString{String},1},var\"#3#4\"}, ::Base.EltypeUnknown,\
    \ ::Base.HasShape{1}) at ./array.jl:678\\n   [4] collect_similar at ./array.jl:607\
    \ [inlined]\\n   [5] map at ./abstractarray.jl:2072 [inlined]\\n   [6] parse_nested_parens(::String)\
    \ at /tmp/tmpc2i9dy2_.jl:10\\n   [7] top-level scope at /tmp/tmpc2i9dy2_.jl:19\\\
    n   [8] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [9] top-level scope at /tmp/tmpc2i9dy2_.jl:17\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpc2i9dy2_.jl:20\\n  Test threw exception\\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\\n  UndefVarError: parse_parens not defined\\n  Stacktrace:\\\
    n   [1] (::var\"#3#4\")(::SubString{String}) at /tmp/tmpc2i9dy2_.jl:10\\n   [2]\
    \ iterate at ./generator.jl:47 [inlined]\\n   [3] _collect(::Array{SubString{String},1},\
    \ ::Base.Generator{Array{SubString{String},1},var\"#3#4\"}, ::Base.EltypeUnknown,\
    \ ::Base.HasShape{1}) at ./array.jl:678\\n   [4] collect_similar at ./array.jl:607\
    \ [inlined]\\n   [5] map at ./abstractarray.jl:2072 [inlined]\\n   [6] parse_nested_parens(::String)\
    \ at /tmp/tmpc2i9dy2_.jl:10\\n   [7] top-level scope at /tmp/tmpc2i9dy2_.jl:20\\\
    n   [8] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [9] top-level scope at /tmp/tmpc2i9dy2_.jl:17\\n  \\nTest Summary: | Error\
    \  Total\\ntest set      |     3      3\\n'"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string =\
    \ replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \"()\", \"\")\n    paren_string = replace(paren_string, \"()\", \"\")\n    paren_string\
    \ = replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \"()\", \"\")\n    paren_string = replace(paren_string, \"()\", \"\")\n    paren_string\
    \ = replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \"()\", \"\")\n    paren_string = replace(paren_string, \"()\", \"\")\n    paren_string\
    \ = replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \"()\", \"\")\n    paren_string = replace(paren_string, \"()\", \"\")\n    paren_string\
    \ = replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \"()\", \"\")\n    paren_string = replace(paren_string, \"()\", \"\")\n    paren_string\
    \ = replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \"()\", \"\")\n    paren_string = replace(paren_string, \"()\", \"\")\n    paren_string\
    \ = replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \"()\", \"\")\n    paren_string = replace(paren_string, \"()\", \"\")\n    paren_string\
    \ = replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \"()\", \"\")\n    paren_string = replace(paren_string, \"()\", \"\")\n    paren_string\
    \ = replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \"()\", \"\")\n    paren_string = replace(paren_string, \"()\", \"\")\n    paren_string\
    \ = replace(\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp6zh0wdt9.jl:40\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp6zh0wdt9.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = []\n    for\
    \ group in paren_groups\n        nesting = 0\n        max_nesting_group = 0\n\
    \        for paren in group\n            if paren == '('\n                nesting\
    \ += 1\n            elseif paren == ')'\n                nesting -= 1\n      \
    \      end\n            if nesting > max_nesting_group\n                max_nesting_group\
    \ = nesting\n            end\n        end\n        push!(max_nesting, max_nesting_group)\n\
    \    end\n    return max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize an empty vector to store the depth of each group\n    depth_vector\
    \ = Int64[]\n    # Initialize a counter to keep track of the depth of the current\
    \ group\n    depth = 0\n    # Iterate through each character in the string\n \
    \   for c in paren_string\n        # If the character is an opening parenthesis,\
    \ increase the depth by 1\n        if c == '('\n            depth += 1\n     \
    \   # If the character is a closing parenthesis, decrease the depth by 1\n   \
    \     elseif c == ')'\n            depth -= 1\n        # If the character is a\
    \ space, append the current depth to the vector\n        elseif c == ' '\n   \
    \         push!(depth_vector, depth)\n        end\n    end\n    # Return the vector\
    \ of depths\n    return depth_vector\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpcxiplcvo.jl:34\\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\\n   Evaluated: [0, 0, 0] == [2,\
    \ 3, 1, 3]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpcxiplcvo.jl:34\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpcxiplcvo.jl:33\\ntest set: Test Failed at /tmp/tmpcxiplcvo.jl:35\\\
    n  Expression: candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\\n   Evaluated:\
    \ [0, 0, 0] == [1, 2, 3, 4]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpcxiplcvo.jl:35\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpcxiplcvo.jl:33\\ntest set: Test Failed at /tmp/tmpcxiplcvo.jl:36\\\
    n  Expression: candidate(\"(()(())((())))\") == [4]\\n   Evaluated: Int64[] ==\
    \ [4]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpcxiplcvo.jl:36\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpcxiplcvo.jl:33\\nTest Summary: | Fail  Total\\\
    ntest set      |    3      3\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize a vector to store the result\n    result = Int64[]\n    #\
    \ Split the string by spaces\n    paren_groups = split(paren_string, \" \")\n\
    \    # Iterate through each group\n    for group in paren_groups\n        # Initialize\
    \ a counter to keep track of the current nesting level\n        counter = 0\n\
    \        # Initialize a variable to keep track of the maximum nesting level\n\
    \        max_counter = 0\n        # Iterate through each character in the group\n\
    \        for char in group\n            # If the character is an opening parenthesis,\
    \ increment the counter\n            if char == '('\n                counter +=\
    \ 1\n            # If the character is a closing parenthesis, decrement the counter\n\
    \            elseif char == ')'\n                counter -= 1\n            end\n\
    \            # Update the maximum nesting level if the current nesting level is\
    \ greater\n            if counter > max_counter\n                max_counter =\
    \ counter\n            end\n        end\n        # Append the maximum nesting\
    \ level to the result\n        push!(result, max_counter)\n    end\n    # Return\
    \ the result\n    return result\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = []\n    for\
    \ paren_group in paren_groups\n        max_nesting_level = 0\n        nesting_level\
    \ = 0\n        for paren in paren_group\n            if paren == '('\n       \
    \         nesting_level += 1\n            elseif paren == ')'\n              \
    \  nesting_level -= 1\n            end\n            if nesting_level > max_nesting_level\n\
    \                max_nesting_level = nesting_level\n            end\n        end\n\
    \        push!(max_nesting, max_nesting_level)\n    end\n    return max_nesting\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_list = split(paren_string, \" \")\n    paren_list = [strip(x) for\
    \ x in paren_list]\n    paren_list = [x for x in paren_list if x != \"\"]\n  \
    \  paren_list = [x for x in paren_list if x != \" \"]\n    paren_list = [x for\
    \ x in paren_list if x != \"()\"]\n    paren_list = [x for x in paren_list if\
    \ x != \"()()\"]\n    paren_list = [x for x in paren_list if x != \"()()()\"]\n\
    \    paren_list = [x for x in paren_list if x != \"()()()()\"]\n    paren_list\
    \ = [x for x in paren_list if x != \"()()()()()\"]\n    paren_list = [x for x\
    \ in paren_list if x != \"()()()()()()\"]\n    paren_list = [x for x in paren_list\
    \ if x != \"()()()()()()()\"]\n    paren_list = [x for x in paren_list if x !=\
    \ \"()()()()()()()()\"]\n    paren_list = [x for x in paren_list if x != \"()()()()()()()()()\"\
    ]\n    paren_list = [x for x in paren_list if x != \"()()()()()()()()()()\"]\n\
    \    paren_list = [x for x in paren_list if x != \"()()()()()()()()()()()\"]\n\
    \    paren_list = [x for x in paren_list if x != \"()()()()()()()()()()()()\"\
    ]\n    paren_list = [x for x in paren_list if x != \"()()()()()()()()()()()()()\"\
    ]\n    paren_list = [x for x in paren_list if x != \"()()()()()()()()()()()()()()\"\
    ]\n    paren_list = [x for x in paren_list if x != \"()()()()()()()()()()()()()()\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: space before \"(\" not allowed in \"\"()()()()()()()()()()()()()()\\\
    nusing Test\\n\\n@testset begin\\n\\ncandidate = parse_nested_parens;\\n\\t@test(candidate(\"\
    (()()) (\" at /tmp/tmp71kl8dtg.jl:33\nStacktrace:\n [1] top-level scope at /tmp/tmp71kl8dtg.jl:33\n\
    \ [2] include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp71kl8dtg.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize a vector to store the results\n    result = Int64[]\n   \
    \ # Split the string into groups\n    groups = split(paren_string, \" \")\n  \
    \  # Iterate over each group\n    for group in groups\n        # Initialize a\
    \ counter\n        counter = 0\n        # Initialize a max counter\n        max_counter\
    \ = 0\n        # Iterate over each character in the group\n        for char in\
    \ group\n            # If the character is an open parenthesis, increment the\
    \ counter\n            if char == '('\n                counter += 1\n        \
    \    # If the character is a closed parenthesis, decrement the counter\n     \
    \       elseif char == ')'\n                counter -= 1\n            end\n  \
    \          # Update the max counter if the current counter is greater\n      \
    \      if counter > max_counter\n                max_counter = counter\n     \
    \       end\n        end\n        # Push the max counter to the result vector\n\
    \        push!(result, max_counter)\n    end\n    # Return the result vector\n\
    \    return result\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = []\n    for\
    \ group in paren_groups\n        max_nesting_group = 0\n        current_nesting\
    \ = 0\n        for char in group\n            if char == '('\n               \
    \ current_nesting += 1\n            elseif char == ')'\n                current_nesting\
    \ -= 1\n            end\n            if current_nesting > max_nesting_group\n\
    \                max_nesting_group = current_nesting\n            end\n      \
    \  end\n        push!(max_nesting, max_nesting_group)\n    end\n    return max_nesting\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = Vector{Int64}(undef,\
    \ length(paren_groups))\n    for i in 1:length(paren_groups)\n        max_nesting[i]\
    \ = get_max_nesting(paren_groups[i])\n    end\n    return max_nesting\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpt4c15eoh.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ get_max_nesting not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmpt4c15eoh.jl:12\n   [2] top-level scope at /tmp/tmpt4c15eoh.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpt4c15eoh.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpt4c15eoh.jl:22\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: get_max_nesting not\
    \ defined\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmpt4c15eoh.jl:12\n\
    \   [2] top-level scope at /tmp/tmpt4c15eoh.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpt4c15eoh.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpt4c15eoh.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: get_max_nesting not defined\n  Stacktrace:\n\
    \   [1] parse_nested_parens(::String) at /tmp/tmpt4c15eoh.jl:12\n   [2] top-level\
    \ scope at /tmp/tmpt4c15eoh.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpt4c15eoh.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpt4c15eoh.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = Vector{Int64}(undef,\
    \ length(paren_groups))\n    for (i, paren_group) in enumerate(paren_groups)\n\
    \        max_nesting[i] = 0\n        current_nesting = 0\n        for paren in\
    \ paren_group\n            if paren == '('\n                current_nesting +=\
    \ 1\n            elseif paren == ')'\n                current_nesting -= 1\n \
    \           end\n            if current_nesting > max_nesting[i]\n           \
    \     max_nesting[i] = current_nesting\n            end\n        end\n    end\n\
    \    return max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = []\n    for\
    \ paren_group in paren_groups\n        max_nesting_level = 0\n        current_nesting_level\
    \ = 0\n        for paren in paren_group\n            if paren == '('\n       \
    \         current_nesting_level += 1\n            elseif paren == ')'\n      \
    \          current_nesting_level -= 1\n            end\n            if current_nesting_level\
    \ > max_nesting_level\n                max_nesting_level = current_nesting_level\n\
    \            end\n        end\n        push!(max_nesting, max_nesting_level)\n\
    \    end\n    return max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    paren_levels = []\n   \
    \ for paren_group in paren_groups\n        paren_levels = [push!(paren_levels,\
    \ get_paren_level(paren_group))]\n    end\n    return paren_levels\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp7sx75nc7.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ get_paren_level not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmp7sx75nc7.jl:12\n   [2] top-level scope at /tmp/tmp7sx75nc7.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7sx75nc7.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp7sx75nc7.jl:22\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: get_paren_level not\
    \ defined\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmp7sx75nc7.jl:12\n\
    \   [2] top-level scope at /tmp/tmp7sx75nc7.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7sx75nc7.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp7sx75nc7.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: get_paren_level not defined\n  Stacktrace:\n\
    \   [1] parse_nested_parens(::String) at /tmp/tmp7sx75nc7.jl:12\n   [2] top-level\
    \ scope at /tmp/tmp7sx75nc7.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp7sx75nc7.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7sx75nc7.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = []\n    for\
    \ paren_group in paren_groups\n        max_nesting_in_group = 0\n        current_nesting\
    \ = 0\n        for paren in paren_group\n            if paren == '('\n       \
    \         current_nesting += 1\n            elseif paren == ')'\n            \
    \    current_nesting -= 1\n            end\n            if current_nesting > max_nesting_in_group\n\
    \                max_nesting_in_group = current_nesting\n            end\n   \
    \     end\n        push!(max_nesting, max_nesting_in_group)\n    end\n    return\
    \ max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string =\
    \ replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \"\")\n    paren_string = replace(paren_string, \"((\", \"\")\n    paren_string\
    \ = replace(paren_string, \"))\", \"\")\n    paren_string = replace(paren_string,\
    \ \")\", \"\")\n    paren_string = replace(paren_string, \"(\", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \"\")\n    return length.(split(paren_string,\
    \ \"\"))\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp5uempsmd.jl:24\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching replace(::String, ::String, ::String)\n  Closest candidates\
    \ are:\n    replace(::String, !Matched::Pair{#s67,B} where B where #s67<:AbstractChar;\
    \ count) at strings/util.jl:421\n    replace(::String, !Matched::Pair{#s64,B}\
    \ where B where #s64<:Union{Tuple{Vararg{AbstractChar,N} where N}, Set{#s61} where\
    \ #s61<:AbstractChar, AbstractArray{#s62,1} where #s62<:AbstractChar}; count)\
    \ at strings/util.jl:426\n    replace(::String, !Matched::Pair; count) at strings/util.jl:433\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmp5uempsmd.jl:9\n\
    \   [2] top-level scope at /tmp/tmp5uempsmd.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5uempsmd.jl:23\n  \ntest set: Error During\
    \ Test at /tmp/tmp5uempsmd.jl:25\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method matching\
    \ replace(::String, ::String, ::String)\n  Closest candidates are:\n    replace(::String,\
    \ !Matched::Pair{#s67,B} where B where #s67<:AbstractChar; count) at strings/util.jl:421\n\
    \    replace(::String, !Matched::Pair{#s64,B} where B where #s64<:Union{Tuple{Vararg{AbstractChar,N}\
    \ where N}, Set{#s61} where #s61<:AbstractChar, AbstractArray{#s62,1} where #s62<:AbstractChar};\
    \ count) at strings/util.jl:426\n    replace(::String, !Matched::Pair; count)\
    \ at strings/util.jl:433\n    ...\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmp5uempsmd.jl:9\n   [2] top-level scope at /tmp/tmp5uempsmd.jl:25\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5uempsmd.jl:23\n  \ntest set: Error During\
    \ Test at /tmp/tmp5uempsmd.jl:26\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  MethodError: no method matching replace(::String,\
    \ ::String, ::String)\n  Closest candidates are:\n    replace(::String, !Matched::Pair{#s67,B}\
    \ where B where #s67<:AbstractChar; count) at strings/util.jl:421\n    replace(::String,\
    \ !Matched::Pair{#s64,B} where B where #s64<:Union{Tuple{Vararg{AbstractChar,N}\
    \ where N}, Set{#s61} where #s61<:AbstractChar, AbstractArray{#s62,1} where #s62<:AbstractChar};\
    \ count) at strings/util.jl:426\n    replace(::String, !Matched::Pair; count)\
    \ at strings/util.jl:433\n    ...\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmp5uempsmd.jl:9\n   [2] top-level scope at /tmp/tmp5uempsmd.jl:26\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5uempsmd.jl:23\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5uempsmd.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = Vector{Int64}(undef,\
    \ length(paren_groups))\n    for i in 1:length(paren_groups)\n        max_nesting[i]\
    \ = parse_parens(paren_groups[i])\n    end\n    return max_nesting\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpf9iyfmd9.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_parens not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmpf9iyfmd9.jl:12\n   [2] top-level scope at /tmp/tmpf9iyfmd9.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpf9iyfmd9.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpf9iyfmd9.jl:22\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_parens not\
    \ defined\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmpf9iyfmd9.jl:12\n\
    \   [2] top-level scope at /tmp/tmpf9iyfmd9.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpf9iyfmd9.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpf9iyfmd9.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: parse_parens not defined\n  Stacktrace:\n\
    \   [1] parse_nested_parens(::String) at /tmp/tmpf9iyfmd9.jl:12\n   [2] top-level\
    \ scope at /tmp/tmpf9iyfmd9.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpf9iyfmd9.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpf9iyfmd9.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize a vector to store the output\n    output = Vector{Int64}()\n\
    \    # Split the string by spaces\n    paren_groups = split(paren_string, \" \"\
    )\n    # For each of the groups,\n    for paren_group in paren_groups\n      \
    \  # Initialize a counter to keep track of the level of nesting\n        counter\
    \ = 0\n        # Initialize a maximum to keep track of the maximum level of nesting\n\
    \        max_counter = 0\n        # For each of the parentheses in the group,\n\
    \        for paren in paren_group\n            # If the parenthesis is an opening\
    \ one,\n            if paren == '('\n                # Increment the counter\n\
    \                counter += 1\n                # If the counter is greater than\
    \ the maximum,\n                if counter > max_counter\n                   \
    \ # Update the maximum\n                    max_counter = counter\n          \
    \      end\n            # If the parenthesis is a closing one,\n            elseif\
    \ paren == ')'\n                # Decrement the counter\n                counter\
    \ -= 1\n            end\n        end\n        # Append the maximum to the output\n\
    \        push!(output, max_counter)\n    end\n    # Return the output\n    return\
    \ output\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = Vector{Int64}(undef,\
    \ length(paren_groups))\n    for i in 1:length(paren_groups)\n        paren_group\
    \ = paren_groups[i]\n        nesting_level = 0\n        max_nesting_level = 0\n\
    \        for j in 1:length(paren_group)\n            if paren_group[j] == '('\n\
    \                nesting_level += 1\n            elseif paren_group[j] == ')'\n\
    \                nesting_level -= 1\n            end\n            if nesting_level\
    \ > max_nesting_level\n                max_nesting_level = nesting_level\n   \
    \         end\n        end\n        max_nesting[i] = max_nesting_level\n    end\n\
    \    return max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string =\
    \ replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \"\")\n    paren_string = replace(paren_string, \")\", \"\")\n    paren_string\
    \ = replace(paren_string, \"(\", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \"\")\n    return length.(split(paren_string, \"\"))\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpbkm1pfte.jl:22\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching replace(::String, ::String, ::String)\n  Closest candidates\
    \ are:\n    replace(::String, !Matched::Pair{#s67,B} where B where #s67<:AbstractChar;\
    \ count) at strings/util.jl:421\n    replace(::String, !Matched::Pair{#s64,B}\
    \ where B where #s64<:Union{Tuple{Vararg{AbstractChar,N} where N}, Set{#s61} where\
    \ #s61<:AbstractChar, AbstractArray{#s62,1} where #s62<:AbstractChar}; count)\
    \ at strings/util.jl:426\n    replace(::String, !Matched::Pair; count) at strings/util.jl:433\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmpbkm1pfte.jl:9\n\
    \   [2] top-level scope at /tmp/tmpbkm1pfte.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbkm1pfte.jl:21\n  \ntest set: Error During\
    \ Test at /tmp/tmpbkm1pfte.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method matching\
    \ replace(::String, ::String, ::String)\n  Closest candidates are:\n    replace(::String,\
    \ !Matched::Pair{#s67,B} where B where #s67<:AbstractChar; count) at strings/util.jl:421\n\
    \    replace(::String, !Matched::Pair{#s64,B} where B where #s64<:Union{Tuple{Vararg{AbstractChar,N}\
    \ where N}, Set{#s61} where #s61<:AbstractChar, AbstractArray{#s62,1} where #s62<:AbstractChar};\
    \ count) at strings/util.jl:426\n    replace(::String, !Matched::Pair; count)\
    \ at strings/util.jl:433\n    ...\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmpbkm1pfte.jl:9\n   [2] top-level scope at /tmp/tmpbkm1pfte.jl:23\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbkm1pfte.jl:21\n  \ntest set: Error During\
    \ Test at /tmp/tmpbkm1pfte.jl:24\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  MethodError: no method matching replace(::String,\
    \ ::String, ::String)\n  Closest candidates are:\n    replace(::String, !Matched::Pair{#s67,B}\
    \ where B where #s67<:AbstractChar; count) at strings/util.jl:421\n    replace(::String,\
    \ !Matched::Pair{#s64,B} where B where #s64<:Union{Tuple{Vararg{AbstractChar,N}\
    \ where N}, Set{#s61} where #s61<:AbstractChar, AbstractArray{#s62,1} where #s62<:AbstractChar};\
    \ count) at strings/util.jl:426\n    replace(::String, !Matched::Pair; count)\
    \ at strings/util.jl:433\n    ...\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmpbkm1pfte.jl:9\n   [2] top-level scope at /tmp/tmpbkm1pfte.jl:24\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbkm1pfte.jl:21\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbkm1pfte.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = Vector{Int64}(undef,\
    \ length(paren_groups))\n    for i in 1:length(paren_groups)\n        paren_group\
    \ = paren_groups[i]\n        max_nesting[i] = 0\n        current_nesting = 0\n\
    \        for j in 1:length(paren_group)\n            if paren_group[j] == '('\n\
    \                current_nesting += 1\n            elseif paren_group[j] == ')'\n\
    \                current_nesting -= 1\n            end\n            if current_nesting\
    \ > max_nesting[i]\n                max_nesting[i] = current_nesting\n       \
    \     end\n        end\n    end\n    return max_nesting\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_list = split(paren_string, \" \")\n    paren_list = map(x -> x[2:end-1],\
    \ paren_list)\n    paren_list = map(x -> count(x, '('), paren_list)\n    return\
    \ paren_list\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpkgib28oa.jl:19\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ objects of type SubString{String} are not callable\n  Stacktrace:\n   [1] count(::SubString{String},\
    \ ::Char) at ./reduce.jl:855\n   [2] #4 at /tmp/tmpkgib28oa.jl:11 [inlined]\n\
    \   [3] iterate at ./generator.jl:47 [inlined]\n   [4] _collect(::Array{SubString{String},1},\
    \ ::Base.Generator{Array{SubString{String},1},var\"#4#6\"}, ::Base.EltypeUnknown,\
    \ ::Base.HasShape{1}) at ./array.jl:678\n   [5] collect_similar at ./array.jl:607\
    \ [inlined]\n   [6] map at ./abstractarray.jl:2072 [inlined]\n   [7] parse_nested_parens(::String)\
    \ at /tmp/tmpkgib28oa.jl:11\n   [8] top-level scope at /tmp/tmpkgib28oa.jl:19\n\
    \   [9] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [10] top-level scope at /tmp/tmpkgib28oa.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpkgib28oa.jl:20\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: objects of type SubString{String}\
    \ are not callable\n  Stacktrace:\n   [1] count(::SubString{String}, ::Char) at\
    \ ./reduce.jl:855\n   [2] #4 at /tmp/tmpkgib28oa.jl:11 [inlined]\n   [3] iterate\
    \ at ./generator.jl:47 [inlined]\n   [4] _collect(::Array{SubString{String},1},\
    \ ::Base.Generator{Array{SubString{String},1},var\"#4#6\"}, ::Base.EltypeUnknown,\
    \ ::Base.HasShape{1}) at ./array.jl:678\n   [5] collect_similar at ./array.jl:607\
    \ [inlined]\n   [6] map at ./abstractarray.jl:2072 [inlined]\n   [7] parse_nested_parens(::String)\
    \ at /tmp/tmpkgib28oa.jl:11\n   [8] top-level scope at /tmp/tmpkgib28oa.jl:20\n\
    \   [9] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [10] top-level scope at /tmp/tmpkgib28oa.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpkgib28oa.jl:21\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  MethodError: objects of type SubString{String} are\
    \ not callable\n  Stacktrace:\n   [1] count(::SubString{String}, ::Char) at ./reduce.jl:855\n\
    \   [2] #4 at /tmp/tmpkgib28oa.jl:11 [inlined]\n   [3] iterate at ./generator.jl:47\
    \ [inlined]\n   [4] _collect(::Array{SubString{String},1}, ::Base.Generator{Array{SubString{String},1},var\"\
    #4#6\"}, ::Base.EltypeUnknown, ::Base.HasShape{1}) at ./array.jl:678\n   [5] collect_similar\
    \ at ./array.jl:607 [inlined]\n   [6] map at ./abstractarray.jl:2072 [inlined]\n\
    \   [7] parse_nested_parens(::String) at /tmp/tmpkgib28oa.jl:11\n   [8] top-level\
    \ scope at /tmp/tmpkgib28oa.jl:21\n   [9] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [10] top-level scope at /tmp/tmpkgib28oa.jl:18\n  \nTest Summary: | Error\
    \  Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpkgib28oa.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = []\n    for\
    \ paren_group in paren_groups\n        max_nesting_level = 0\n        nesting_level\
    \ = 0\n        for paren in paren_group\n            if paren == '('\n       \
    \         nesting_level += 1\n            elseif paren == ')'\n              \
    \  nesting_level -= 1\n            end\n            if nesting_level > max_nesting_level\n\
    \                max_nesting_level = nesting_level\n            end\n        end\n\
    \        push!(max_nesting, max_nesting_level)\n    end\n    return max_nesting\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = zeros(Int64,\
    \ length(paren_groups))\n    for (i, paren_group) in enumerate(paren_groups)\n\
    \        paren_count = 0\n        max_nesting[i] = 0\n        for paren in paren_group\n\
    \            if paren == '('\n                paren_count += 1\n            elseif\
    \ paren == ')'\n                paren_count -= 1\n            end\n          \
    \  max_nesting[i] = max(max_nesting[i], paren_count)\n        end\n    end\n \
    \   return max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = Vector{Int64}(undef,\
    \ length(paren_groups))\n    for i in 1:length(paren_groups)\n        max_nesting[i]\
    \ = get_max_nesting(paren_groups[i])\n    end\n    return max_nesting\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp0nwp2uai.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ get_max_nesting not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmp0nwp2uai.jl:12\n   [2] top-level scope at /tmp/tmp0nwp2uai.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0nwp2uai.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp0nwp2uai.jl:22\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: get_max_nesting not\
    \ defined\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmp0nwp2uai.jl:12\n\
    \   [2] top-level scope at /tmp/tmp0nwp2uai.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0nwp2uai.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp0nwp2uai.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: get_max_nesting not defined\n  Stacktrace:\n\
    \   [1] parse_nested_parens(::String) at /tmp/tmp0nwp2uai.jl:12\n   [2] top-level\
    \ scope at /tmp/tmp0nwp2uai.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0nwp2uai.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0nwp2uai.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize a vector to store the depth of each group\n    depth = Vector{Int64}()\n\
    \    # Initialize a counter to keep track of the depth of the current group\n\
    \    count = 0\n    # Iterate through the string\n    for i in 1:length(paren_string)\n\
    \        # If the current character is an opening parenthesis, increment the counter\n\
    \        if paren_string[i] == '('\n            count += 1\n        # If the current\
    \ character is a closing parenthesis, decrement the counter\n        elseif paren_string[i]\
    \ == ')'\n            count -= 1\n        # If the current character is a space,\
    \ push the current depth to the vector and reset the counter\n        elseif paren_string[i]\
    \ == ' '\n            push!(depth, count)\n            count = 0\n        end\n\
    \    end\n    # Return the vector\n    return depth\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpp79_jx20.jl:35\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0] == [2,\
    \ 3, 1, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpp79_jx20.jl:35\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp79_jx20.jl:34\ntest set: Test Failed at /tmp/tmpp79_jx20.jl:36\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n   Evaluated:\
    \ [0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1] top-level scope at /tmp/tmpp79_jx20.jl:36\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp79_jx20.jl:34\ntest set: Test Failed at /tmp/tmpp79_jx20.jl:37\n\
    \  Expression: candidate(\"(()(())((())))\") == [4]\n   Evaluated: Int64[] ==\
    \ [4]\nStacktrace:\n [1] top-level scope at /tmp/tmpp79_jx20.jl:37\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp79_jx20.jl:34\nTest Summary: | Fail  Total\n\
    test set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpp79_jx20.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = split(paren_string, \" \")\n    max_depth = Vector{Int64}(undef,\
    \ length(paren_string))\n    for i in 1:length(paren_string)\n        depth =\
    \ 0\n        max_depth[i] = 0\n        for j in 1:length(paren_string[i])\n  \
    \          if paren_string[i][j] == '('\n                depth += 1\n        \
    \        if depth > max_depth[i]\n                    max_depth[i] = depth\n \
    \               end\n            elseif paren_string[i][j] == ')'\n          \
    \      depth -= 1\n            end\n        end\n    end\n    return max_depth\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = Vector{Int64}(undef,\
    \ length(paren_groups))\n    for (i, paren_group) in enumerate(paren_groups)\n\
    \        max_nesting[i] = get_max_nesting(paren_group)\n    end\n    return max_nesting\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpg2iye7g8.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ get_max_nesting not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmpg2iye7g8.jl:12\n   [2] top-level scope at /tmp/tmpg2iye7g8.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg2iye7g8.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpg2iye7g8.jl:22\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: get_max_nesting not\
    \ defined\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmpg2iye7g8.jl:12\n\
    \   [2] top-level scope at /tmp/tmpg2iye7g8.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg2iye7g8.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpg2iye7g8.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: get_max_nesting not defined\n  Stacktrace:\n\
    \   [1] parse_nested_parens(::String) at /tmp/tmpg2iye7g8.jl:12\n   [2] top-level\
    \ scope at /tmp/tmpg2iye7g8.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg2iye7g8.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpg2iye7g8.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = Vector{Int64}(undef,\
    \ length(paren_groups))\n    for i in 1:length(paren_groups)\n        paren_group\
    \ = paren_groups[i]\n        max_nesting[i] = 0\n        current_nesting = 0\n\
    \        for j in 1:length(paren_group)\n            if paren_group[j] == '('\n\
    \                current_nesting += 1\n            elseif paren_group[j] == ')'\n\
    \                current_nesting -= 1\n            end\n            if current_nesting\
    \ > max_nesting[i]\n                max_nesting[i] = current_nesting\n       \
    \     end\n        end\n    end\n    return max_nesting\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = Vector{Int64}(undef,\
    \ length(paren_groups))\n    for i in 1:length(paren_groups)\n        max_nesting[i]\
    \ = parse_nested_parens_helper(paren_groups[i])\n    end\n    return max_nesting\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmpp1uy00eb.jl:21\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3]\\n  UndefVarError: parse_nested_parens_helper not defined\\n  Stacktrace:\\\
    n   [1] parse_nested_parens(::String) at /tmp/tmpp1uy00eb.jl:12\\n   [2] top-level\
    \ scope at /tmp/tmpp1uy00eb.jl:21\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpp1uy00eb.jl:20\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpp1uy00eb.jl:22\\n  Test threw exception\\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\\n  UndefVarError: parse_nested_parens_helper\
    \ not defined\\n  Stacktrace:\\n   [1] parse_nested_parens(::String) at /tmp/tmpp1uy00eb.jl:12\\\
    n   [2] top-level scope at /tmp/tmpp1uy00eb.jl:22\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpp1uy00eb.jl:20\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpp1uy00eb.jl:23\\n  Test threw exception\\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\\n  UndefVarError: parse_nested_parens_helper not defined\\\
    n  Stacktrace:\\n   [1] parse_nested_parens(::String) at /tmp/tmpp1uy00eb.jl:12\\\
    n   [2] top-level scope at /tmp/tmpp1uy00eb.jl:23\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpp1uy00eb.jl:20\\n  \\nTest Summary: | Error\
    \  Total\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = []\n    for\
    \ paren_group in paren_groups\n        max_nesting_count = 0\n        nesting_count\
    \ = 0\n        for paren in paren_group\n            if paren == '('\n       \
    \         nesting_count += 1\n            elseif paren == ')'\n              \
    \  nesting_count -= 1\n            end\n            if nesting_count > max_nesting_count\n\
    \                max_nesting_count = nesting_count\n            end\n        end\n\
    \        push!(max_nesting, max_nesting_count)\n    end\n    return max_nesting\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string =\
    \ replace(paren_string, \"()\", \" \")\n    paren_string = replace(paren_string,\
    \ \")\", \"\")\n    paren_string = replace(paren_string, \"(\", \"\")\n    return\
    \ parse.(Int64, split(paren_string, \" \"))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp2wgqpo7m.jl:20\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3]\\n  MethodError: no method matching replace(::String, ::String, ::String)\\\
    n  Closest candidates are:\\n    replace(::String, !Matched::Pair{#s67,B} where\
    \ B where #s67<:AbstractChar; count) at strings/util.jl:421\\n    replace(::String,\
    \ !Matched::Pair{#s64,B} where B where #s64<:Union{Tuple{Vararg{AbstractChar,N}\
    \ where N}, Set{#s61} where #s61<:AbstractChar, AbstractArray{#s62,1} where #s62<:AbstractChar};\
    \ count) at strings/util.jl:426\\n    replace(::String, !Matched::Pair; count)\
    \ at strings/util.jl:433\\n    ...\\n  Stacktrace:\\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmp2wgqpo7m.jl:9\\n   [2] top-level scope at /tmp/tmp2wgqpo7m.jl:20\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp2wgqpo7m.jl:19\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp2wgqpo7m.jl:21\\n  Test threw exception\\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\\n  MethodError: no method matching\
    \ replace(::String, ::String, ::String)\\n  Closest candidates are:\\n    replace(::String,\
    \ !Matched::Pair{#s67,B} where B where #s67<:AbstractChar; count) at strings/util.jl:421\\\
    n    replace(::String, !Matched::Pair{#s64,B} where B where #s64<:Union{Tuple{Vararg{AbstractChar,N}\
    \ where N}, Set{#s61} where #s61<:AbstractChar, AbstractArray{#s62,1} where #s62<:AbstractChar};\
    \ count) at strings/util.jl:426\\n    replace(::String, !Matched::Pair; count)\
    \ at strings/util.jl:433\\n    ...\\n  Stacktrace:\\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmp2wgqpo7m.jl:9\\n   [2] top-level scope at /tmp/tmp2wgqpo7m.jl:21\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp2wgqpo7m.jl:19\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp2wgqpo7m.jl:22\\n  Test threw exception\\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\\n  MethodError: no method matching replace(::String,\
    \ ::String, ::String)\\n  Closest candidates are:\\n    replace(::String, !Matched::Pair{#s67,B}\
    \ where B where #s67<:AbstractChar; count) at strings/util.jl:421\\n    replace(::String,\
    \ !Matched::Pair{#s64,B} where B where #s64<:Union{Tuple{Vararg{AbstractChar,N}\
    \ where N}, Set{#s61} where #s61<:AbstractChar, AbstractArray{#s62,1} where #s62<:AbstractChar};\
    \ count) at strings/util.jl:426\\n    replace(::String, !Matched::Pair; count)\
    \ at strings/util.jl:433\\n    ...\\n  Stacktrace:\\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmp2wgqpo7m.jl:9\\n   [2] top-level scope at /tmp/tmp2wgqpo7m.jl:22\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp2wgqpo7m.jl:19\\n  \\nTest Summary: | Error\
    \  Total\\ntest set      |     3      3\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = Vector{Int64}(undef,\
    \ length(paren_groups))\n    for (i, paren_group) in enumerate(paren_groups)\n\
    \        max_nesting[i] = get_max_nesting(paren_group)\n    end\n    return max_nesting\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpxib7jips.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ get_max_nesting not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmpxib7jips.jl:12\n   [2] top-level scope at /tmp/tmpxib7jips.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxib7jips.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpxib7jips.jl:22\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: get_max_nesting not\
    \ defined\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmpxib7jips.jl:12\n\
    \   [2] top-level scope at /tmp/tmpxib7jips.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxib7jips.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpxib7jips.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: get_max_nesting not defined\n  Stacktrace:\n\
    \   [1] parse_nested_parens(::String) at /tmp/tmpxib7jips.jl:12\n   [2] top-level\
    \ scope at /tmp/tmpxib7jips.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxib7jips.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxib7jips.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = []\n    for\
    \ paren_group in paren_groups\n        nesting = 0\n        max_nesting_in_group\
    \ = 0\n        for paren in paren_group\n            if paren == '('\n       \
    \         nesting += 1\n            elseif paren == ')'\n                nesting\
    \ -= 1\n            end\n            if nesting > max_nesting_in_group\n     \
    \           max_nesting_in_group = nesting\n            end\n        end\n   \
    \     push!(max_nesting, max_nesting_in_group)\n    end\n    return max_nesting\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    paren_counts = Vector{Int64}(undef,\
    \ length(paren_groups))\n    for i in 1:length(paren_groups)\n        paren_counts[i]\
    \ = parse_nested_parens_single(paren_groups[i])\n    end\n    return paren_counts\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp4qlh_ogg.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_nested_parens_single not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmp4qlh_ogg.jl:12\n   [2] top-level scope at /tmp/tmp4qlh_ogg.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4qlh_ogg.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp4qlh_ogg.jl:22\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_nested_parens_single\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmp4qlh_ogg.jl:12\n\
    \   [2] top-level scope at /tmp/tmp4qlh_ogg.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4qlh_ogg.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp4qlh_ogg.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: parse_nested_parens_single not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmp4qlh_ogg.jl:12\n\
    \   [2] top-level scope at /tmp/tmp4qlh_ogg.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4qlh_ogg.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4qlh_ogg.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string =\
    \ replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")\", \"\")\n    paren_string = replace(paren_string, \"(\", \"\")\n    return\
    \ [length(x) for x in split(paren_string, \"\")]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmphbucfp2c.jl:20\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching replace(::String, ::String, ::String)\n  Closest candidates\
    \ are:\n    replace(::String, !Matched::Pair{#s67,B} where B where #s67<:AbstractChar;\
    \ count) at strings/util.jl:421\n    replace(::String, !Matched::Pair{#s64,B}\
    \ where B where #s64<:Union{Tuple{Vararg{AbstractChar,N} where N}, Set{#s61} where\
    \ #s61<:AbstractChar, AbstractArray{#s62,1} where #s62<:AbstractChar}; count)\
    \ at strings/util.jl:426\n    replace(::String, !Matched::Pair; count) at strings/util.jl:433\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmphbucfp2c.jl:9\n\
    \   [2] top-level scope at /tmp/tmphbucfp2c.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphbucfp2c.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmphbucfp2c.jl:21\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method matching\
    \ replace(::String, ::String, ::String)\n  Closest candidates are:\n    replace(::String,\
    \ !Matched::Pair{#s67,B} where B where #s67<:AbstractChar; count) at strings/util.jl:421\n\
    \    replace(::String, !Matched::Pair{#s64,B} where B where #s64<:Union{Tuple{Vararg{AbstractChar,N}\
    \ where N}, Set{#s61} where #s61<:AbstractChar, AbstractArray{#s62,1} where #s62<:AbstractChar};\
    \ count) at strings/util.jl:426\n    replace(::String, !Matched::Pair; count)\
    \ at strings/util.jl:433\n    ...\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmphbucfp2c.jl:9\n   [2] top-level scope at /tmp/tmphbucfp2c.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphbucfp2c.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmphbucfp2c.jl:22\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  MethodError: no method matching replace(::String,\
    \ ::String, ::String)\n  Closest candidates are:\n    replace(::String, !Matched::Pair{#s67,B}\
    \ where B where #s67<:AbstractChar; count) at strings/util.jl:421\n    replace(::String,\
    \ !Matched::Pair{#s64,B} where B where #s64<:Union{Tuple{Vararg{AbstractChar,N}\
    \ where N}, Set{#s61} where #s61<:AbstractChar, AbstractArray{#s62,1} where #s62<:AbstractChar};\
    \ count) at strings/util.jl:426\n    replace(::String, !Matched::Pair; count)\
    \ at strings/util.jl:433\n    ...\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmphbucfp2c.jl:9\n   [2] top-level scope at /tmp/tmphbucfp2c.jl:22\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphbucfp2c.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphbucfp2c.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Split the string into groups\n    groups = split(paren_string, \" \"\
    )\n    # Initialize a vector to store the maximum depth of each group\n    max_depth\
    \ = zeros(Int64, length(groups))\n    # Iterate through each group\n    for i\
    \ in 1:length(groups)\n        # Initialize a counter to keep track of the depth\
    \ of the current group\n        depth = 0\n        # Initialize a counter to keep\
    \ track of the maximum depth of the current group\n        max_depth_curr = 0\n\
    \        # Iterate through each character in the current group\n        for j\
    \ in 1:length(groups[i])\n            # If the character is an opening parenthesis,\
    \ increment the depth counter\n            if groups[i][j] == '('\n          \
    \      depth += 1\n            # If the character is a closing parenthesis, decrement\
    \ the depth counter\n            elseif groups[i][j] == ')'\n                depth\
    \ -= 1\n            end\n            # If the depth counter is greater than the\
    \ maximum depth counter, update the maximum depth counter\n            if depth\
    \ > max_depth_curr\n                max_depth_curr = depth\n            end\n\
    \        end\n        # Update the maximum depth vector with the maximum depth\
    \ of the current group\n        max_depth[i] = max_depth_curr\n    end\n    #\
    \ Return the maximum depth vector\n    return max_depth\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize an empty vector to store the result\n    result = Int64[]\n\
    \    # Split the string by space to get individual groups\n    for group in split(paren_string,\
    \ \" \")\n        # Initialize a counter to keep track of the number of nested\
    \ parentheses\n        counter = 0\n        # Initialize a maximum counter to\
    \ keep track of the maximum number of nested parentheses\n        max_counter\
    \ = 0\n        # Iterate through each character in the group\n        for c in\
    \ group\n            # If the character is an opening parenthesis, increment the\
    \ counter\n            if c == '('\n                counter += 1\n           \
    \ # If the character is a closing parenthesis, decrement the counter\n       \
    \     elseif c == ')'\n                counter -= 1\n            end\n       \
    \     # Update the maximum counter if the current counter is greater than the\
    \ maximum counter\n            if counter > max_counter\n                max_counter\
    \ = counter\n            end\n        end\n        # Push the maximum counter\
    \ to the result vector\n        push!(result, max_counter)\n    end\n    # Return\
    \ the result vector\n    return result\nend\nusing Test\n\n@testset begin\n\n\
    candidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_list = split(paren_string, \" \")\n    max_nesting = zeros(Int64,\
    \ length(paren_list))\n    for i in 1:length(paren_list)\n        paren_group\
    \ = paren_list[i]\n        max_nesting[i] = count_nesting(paren_group)\n    end\n\
    \    return max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp8i8f5tbl.jl:22\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ count_nesting not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmp8i8f5tbl.jl:13\n   [2] top-level scope at /tmp/tmp8i8f5tbl.jl:22\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8i8f5tbl.jl:21\n  \ntest set: Error During\
    \ Test at /tmp/tmp8i8f5tbl.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: count_nesting not\
    \ defined\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmp8i8f5tbl.jl:13\n\
    \   [2] top-level scope at /tmp/tmp8i8f5tbl.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8i8f5tbl.jl:21\n  \ntest set: Error During\
    \ Test at /tmp/tmp8i8f5tbl.jl:24\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: count_nesting not defined\n  Stacktrace:\n\
    \   [1] parse_nested_parens(::String) at /tmp/tmp8i8f5tbl.jl:13\n   [2] top-level\
    \ scope at /tmp/tmp8i8f5tbl.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8i8f5tbl.jl:21\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8i8f5tbl.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = []\n    for\
    \ group in paren_groups\n        nesting = 0\n        max_nesting_in_group = 0\n\
    \        for char in group\n            if char == '('\n                nesting\
    \ += 1\n            elseif char == ')'\n                nesting -= 1\n       \
    \     end\n            if nesting > max_nesting_in_group\n                max_nesting_in_group\
    \ = nesting\n            end\n        end\n        push!(max_nesting, max_nesting_in_group)\n\
    \    end\n    return max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = split(paren_string, \" \")\n    max_nesting = zeros(Int64,\
    \ length(paren_string))\n    for i in 1:length(paren_string)\n        paren_group\
    \ = paren_string[i]\n        paren_count = 0\n        for j in 1:length(paren_group)\n\
    \            if paren_group[j] == '('\n                paren_count += 1\n    \
    \        elseif paren_group[j] == ')'\n                paren_count -= 1\n    \
    \        end\n            max_nesting[i] = max(max_nesting[i], paren_count)\n\
    \        end\n    end\n    return max_nesting\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string =\
    \ replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")\", \"\")\n    paren_string = replace(paren_string, \"(\", \"\")\n    return\
    \ length.(split(paren_string, \"\"))\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpz3ud6m04.jl:20\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching replace(::String, ::String, ::String)\n  Closest candidates\
    \ are:\n    replace(::String, !Matched::Pair{#s67,B} where B where #s67<:AbstractChar;\
    \ count) at strings/util.jl:421\n    replace(::String, !Matched::Pair{#s64,B}\
    \ where B where #s64<:Union{Tuple{Vararg{AbstractChar,N} where N}, Set{#s61} where\
    \ #s61<:AbstractChar, AbstractArray{#s62,1} where #s62<:AbstractChar}; count)\
    \ at strings/util.jl:426\n    replace(::String, !Matched::Pair; count) at strings/util.jl:433\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmpz3ud6m04.jl:9\n\
    \   [2] top-level scope at /tmp/tmpz3ud6m04.jl:20\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpz3ud6m04.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpz3ud6m04.jl:21\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method matching\
    \ replace(::String, ::String, ::String)\n  Closest candidates are:\n    replace(::String,\
    \ !Matched::Pair{#s67,B} where B where #s67<:AbstractChar; count) at strings/util.jl:421\n\
    \    replace(::String, !Matched::Pair{#s64,B} where B where #s64<:Union{Tuple{Vararg{AbstractChar,N}\
    \ where N}, Set{#s61} where #s61<:AbstractChar, AbstractArray{#s62,1} where #s62<:AbstractChar};\
    \ count) at strings/util.jl:426\n    replace(::String, !Matched::Pair; count)\
    \ at strings/util.jl:433\n    ...\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmpz3ud6m04.jl:9\n   [2] top-level scope at /tmp/tmpz3ud6m04.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpz3ud6m04.jl:19\n  \ntest set: Error During\
    \ Test at /tmp/tmpz3ud6m04.jl:22\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  MethodError: no method matching replace(::String,\
    \ ::String, ::String)\n  Closest candidates are:\n    replace(::String, !Matched::Pair{#s67,B}\
    \ where B where #s67<:AbstractChar; count) at strings/util.jl:421\n    replace(::String,\
    \ !Matched::Pair{#s64,B} where B where #s64<:Union{Tuple{Vararg{AbstractChar,N}\
    \ where N}, Set{#s61} where #s61<:AbstractChar, AbstractArray{#s62,1} where #s62<:AbstractChar};\
    \ count) at strings/util.jl:426\n    replace(::String, !Matched::Pair; count)\
    \ at strings/util.jl:433\n    ...\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmpz3ud6m04.jl:9\n   [2] top-level scope at /tmp/tmpz3ud6m04.jl:22\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpz3ud6m04.jl:19\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpz3ud6m04.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string =\
    \ replace(paren_string, \")\", \"\")\n    paren_string = replace(paren_string,\
    \ \"(\", \" \")\n    paren_string = replace(paren_string, \"  \", \" \")\n   \
    \ paren_string = replace(paren_string, \"  \", \" \")\n    paren_string = replace(paren_string,\
    \ \"  \", \" \")\n    paren_string = replace(paren_string, \"  \", \" \")\n  \
    \  paren_string = replace(paren_string, \"  \", \" \")\n    paren_string = replace(paren_string,\
    \ \"  \", \" \")\n    paren_string = replace(paren_string, \"  \", \" \")\n  \
    \  paren_string = replace(paren_string, \"  \", \" \")\n    paren_string = replace(paren_string,\
    \ \"  \", \" \")\n    paren_string = replace(paren_string, \"  \", \" \")\n  \
    \  paren_string = replace(paren_string, \"  \", \" \")\n    paren_string = replace(paren_string,\
    \ \"  \", \" \")\n    paren_string = replace(paren_string, \"  \", \" \")\n  \
    \  paren_string = replace(paren_string, \"  \", \" \")\n    paren_string = replace(paren_string,\
    \ \"  \", \" \")\n    paren_string = replace(paren_string, \"  \", \" \")\n  \
    \  paren_string = replace(paren_string, \"  \", \" \")\n    paren_string = replace(paren_string,\
    \ \"  \", \" \")\n    paren_string = replace(paren_string, \"  \", \" \")\n  \
    \  paren_string = replace(paren_string, \"  \", \" \")\n    paren_string = replace(paren_string,\
    \ \"  \", \" \")\n    paren_string = replace(paren_string, \"  \", \" \")\n  \
    \  paren_string = replace(paren_string, \"  \", \" \")\n    paren_string = replace(paren_string,\
    \ \"  \", \" \")\n    paren\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpnugdv4ch.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpnugdv4ch.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpnugdv4ch.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    return [parse_nested_parens_helper(group)\
    \ for group in paren_groups]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpk24aymle.jl:17\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_nested_parens_helper not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmpk24aymle.jl:10\n   [2] top-level scope at /tmp/tmpk24aymle.jl:17\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpk24aymle.jl:16\n  \ntest set: Error During\
    \ Test at /tmp/tmpk24aymle.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_nested_parens_helper\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmpk24aymle.jl:10\n\
    \   [2] top-level scope at /tmp/tmpk24aymle.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpk24aymle.jl:16\n  \ntest set: Error During\
    \ Test at /tmp/tmpk24aymle.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: parse_nested_parens_helper not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmpk24aymle.jl:10\n\
    \   [2] top-level scope at /tmp/tmpk24aymle.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpk24aymle.jl:16\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpk24aymle.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = zeros(Int64,\
    \ length(paren_groups))\n    for (i, paren_group) in enumerate(paren_groups)\n\
    \        level = 0\n        max_level = 0\n        for paren in paren_group\n\
    \            if paren == '('\n                level += 1\n            elseif paren\
    \ == ')'\n                level -= 1\n            end\n            max_level =\
    \ max(max_level, level)\n        end\n        max_nesting[i] = max_level\n   \
    \ end\n    return max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = Vector{Int64}(undef,\
    \ length(paren_groups))\n    for (i, group) in enumerate(paren_groups)\n     \
    \   max_nesting[i] = parse_nested_parens_helper(group)\n    end\n    return max_nesting\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpbl36vr2r.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_nested_parens_helper not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmpbl36vr2r.jl:12\n   [2] top-level scope at /tmp/tmpbl36vr2r.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbl36vr2r.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpbl36vr2r.jl:22\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_nested_parens_helper\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmpbl36vr2r.jl:12\n\
    \   [2] top-level scope at /tmp/tmpbl36vr2r.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbl36vr2r.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpbl36vr2r.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: parse_nested_parens_helper not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmpbl36vr2r.jl:12\n\
    \   [2] top-level scope at /tmp/tmpbl36vr2r.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbl36vr2r.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbl36vr2r.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string =\
    \ replace(paren_string, \")\", \"\")\n    paren_string = replace(paren_string,\
    \ \"(\", \"\")\n    paren_string = replace(paren_string, \"\", \" \")\n    paren_string\
    \ = replace(paren_string, \" \", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \" \")\n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \" \")\n    paren_string = replace(paren_string,\
    \ \" \", \"\")\n    paren_string = replace(paren_string, \"\", \" \")\n    paren_string\
    \ = replace(paren_string, \" \", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \" \")\n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \" \")\n    paren_string = replace(paren_string,\
    \ \" \", \"\")\n    paren_string = replace(paren_string, \"\", \" \")\n    paren_string\
    \ = replace(paren_string, \" \", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \" \")\n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \" \")\n    paren_string = replace(paren_string,\
    \ \" \", \"\")\n    paren_string = replace(paren_string, \"\", \" \")\n    paren_string\
    \ = replace(paren_string, \" \", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \" \")\n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \" \")\n    paren_string = replace(paren_string,\
    \ \" \", \"\")\n    paren_string = replace(paren_string, \"\", \" \")\n    paren_string\
    \ = replace(paren_string, \" \", \"\")\n    paren_string\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp1ueww9as.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp1ueww9as.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp1ueww9as.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    return [parse_nested_parens_helper(group)\
    \ for group in paren_groups]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpw_yenfo_.jl:17\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3]\\n  UndefVarError: parse_nested_parens_helper not defined\\n  Stacktrace:\\\
    n   [1] parse_nested_parens(::String) at /tmp/tmpw_yenfo_.jl:10\\n   [2] top-level\
    \ scope at /tmp/tmpw_yenfo_.jl:17\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpw_yenfo_.jl:16\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpw_yenfo_.jl:18\\n  Test threw exception\\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\\n  UndefVarError: parse_nested_parens_helper\
    \ not defined\\n  Stacktrace:\\n   [1] parse_nested_parens(::String) at /tmp/tmpw_yenfo_.jl:10\\\
    n   [2] top-level scope at /tmp/tmpw_yenfo_.jl:18\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpw_yenfo_.jl:16\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpw_yenfo_.jl:19\\n  Test threw exception\\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\\n  UndefVarError: parse_nested_parens_helper not defined\\\
    n  Stacktrace:\\n   [1] parse_nested_parens(::String) at /tmp/tmpw_yenfo_.jl:10\\\
    n   [2] top-level scope at /tmp/tmpw_yenfo_.jl:19\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpw_yenfo_.jl:16\\n  \\nTest Summary: | Error\
    \  Total\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Split the string into groups of parentheses\n    paren_groups = split(paren_string,\
    \ \" \")\n    # Initialize a vector to store the maximum nesting level for each\
    \ group\n    max_nesting_level = zeros(Int64, length(paren_groups))\n    # Loop\
    \ through each group\n    for i in 1:length(paren_groups)\n        # Initialize\
    \ a counter to keep track of the nesting level\n        nesting_level = 0\n  \
    \      # Initialize a variable to keep track of the maximum nesting level\n  \
    \      max_nesting_level[i] = 0\n        # Loop through each character in the\
    \ group\n        for c in paren_groups[i]\n            # If the character is an\
    \ opening parenthesis, increment the nesting level\n            if c == '('\n\
    \                nesting_level += 1\n            # If the character is a closing\
    \ parenthesis, decrement the nesting level\n            elseif c == ')'\n    \
    \            nesting_level -= 1\n            end\n            # Update the maximum\
    \ nesting level if the current nesting level is greater\n            if nesting_level\
    \ > max_nesting_level[i]\n                max_nesting_level[i] = nesting_level\n\
    \            end\n        end\n    end\n    # Return the maximum nesting level\
    \ for each group\n    return max_nesting_level\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = Vector{Int64}(undef,\
    \ length(paren_groups))\n    for (i, paren_group) in enumerate(paren_groups)\n\
    \        max_nesting[i] = parse_nested_parens_helper(paren_group)\n    end\n \
    \   return max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmput3bm2re.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_nested_parens_helper not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmput3bm2re.jl:12\n   [2] top-level scope at /tmp/tmput3bm2re.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmput3bm2re.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmput3bm2re.jl:22\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_nested_parens_helper\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmput3bm2re.jl:12\n\
    \   [2] top-level scope at /tmp/tmput3bm2re.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmput3bm2re.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmput3bm2re.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: parse_nested_parens_helper not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmput3bm2re.jl:12\n\
    \   [2] top-level scope at /tmp/tmput3bm2re.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmput3bm2re.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmput3bm2re.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string =\
    \ replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \"\")\n    paren_string = replace(paren_string, \")(\", \"\")\n    paren_string\
    \ = replace(paren_string, \")(\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \"\")\n    paren_string = replace(paren_string, \")(\", \"\")\n    paren_string\
    \ = replace(paren_string, \")(\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \"\")\n    paren_string = replace(paren_string, \")(\", \"\")\n    paren_string\
    \ = replace(paren_string, \")(\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \"\")\n    paren_string = replace(paren_string, \")(\", \"\")\n    paren_string\
    \ = replace(paren_string, \")(\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \"\")\n    paren_string = replace(paren_string, \")(\", \"\")\n    paren_string\
    \ = replace(paren_string, \")(\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \"\")\n    paren_string = replace(paren_string, \")(\", \"\")\n    paren_string\
    \ = replace(paren_string, \")(\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \"\")\n    paren_string = replace(paren_string, \")(\", \"\")\n    paren_string\
    \ = replace(paren_string, \")(\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \"\")\n    paren_string = replace(paren_string, \")(\", \"\")\n    paren_string\
    \ = replace(paren_string, \")(\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \"\")\n    paren_string = replace(paren_string, \")(\", \"\")\n    paren_string\
    \ = replace(\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmphetn58l_.jl:40\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmphetn58l_.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string =\
    \ replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \"\")\n    paren_string = replace(paren_string, \"((\", \"\")\n    paren_string\
    \ = replace(paren_string, \"))\", \"\")\n    paren_string = replace(paren_string,\
    \ \"(\", \"\")\n    paren_string = replace(paren_string, \")\", \"\")\n    paren_string\
    \ = replace(paren_string, \" \", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \"\")\n    paren_string = replace(paren_string, \"\", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \"\")\n    paren_string = replace(paren_string, \"\", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \"\")\n    paren_string = replace(paren_string, \"\", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \"\")\n    paren_string = replace(paren_string, \"\", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \"\")\n    paren_string = replace(paren_string, \"\", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \"\")\n    paren_string = replace(paren_string, \"\", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \"\")\n    paren_string = replace(paren_string, \"\", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \"\")\n    paren_string = replace(paren_string,\
    \ \"\",\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t\
    @test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpvm1dx5kb.jl:41\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpvm1dx5kb.jl:41\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string =\
    \ replace(paren_string, \")\", \"\")\n    paren_string = replace(paren_string,\
    \ \"(\", \"\")\n    paren_string = replace(paren_string, \"\", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \"\")\n    paren_string = replace(paren_string, \"\", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \"\")\n    paren_string = replace(paren_string, \"\", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \"\")\n    paren_string = replace(paren_string, \"\", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \"\")\n    paren_string = replace(paren_string, \"\", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \"\")\n    paren_string = replace(paren_string, \"\", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \"\")\n    paren_string = replace(paren_string, \"\", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \"\")\n    paren_string = replace(paren_string, \"\", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \"\")\n    paren_string = replace(paren_string, \"\", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \"\")\n   \nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmprqivoat7.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmprqivoat7.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmprqivoat7.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_list = split(paren_string, \" \")\n    max_nest_list = []\n    for\
    \ paren in paren_list\n        max_nest = 0\n        nest_count = 0\n        for\
    \ c in paren\n            if c == '('\n                nest_count += 1\n     \
    \       elseif c == ')'\n                nest_count -= 1\n            end\n  \
    \          if nest_count > max_nest\n                max_nest = nest_count\n \
    \           end\n        end\n        push!(max_nest_list, max_nest)\n    end\n\
    \    return max_nest_list\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = split(paren_string, \" \")\n    max_depth = Vector{Int64}(undef,\
    \ length(paren_string))\n    for i in 1:length(paren_string)\n        max_depth[i]\
    \ = 0\n        depth = 0\n        for j in 1:length(paren_string[i])\n       \
    \     if paren_string[i][j] == '('\n                depth += 1\n            elseif\
    \ paren_string[i][j] == ')'\n                depth -= 1\n            end\n   \
    \         if depth > max_depth[i]\n                max_depth[i] = depth\n    \
    \        end\n        end\n    end\n    return max_depth\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string =\
    \ replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \"\")\n    paren_string = replace(paren_string, \")(\", \"\")\n    paren_string\
    \ = replace(paren_string, \")(\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \"\")\n    paren_string = replace(paren_string, \")(\", \"\")\n    paren_string\
    \ = replace(paren_string, \")(\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \"\")\n    paren_string = replace(paren_string, \")(\", \"\")\n    paren_string\
    \ = replace(paren_string, \")(\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \"\")\n    paren_string = replace(paren_string, \")(\", \"\")\n    paren_string\
    \ = replace(paren_string, \")(\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \"\")\n    paren_string = replace(paren_string, \")(\", \"\")\n    paren_string\
    \ = replace(paren_string, \")(\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \"\")\n    paren_string = replace(paren_string, \")(\", \"\")\n    paren_string\
    \ = replace(paren_string, \")(\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \"\")\n    paren_string = replace(paren_string, \")(\", \"\")\n    paren_string\
    \ = replace(paren_string, \")(\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \"\")\n    paren_string = replace(paren_string, \")(\", \"\")\n    paren_string\
    \ = replace(paren_string, \")(\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \"\")\n    paren_string = replace(paren_string, \")(\", \"\")\n    paren_string\
    \ = replace(\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpdl4x74mq.jl:40\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpdl4x74mq.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    return [parse_nested_parens_helper(group)\
    \ for group in paren_groups]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpltvw6lxs.jl:17\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_nested_parens_helper not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmpltvw6lxs.jl:10\n   [2] top-level scope at /tmp/tmpltvw6lxs.jl:17\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpltvw6lxs.jl:16\n  \ntest set: Error During\
    \ Test at /tmp/tmpltvw6lxs.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_nested_parens_helper\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmpltvw6lxs.jl:10\n\
    \   [2] top-level scope at /tmp/tmpltvw6lxs.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpltvw6lxs.jl:16\n  \ntest set: Error During\
    \ Test at /tmp/tmpltvw6lxs.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: parse_nested_parens_helper not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmpltvw6lxs.jl:10\n\
    \   [2] top-level scope at /tmp/tmpltvw6lxs.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpltvw6lxs.jl:16\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpltvw6lxs.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string =\
    \ replace(paren_string, \")\", \"\")\n    paren_string = replace(paren_string,\
    \ \"(\", \" \")\n    paren_string = replace(paren_string, \"  \", \" \")\n   \
    \ paren_string = replace(paren_string, \"  \", \" \")\n    paren_string = replace(paren_string,\
    \ \"  \", \" \")\n    paren_string = replace(paren_string, \"  \", \" \")\n  \
    \  paren_string = replace(paren_string, \"  \", \" \")\n    paren_string = replace(paren_string,\
    \ \"  \", \" \")\n    paren_string = replace(paren_string, \"  \", \" \")\n  \
    \  paren_string = replace(paren_string, \"  \", \" \")\n    paren_string = replace(paren_string,\
    \ \"  \", \" \")\n    paren_string = replace(paren_string, \"  \", \" \")\n  \
    \  paren_string = replace(paren_string, \"  \", \" \")\n    paren_string = replace(paren_string,\
    \ \"  \", \" \")\n    paren_string = replace(paren_string, \"  \", \" \")\n  \
    \  paren_string = replace(paren_string, \"  \", \" \")\n    paren_string = replace(paren_string,\
    \ \"  \", \" \")\n    paren_string = replace(paren_string, \"  \", \" \")\n  \
    \  paren_string = replace(paren_string, \"  \", \" \")\n    paren_string = replace(paren_string,\
    \ \"  \", \" \")\n    paren_string = replace(paren_string, \"  \", \" \")\n  \
    \  paren_string = replace(paren_string, \"  \", \" \")\n    paren_string = replace(paren_string,\
    \ \"  \", \" \")\n    paren_string = replace(paren_string, \"  \", \" \")\n  \
    \  paren_string = replace(paren_string, \"  \", \" \")\n    paren_string = replace(paren_string,\
    \ \"  \", \" \")\n    paren\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2evv6i3m.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp2evv6i3m.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp2evv6i3m.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize a vector to store the depth of nesting for each group\n \
    \   depths = Vector{Int64}()\n    # Initialize a counter to keep track of the\
    \ depth of nesting\n    depth = 0\n    # Initialize a variable to keep track of\
    \ the start of a group\n    start = 1\n    # Loop through the string\n    for\
    \ i in 1:length(paren_string)\n        # If we encounter an opening parenthesis,\
    \ increment the depth\n        if paren_string[i] == '('\n            depth +=\
    \ 1\n        # If we encounter a closing parenthesis, decrement the depth\n  \
    \      elseif paren_string[i] == ')'\n            depth -= 1\n        # If we\
    \ encounter a space, we have reached the end of a group\n        elseif paren_string[i]\
    \ == ' '\n            # Append the depth of the group to the vector\n        \
    \    push!(depths, depth)\n            # Reset the depth counter\n           \
    \ depth = 0\n            # Reset the start of the group\n            start = i\
    \ + 1\n        end\n    end\n    # Return the vector\n    return depths\nend\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "b'test set: Test Failed at /tmp/tmp79152jk8.jl:41\\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\\n   Evaluated: [0, 0, 0] == [2,\
    \ 3, 1, 3]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp79152jk8.jl:41\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp79152jk8.jl:40\\ntest set: Test Failed at /tmp/tmp79152jk8.jl:42\\\
    n  Expression: candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\\n   Evaluated:\
    \ [0, 0, 0] == [1, 2, 3, 4]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp79152jk8.jl:42\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp79152jk8.jl:40\\ntest set: Test Failed at /tmp/tmp79152jk8.jl:43\\\
    n  Expression: candidate(\"(()(())((())))\") == [4]\\n   Evaluated: Int64[] ==\
    \ [4]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp79152jk8.jl:43\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp79152jk8.jl:40\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = []\n    for\
    \ paren_group in paren_groups\n        paren_stack = []\n        max_depth = 0\n\
    \        for paren in paren_group\n            if paren == '('\n             \
    \   push!(paren_stack, paren)\n                max_depth = max(max_depth, length(paren_stack))\n\
    \            elseif paren == ')'\n                pop!(paren_stack)\n        \
    \    end\n        end\n        push!(max_nesting, max_depth)\n    end\n    return\
    \ max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string =\
    \ replace(paren_string, \")(\", \") (\")\n    paren_string = split(paren_string,\
    \ \" \")\n    paren_string = map(x -> count_parens(x), paren_string)\n    return\
    \ paren_string\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpmv2nq0wk.jl:20\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3]\\n  MethodError: no method matching replace(::String, ::String, ::String)\\\
    n  Closest candidates are:\\n    replace(::String, !Matched::Pair{#s67,B} where\
    \ B where #s67<:AbstractChar; count) at strings/util.jl:421\\n    replace(::String,\
    \ !Matched::Pair{#s64,B} where B where #s64<:Union{Tuple{Vararg{AbstractChar,N}\
    \ where N}, Set{#s61} where #s61<:AbstractChar, AbstractArray{#s62,1} where #s62<:AbstractChar};\
    \ count) at strings/util.jl:426\\n    replace(::String, !Matched::Pair; count)\
    \ at strings/util.jl:433\\n    ...\\n  Stacktrace:\\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmpmv2nq0wk.jl:9\\n   [2] top-level scope at /tmp/tmpmv2nq0wk.jl:20\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpmv2nq0wk.jl:19\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpmv2nq0wk.jl:21\\n  Test threw exception\\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\\n  MethodError: no method matching\
    \ replace(::String, ::String, ::String)\\n  Closest candidates are:\\n    replace(::String,\
    \ !Matched::Pair{#s67,B} where B where #s67<:AbstractChar; count) at strings/util.jl:421\\\
    n    replace(::String, !Matched::Pair{#s64,B} where B where #s64<:Union{Tuple{Vararg{AbstractChar,N}\
    \ where N}, Set{#s61} where #s61<:AbstractChar, AbstractArray{#s62,1} where #s62<:AbstractChar};\
    \ count) at strings/util.jl:426\\n    replace(::String, !Matched::Pair; count)\
    \ at strings/util.jl:433\\n    ...\\n  Stacktrace:\\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmpmv2nq0wk.jl:9\\n   [2] top-level scope at /tmp/tmpmv2nq0wk.jl:21\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpmv2nq0wk.jl:19\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpmv2nq0wk.jl:22\\n  Test threw exception\\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\\n  MethodError: no method matching replace(::String,\
    \ ::String, ::String)\\n  Closest candidates are:\\n    replace(::String, !Matched::Pair{#s67,B}\
    \ where B where #s67<:AbstractChar; count) at strings/util.jl:421\\n    replace(::String,\
    \ !Matched::Pair{#s64,B} where B where #s64<:Union{Tuple{Vararg{AbstractChar,N}\
    \ where N}, Set{#s61} where #s61<:AbstractChar, AbstractArray{#s62,1} where #s62<:AbstractChar};\
    \ count) at strings/util.jl:426\\n    replace(::String, !Matched::Pair; count)\
    \ at strings/util.jl:433\\n    ...\\n  Stacktrace:\\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmpmv2nq0wk.jl:9\\n   [2] top-level scope at /tmp/tmpmv2nq0wk.jl:22\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpmv2nq0wk.jl:19\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Split the string into groups\n    groups = split(paren_string, \" \"\
    )\n    # Initialize the output vector\n    output = Vector{Int64}(undef, length(groups))\n\
    \    # Iterate over the groups\n    for (i, group) in enumerate(groups)\n    \
    \    # Initialize the stack\n        stack = []\n        # Initialize the max\
    \ level\n        max_level = 0\n        # Iterate over the characters in the group\n\
    \        for c in group\n            # If the character is an opening parenthesis,\
    \ push it to the stack\n            if c == '('\n                push!(stack,\
    \ c)\n            # If the character is a closing parenthesis, pop the stack\n\
    \            elseif c == ')'\n                pop!(stack)\n            end\n \
    \           # Update the max level\n            max_level = max(max_level, length(stack))\n\
    \        end\n        # Save the max level\n        output[i] = max_level\n  \
    \  end\n    # Return the output\n    return output\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    paren_levels = []\n   \
    \ for paren_group in paren_groups\n        paren_levels = push!(paren_levels,\
    \ parse_parens(paren_group))\n    end\n    return paren_levels\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmptffteuoh.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_parens not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmptffteuoh.jl:12\n   [2] top-level scope at /tmp/tmptffteuoh.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmptffteuoh.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmptffteuoh.jl:22\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_parens not\
    \ defined\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmptffteuoh.jl:12\n\
    \   [2] top-level scope at /tmp/tmptffteuoh.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmptffteuoh.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmptffteuoh.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: parse_parens not defined\n  Stacktrace:\n\
    \   [1] parse_nested_parens(::String) at /tmp/tmptffteuoh.jl:12\n   [2] top-level\
    \ scope at /tmp/tmptffteuoh.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmptffteuoh.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmptffteuoh.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = zeros(Int64,\
    \ length(paren_groups))\n    for (i, paren_group) in enumerate(paren_groups)\n\
    \        nesting = 0\n        max_nesting_in_group = 0\n        for c in paren_group\n\
    \            if c == '('\n                nesting += 1\n            elseif c ==\
    \ ')'\n                nesting -= 1\n            end\n            max_nesting_in_group\
    \ = max(max_nesting_in_group, nesting)\n        end\n        max_nesting[i] =\
    \ max_nesting_in_group\n    end\n    return max_nesting\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = zeros(Int64,\
    \ length(paren_groups))\n    for i in 1:length(paren_groups)\n        paren_group\
    \ = paren_groups[i]\n        paren_count = 0\n        max_count = 0\n        for\
    \ j in 1:length(paren_group)\n            if paren_group[j] == '('\n         \
    \       paren_count += 1\n            elseif paren_group[j] == ')'\n         \
    \       paren_count -= 1\n            end\n            if paren_count > max_count\n\
    \                max_count = paren_count\n            end\n        end\n     \
    \   max_nesting[i] = max_count\n    end\n    return max_nesting\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize a vector to store the depth of each group\n    depth = Vector{Int64}()\n\
    \    # Initialize a counter to keep track of the depth\n    count = 0\n    # Iterate\
    \ through each character in the string\n    for c in paren_string\n        # If\
    \ the character is an opening parenthesis, increment the counter\n        if c\
    \ == '('\n            count += 1\n        # If the character is a closing parenthesis,\
    \ decrement the counter\n        elseif c == ')'\n            count -= 1\n   \
    \     # If the character is a space, store the current depth and reset the counter\n\
    \        elseif c == ' '\n            push!(depth, count)\n            count =\
    \ 0\n        end\n    end\n    # Return the vector of depths\n    return depth\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpvdd64yge.jl:35\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0] == [2,\
    \ 3, 1, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpvdd64yge.jl:35\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvdd64yge.jl:34\ntest set: Test Failed at /tmp/tmpvdd64yge.jl:36\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n   Evaluated:\
    \ [0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1] top-level scope at /tmp/tmpvdd64yge.jl:36\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvdd64yge.jl:34\ntest set: Test Failed at /tmp/tmpvdd64yge.jl:37\n\
    \  Expression: candidate(\"(()(())((())))\") == [4]\n   Evaluated: Int64[] ==\
    \ [4]\nStacktrace:\n [1] top-level scope at /tmp/tmpvdd64yge.jl:37\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvdd64yge.jl:34\nTest Summary: | Fail  Total\n\
    test set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpvdd64yge.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = []\n    for\
    \ paren_group in paren_groups\n        nesting = 0\n        max_nesting_level\
    \ = 0\n        for paren in paren_group\n            if paren == '('\n       \
    \         nesting += 1\n            elseif paren == ')'\n                nesting\
    \ -= 1\n            end\n            if nesting > max_nesting_level\n        \
    \        max_nesting_level = nesting\n            end\n        end\n        push!(max_nesting,\
    \ max_nesting_level)\n    end\n    return max_nesting\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = Vector{Int64}(undef,\
    \ length(paren_groups))\n    for i in 1:length(paren_groups)\n        max_nesting[i]\
    \ = parse_nested_parens_helper(paren_groups[i])\n    end\n    return max_nesting\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpv18ve7nb.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_nested_parens_helper not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmpv18ve7nb.jl:12\n   [2] top-level scope at /tmp/tmpv18ve7nb.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpv18ve7nb.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpv18ve7nb.jl:22\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_nested_parens_helper\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmpv18ve7nb.jl:12\n\
    \   [2] top-level scope at /tmp/tmpv18ve7nb.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpv18ve7nb.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpv18ve7nb.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: parse_nested_parens_helper not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmpv18ve7nb.jl:12\n\
    \   [2] top-level scope at /tmp/tmpv18ve7nb.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpv18ve7nb.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpv18ve7nb.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # initialize a vector to store the depth of each group\n    depth_vector\
    \ = Vector{Int64}()\n    # initialize a variable to store the depth of the current\
    \ group\n    depth = 0\n    # loop through each character in the string\n    for\
    \ c in paren_string\n        # if the character is an opening parenthesis, increment\
    \ the depth\n        if c == '('\n            depth += 1\n        # if the character\
    \ is a closing parenthesis, decrement the depth\n        elseif c == ')'\n   \
    \         depth -= 1\n        # if the character is a space, append the current\
    \ depth to the vector and reset the depth to 0\n        elseif c == ' '\n    \
    \        push!(depth_vector, depth)\n            depth = 0\n        end\n    end\n\
    \    # return the vector\n    return depth_vector\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpgh8vp9fx.jl:35\\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\\n   Evaluated: [0, 0, 0] == [2,\
    \ 3, 1, 3]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpgh8vp9fx.jl:35\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpgh8vp9fx.jl:34\\ntest set: Test Failed at /tmp/tmpgh8vp9fx.jl:36\\\
    n  Expression: candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\\n   Evaluated:\
    \ [0, 0, 0] == [1, 2, 3, 4]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpgh8vp9fx.jl:36\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpgh8vp9fx.jl:34\\ntest set: Test Failed at /tmp/tmpgh8vp9fx.jl:37\\\
    n  Expression: candidate(\"(()(())((())))\") == [4]\\n   Evaluated: Int64[] ==\
    \ [4]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpgh8vp9fx.jl:37\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpgh8vp9fx.jl:34\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Split the string into groups\n    groups = split(paren_string, \" \"\
    )\n    # Initialize a vector to store the depth of each group\n    depth = Vector{Int64}(undef,\
    \ length(groups))\n    # Iterate over each group\n    for i in 1:length(groups)\n\
    \        # Initialize a counter to keep track of the depth\n        count = 0\n\
    \        # Iterate over each character in the group\n        for j in 1:length(groups[i])\n\
    \            # If the character is an opening parenthesis, increment the counter\n\
    \            if groups[i][j] == '('\n                count += 1\n            #\
    \ If the character is a closing parenthesis, decrement the counter\n         \
    \   elseif groups[i][j] == ')'\n                count -= 1\n            end\n\
    \        end\n        # Store the depth of the group\n        depth[i] = count\n\
    \    end\n    # Return the depth of each group\n    return depth\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "b'test set: Test Failed at /tmp/tmpyb092or2.jl:38\\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\\n   Evaluated: [0, 0, 0, 0] ==\
    \ [2, 3, 1, 3]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpyb092or2.jl:38\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpyb092or2.jl:37\\ntest set: Test Failed at /tmp/tmpyb092or2.jl:39\\\
    n  Expression: candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\\n   Evaluated:\
    \ [0, 0, 0, 0] == [1, 2, 3, 4]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpyb092or2.jl:39\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpyb092or2.jl:37\\ntest set: Test Failed at /tmp/tmpyb092or2.jl:40\\\
    n  Expression: candidate(\"(()(())((())))\") == [4]\\n   Evaluated: [0] == [4]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpyb092or2.jl:40\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpyb092or2.jl:37\\nTest Summary: | Fail  Total\\\
    ntest set      |    3      3\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    return map(x -> count_nested_parens(x),\
    \ paren_groups)\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpgyums67m.jl:17\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ count_nested_parens not defined\n  Stacktrace:\n   [1] (::var\"#3#4\")(::SubString{String})\
    \ at /tmp/tmpgyums67m.jl:10\n   [2] iterate at ./generator.jl:47 [inlined]\n \
    \  [3] _collect(::Array{SubString{String},1}, ::Base.Generator{Array{SubString{String},1},var\"\
    #3#4\"}, ::Base.EltypeUnknown, ::Base.HasShape{1}) at ./array.jl:678\n   [4] collect_similar\
    \ at ./array.jl:607 [inlined]\n   [5] map at ./abstractarray.jl:2072 [inlined]\n\
    \   [6] parse_nested_parens(::String) at /tmp/tmpgyums67m.jl:10\n   [7] top-level\
    \ scope at /tmp/tmpgyums67m.jl:17\n   [8] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [9] top-level scope at /tmp/tmpgyums67m.jl:16\n  \ntest set: Error During\
    \ Test at /tmp/tmpgyums67m.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: count_nested_parens\
    \ not defined\n  Stacktrace:\n   [1] (::var\"#3#4\")(::SubString{String}) at /tmp/tmpgyums67m.jl:10\n\
    \   [2] iterate at ./generator.jl:47 [inlined]\n   [3] _collect(::Array{SubString{String},1},\
    \ ::Base.Generator{Array{SubString{String},1},var\"#3#4\"}, ::Base.EltypeUnknown,\
    \ ::Base.HasShape{1}) at ./array.jl:678\n   [4] collect_similar at ./array.jl:607\
    \ [inlined]\n   [5] map at ./abstractarray.jl:2072 [inlined]\n   [6] parse_nested_parens(::String)\
    \ at /tmp/tmpgyums67m.jl:10\n   [7] top-level scope at /tmp/tmpgyums67m.jl:18\n\
    \   [8] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [9] top-level scope at /tmp/tmpgyums67m.jl:16\n  \ntest set: Error During\
    \ Test at /tmp/tmpgyums67m.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: count_nested_parens not defined\n \
    \ Stacktrace:\n   [1] (::var\"#3#4\")(::SubString{String}) at /tmp/tmpgyums67m.jl:10\n\
    \   [2] iterate at ./generator.jl:47 [inlined]\n   [3] _collect(::Array{SubString{String},1},\
    \ ::Base.Generator{Array{SubString{String},1},var\"#3#4\"}, ::Base.EltypeUnknown,\
    \ ::Base.HasShape{1}) at ./array.jl:678\n   [4] collect_similar at ./array.jl:607\
    \ [inlined]\n   [5] map at ./abstractarray.jl:2072 [inlined]\n   [6] parse_nested_parens(::String)\
    \ at /tmp/tmpgyums67m.jl:10\n   [7] top-level scope at /tmp/tmpgyums67m.jl:19\n\
    \   [8] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [9] top-level scope at /tmp/tmpgyums67m.jl:16\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgyums67m.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = Vector{Int64}(undef,\
    \ length(paren_groups))\n    for (i, paren_group) in enumerate(paren_groups)\n\
    \        max_nesting[i] = count_nesting(paren_group)\n    end\n    return max_nesting\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp0pvwhzv2.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ count_nesting not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmp0pvwhzv2.jl:12\n   [2] top-level scope at /tmp/tmp0pvwhzv2.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0pvwhzv2.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp0pvwhzv2.jl:22\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: count_nesting not\
    \ defined\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmp0pvwhzv2.jl:12\n\
    \   [2] top-level scope at /tmp/tmp0pvwhzv2.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0pvwhzv2.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp0pvwhzv2.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: count_nesting not defined\n  Stacktrace:\n\
    \   [1] parse_nested_parens(::String) at /tmp/tmp0pvwhzv2.jl:12\n   [2] top-level\
    \ scope at /tmp/tmp0pvwhzv2.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0pvwhzv2.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0pvwhzv2.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = []\n    for\
    \ group in paren_groups\n        max_nesting_level = 0\n        current_nesting_level\
    \ = 0\n        for c in group\n            if c == '('\n                current_nesting_level\
    \ += 1\n            elseif c == ')'\n                current_nesting_level -=\
    \ 1\n            end\n            if current_nesting_level > max_nesting_level\n\
    \                max_nesting_level = current_nesting_level\n            end\n\
    \        end\n        push!(max_nesting, max_nesting_level)\n    end\n    return\
    \ max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    return [parse_parens(group)\
    \ for group in paren_groups]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp2cpy3w6g.jl:17\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_parens not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmp2cpy3w6g.jl:10\n   [2] top-level scope at /tmp/tmp2cpy3w6g.jl:17\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2cpy3w6g.jl:16\n  \ntest set: Error During\
    \ Test at /tmp/tmp2cpy3w6g.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_parens not\
    \ defined\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmp2cpy3w6g.jl:10\n\
    \   [2] top-level scope at /tmp/tmp2cpy3w6g.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2cpy3w6g.jl:16\n  \ntest set: Error During\
    \ Test at /tmp/tmp2cpy3w6g.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: parse_parens not defined\n  Stacktrace:\n\
    \   [1] parse_nested_parens(::String) at /tmp/tmp2cpy3w6g.jl:10\n   [2] top-level\
    \ scope at /tmp/tmp2cpy3w6g.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2cpy3w6g.jl:16\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2cpy3w6g.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = Vector{Int64}(undef,\
    \ length(paren_groups))\n    for (i, paren_group) in enumerate(paren_groups)\n\
    \        max_nesting[i] = max_nesting_depth(paren_group)\n    end\n    return\
    \ max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpqhgqiyh_.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ max_nesting_depth not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmpqhgqiyh_.jl:12\n   [2] top-level scope at /tmp/tmpqhgqiyh_.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqhgqiyh_.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpqhgqiyh_.jl:22\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: max_nesting_depth\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmpqhgqiyh_.jl:12\n\
    \   [2] top-level scope at /tmp/tmpqhgqiyh_.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqhgqiyh_.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpqhgqiyh_.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: max_nesting_depth not defined\n  Stacktrace:\n\
    \   [1] parse_nested_parens(::String) at /tmp/tmpqhgqiyh_.jl:12\n   [2] top-level\
    \ scope at /tmp/tmpqhgqiyh_.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqhgqiyh_.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqhgqiyh_.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = Vector{Int64}(undef,\
    \ length(paren_groups))\n    for (i, paren_group) in enumerate(paren_groups)\n\
    \        max_nesting[i] = get_max_nesting(paren_group)\n    end\n    return max_nesting\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmpqknv45uq.jl:21\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3]\\n  UndefVarError: get_max_nesting not defined\\n  Stacktrace:\\n \
    \  [1] parse_nested_parens(::String) at /tmp/tmpqknv45uq.jl:12\\n   [2] top-level\
    \ scope at /tmp/tmpqknv45uq.jl:21\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpqknv45uq.jl:20\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpqknv45uq.jl:22\\n  Test threw exception\\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\\n  UndefVarError: get_max_nesting\
    \ not defined\\n  Stacktrace:\\n   [1] parse_nested_parens(::String) at /tmp/tmpqknv45uq.jl:12\\\
    n   [2] top-level scope at /tmp/tmpqknv45uq.jl:22\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpqknv45uq.jl:20\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpqknv45uq.jl:23\\n  Test threw exception\\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\\n  UndefVarError: get_max_nesting not defined\\n  Stacktrace:\\\
    n   [1] parse_nested_parens(::String) at /tmp/tmpqknv45uq.jl:12\\n   [2] top-level\
    \ scope at /tmp/tmpqknv45uq.jl:23\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpqknv45uq.jl:20\\n  \\nTest Summary: | Error\
    \  Total\\ntest set      |     3      3\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = []\n    for\
    \ paren_group in paren_groups\n        max_nesting_level = 0\n        current_nesting_level\
    \ = 0\n        for paren in paren_group\n            if paren == '('\n       \
    \         current_nesting_level += 1\n            elseif paren == ')'\n      \
    \          current_nesting_level -= 1\n            end\n            if current_nesting_level\
    \ > max_nesting_level\n                max_nesting_level = current_nesting_level\n\
    \            end\n        end\n        push!(max_nesting, max_nesting_level)\n\
    \    end\n    return max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string =\
    \ replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \"\")\n    paren_string = replace(paren_string, \")\", \"\")\n    paren_string\
    \ = replace(paren_string, \"(\", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \"\")\n    return [length(x) for x in split(paren_string, \"\")]\nend\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpg96hujn6.jl:22\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching replace(::String, ::String, ::String)\n  Closest candidates\
    \ are:\n    replace(::String, !Matched::Pair{#s67,B} where B where #s67<:AbstractChar;\
    \ count) at strings/util.jl:421\n    replace(::String, !Matched::Pair{#s64,B}\
    \ where B where #s64<:Union{Tuple{Vararg{AbstractChar,N} where N}, Set{#s61} where\
    \ #s61<:AbstractChar, AbstractArray{#s62,1} where #s62<:AbstractChar}; count)\
    \ at strings/util.jl:426\n    replace(::String, !Matched::Pair; count) at strings/util.jl:433\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmpg96hujn6.jl:9\n\
    \   [2] top-level scope at /tmp/tmpg96hujn6.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg96hujn6.jl:21\n  \ntest set: Error During\
    \ Test at /tmp/tmpg96hujn6.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method matching\
    \ replace(::String, ::String, ::String)\n  Closest candidates are:\n    replace(::String,\
    \ !Matched::Pair{#s67,B} where B where #s67<:AbstractChar; count) at strings/util.jl:421\n\
    \    replace(::String, !Matched::Pair{#s64,B} where B where #s64<:Union{Tuple{Vararg{AbstractChar,N}\
    \ where N}, Set{#s61} where #s61<:AbstractChar, AbstractArray{#s62,1} where #s62<:AbstractChar};\
    \ count) at strings/util.jl:426\n    replace(::String, !Matched::Pair; count)\
    \ at strings/util.jl:433\n    ...\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmpg96hujn6.jl:9\n   [2] top-level scope at /tmp/tmpg96hujn6.jl:23\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg96hujn6.jl:21\n  \ntest set: Error During\
    \ Test at /tmp/tmpg96hujn6.jl:24\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  MethodError: no method matching replace(::String,\
    \ ::String, ::String)\n  Closest candidates are:\n    replace(::String, !Matched::Pair{#s67,B}\
    \ where B where #s67<:AbstractChar; count) at strings/util.jl:421\n    replace(::String,\
    \ !Matched::Pair{#s64,B} where B where #s64<:Union{Tuple{Vararg{AbstractChar,N}\
    \ where N}, Set{#s61} where #s61<:AbstractChar, AbstractArray{#s62,1} where #s62<:AbstractChar};\
    \ count) at strings/util.jl:426\n    replace(::String, !Matched::Pair; count)\
    \ at strings/util.jl:433\n    ...\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmpg96hujn6.jl:9\n   [2] top-level scope at /tmp/tmpg96hujn6.jl:24\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg96hujn6.jl:21\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpg96hujn6.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    return [parse_nested_parens_helper(group)\
    \ for group in paren_groups]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp9hbnqwf3.jl:17\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_nested_parens_helper not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmp9hbnqwf3.jl:10\n   [2] top-level scope at /tmp/tmp9hbnqwf3.jl:17\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9hbnqwf3.jl:16\n  \ntest set: Error During\
    \ Test at /tmp/tmp9hbnqwf3.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_nested_parens_helper\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmp9hbnqwf3.jl:10\n\
    \   [2] top-level scope at /tmp/tmp9hbnqwf3.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9hbnqwf3.jl:16\n  \ntest set: Error During\
    \ Test at /tmp/tmp9hbnqwf3.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: parse_nested_parens_helper not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmp9hbnqwf3.jl:10\n\
    \   [2] top-level scope at /tmp/tmp9hbnqwf3.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp9hbnqwf3.jl:16\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9hbnqwf3.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = []\n    for\
    \ group in paren_groups\n        max_nesting = push!(max_nesting, find_max_nesting(group))\n\
    \    end\n    return max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpmhr2rw35.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ find_max_nesting not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmpmhr2rw35.jl:12\n   [2] top-level scope at /tmp/tmpmhr2rw35.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmhr2rw35.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpmhr2rw35.jl:22\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: find_max_nesting\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmpmhr2rw35.jl:12\n\
    \   [2] top-level scope at /tmp/tmpmhr2rw35.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmhr2rw35.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpmhr2rw35.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: find_max_nesting not defined\n  Stacktrace:\n\
    \   [1] parse_nested_parens(::String) at /tmp/tmpmhr2rw35.jl:12\n   [2] top-level\
    \ scope at /tmp/tmpmhr2rw35.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpmhr2rw35.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmhr2rw35.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = []\n    for\
    \ paren_group in paren_groups\n        max_nesting_level = 0\n        current_nesting_level\
    \ = 0\n        for paren in paren_group\n            if paren == '('\n       \
    \         current_nesting_level += 1\n            elseif paren == ')'\n      \
    \          current_nesting_level -= 1\n            end\n            if current_nesting_level\
    \ > max_nesting_level\n                max_nesting_level = current_nesting_level\n\
    \            end\n        end\n        push!(max_nesting, max_nesting_level)\n\
    \    end\n    return max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_depth = Vector{Int64}(undef,\
    \ length(paren_groups))\n    for i in 1:length(paren_groups)\n        max_depth[i]\
    \ = parse_parens(paren_groups[i])\n    end\n    return max_depth\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp33nja4w2.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_parens not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmp33nja4w2.jl:12\n   [2] top-level scope at /tmp/tmp33nja4w2.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp33nja4w2.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp33nja4w2.jl:22\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_parens not\
    \ defined\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmp33nja4w2.jl:12\n\
    \   [2] top-level scope at /tmp/tmp33nja4w2.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp33nja4w2.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp33nja4w2.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: parse_parens not defined\n  Stacktrace:\n\
    \   [1] parse_nested_parens(::String) at /tmp/tmp33nja4w2.jl:12\n   [2] top-level\
    \ scope at /tmp/tmp33nja4w2.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp33nja4w2.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp33nja4w2.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize a vector to store the result\n    result = Vector{Int64}()\n\
    \    # Split the string by spaces\n    groups = split(paren_string, \" \")\n \
    \   # Loop through each group\n    for group in groups\n        # Initialize a\
    \ counter for the current group\n        counter = 0\n        # Initialize a maximum\
    \ counter for the current group\n        max_counter = 0\n        # Loop through\
    \ each character in the current group\n        for char in group\n           \
    \ # If the character is an open parenthesis, increase the counter\n          \
    \  if char == '('\n                counter += 1\n            # If the character\
    \ is a closed parenthesis, decrease the counter\n            elseif char == ')'\n\
    \                counter -= 1\n            end\n            # Update the maximum\
    \ counter if the current counter is larger\n            if counter > max_counter\n\
    \                max_counter = counter\n            end\n        end\n       \
    \ # Append the maximum counter to the result\n        push!(result, max_counter)\n\
    \    end\n    # Return the result\n    return result\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = []\n    for\
    \ paren_group in paren_groups\n        max_nesting_level = 0\n        current_nesting_level\
    \ = 0\n        for paren in paren_group\n            if paren == '('\n       \
    \         current_nesting_level += 1\n            elseif paren == ')'\n      \
    \          current_nesting_level -= 1\n            end\n            if current_nesting_level\
    \ > max_nesting_level\n                max_nesting_level = current_nesting_level\n\
    \            end\n        end\n        push!(max_nesting, max_nesting_level)\n\
    \    end\n    return max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_list = split(paren_string, \" \")\n    paren_depth = []\n    for\
    \ paren in paren_list\n        depth = 0\n        max_depth = 0\n        for c\
    \ in paren\n            if c == '('\n                depth += 1\n            elseif\
    \ c == ')'\n                depth -= 1\n            end\n            if depth\
    \ > max_depth\n                max_depth = depth\n            end\n        end\n\
    \        push!(paren_depth, max_depth)\n    end\n    return paren_depth\nend\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Split the string into groups\n    groups = split(paren_string, \" \"\
    )\n    # Initialize a vector to store the maximum nesting level for each group\n\
    \    max_nesting = zeros(Int64, length(groups))\n    # Loop through each group\n\
    \    for i in 1:length(groups)\n        # Initialize a counter for the current\
    \ nesting level\n        curr_nesting = 0\n        # Initialize a counter for\
    \ the maximum nesting level\n        max_nesting[i] = 0\n        # Loop through\
    \ each character in the group\n        for j in 1:length(groups[i])\n        \
    \    # If the character is an opening parenthesis, increment the current nesting\
    \ level\n            if groups[i][j] == '('\n                curr_nesting += 1\n\
    \            # If the character is a closing parenthesis, decrement the current\
    \ nesting level\n            elseif groups[i][j] == ')'\n                curr_nesting\
    \ -= 1\n            end\n            # If the current nesting level is greater\
    \ than the maximum nesting level, update the maximum nesting level\n         \
    \   if curr_nesting > max_nesting[i]\n                max_nesting[i] = curr_nesting\n\
    \            end\n        end\n    end\n    # Return the maximum nesting level\
    \ for each group\n    return max_nesting\nend\nusing Test\n\n@testset begin\n\n\
    candidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = Vector{Int64}(undef,\
    \ length(paren_groups))\n    for (i, paren_group) in enumerate(paren_groups)\n\
    \        max_nesting[i] = get_max_nesting(paren_group)\n    end\n    return max_nesting\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmppx0hjhc_.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ get_max_nesting not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmppx0hjhc_.jl:12\n   [2] top-level scope at /tmp/tmppx0hjhc_.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppx0hjhc_.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmppx0hjhc_.jl:22\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: get_max_nesting not\
    \ defined\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmppx0hjhc_.jl:12\n\
    \   [2] top-level scope at /tmp/tmppx0hjhc_.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppx0hjhc_.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmppx0hjhc_.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: get_max_nesting not defined\n  Stacktrace:\n\
    \   [1] parse_nested_parens(::String) at /tmp/tmppx0hjhc_.jl:12\n   [2] top-level\
    \ scope at /tmp/tmppx0hjhc_.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppx0hjhc_.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmppx0hjhc_.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    paren_levels = []\n   \
    \ for group in paren_groups\n        paren_levels = [push!(paren_levels, parse_parens(group))]\n\
    \    end\n    return paren_levels\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp_0me3tr5.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_parens not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmp_0me3tr5.jl:12\n   [2] top-level scope at /tmp/tmp_0me3tr5.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_0me3tr5.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp_0me3tr5.jl:22\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_parens not\
    \ defined\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmp_0me3tr5.jl:12\n\
    \   [2] top-level scope at /tmp/tmp_0me3tr5.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_0me3tr5.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp_0me3tr5.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: parse_parens not defined\n  Stacktrace:\n\
    \   [1] parse_nested_parens(::String) at /tmp/tmp_0me3tr5.jl:12\n   [2] top-level\
    \ scope at /tmp/tmp_0me3tr5.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_0me3tr5.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_0me3tr5.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = Vector{Int64}(undef,\
    \ length(paren_groups))\n    for (i, paren_group) in enumerate(paren_groups)\n\
    \        max_nesting[i] = max_nesting_in_paren_group(paren_group)\n    end\n \
    \   return max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpqegf_78y.jl:21\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3]\\n  UndefVarError: max_nesting_in_paren_group not defined\\n  Stacktrace:\\\
    n   [1] parse_nested_parens(::String) at /tmp/tmpqegf_78y.jl:12\\n   [2] top-level\
    \ scope at /tmp/tmpqegf_78y.jl:21\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpqegf_78y.jl:20\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpqegf_78y.jl:22\\n  Test threw exception\\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\\n  UndefVarError: max_nesting_in_paren_group\
    \ not defined\\n  Stacktrace:\\n   [1] parse_nested_parens(::String) at /tmp/tmpqegf_78y.jl:12\\\
    n   [2] top-level scope at /tmp/tmpqegf_78y.jl:22\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpqegf_78y.jl:20\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpqegf_78y.jl:23\\n  Test threw exception\\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\\n  UndefVarError: max_nesting_in_paren_group not defined\\\
    n  Stacktrace:\\n   [1] parse_nested_parens(::String) at /tmp/tmpqegf_78y.jl:12\\\
    n   [2] top-level scope at /tmp/tmpqegf_78y.jl:23\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpqegf_78y.jl:20\\n  \\nTest Summary: | Error\
    \  Total\\ntest set      |     3      3\\n'"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize a vector to store the depth of each group\n    depths = Int64[]\n\
    \    # Initialize a counter to keep track of the depth of the current group\n\
    \    depth = 0\n    # Initialize a variable to keep track of the start of the\
    \ current group\n    start = 0\n    # Loop through the string\n    for i in 1:length(paren_string)\n\
    \        # If the current character is an opening parenthesis, increment the depth\n\
    \        if paren_string[i] == '('\n            depth += 1\n        # If the current\
    \ character is a closing parenthesis, decrement the depth\n        elseif paren_string[i]\
    \ == ')'\n            depth -= 1\n        # If the current character is a space,\
    \ and the depth is zero, we have reached the end of a group\n        elseif paren_string[i]\
    \ == ' ' && depth == 0\n            # Append the depth of the current group to\
    \ the depths vector\n            push!(depths, depth)\n            # Reset the\
    \ depth counter\n            depth = 0\n            # Reset the start index\n\
    \            start = i + 1\n        end\n    end\n    # Return the depths vector\n\
    \    return depths\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpj354zvkb.jl:41\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0] == [2,\
    \ 3, 1, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpj354zvkb.jl:41\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpj354zvkb.jl:40\ntest set: Test Failed at /tmp/tmpj354zvkb.jl:42\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n   Evaluated:\
    \ [0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1] top-level scope at /tmp/tmpj354zvkb.jl:42\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpj354zvkb.jl:40\ntest set: Test Failed at /tmp/tmpj354zvkb.jl:43\n\
    \  Expression: candidate(\"(()(())((())))\") == [4]\n   Evaluated: Int64[] ==\
    \ [4]\nStacktrace:\n [1] top-level scope at /tmp/tmpj354zvkb.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpj354zvkb.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpj354zvkb.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = Vector{Int64}(undef,\
    \ length(paren_groups))\n    for (i, paren_group) in enumerate(paren_groups)\n\
    \        max_nesting[i] = parse_nested_parens_helper(paren_group)\n    end\n \
    \   return max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpsofbw5vu.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_nested_parens_helper not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmpsofbw5vu.jl:12\n   [2] top-level scope at /tmp/tmpsofbw5vu.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpsofbw5vu.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpsofbw5vu.jl:22\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_nested_parens_helper\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmpsofbw5vu.jl:12\n\
    \   [2] top-level scope at /tmp/tmpsofbw5vu.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpsofbw5vu.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpsofbw5vu.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: parse_nested_parens_helper not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmpsofbw5vu.jl:12\n\
    \   [2] top-level scope at /tmp/tmpsofbw5vu.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpsofbw5vu.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpsofbw5vu.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = Vector{Int64}(undef,\
    \ length(paren_groups))\n    for (i, paren_group) in enumerate(paren_groups)\n\
    \        max_nesting[i] = 0\n        current_nesting = 0\n        for paren in\
    \ paren_group\n            if paren == '('\n                current_nesting +=\
    \ 1\n            elseif paren == ')'\n                current_nesting -= 1\n \
    \           end\n            if current_nesting > max_nesting[i]\n           \
    \     max_nesting[i] = current_nesting\n            end\n        end\n    end\n\
    \    return max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = []\n    for\
    \ paren_group in paren_groups\n        max_nesting_level = 0\n        current_nesting_level\
    \ = 0\n        for paren in paren_group\n            if paren == '('\n       \
    \         current_nesting_level += 1\n            elseif paren == ')'\n      \
    \          current_nesting_level -= 1\n            end\n            if current_nesting_level\
    \ > max_nesting_level\n                max_nesting_level = current_nesting_level\n\
    \            end\n        end\n        push!(max_nesting, max_nesting_level)\n\
    \    end\n    return max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    return [parse_nested_parens_helper(group)\
    \ for group in paren_groups]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpzrgwzq39.jl:17\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3]\\n  UndefVarError: parse_nested_parens_helper not defined\\n  Stacktrace:\\\
    n   [1] parse_nested_parens(::String) at /tmp/tmpzrgwzq39.jl:10\\n   [2] top-level\
    \ scope at /tmp/tmpzrgwzq39.jl:17\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpzrgwzq39.jl:16\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpzrgwzq39.jl:18\\n  Test threw exception\\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\\n  UndefVarError: parse_nested_parens_helper\
    \ not defined\\n  Stacktrace:\\n   [1] parse_nested_parens(::String) at /tmp/tmpzrgwzq39.jl:10\\\
    n   [2] top-level scope at /tmp/tmpzrgwzq39.jl:18\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpzrgwzq39.jl:16\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpzrgwzq39.jl:19\\n  Test threw exception\\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\\n  UndefVarError: parse_nested_parens_helper not defined\\\
    n  Stacktrace:\\n   [1] parse_nested_parens(::String) at /tmp/tmpzrgwzq39.jl:10\\\
    n   [2] top-level scope at /tmp/tmpzrgwzq39.jl:19\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpzrgwzq39.jl:16\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # split the string into groups\n    groups = split(paren_string, \" \"\
    )\n    # initialize an array to store the maximum nesting level for each group\n\
    \    max_nesting = zeros(Int64, length(groups))\n    # loop through each group\n\
    \    for i in 1:length(groups)\n        # initialize a counter to keep track of\
    \ the current nesting level\n        nesting_level = 0\n        # loop through\
    \ each character in the group\n        for j in 1:length(groups[i])\n        \
    \    # if the character is an opening parenthesis, increase the nesting level\
    \ by 1\n            if groups[i][j] == '('\n                nesting_level += 1\n\
    \            # if the character is a closing parenthesis, decrease the nesting\
    \ level by 1\n            elseif groups[i][j] == ')'\n                nesting_level\
    \ -= 1\n            end\n            # if the current nesting level is greater\
    \ than the maximum nesting level for this group,\n            # update the maximum\
    \ nesting level\n            if nesting_level > max_nesting[i]\n             \
    \   max_nesting[i] = nesting_level\n            end\n        end\n    end\n  \
    \  # return the maximum nesting level for each group\n    return max_nesting\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = zeros(Int64,\
    \ length(paren_groups))\n    for (i, paren_group) in enumerate(paren_groups)\n\
    \        paren_stack = []\n        for c in paren_group\n            if c == '('\n\
    \                push!(paren_stack, c)\n            elseif c == ')'\n        \
    \        pop!(paren_stack)\n            end\n        end\n        max_nesting[i]\
    \ = length(paren_stack)\n    end\n    return max_nesting\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpkzqc5kdu.jl:29\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0, 0] ==\
    \ [2, 3, 1, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpkzqc5kdu.jl:29\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpkzqc5kdu.jl:28\ntest set: Test Failed at /tmp/tmpkzqc5kdu.jl:30\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n   Evaluated:\
    \ [0, 0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1] top-level scope at /tmp/tmpkzqc5kdu.jl:30\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpkzqc5kdu.jl:28\ntest set: Test Failed at /tmp/tmpkzqc5kdu.jl:31\n\
    \  Expression: candidate(\"(()(())((())))\") == [4]\n   Evaluated: [0] == [4]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpkzqc5kdu.jl:31\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpkzqc5kdu.jl:28\nTest Summary: | Fail  Total\n\
    test set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpkzqc5kdu.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize a vector to store the results\n    result = Vector{Int64}()\n\
    \    # Split the string by spaces\n    paren_groups = split(paren_string, \" \"\
    )\n    # For each group, calculate the maximum nesting level\n    for group in\
    \ paren_groups\n        # Initialize a counter to keep track of the nesting level\n\
    \        counter = 0\n        # Initialize a variable to keep track of the maximum\
    \ nesting level\n        max_level = 0\n        # For each character in the group\n\
    \        for char in group\n            # If the character is an opening parenthesis,\
    \ increment the counter\n            if char == '('\n                counter +=\
    \ 1\n            # If the character is a closing parenthesis, decrement the counter\n\
    \            elseif char == ')'\n                counter -= 1\n            end\n\
    \            # Update the maximum nesting level if the current nesting level is\
    \ greater than the current maximum\n            if counter > max_level\n     \
    \           max_level = counter\n            end\n        end\n        # Append\
    \ the maximum nesting level to the result vector\n        push!(result, max_level)\n\
    \    end\n    # Return the result vector\n    return result\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize a vector to store the depths of each group\n    depths =\
    \ Vector{Int64}()\n    # Initialize a counter to keep track of the current depth\n\
    \    depth = 0\n    # Loop through each character in the string\n    for c in\
    \ paren_string\n        # If the character is an open paren, increment the depth\n\
    \        if c == '('\n            depth += 1\n        # If the character is a\
    \ closed paren, decrement the depth\n        elseif c == ')'\n            depth\
    \ -= 1\n        # If the character is a space, add the current depth to the vector\
    \ and reset the depth to 0\n        elseif c == ' '\n            push!(depths,\
    \ depth)\n            depth = 0\n        end\n    end\n    # Return the vector\
    \ of depths\n    return depths\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpi3td990i.jl:35\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0] == [2,\
    \ 3, 1, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpi3td990i.jl:35\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpi3td990i.jl:34\ntest set: Test Failed at /tmp/tmpi3td990i.jl:36\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n   Evaluated:\
    \ [0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1] top-level scope at /tmp/tmpi3td990i.jl:36\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpi3td990i.jl:34\ntest set: Test Failed at /tmp/tmpi3td990i.jl:37\n\
    \  Expression: candidate(\"(()(())((())))\") == [4]\n   Evaluated: Int64[] ==\
    \ [4]\nStacktrace:\n [1] top-level scope at /tmp/tmpi3td990i.jl:37\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpi3td990i.jl:34\nTest Summary: | Fail  Total\n\
    test set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpi3td990i.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = replace(paren_string, \" \", \"\")\n    result = Vector{Int64}()\n\
    \    for i in 1:length(paren_string)\n        if paren_string[i] == '('\n    \
    \        j = i\n            count = 0\n            while j <= length(paren_string)\
    \ && paren_string[j] != ')'\n                if paren_string[j] == '('\n     \
    \               count += 1\n                end\n                j += 1\n    \
    \        end\n            push!(result, count)\n        end\n    end\n    return\
    \ result\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpii0my0gk.jl:31\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching replace(::String, ::String, ::String)\n  Closest candidates\
    \ are:\n    replace(::String, !Matched::Pair{#s67,B} where B where #s67<:AbstractChar;\
    \ count) at strings/util.jl:421\n    replace(::String, !Matched::Pair{#s64,B}\
    \ where B where #s64<:Union{Tuple{Vararg{AbstractChar,N} where N}, Set{#s61} where\
    \ #s61<:AbstractChar, AbstractArray{#s62,1} where #s62<:AbstractChar}; count)\
    \ at strings/util.jl:426\n    replace(::String, !Matched::Pair; count) at strings/util.jl:433\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmpii0my0gk.jl:9\n\
    \   [2] top-level scope at /tmp/tmpii0my0gk.jl:31\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpii0my0gk.jl:30\n  \ntest set: Error During\
    \ Test at /tmp/tmpii0my0gk.jl:32\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method matching\
    \ replace(::String, ::String, ::String)\n  Closest candidates are:\n    replace(::String,\
    \ !Matched::Pair{#s67,B} where B where #s67<:AbstractChar; count) at strings/util.jl:421\n\
    \    replace(::String, !Matched::Pair{#s64,B} where B where #s64<:Union{Tuple{Vararg{AbstractChar,N}\
    \ where N}, Set{#s61} where #s61<:AbstractChar, AbstractArray{#s62,1} where #s62<:AbstractChar};\
    \ count) at strings/util.jl:426\n    replace(::String, !Matched::Pair; count)\
    \ at strings/util.jl:433\n    ...\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmpii0my0gk.jl:9\n   [2] top-level scope at /tmp/tmpii0my0gk.jl:32\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpii0my0gk.jl:30\n  \ntest set: Error During\
    \ Test at /tmp/tmpii0my0gk.jl:33\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  MethodError: no method matching replace(::String,\
    \ ::String, ::String)\n  Closest candidates are:\n    replace(::String, !Matched::Pair{#s67,B}\
    \ where B where #s67<:AbstractChar; count) at strings/util.jl:421\n    replace(::String,\
    \ !Matched::Pair{#s64,B} where B where #s64<:Union{Tuple{Vararg{AbstractChar,N}\
    \ where N}, Set{#s61} where #s61<:AbstractChar, AbstractArray{#s62,1} where #s62<:AbstractChar};\
    \ count) at strings/util.jl:426\n    replace(::String, !Matched::Pair; count)\
    \ at strings/util.jl:433\n    ...\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmpii0my0gk.jl:9\n   [2] top-level scope at /tmp/tmpii0my0gk.jl:33\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpii0my0gk.jl:30\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpii0my0gk.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = Vector{Int64}(undef,\
    \ length(paren_groups))\n    for i in 1:length(paren_groups)\n        max_nesting[i]\
    \ = parse_nested_parens_helper(paren_groups[i])\n    end\n    return max_nesting\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp_pjytz2p.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_nested_parens_helper not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmp_pjytz2p.jl:12\n   [2] top-level scope at /tmp/tmp_pjytz2p.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_pjytz2p.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp_pjytz2p.jl:22\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_nested_parens_helper\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmp_pjytz2p.jl:12\n\
    \   [2] top-level scope at /tmp/tmp_pjytz2p.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_pjytz2p.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp_pjytz2p.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: parse_nested_parens_helper not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmp_pjytz2p.jl:12\n\
    \   [2] top-level scope at /tmp/tmp_pjytz2p.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_pjytz2p.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_pjytz2p.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    return [parse_nested_parens_single(group)\
    \ for group in paren_groups]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp78gsq755.jl:17\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_nested_parens_single not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmp78gsq755.jl:10\n   [2] top-level scope at /tmp/tmp78gsq755.jl:17\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp78gsq755.jl:16\n  \ntest set: Error During\
    \ Test at /tmp/tmp78gsq755.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_nested_parens_single\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmp78gsq755.jl:10\n\
    \   [2] top-level scope at /tmp/tmp78gsq755.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp78gsq755.jl:16\n  \ntest set: Error During\
    \ Test at /tmp/tmp78gsq755.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: parse_nested_parens_single not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmp78gsq755.jl:10\n\
    \   [2] top-level scope at /tmp/tmp78gsq755.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp78gsq755.jl:16\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp78gsq755.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string =\
    \ replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \"\")\n    paren_string = replace(paren_string, \")\", \"\")\n    paren_string\
    \ = replace(paren_string, \"(\", \"\")\n    return [length(x) for x in split(paren_string,\
    \ \"\")]\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpf8_j4q6r.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching replace(::String, ::String, ::String)\n  Closest candidates\
    \ are:\n    replace(::String, !Matched::Pair{#s67,B} where B where #s67<:AbstractChar;\
    \ count) at strings/util.jl:421\n    replace(::String, !Matched::Pair{#s64,B}\
    \ where B where #s64<:Union{Tuple{Vararg{AbstractChar,N} where N}, Set{#s61} where\
    \ #s61<:AbstractChar, AbstractArray{#s62,1} where #s62<:AbstractChar}; count)\
    \ at strings/util.jl:426\n    replace(::String, !Matched::Pair; count) at strings/util.jl:433\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmpf8_j4q6r.jl:9\n\
    \   [2] top-level scope at /tmp/tmpf8_j4q6r.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpf8_j4q6r.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpf8_j4q6r.jl:22\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method matching\
    \ replace(::String, ::String, ::String)\n  Closest candidates are:\n    replace(::String,\
    \ !Matched::Pair{#s67,B} where B where #s67<:AbstractChar; count) at strings/util.jl:421\n\
    \    replace(::String, !Matched::Pair{#s64,B} where B where #s64<:Union{Tuple{Vararg{AbstractChar,N}\
    \ where N}, Set{#s61} where #s61<:AbstractChar, AbstractArray{#s62,1} where #s62<:AbstractChar};\
    \ count) at strings/util.jl:426\n    replace(::String, !Matched::Pair; count)\
    \ at strings/util.jl:433\n    ...\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmpf8_j4q6r.jl:9\n   [2] top-level scope at /tmp/tmpf8_j4q6r.jl:22\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpf8_j4q6r.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpf8_j4q6r.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  MethodError: no method matching replace(::String,\
    \ ::String, ::String)\n  Closest candidates are:\n    replace(::String, !Matched::Pair{#s67,B}\
    \ where B where #s67<:AbstractChar; count) at strings/util.jl:421\n    replace(::String,\
    \ !Matched::Pair{#s64,B} where B where #s64<:Union{Tuple{Vararg{AbstractChar,N}\
    \ where N}, Set{#s61} where #s61<:AbstractChar, AbstractArray{#s62,1} where #s62<:AbstractChar};\
    \ count) at strings/util.jl:426\n    replace(::String, !Matched::Pair; count)\
    \ at strings/util.jl:433\n    ...\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmpf8_j4q6r.jl:9\n   [2] top-level scope at /tmp/tmpf8_j4q6r.jl:23\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpf8_j4q6r.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpf8_j4q6r.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = []\n    for\
    \ group in paren_groups\n        max_nesting = push!(max_nesting, count_nesting(group))\n\
    \    end\n    return max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpcvsl162h.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ count_nesting not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmpcvsl162h.jl:12\n   [2] top-level scope at /tmp/tmpcvsl162h.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcvsl162h.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpcvsl162h.jl:22\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: count_nesting not\
    \ defined\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmpcvsl162h.jl:12\n\
    \   [2] top-level scope at /tmp/tmpcvsl162h.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcvsl162h.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpcvsl162h.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: count_nesting not defined\n  Stacktrace:\n\
    \   [1] parse_nested_parens(::String) at /tmp/tmpcvsl162h.jl:12\n   [2] top-level\
    \ scope at /tmp/tmpcvsl162h.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpcvsl162h.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpcvsl162h.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = Vector{Int64}(undef,\
    \ length(paren_groups))\n    for (i, paren_group) in enumerate(paren_groups)\n\
    \        max_nesting[i] = max_nesting_in_group(paren_group)\n    end\n    return\
    \ max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp3xtsjbml.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ max_nesting_in_group not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmp3xtsjbml.jl:12\n   [2] top-level scope at /tmp/tmp3xtsjbml.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3xtsjbml.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp3xtsjbml.jl:22\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: max_nesting_in_group\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmp3xtsjbml.jl:12\n\
    \   [2] top-level scope at /tmp/tmp3xtsjbml.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3xtsjbml.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp3xtsjbml.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: max_nesting_in_group not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmp3xtsjbml.jl:12\n\
    \   [2] top-level scope at /tmp/tmp3xtsjbml.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3xtsjbml.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3xtsjbml.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string =\
    \ replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \"\")\n    paren_string = replace(paren_string, \"((\", \"\")\n    paren_string\
    \ = replace(paren_string, \"))\", \"\")\n    paren_string = replace(paren_string,\
    \ \")\", \"\")\n    paren_string = replace(paren_string, \"(\", \"\")\n    return\
    \ [length(x) for x in split(paren_string, \"\")]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp42omu_lc.jl:23\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching replace(::String, ::String, ::String)\n  Closest candidates\
    \ are:\n    replace(::String, !Matched::Pair{#s67,B} where B where #s67<:AbstractChar;\
    \ count) at strings/util.jl:421\n    replace(::String, !Matched::Pair{#s64,B}\
    \ where B where #s64<:Union{Tuple{Vararg{AbstractChar,N} where N}, Set{#s61} where\
    \ #s61<:AbstractChar, AbstractArray{#s62,1} where #s62<:AbstractChar}; count)\
    \ at strings/util.jl:426\n    replace(::String, !Matched::Pair; count) at strings/util.jl:433\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmp42omu_lc.jl:9\n\
    \   [2] top-level scope at /tmp/tmp42omu_lc.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp42omu_lc.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmp42omu_lc.jl:24\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method matching\
    \ replace(::String, ::String, ::String)\n  Closest candidates are:\n    replace(::String,\
    \ !Matched::Pair{#s67,B} where B where #s67<:AbstractChar; count) at strings/util.jl:421\n\
    \    replace(::String, !Matched::Pair{#s64,B} where B where #s64<:Union{Tuple{Vararg{AbstractChar,N}\
    \ where N}, Set{#s61} where #s61<:AbstractChar, AbstractArray{#s62,1} where #s62<:AbstractChar};\
    \ count) at strings/util.jl:426\n    replace(::String, !Matched::Pair; count)\
    \ at strings/util.jl:433\n    ...\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmp42omu_lc.jl:9\n   [2] top-level scope at /tmp/tmp42omu_lc.jl:24\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp42omu_lc.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmp42omu_lc.jl:25\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  MethodError: no method matching replace(::String,\
    \ ::String, ::String)\n  Closest candidates are:\n    replace(::String, !Matched::Pair{#s67,B}\
    \ where B where #s67<:AbstractChar; count) at strings/util.jl:421\n    replace(::String,\
    \ !Matched::Pair{#s64,B} where B where #s64<:Union{Tuple{Vararg{AbstractChar,N}\
    \ where N}, Set{#s61} where #s61<:AbstractChar, AbstractArray{#s62,1} where #s62<:AbstractChar};\
    \ count) at strings/util.jl:426\n    replace(::String, !Matched::Pair; count)\
    \ at strings/util.jl:433\n    ...\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmp42omu_lc.jl:9\n   [2] top-level scope at /tmp/tmp42omu_lc.jl:25\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp42omu_lc.jl:22\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp42omu_lc.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    paren_levels = []\n   \
    \ for paren_group in paren_groups\n        paren_levels = [push!(paren_levels,\
    \ paren_level(paren_group))]\n    end\n    return paren_levels\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp325ahzqm.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ paren_level not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmp325ahzqm.jl:12\n   [2] top-level scope at /tmp/tmp325ahzqm.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp325ahzqm.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp325ahzqm.jl:22\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: paren_level not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmp325ahzqm.jl:12\n\
    \   [2] top-level scope at /tmp/tmp325ahzqm.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp325ahzqm.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp325ahzqm.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: paren_level not defined\n  Stacktrace:\n\
    \   [1] parse_nested_parens(::String) at /tmp/tmp325ahzqm.jl:12\n   [2] top-level\
    \ scope at /tmp/tmp325ahzqm.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp325ahzqm.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp325ahzqm.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_list = split(paren_string, \" \")\n    paren_list = map(x -> x[2:end-1],\
    \ paren_list)\n    paren_list = map(x -> count(x, '('), paren_list)\n    return\
    \ paren_list\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpg_3pdk7u.jl:19\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ objects of type SubString{String} are not callable\n  Stacktrace:\n   [1] count(::SubString{String},\
    \ ::Char) at ./reduce.jl:855\n   [2] #4 at /tmp/tmpg_3pdk7u.jl:11 [inlined]\n\
    \   [3] iterate at ./generator.jl:47 [inlined]\n   [4] _collect(::Array{SubString{String},1},\
    \ ::Base.Generator{Array{SubString{String},1},var\"#4#6\"}, ::Base.EltypeUnknown,\
    \ ::Base.HasShape{1}) at ./array.jl:678\n   [5] collect_similar at ./array.jl:607\
    \ [inlined]\n   [6] map at ./abstractarray.jl:2072 [inlined]\n   [7] parse_nested_parens(::String)\
    \ at /tmp/tmpg_3pdk7u.jl:11\n   [8] top-level scope at /tmp/tmpg_3pdk7u.jl:19\n\
    \   [9] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [10] top-level scope at /tmp/tmpg_3pdk7u.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpg_3pdk7u.jl:20\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: objects of type SubString{String}\
    \ are not callable\n  Stacktrace:\n   [1] count(::SubString{String}, ::Char) at\
    \ ./reduce.jl:855\n   [2] #4 at /tmp/tmpg_3pdk7u.jl:11 [inlined]\n   [3] iterate\
    \ at ./generator.jl:47 [inlined]\n   [4] _collect(::Array{SubString{String},1},\
    \ ::Base.Generator{Array{SubString{String},1},var\"#4#6\"}, ::Base.EltypeUnknown,\
    \ ::Base.HasShape{1}) at ./array.jl:678\n   [5] collect_similar at ./array.jl:607\
    \ [inlined]\n   [6] map at ./abstractarray.jl:2072 [inlined]\n   [7] parse_nested_parens(::String)\
    \ at /tmp/tmpg_3pdk7u.jl:11\n   [8] top-level scope at /tmp/tmpg_3pdk7u.jl:20\n\
    \   [9] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [10] top-level scope at /tmp/tmpg_3pdk7u.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpg_3pdk7u.jl:21\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  MethodError: objects of type SubString{String} are\
    \ not callable\n  Stacktrace:\n   [1] count(::SubString{String}, ::Char) at ./reduce.jl:855\n\
    \   [2] #4 at /tmp/tmpg_3pdk7u.jl:11 [inlined]\n   [3] iterate at ./generator.jl:47\
    \ [inlined]\n   [4] _collect(::Array{SubString{String},1}, ::Base.Generator{Array{SubString{String},1},var\"\
    #4#6\"}, ::Base.EltypeUnknown, ::Base.HasShape{1}) at ./array.jl:678\n   [5] collect_similar\
    \ at ./array.jl:607 [inlined]\n   [6] map at ./abstractarray.jl:2072 [inlined]\n\
    \   [7] parse_nested_parens(::String) at /tmp/tmpg_3pdk7u.jl:11\n   [8] top-level\
    \ scope at /tmp/tmpg_3pdk7u.jl:21\n   [9] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [10] top-level scope at /tmp/tmpg_3pdk7u.jl:18\n  \nTest Summary: | Error\
    \  Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpg_3pdk7u.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_list = split(paren_string, \" \")\n    paren_list = map(x -> x[2:end-1],\
    \ paren_list)\n    paren_list = map(x -> count_parens(x), paren_list)\n    return\
    \ paren_list\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpix7b5plf.jl:19\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ count_parens not defined\n  Stacktrace:\n   [1] (::var\"#4#6\")(::SubString{String})\
    \ at /tmp/tmpix7b5plf.jl:11\n   [2] iterate at ./generator.jl:47 [inlined]\n \
    \  [3] _collect(::Array{SubString{String},1}, ::Base.Generator{Array{SubString{String},1},var\"\
    #4#6\"}, ::Base.EltypeUnknown, ::Base.HasShape{1}) at ./array.jl:678\n   [4] collect_similar\
    \ at ./array.jl:607 [inlined]\n   [5] map at ./abstractarray.jl:2072 [inlined]\n\
    \   [6] parse_nested_parens(::String) at /tmp/tmpix7b5plf.jl:11\n   [7] top-level\
    \ scope at /tmp/tmpix7b5plf.jl:19\n   [8] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [9] top-level scope at /tmp/tmpix7b5plf.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpix7b5plf.jl:20\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: count_parens not\
    \ defined\n  Stacktrace:\n   [1] (::var\"#4#6\")(::SubString{String}) at /tmp/tmpix7b5plf.jl:11\n\
    \   [2] iterate at ./generator.jl:47 [inlined]\n   [3] _collect(::Array{SubString{String},1},\
    \ ::Base.Generator{Array{SubString{String},1},var\"#4#6\"}, ::Base.EltypeUnknown,\
    \ ::Base.HasShape{1}) at ./array.jl:678\n   [4] collect_similar at ./array.jl:607\
    \ [inlined]\n   [5] map at ./abstractarray.jl:2072 [inlined]\n   [6] parse_nested_parens(::String)\
    \ at /tmp/tmpix7b5plf.jl:11\n   [7] top-level scope at /tmp/tmpix7b5plf.jl:20\n\
    \   [8] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [9] top-level scope at /tmp/tmpix7b5plf.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpix7b5plf.jl:21\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: count_parens not defined\n  Stacktrace:\n\
    \   [1] (::var\"#4#6\")(::SubString{String}) at /tmp/tmpix7b5plf.jl:11\n   [2]\
    \ iterate at ./generator.jl:47 [inlined]\n   [3] _collect(::Array{SubString{String},1},\
    \ ::Base.Generator{Array{SubString{String},1},var\"#4#6\"}, ::Base.EltypeUnknown,\
    \ ::Base.HasShape{1}) at ./array.jl:678\n   [4] collect_similar at ./array.jl:607\
    \ [inlined]\n   [5] map at ./abstractarray.jl:2072 [inlined]\n   [6] parse_nested_parens(::String)\
    \ at /tmp/tmpix7b5plf.jl:11\n   [7] top-level scope at /tmp/tmpix7b5plf.jl:21\n\
    \   [8] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [9] top-level scope at /tmp/tmpix7b5plf.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpix7b5plf.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize a vector to store the results\n    results = Vector{Int64}()\n\
    \    # Split the string by spaces\n    paren_groups = split(paren_string, \" \"\
    )\n    # Iterate through each group\n    for group in paren_groups\n        #\
    \ Initialize a counter to keep track of the current level of nesting\n       \
    \ current_level = 0\n        # Initialize a counter to keep track of the maximum\
    \ level of nesting\n        max_level = 0\n        # Iterate through each character\
    \ in the group\n        for char in group\n            # If the character is an\
    \ opening parenthesis, increment the current level\n            if char == '('\n\
    \                current_level += 1\n            # If the character is a closing\
    \ parenthesis, decrement the current level\n            elseif char == ')'\n \
    \               current_level -= 1\n            end\n            # If the current\
    \ level is greater than the maximum level, update the maximum level\n        \
    \    if current_level > max_level\n                max_level = current_level\n\
    \            end\n        end\n        # Append the maximum level to the results\
    \ vector\n        push!(results, max_level)\n    end\n    # Return the results\
    \ vector\n    return results\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize a vector to store the depth of each group\n    depth_vector\
    \ = Vector{Int64}()\n    # Initialize a counter to keep track of the depth\n \
    \   depth_counter = 0\n    # Initialize a string to store the current group\n\
    \    current_group = \"\"\n    # Loop through the string\n    for i in 1:length(paren_string)\n\
    \        # If the current character is a left parenthesis, increment the depth\
    \ counter\n        if paren_string[i] == '('\n            depth_counter += 1\n\
    \        # If the current character is a right parenthesis, decrement the depth\
    \ counter\n        elseif paren_string[i] == ')'\n            depth_counter -=\
    \ 1\n        # If the current character is a space, push the depth counter to\
    \ the depth vector\n        # and reset the depth counter and current group\n\
    \        elseif paren_string[i] == ' '\n            push!(depth_vector, depth_counter)\n\
    \            depth_counter = 0\n            current_group = \"\"\n        # If\
    \ the current character is not a parenthesis or a space, add it to the current\
    \ group\n        else\n            current_group = string(current_group, paren_string[i])\n\
    \        end\n    end\n    # Return the depth vector\n    return depth_vector\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp3dvt2ckq.jl:42\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0] == [2,\
    \ 3, 1, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmp3dvt2ckq.jl:42\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3dvt2ckq.jl:41\ntest set: Test Failed at /tmp/tmp3dvt2ckq.jl:43\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n   Evaluated:\
    \ [0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1] top-level scope at /tmp/tmp3dvt2ckq.jl:43\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3dvt2ckq.jl:41\ntest set: Test Failed at /tmp/tmp3dvt2ckq.jl:44\n\
    \  Expression: candidate(\"(()(())((())))\") == [4]\n   Evaluated: Int64[] ==\
    \ [4]\nStacktrace:\n [1] top-level scope at /tmp/tmp3dvt2ckq.jl:44\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3dvt2ckq.jl:41\nTest Summary: | Fail  Total\n\
    test set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3dvt2ckq.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize a vector to store the depth of each group\n    depth_vector\
    \ = Int64[]\n    # Initialize a counter to keep track of the depth of the current\
    \ group\n    depth = 0\n    # Initialize a variable to keep track of the current\
    \ group\n    group = \"\"\n    # Loop through the string\n    for i in 1:length(paren_string)\n\
    \        # If we encounter an opening parenthesis, increment the depth counter\n\
    \        if paren_string[i] == '('\n            depth += 1\n        # If we encounter\
    \ a closing parenthesis, decrement the depth counter\n        elseif paren_string[i]\
    \ == ')'\n            depth -= 1\n        # If we encounter a space, we have reached\
    \ the end of a group\n        elseif paren_string[i] == ' '\n            # Push\
    \ the depth of the current group to the depth vector\n            push!(depth_vector,\
    \ depth)\n            # Reset the depth counter\n            depth = 0\n     \
    \       # Reset the current group\n            group = \"\"\n        # If we encounter\
    \ any other character, add it to the current group\n        else\n           \
    \ group = group * paren_string[i]\n        end\n    end\n    # Return the depth\
    \ vector\n    return depth_vector\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpx536tlkt.jl:44\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0] == [2,\
    \ 3, 1, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpx536tlkt.jl:44\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpx536tlkt.jl:43\ntest set: Test Failed at /tmp/tmpx536tlkt.jl:45\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n   Evaluated:\
    \ [0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1] top-level scope at /tmp/tmpx536tlkt.jl:45\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpx536tlkt.jl:43\ntest set: Test Failed at /tmp/tmpx536tlkt.jl:46\n\
    \  Expression: candidate(\"(()(())((())))\") == [4]\n   Evaluated: Int64[] ==\
    \ [4]\nStacktrace:\n [1] top-level scope at /tmp/tmpx536tlkt.jl:46\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpx536tlkt.jl:43\nTest Summary: | Fail  Total\n\
    test set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpx536tlkt.jl:41\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = Vector{Int64}(undef,\
    \ length(paren_groups))\n    for (i, paren_group) in enumerate(paren_groups)\n\
    \        max_nesting[i] = max_nesting_parens(paren_group)\n    end\n    return\
    \ max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpecauycpf.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ max_nesting_parens not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmpecauycpf.jl:12\n   [2] top-level scope at /tmp/tmpecauycpf.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpecauycpf.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpecauycpf.jl:22\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: max_nesting_parens\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmpecauycpf.jl:12\n\
    \   [2] top-level scope at /tmp/tmpecauycpf.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpecauycpf.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpecauycpf.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: max_nesting_parens not defined\n  Stacktrace:\n\
    \   [1] parse_nested_parens(::String) at /tmp/tmpecauycpf.jl:12\n   [2] top-level\
    \ scope at /tmp/tmpecauycpf.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpecauycpf.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpecauycpf.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize a vector to store the depth of each group\n    depths = Vector{Int64}()\n\
    \    # Initialize a variable to store the current depth\n    depth = 0\n    #\
    \ Initialize a variable to store the current group\n    group = \"\"\n    # Iterate\
    \ through the string\n    for c in paren_string\n        # If the character is\
    \ a space, then we have reached the end of a group\n        if c == ' '\n    \
    \        # Add the depth of the current group to the vector\n            push!(depths,\
    \ depth)\n            # Reset the depth and group variables\n            depth\
    \ = 0\n            group = \"\"\n        else\n            # If the character\
    \ is a left parenthesis, increment the depth\n            if c == '('\n      \
    \          depth += 1\n            # If the character is a right parenthesis,\
    \ decrement the depth\n            elseif c == ')'\n                depth -= 1\n\
    \            end\n            # Add the character to the current group\n     \
    \       group = string(group, c)\n        end\n    end\n    # Add the depth of\
    \ the last group to the vector\n    push!(depths, depth)\n    # Return the vector\
    \ of depths\n    return depths\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpb17upv4a.jl:46\\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\\n   Evaluated: [0, 0, 0, 0] ==\
    \ [2, 3, 1, 3]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpb17upv4a.jl:46\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpb17upv4a.jl:45\\ntest set: Test Failed at /tmp/tmpb17upv4a.jl:47\\\
    n  Expression: candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\\n   Evaluated:\
    \ [0, 0, 0, 0] == [1, 2, 3, 4]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpb17upv4a.jl:47\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpb17upv4a.jl:45\\ntest set: Test Failed at /tmp/tmpb17upv4a.jl:48\\\
    n  Expression: candidate(\"(()(())((())))\") == [4]\\n   Evaluated: [0] == [4]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpb17upv4a.jl:48\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpb17upv4a.jl:45\\nTest Summary: | Fail  Total\\\
    ntest set      |    3      3\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    open_parens = 0\n    max_open_parens = 0\n    max_open_parens_vec = Vector{Int64}()\n\
    \    for c in paren_string\n        if c == '('\n            open_parens += 1\n\
    \            if open_parens > max_open_parens\n                max_open_parens\
    \ = open_parens\n            end\n        elseif c == ')'\n            open_parens\
    \ -= 1\n        elseif c == ' '\n            push!(max_open_parens_vec, max_open_parens)\n\
    \            max_open_parens = 0\n        end\n    end\n    push!(max_open_parens_vec,\
    \ max_open_parens)\n    return max_open_parens_vec\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = zeros(Int64,\
    \ length(paren_groups))\n    for (i, paren_group) in enumerate(paren_groups)\n\
    \        paren_stack = []\n        for c in paren_group\n            if c == '('\n\
    \                push!(paren_stack, c)\n            elseif c == ')'\n        \
    \        pop!(paren_stack)\n            end\n        end\n        max_nesting[i]\
    \ = length(paren_stack)\n    end\n    return max_nesting\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "b'test set: Test Failed at /tmp/tmp12f2va3d.jl:29\\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\\n   Evaluated: [0, 0, 0, 0] ==\
    \ [2, 3, 1, 3]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp12f2va3d.jl:29\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp12f2va3d.jl:28\\ntest set: Test Failed at /tmp/tmp12f2va3d.jl:30\\\
    n  Expression: candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\\n   Evaluated:\
    \ [0, 0, 0, 0] == [1, 2, 3, 4]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp12f2va3d.jl:30\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp12f2va3d.jl:28\\ntest set: Test Failed at /tmp/tmp12f2va3d.jl:31\\\
    n  Expression: candidate(\"(()(())((())))\") == [4]\\n   Evaluated: [0] == [4]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp12f2va3d.jl:31\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp12f2va3d.jl:28\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize a vector to store the deepest level of nesting for each group\n\
    \    deepest_nesting = Vector{Int64}()\n    # Split the string into groups\n \
    \   groups = split(paren_string, \" \")\n    # Iterate through each group\n  \
    \  for group in groups\n        # Initialize a counter to keep track of the current\
    \ level of nesting\n        current_nesting = 0\n        # Initialize a counter\
    \ to keep track of the deepest level of nesting\n        max_nesting = 0\n   \
    \     # Iterate through each character in the group\n        for char in group\n\
    \            # If the character is an opening parenthesis, increment the current\
    \ level of nesting\n            if char == '('\n                current_nesting\
    \ += 1\n            # If the character is a closing parenthesis, decrement the\
    \ current level of nesting\n            elseif char == ')'\n                current_nesting\
    \ -= 1\n            end\n            # Update the deepest level of nesting if\
    \ the current level of nesting is deeper\n            if current_nesting > max_nesting\n\
    \                max_nesting = current_nesting\n            end\n        end\n\
    \        # Append the deepest level of nesting for the current group to the vector\n\
    \        push!(deepest_nesting, max_nesting)\n    end\n    # Return the vector\
    \ of deepest levels of nesting\n    return deepest_nesting\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    return map(paren_groups)\
    \ do paren_group\n        paren_stack = []\n        max_depth = 0\n        for\
    \ i in 1:length(paren_group)\n            if paren_group[i] == '('\n         \
    \       push!(paren_stack, i)\n            elseif paren_group[i] == ')'\n    \
    \            if !isempty(paren_stack)\n                    pop!(paren_stack)\n\
    \                    max_depth = max(max_depth, length(paren_stack))\n       \
    \         end\n            end\n        end\n        max_depth\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpsbcd7bfe.jl:31\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [1, 2, 0, 2] ==\
    \ [2, 3, 1, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpsbcd7bfe.jl:31\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpsbcd7bfe.jl:30\ntest set: Test Failed at /tmp/tmpsbcd7bfe.jl:32\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n   Evaluated:\
    \ [0, 1, 2, 3] == [1, 2, 3, 4]\nStacktrace:\n [1] top-level scope at /tmp/tmpsbcd7bfe.jl:32\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpsbcd7bfe.jl:30\ntest set: Test Failed at /tmp/tmpsbcd7bfe.jl:33\n\
    \  Expression: candidate(\"(()(())((())))\") == [4]\n   Evaluated: [3] == [4]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpsbcd7bfe.jl:33\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpsbcd7bfe.jl:30\nTest Summary: | Fail  Total\n\
    test set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpsbcd7bfe.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = []\n    for\
    \ group in paren_groups\n        max_nesting_in_group = 0\n        current_nesting\
    \ = 0\n        for paren in group\n            if paren == '('\n             \
    \   current_nesting += 1\n            elseif paren == ')'\n                current_nesting\
    \ -= 1\n            end\n            if current_nesting > max_nesting_in_group\n\
    \                max_nesting_in_group = current_nesting\n            end\n   \
    \     end\n        push!(max_nesting, max_nesting_in_group)\n    end\n    return\
    \ max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize a vector to store the deepest level of nesting for each group\n\
    \    deepest_nesting = Vector{Int64}()\n    # Split the string by spaces to get\
    \ each group\n    groups = split(paren_string, \" \")\n    # For each group, find\
    \ the deepest level of nesting\n    for group in groups\n        # Initialize\
    \ a counter to keep track of the current level of nesting\n        current_nesting\
    \ = 0\n        # Initialize a counter to keep track of the deepest level of nesting\n\
    \        max_nesting = 0\n        # For each character in the group\n        for\
    \ char in group\n            # If the character is an opening parenthesis, increment\
    \ the current level of nesting\n            if char == '('\n                current_nesting\
    \ += 1\n            # If the character is a closing parenthesis, decrement the\
    \ current level of nesting\n            elseif char == ')'\n                current_nesting\
    \ -= 1\n            end\n            # If the current level of nesting is greater\
    \ than the deepest level of nesting, update the deepest level of nesting\n   \
    \         if current_nesting > max_nesting\n                max_nesting = current_nesting\n\
    \            end\n        end\n        # Append the deepest level of nesting for\
    \ the current group to the vector\n        push!(deepest_nesting, max_nesting)\n\
    \    end\n    # Return the vector of deepest levels of nesting\n    return deepest_nesting\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string =\
    \ replace(paren_string, \")\", \"\")\n    paren_string = replace(paren_string,\
    \ \"(\", \"\")\n    return [count(x) for x in paren_string]\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpj3botb22.jl:19\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching replace(::String, ::String, ::String)\n  Closest candidates\
    \ are:\n    replace(::String, !Matched::Pair{#s67,B} where B where #s67<:AbstractChar;\
    \ count) at strings/util.jl:421\n    replace(::String, !Matched::Pair{#s64,B}\
    \ where B where #s64<:Union{Tuple{Vararg{AbstractChar,N} where N}, Set{#s61} where\
    \ #s61<:AbstractChar, AbstractArray{#s62,1} where #s62<:AbstractChar}; count)\
    \ at strings/util.jl:426\n    replace(::String, !Matched::Pair; count) at strings/util.jl:433\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmpj3botb22.jl:9\n\
    \   [2] top-level scope at /tmp/tmpj3botb22.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpj3botb22.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpj3botb22.jl:20\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method matching\
    \ replace(::String, ::String, ::String)\n  Closest candidates are:\n    replace(::String,\
    \ !Matched::Pair{#s67,B} where B where #s67<:AbstractChar; count) at strings/util.jl:421\n\
    \    replace(::String, !Matched::Pair{#s64,B} where B where #s64<:Union{Tuple{Vararg{AbstractChar,N}\
    \ where N}, Set{#s61} where #s61<:AbstractChar, AbstractArray{#s62,1} where #s62<:AbstractChar};\
    \ count) at strings/util.jl:426\n    replace(::String, !Matched::Pair; count)\
    \ at strings/util.jl:433\n    ...\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmpj3botb22.jl:9\n   [2] top-level scope at /tmp/tmpj3botb22.jl:20\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpj3botb22.jl:18\n  \ntest set: Error During\
    \ Test at /tmp/tmpj3botb22.jl:21\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  MethodError: no method matching replace(::String,\
    \ ::String, ::String)\n  Closest candidates are:\n    replace(::String, !Matched::Pair{#s67,B}\
    \ where B where #s67<:AbstractChar; count) at strings/util.jl:421\n    replace(::String,\
    \ !Matched::Pair{#s64,B} where B where #s64<:Union{Tuple{Vararg{AbstractChar,N}\
    \ where N}, Set{#s61} where #s61<:AbstractChar, AbstractArray{#s62,1} where #s62<:AbstractChar};\
    \ count) at strings/util.jl:426\n    replace(::String, !Matched::Pair; count)\
    \ at strings/util.jl:433\n    ...\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmpj3botb22.jl:9\n   [2] top-level scope at /tmp/tmpj3botb22.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpj3botb22.jl:18\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpj3botb22.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = []\n    for\
    \ group in paren_groups\n        nesting = 0\n        max_nesting_group = 0\n\
    \        for paren in group\n            if paren == '('\n                nesting\
    \ += 1\n            elseif paren == ')'\n                nesting -= 1\n      \
    \      end\n            if nesting > max_nesting_group\n                max_nesting_group\
    \ = nesting\n            end\n        end\n        push!(max_nesting, max_nesting_group)\n\
    \    end\n    return max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Split the string into groups\n    groups = split(paren_string, \" \"\
    )\n    # Initialize a vector to store the results\n    results = Vector{Int64}(undef,\
    \ length(groups))\n    # Iterate over each group\n    for i in 1:length(groups)\n\
    \        # Initialize a counter\n        counter = 0\n        # Initialize a maximum\
    \ counter\n        max_counter = 0\n        # Iterate over each character in the\
    \ group\n        for j in 1:length(groups[i])\n            # If the character\
    \ is an open parenthesis, increment the counter\n            if groups[i][j] ==\
    \ '('\n                counter += 1\n            # If the character is a closed\
    \ parenthesis, decrement the counter\n            elseif groups[i][j] == ')'\n\
    \                counter -= 1\n            end\n            # Update the maximum\
    \ counter if the current counter is greater\n            if counter > max_counter\n\
    \                max_counter = counter\n            end\n        end\n       \
    \ # Store the maximum counter in the results vector\n        results[i] = max_counter\n\
    \    end\n    # Return the results vector\n    return results\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize a vector to store the depth of each group\n    depth_vector\
    \ = Int64[]\n    # Initialize a counter to keep track of the depth of the current\
    \ group\n    depth = 0\n    # Initialize a counter to keep track of the current\
    \ group\n    group_counter = 0\n    # Initialize a boolean to keep track of whether\
    \ we are in a group\n    in_group = false\n    # Loop through each character in\
    \ the string\n    for i in 1:length(paren_string)\n        # If we encounter an\
    \ open parenthesis, increment the depth counter\n        if paren_string[i] ==\
    \ '('\n            depth += 1\n            # If we are not in a group, set the\
    \ in_group boolean to true\n            if !in_group\n                in_group\
    \ = true\n            end\n        # If we encounter a closed parenthesis, decrement\
    \ the depth counter\n        elseif paren_string[i] == ')'\n            depth\
    \ -= 1\n            # If we are at the end of a group, add the depth to the depth\
    \ vector\n            if depth == 0\n                push!(depth_vector, group_counter)\n\
    \                group_counter = 0\n                in_group = false\n       \
    \     end\n        # If we encounter a space, increment the group counter\n  \
    \      elseif paren_string[i] == ' '\n            group_counter += 1\n       \
    \ end\n    end\n    return depth_vector\nend\nusing Test\n\n@testset begin\n\n\
    candidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpr9o26_p8.jl:47\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 1, 1, 1] ==\
    \ [2, 3, 1, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpr9o26_p8.jl:47\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpr9o26_p8.jl:46\ntest set: Test Failed at /tmp/tmpr9o26_p8.jl:48\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n   Evaluated:\
    \ [0, 1, 1, 1] == [1, 2, 3, 4]\nStacktrace:\n [1] top-level scope at /tmp/tmpr9o26_p8.jl:48\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpr9o26_p8.jl:46\ntest set: Test Failed at /tmp/tmpr9o26_p8.jl:49\n\
    \  Expression: candidate(\"(()(())((())))\") == [4]\n   Evaluated: [0] == [4]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpr9o26_p8.jl:49\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpr9o26_p8.jl:46\nTest Summary: | Fail  Total\n\
    test set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpr9o26_p8.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string =\
    \ replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \"\")\n    paren_string = replace(paren_string, \")\", \"\")\n    paren_string\
    \ = replace(paren_string, \"(\", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \"\")\n    paren_string = replace(paren_string, \"\", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \"\")\n    paren_string = replace(paren_string, \"\", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \"\")\n    paren_string = replace(paren_string, \"\", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \"\")\n    paren_string = replace(paren_string, \"\", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \"\")\n    paren_string = replace(paren_string, \"\", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \"\")\n    paren_string = replace(paren_string, \"\", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \"\")\n    paren_string = replace(paren_string, \"\", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \"\")\n    paren_string = replace(paren_string, \"\", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \"\")\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp692sbuum.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmp692sbuum.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp692sbuum.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize a vector to store the deepest level of nesting for each group\n\
    \    deepest_level = Int64[]\n    # Split the string into groups\n    groups =\
    \ split(paren_string, \" \")\n    # For each group, find the deepest level of\
    \ nesting\n    for group in groups\n        # Initialize a counter to keep track\
    \ of the current level of nesting\n        current_level = 0\n        # Initialize\
    \ a variable to keep track of the deepest level of nesting\n        deepest_level_group\
    \ = 0\n        # For each character in the group\n        for char in group\n\
    \            # If the character is an opening parenthesis, increase the current\
    \ level of nesting\n            if char == '('\n                current_level\
    \ += 1\n            # If the character is a closing parenthesis, decrease the\
    \ current level of nesting\n            elseif char == ')'\n                current_level\
    \ -= 1\n            end\n            # If the current level of nesting is greater\
    \ than the deepest level of nesting for the group,\n            # update the deepest\
    \ level of nesting for the group\n            if current_level > deepest_level_group\n\
    \                deepest_level_group = current_level\n            end\n      \
    \  end\n        # Append the deepest level of nesting for the group to the vector\n\
    \        push!(deepest_level, deepest_level_group)\n    end\n    # Return the\
    \ vector\n    return deepest_level\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    paren_levels = zeros(Int64,\
    \ length(paren_groups))\n    for (i, paren_group) in enumerate(paren_groups)\n\
    \        paren_levels[i] = count_nested_parens(paren_group)\n    end\n    return\
    \ paren_levels\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpj4laei_4.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ count_nested_parens not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmpj4laei_4.jl:12\n   [2] top-level scope at /tmp/tmpj4laei_4.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpj4laei_4.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpj4laei_4.jl:22\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: count_nested_parens\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmpj4laei_4.jl:12\n\
    \   [2] top-level scope at /tmp/tmpj4laei_4.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpj4laei_4.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpj4laei_4.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: count_nested_parens not defined\n \
    \ Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmpj4laei_4.jl:12\n\
    \   [2] top-level scope at /tmp/tmpj4laei_4.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpj4laei_4.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpj4laei_4.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = Vector{Int64}(undef,\
    \ length(paren_groups))\n    for i in 1:length(paren_groups)\n        paren_group\
    \ = paren_groups[i]\n        max_nesting[i] = 0\n        current_nesting = 0\n\
    \        for j in 1:length(paren_group)\n            if paren_group[j] == '('\n\
    \                current_nesting += 1\n            elseif paren_group[j] == ')'\n\
    \                current_nesting -= 1\n            end\n            if current_nesting\
    \ > max_nesting[i]\n                max_nesting[i] = current_nesting\n       \
    \     end\n        end\n    end\n    return max_nesting\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    paren_levels = Vector{Int64}(undef,\
    \ length(paren_groups))\n    for (i, paren_group) in enumerate(paren_groups)\n\
    \        paren_levels[i] = parse_nested_parens_single(paren_group)\n    end\n\
    \    return paren_levels\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp4z_5egla.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_nested_parens_single not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmp4z_5egla.jl:12\n   [2] top-level scope at /tmp/tmp4z_5egla.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4z_5egla.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp4z_5egla.jl:22\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_nested_parens_single\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmp4z_5egla.jl:12\n\
    \   [2] top-level scope at /tmp/tmp4z_5egla.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4z_5egla.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp4z_5egla.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: parse_nested_parens_single not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmp4z_5egla.jl:12\n\
    \   [2] top-level scope at /tmp/tmp4z_5egla.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4z_5egla.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4z_5egla.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = []\n    for\
    \ paren_group in paren_groups\n        nesting = 0\n        max_nesting_in_group\
    \ = 0\n        for paren in paren_group\n            if paren == '('\n       \
    \         nesting += 1\n            elseif paren == ')'\n                nesting\
    \ -= 1\n            end\n            if nesting > max_nesting_in_group\n     \
    \           max_nesting_in_group = nesting\n            end\n        end\n   \
    \     push!(max_nesting, max_nesting_in_group)\n    end\n    return max_nesting\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = []\n    for\
    \ paren_group in paren_groups\n        max_nesting_level = 0\n        current_nesting_level\
    \ = 0\n        for paren in paren_group\n            if paren == '('\n       \
    \         current_nesting_level += 1\n            elseif paren == ')'\n      \
    \          current_nesting_level -= 1\n            end\n            if current_nesting_level\
    \ > max_nesting_level\n                max_nesting_level = current_nesting_level\n\
    \            end\n        end\n        push!(max_nesting, max_nesting_level)\n\
    \    end\n    return max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_list = split(paren_string, \" \")\n    max_nesting = []\n    for\
    \ paren in paren_list\n        max_nesting_level = 0\n        current_nesting_level\
    \ = 0\n        for c in paren\n            if c == '('\n                current_nesting_level\
    \ += 1\n            elseif c == ')'\n                current_nesting_level -=\
    \ 1\n            end\n            if current_nesting_level > max_nesting_level\n\
    \                max_nesting_level = current_nesting_level\n            end\n\
    \        end\n        push!(max_nesting, max_nesting_level)\n    end\n    return\
    \ max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    return [parse_nested_parens_helper(group)\
    \ for group in paren_groups]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp4_jwqjzx.jl:17\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_nested_parens_helper not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmp4_jwqjzx.jl:10\n   [2] top-level scope at /tmp/tmp4_jwqjzx.jl:17\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4_jwqjzx.jl:16\n  \ntest set: Error During\
    \ Test at /tmp/tmp4_jwqjzx.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_nested_parens_helper\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmp4_jwqjzx.jl:10\n\
    \   [2] top-level scope at /tmp/tmp4_jwqjzx.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4_jwqjzx.jl:16\n  \ntest set: Error During\
    \ Test at /tmp/tmp4_jwqjzx.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: parse_nested_parens_helper not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmp4_jwqjzx.jl:10\n\
    \   [2] top-level scope at /tmp/tmp4_jwqjzx.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4_jwqjzx.jl:16\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4_jwqjzx.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = Vector{Int64}(undef,\
    \ length(paren_groups))\n    for (i, paren_group) in enumerate(paren_groups)\n\
    \        max_nesting[i] = get_max_nesting(paren_group)\n    end\n    return max_nesting\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpwn6wfd_7.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ get_max_nesting not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmpwn6wfd_7.jl:12\n   [2] top-level scope at /tmp/tmpwn6wfd_7.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwn6wfd_7.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpwn6wfd_7.jl:22\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: get_max_nesting not\
    \ defined\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmpwn6wfd_7.jl:12\n\
    \   [2] top-level scope at /tmp/tmpwn6wfd_7.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwn6wfd_7.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpwn6wfd_7.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: get_max_nesting not defined\n  Stacktrace:\n\
    \   [1] parse_nested_parens(::String) at /tmp/tmpwn6wfd_7.jl:12\n   [2] top-level\
    \ scope at /tmp/tmpwn6wfd_7.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwn6wfd_7.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwn6wfd_7.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = Vector{Int64}(undef,\
    \ length(paren_groups))\n    for (i, paren_group) in enumerate(paren_groups)\n\
    \        max_nesting[i] = parse_nested_parens_helper(paren_group)\n    end\n \
    \   return max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpbbs1f81n.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_nested_parens_helper not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmpbbs1f81n.jl:12\n   [2] top-level scope at /tmp/tmpbbs1f81n.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbbs1f81n.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpbbs1f81n.jl:22\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_nested_parens_helper\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmpbbs1f81n.jl:12\n\
    \   [2] top-level scope at /tmp/tmpbbs1f81n.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbbs1f81n.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpbbs1f81n.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: parse_nested_parens_helper not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmpbbs1f81n.jl:12\n\
    \   [2] top-level scope at /tmp/tmpbbs1f81n.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbbs1f81n.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbbs1f81n.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = split(paren_string, \" \")\n    max_depth = Vector{Int64}(undef,\
    \ length(paren_string))\n    for i in 1:length(paren_string)\n        depth =\
    \ 0\n        max_depth[i] = 0\n        for j in 1:length(paren_string[i])\n  \
    \          if paren_string[i][j] == '('\n                depth += 1\n        \
    \        if depth > max_depth[i]\n                    max_depth[i] = depth\n \
    \               end\n            elseif paren_string[i][j] == ')'\n          \
    \      depth -= 1\n            end\n        end\n    end\n    return max_depth\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = Vector{Int64}(undef,\
    \ length(paren_groups))\n    for i in 1:length(paren_groups)\n        max_nesting[i]\
    \ = max_nesting_parens(paren_groups[i])\n    end\n    return max_nesting\nend\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmppuo6rhkn.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ max_nesting_parens not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmppuo6rhkn.jl:12\n   [2] top-level scope at /tmp/tmppuo6rhkn.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppuo6rhkn.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmppuo6rhkn.jl:22\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: max_nesting_parens\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmppuo6rhkn.jl:12\n\
    \   [2] top-level scope at /tmp/tmppuo6rhkn.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppuo6rhkn.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmppuo6rhkn.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: max_nesting_parens not defined\n  Stacktrace:\n\
    \   [1] parse_nested_parens(::String) at /tmp/tmppuo6rhkn.jl:12\n   [2] top-level\
    \ scope at /tmp/tmppuo6rhkn.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppuo6rhkn.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmppuo6rhkn.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize a vector to store the results\n    result = Vector{Int64}()\n\
    \    # Split the string by spaces\n    paren_groups = split(paren_string, \" \"\
    )\n    # For each of the groups\n    for group in paren_groups\n        # Initialize\
    \ a counter\n        counter = 0\n        # Initialize a maximum counter\n   \
    \     max_counter = 0\n        # For each of the characters in the group\n   \
    \     for char in group\n            # If the character is an opening parenthesis\n\
    \            if char == '('\n                # Increment the counter\n       \
    \         counter += 1\n            # If the character is a closing parenthesis\n\
    \            elseif char == ')'\n                # Decrement the counter\n   \
    \             counter -= 1\n            end\n            # Update the maximum\
    \ counter\n            max_counter = max(max_counter, counter)\n        end\n\
    \        # Append the maximum counter to the result\n        push!(result, max_counter)\n\
    \    end\n    # Return the result\n    return result\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string =\
    \ replace(paren_string, \")\", \" )\")\n    paren_string = replace(paren_string,\
    \ \"(\", \"( \")\n    paren_string = replace(paren_string, \")(\", \") (\")\n\
    \    paren_string = replace(paren_string, \"  \", \" \")\n    paren_string = replace(paren_string,\
    \ \"  \", \" \")\n    paren_string = replace(paren_string, \"  \", \" \")\n  \
    \  paren_string = replace(paren_string, \"  \", \" \")\n    paren_string = replace(paren_string,\
    \ \"  \", \" \")\n    paren_string = replace(paren_string, \"  \", \" \")\n  \
    \  paren_string = replace(paren_string, \"  \", \" \")\n    paren_string = replace(paren_string,\
    \ \"  \", \" \")\n    paren_string = replace(paren_string, \"  \", \" \")\n  \
    \  paren_string = replace(paren_string, \"  \", \" \")\n    paren_string = replace(paren_string,\
    \ \"  \", \" \")\n    paren_string = replace(paren_string, \"  \", \" \")\n  \
    \  paren_string = replace(paren_string, \"  \", \" \")\n    paren_string = replace(paren_string,\
    \ \"  \", \" \")\n    paren_string = replace(paren_string, \"  \", \" \")\n  \
    \  paren_string = replace(paren_string, \"  \", \" \")\n    paren_string = replace(paren_string,\
    \ \"  \", \" \")\n    paren_string = replace(paren_string, \"  \", \" \")\n  \
    \  paren_string = replace(paren_string, \"  \", \" \")\n    paren_string = replace(paren_string,\
    \ \"  \", \" \")\n    paren_string = replace(paren_string, \"  \", \" \")\n  \
    \  paren_string = replace(paren_string, \"  \", \" \")\n    paren_string = replace(paren_string,\
    \ \"  \", \" \")\n   \nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpe9yu6s2d.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpe9yu6s2d.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpe9yu6s2d.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = Vector{Int64}(undef,\
    \ length(paren_groups))\n    for (i, group) in enumerate(paren_groups)\n     \
    \   max_nesting[i] = max_nesting_in_group(group)\n    end\n    return max_nesting\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp1yv4nxnj.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ max_nesting_in_group not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmp1yv4nxnj.jl:12\n   [2] top-level scope at /tmp/tmp1yv4nxnj.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1yv4nxnj.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp1yv4nxnj.jl:22\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: max_nesting_in_group\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmp1yv4nxnj.jl:12\n\
    \   [2] top-level scope at /tmp/tmp1yv4nxnj.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1yv4nxnj.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp1yv4nxnj.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: max_nesting_in_group not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmp1yv4nxnj.jl:12\n\
    \   [2] top-level scope at /tmp/tmp1yv4nxnj.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1yv4nxnj.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1yv4nxnj.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = Vector{Int64}(undef,\
    \ length(paren_groups))\n    for (i, paren_group) in enumerate(paren_groups)\n\
    \        max_nesting[i] = max_nesting_parens(paren_group)\n    end\n    return\
    \ max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpwooayxy5.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ max_nesting_parens not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmpwooayxy5.jl:12\n   [2] top-level scope at /tmp/tmpwooayxy5.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwooayxy5.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpwooayxy5.jl:22\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: max_nesting_parens\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmpwooayxy5.jl:12\n\
    \   [2] top-level scope at /tmp/tmpwooayxy5.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwooayxy5.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpwooayxy5.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: max_nesting_parens not defined\n  Stacktrace:\n\
    \   [1] parse_nested_parens(::String) at /tmp/tmpwooayxy5.jl:12\n   [2] top-level\
    \ scope at /tmp/tmpwooayxy5.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwooayxy5.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwooayxy5.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize a vector to store the depth of each group\n    depth_vector\
    \ = Vector{Int64}()\n    # Initialize a counter to keep track of the depth of\
    \ the current group\n    depth_counter = 0\n    # Initialize a flag to keep track\
    \ of whether we are in a group or not\n    in_group = false\n    # Iterate through\
    \ the characters in the string\n    for char in paren_string\n        # If we\
    \ are in a group and we encounter an opening paren, increment the depth counter\n\
    \        if in_group && char == '('\n            depth_counter += 1\n        #\
    \ If we are in a group and we encounter a closing paren, decrement the depth counter\n\
    \        elseif in_group && char == ')'\n            depth_counter -= 1\n    \
    \    # If we are not in a group and we encounter an opening paren, set the in_group\
    \ flag to true\n        elseif !in_group && char == '('\n            in_group\
    \ = true\n        # If we are in a group and we encounter a closing paren, set\
    \ the in_group flag to false\n        elseif in_group && char == ')'\n       \
    \     in_group = false\n            # Push the current depth counter to the vector\
    \ and reset the counter\n            push!(depth_vector, depth_counter)\n    \
    \        depth_counter = 0\n        end\n    end\n    # Return the vector\n  \
    \  return depth_vector\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpn7k1m558.jl:42\\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\\n   Evaluated: Int64[] == [2,\
    \ 3, 1, 3]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpn7k1m558.jl:42\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpn7k1m558.jl:41\\ntest set: Test Failed at /tmp/tmpn7k1m558.jl:43\\\
    n  Expression: candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\\n   Evaluated:\
    \ Int64[] == [1, 2, 3, 4]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpn7k1m558.jl:43\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpn7k1m558.jl:41\\ntest set: Test Failed at /tmp/tmpn7k1m558.jl:44\\\
    n  Expression: candidate(\"(()(())((())))\") == [4]\\n   Evaluated: Int64[] ==\
    \ [4]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpn7k1m558.jl:44\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpn7k1m558.jl:41\\nTest Summary: | Fail  Total\\\
    ntest set      |    3      3\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string =\
    \ replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \"\")\n    paren_string = replace(paren_string, \"(\", \"\")\n    paren_string\
    \ = replace(paren_string, \")\", \"\")\n    return [length(x) for x in split(paren_string,\
    \ \"\")]\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpfo75iefh.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching replace(::String, ::String, ::String)\n  Closest candidates\
    \ are:\n    replace(::String, !Matched::Pair{#s67,B} where B where #s67<:AbstractChar;\
    \ count) at strings/util.jl:421\n    replace(::String, !Matched::Pair{#s64,B}\
    \ where B where #s64<:Union{Tuple{Vararg{AbstractChar,N} where N}, Set{#s61} where\
    \ #s61<:AbstractChar, AbstractArray{#s62,1} where #s62<:AbstractChar}; count)\
    \ at strings/util.jl:426\n    replace(::String, !Matched::Pair; count) at strings/util.jl:433\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmpfo75iefh.jl:9\n\
    \   [2] top-level scope at /tmp/tmpfo75iefh.jl:21\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfo75iefh.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpfo75iefh.jl:22\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method matching\
    \ replace(::String, ::String, ::String)\n  Closest candidates are:\n    replace(::String,\
    \ !Matched::Pair{#s67,B} where B where #s67<:AbstractChar; count) at strings/util.jl:421\n\
    \    replace(::String, !Matched::Pair{#s64,B} where B where #s64<:Union{Tuple{Vararg{AbstractChar,N}\
    \ where N}, Set{#s61} where #s61<:AbstractChar, AbstractArray{#s62,1} where #s62<:AbstractChar};\
    \ count) at strings/util.jl:426\n    replace(::String, !Matched::Pair; count)\
    \ at strings/util.jl:433\n    ...\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmpfo75iefh.jl:9\n   [2] top-level scope at /tmp/tmpfo75iefh.jl:22\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfo75iefh.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpfo75iefh.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  MethodError: no method matching replace(::String,\
    \ ::String, ::String)\n  Closest candidates are:\n    replace(::String, !Matched::Pair{#s67,B}\
    \ where B where #s67<:AbstractChar; count) at strings/util.jl:421\n    replace(::String,\
    \ !Matched::Pair{#s64,B} where B where #s64<:Union{Tuple{Vararg{AbstractChar,N}\
    \ where N}, Set{#s61} where #s61<:AbstractChar, AbstractArray{#s62,1} where #s62<:AbstractChar};\
    \ count) at strings/util.jl:426\n    replace(::String, !Matched::Pair; count)\
    \ at strings/util.jl:433\n    ...\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmpfo75iefh.jl:9\n   [2] top-level scope at /tmp/tmpfo75iefh.jl:23\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfo75iefh.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpfo75iefh.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = split(paren_string, \" \")\n    max_depth = Vector{Int64}(undef,\
    \ length(paren_string))\n    for (i, paren_group) in enumerate(paren_string)\n\
    \        depth = 0\n        max_depth[i] = 0\n        for paren in paren_group\n\
    \            if paren == '('\n                depth += 1\n            elseif paren\
    \ == ')'\n                depth -= 1\n            end\n            max_depth[i]\
    \ = max(max_depth[i], depth)\n        end\n    end\n    return max_depth\nend\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = []\n    for\
    \ paren_group in paren_groups\n        max_nesting_level = 0\n        current_nesting_level\
    \ = 0\n        for paren in paren_group\n            if paren == '('\n       \
    \         current_nesting_level += 1\n            elseif paren == ')'\n      \
    \          current_nesting_level -= 1\n            end\n            if current_nesting_level\
    \ > max_nesting_level\n                max_nesting_level = current_nesting_level\n\
    \            end\n        end\n        push!(max_nesting, max_nesting_level)\n\
    \    end\n    return max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize an empty vector to store the results\n    result = Int64[]\n\
    \    # Split the input string into groups\n    groups = split(paren_string, \"\
    \ \")\n    # Loop through each group\n    for group in groups\n        # Initialize\
    \ a counter to keep track of the nesting level\n        level = 0\n        # Initialize\
    \ a counter to keep track of the max nesting level\n        max_level = 0\n  \
    \      # Loop through each character in the group\n        for c in group\n  \
    \          # If the character is an open parenthesis, increment the level\n  \
    \          if c == '('\n                level += 1\n            # If the character\
    \ is a closed parenthesis, decrement the level\n            elseif c == ')'\n\
    \                level -= 1\n            end\n            # Update the max level\
    \ if the current level is greater than the max level\n            if level > max_level\n\
    \                max_level = level\n            end\n        end\n        # Push\
    \ the max level to the result vector\n        push!(result, max_level)\n    end\n\
    \    # Return the result vector\n    return result\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Split the string into groups\n    groups = split(paren_string, \" \"\
    )\n    # Initialize a vector to store the results\n    results = Vector{Int64}(undef,\
    \ length(groups))\n    # Loop through each group\n    for i in 1:length(groups)\n\
    \        # Initialize a counter\n        count = 0\n        # Initialize a maximum\
    \ counter\n        max_count = 0\n        # Loop through each character in the\
    \ group\n        for j in 1:length(groups[i])\n            # If the character\
    \ is an open parenthesis, increment the counter\n            if groups[i][j] ==\
    \ '('\n                count += 1\n            # If the character is a closed\
    \ parenthesis, decrement the counter\n            elseif groups[i][j] == ')'\n\
    \                count -= 1\n            end\n            # If the counter is\
    \ greater than the maximum counter, update the maximum counter\n            if\
    \ count > max_count\n                max_count = count\n            end\n    \
    \    end\n        # Store the maximum counter in the results vector\n        results[i]\
    \ = max_count\n    end\n    # Return the results vector\n    return results\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # split the string into groups\n    groups = split(paren_string, \" \"\
    )\n    # initialize a vector to store the output\n    output = Vector{Int64}(undef,\
    \ length(groups))\n    # for each group, find the maximum depth of nesting\n \
    \   for i in 1:length(groups)\n        group = groups[i]\n        depth = 0\n\
    \        max_depth = 0\n        for j in 1:length(group)\n            if group[j]\
    \ == '('\n                depth += 1\n            elseif group[j] == ')'\n   \
    \             depth -= 1\n            end\n            if depth > max_depth\n\
    \                max_depth = depth\n            end\n        end\n        output[i]\
    \ = max_depth\n    end\n    return output\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize the vector to store the output\n    output = Vector{Int64}()\n\
    \    \n    # Split the string by space\n    paren_groups = split(paren_string,\
    \ \" \")\n    \n    # For each group of parentheses, find the maximum depth of\
    \ nesting\n    for group in paren_groups\n        max_depth = 0\n        depth\
    \ = 0\n        for paren in group\n            if paren == '('\n             \
    \   depth += 1\n            elseif paren == ')'\n                depth -= 1\n\
    \            end\n            max_depth = max(max_depth, depth)\n        end\n\
    \        push!(output, max_depth)\n    end\n    return output\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    return [parse_nested_parens_helper(group)\
    \ for group in paren_groups]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpk01hq43t.jl:17\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_nested_parens_helper not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmpk01hq43t.jl:10\n   [2] top-level scope at /tmp/tmpk01hq43t.jl:17\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpk01hq43t.jl:16\n  \ntest set: Error During\
    \ Test at /tmp/tmpk01hq43t.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_nested_parens_helper\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmpk01hq43t.jl:10\n\
    \   [2] top-level scope at /tmp/tmpk01hq43t.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpk01hq43t.jl:16\n  \ntest set: Error During\
    \ Test at /tmp/tmpk01hq43t.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: parse_nested_parens_helper not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmpk01hq43t.jl:10\n\
    \   [2] top-level scope at /tmp/tmpk01hq43t.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpk01hq43t.jl:16\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpk01hq43t.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string =\
    \ replace(paren_string, \")(\", \") (\")\n    paren_string = replace(paren_string,\
    \ \"()\", \"\")\n    paren_string = replace(paren_string, \")(\", \") (\")\n \
    \   paren_string = replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \"()\", \"\")\n \
    \   paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \"()\", \"\")\n \
    \   paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \"()\", \"\")\n \
    \   paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \"()\", \"\")\n \
    \   paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \"()\", \"\")\n \
    \   paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \"()\", \"\")\n\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpw9zmcrx5.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpw9zmcrx5.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpw9zmcrx5.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = []\n    for\
    \ paren_group in paren_groups\n        max_nesting_level = 0\n        current_nesting_level\
    \ = 0\n        for paren in paren_group\n            if paren == '('\n       \
    \         current_nesting_level += 1\n            elseif paren == ')'\n      \
    \          current_nesting_level -= 1\n            end\n            if current_nesting_level\
    \ > max_nesting_level\n                max_nesting_level = current_nesting_level\n\
    \            end\n        end\n        push!(max_nesting, max_nesting_level)\n\
    \    end\n    return max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = Vector{Int64}(undef,\
    \ length(paren_groups))\n    for (i, paren_group) in enumerate(paren_groups)\n\
    \        max_nesting[i] = max_nesting_in_parens(paren_group)\n    end\n    return\
    \ max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpj7pvx6c5.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ max_nesting_in_parens not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmpj7pvx6c5.jl:12\n   [2] top-level scope at /tmp/tmpj7pvx6c5.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpj7pvx6c5.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpj7pvx6c5.jl:22\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: max_nesting_in_parens\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmpj7pvx6c5.jl:12\n\
    \   [2] top-level scope at /tmp/tmpj7pvx6c5.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpj7pvx6c5.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpj7pvx6c5.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: max_nesting_in_parens not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmpj7pvx6c5.jl:12\n\
    \   [2] top-level scope at /tmp/tmpj7pvx6c5.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpj7pvx6c5.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpj7pvx6c5.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    return [parse_parens(group)\
    \ for group in paren_groups]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpsjtij17p.jl:17\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_parens not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmpsjtij17p.jl:10\n   [2] top-level scope at /tmp/tmpsjtij17p.jl:17\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpsjtij17p.jl:16\n  \ntest set: Error During\
    \ Test at /tmp/tmpsjtij17p.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_parens not\
    \ defined\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmpsjtij17p.jl:10\n\
    \   [2] top-level scope at /tmp/tmpsjtij17p.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpsjtij17p.jl:16\n  \ntest set: Error During\
    \ Test at /tmp/tmpsjtij17p.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: parse_parens not defined\n  Stacktrace:\n\
    \   [1] parse_nested_parens(::String) at /tmp/tmpsjtij17p.jl:10\n   [2] top-level\
    \ scope at /tmp/tmpsjtij17p.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpsjtij17p.jl:16\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpsjtij17p.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    paren_levels = []\n   \
    \ for paren_group in paren_groups\n        paren_levels = [parse_nested_parens_helper(paren_group)]\n\
    \    end\n    return paren_levels\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp2hq6t1tr.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_nested_parens_helper not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmp2hq6t1tr.jl:12\n   [2] top-level scope at /tmp/tmp2hq6t1tr.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2hq6t1tr.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp2hq6t1tr.jl:22\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_nested_parens_helper\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmp2hq6t1tr.jl:12\n\
    \   [2] top-level scope at /tmp/tmp2hq6t1tr.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2hq6t1tr.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmp2hq6t1tr.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: parse_nested_parens_helper not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmp2hq6t1tr.jl:12\n\
    \   [2] top-level scope at /tmp/tmp2hq6t1tr.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2hq6t1tr.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2hq6t1tr.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    return [maximum(count_parens(group))\
    \ for group in paren_groups]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpenm98owj.jl:17\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ count_parens not defined\n  Stacktrace:\n   [1] (::var\"#3#4\")(::SubString{String})\
    \ at ./none:0\n   [2] iterate at ./generator.jl:47 [inlined]\n   [3] collect(::Base.Generator{Array{SubString{String},1},var\"\
    #3#4\"}) at ./array.jl:665\n   [4] parse_nested_parens(::String) at /tmp/tmpenm98owj.jl:10\n\
    \   [5] top-level scope at /tmp/tmpenm98owj.jl:17\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpenm98owj.jl:16\n  \ntest set: Error During\
    \ Test at /tmp/tmpenm98owj.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: count_parens not\
    \ defined\n  Stacktrace:\n   [1] (::var\"#3#4\")(::SubString{String}) at ./none:0\n\
    \   [2] iterate at ./generator.jl:47 [inlined]\n   [3] collect(::Base.Generator{Array{SubString{String},1},var\"\
    #3#4\"}) at ./array.jl:665\n   [4] parse_nested_parens(::String) at /tmp/tmpenm98owj.jl:10\n\
    \   [5] top-level scope at /tmp/tmpenm98owj.jl:18\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpenm98owj.jl:16\n  \ntest set: Error During\
    \ Test at /tmp/tmpenm98owj.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: count_parens not defined\n  Stacktrace:\n\
    \   [1] (::var\"#3#4\")(::SubString{String}) at ./none:0\n   [2] iterate at ./generator.jl:47\
    \ [inlined]\n   [3] collect(::Base.Generator{Array{SubString{String},1},var\"\
    #3#4\"}) at ./array.jl:665\n   [4] parse_nested_parens(::String) at /tmp/tmpenm98owj.jl:10\n\
    \   [5] top-level scope at /tmp/tmpenm98owj.jl:19\n   [6] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [7] top-level scope at /tmp/tmpenm98owj.jl:16\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpenm98owj.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string =\
    \ replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \"\")\n    paren_string = replace(paren_string, \"((\", \"\")\n    paren_string\
    \ = replace(paren_string, \"))\", \"\")\n    paren_string = replace(paren_string,\
    \ \"(((\", \"\")\n    paren_string = replace(paren_string, \")))\", \"\")\n  \
    \  paren_string = replace(paren_string, \"((((\", \"\")\n    paren_string = replace(paren_string,\
    \ \")))))\", \"\")\n    paren_string = replace(paren_string, \"(((((\", \"\")\n\
    \    paren_string = replace(paren_string, \")))))))\", \"\")\n    paren_string\
    \ = replace(paren_string, \"((((((\", \"\")\n    paren_string = replace(paren_string,\
    \ \"))))))))\", \"\")\n    paren_string = replace(paren_string, \"(((((((\", \"\
    \")\n    paren_string = replace(paren_string, \"))))))))))\", \"\")\n    paren_string\
    \ = replace(paren_string, \"((((((((\", \"\")\n    paren_string = replace(paren_string,\
    \ \")))))))))))\", \"\")\n    paren_string = replace(paren_string, \"(((((((((\"\
    , \"\")\n    paren_string = replace(paren_string, \"))))))))))))\", \"\")\n  \
    \  paren_string = replace(paren_string, \"((((((((((\", \"\")\n    paren_string\
    \ = replace(paren_string, \")))))))))))))\", \"\")\n    paren_string = replace(paren_string,\
    \ \"(((((((((((\", \"\")\n    paren_string = replace(paren_string, \"))))))))))))))\"\
    , \"\")\n    paren_string = replace(paren_string, \"((((((((((((\", \"\")\n  \
    \  paren_string = replace(paren_string, \")))))))))))))))\", \"\")\n    paren_string\
    \ = replace(paren_string, \"((\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: space before \"(\" not allowed in \"\"((\\nusing\
    \ Test\\n\\n@testset begin\\n\\ncandidate = parse_nested_parens;\\n\\t@test(candidate(\"\
    (()()) (\" at /tmp/tmp0_j7zqsw.jl:40\nStacktrace:\n [1] top-level scope at /tmp/tmp0_j7zqsw.jl:40\n\
    \ [2] include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmp0_j7zqsw.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = Vector{Int64}(undef,\
    \ length(paren_groups))\n    for i in 1:length(paren_groups)\n        max_nesting[i]\
    \ = parse_nested_parens_helper(paren_groups[i])\n    end\n    return max_nesting\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpryx4245r.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_nested_parens_helper not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmpryx4245r.jl:12\n   [2] top-level scope at /tmp/tmpryx4245r.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpryx4245r.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpryx4245r.jl:22\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_nested_parens_helper\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmpryx4245r.jl:12\n\
    \   [2] top-level scope at /tmp/tmpryx4245r.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpryx4245r.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpryx4245r.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: parse_nested_parens_helper not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmpryx4245r.jl:12\n\
    \   [2] top-level scope at /tmp/tmpryx4245r.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpryx4245r.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpryx4245r.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string =\
    \ replace(paren_string, \")\", \" )\")\n    paren_string = replace(paren_string,\
    \ \"(\", \"( \")\n    paren_string = replace(paren_string, \")(\", \") (\")\n\
    \    paren_string = replace(paren_string, \"  \", \" \")\n    paren_string = replace(paren_string,\
    \ \"  \", \" \")\n    paren_string = replace(paren_string, \"  \", \" \")\n  \
    \  paren_string = replace(paren_string, \"  \", \" \")\n    paren_string = replace(paren_string,\
    \ \"  \", \" \")\n    paren_string = replace(paren_string, \"  \", \" \")\n  \
    \  paren_string = replace(paren_string, \"  \", \" \")\n    paren_string = replace(paren_string,\
    \ \"  \", \" \")\n    paren_string = replace(paren_string, \"  \", \" \")\n  \
    \  paren_string = replace(paren_string, \"  \", \" \")\n    paren_string = replace(paren_string,\
    \ \"  \", \" \")\n    paren_string = replace(paren_string, \"  \", \" \")\n  \
    \  paren_string = replace(paren_string, \"  \", \" \")\n    paren_string = replace(paren_string,\
    \ \"  \", \" \")\n    paren_string = replace(paren_string, \"  \", \" \")\n  \
    \  paren_string = replace(paren_string, \"  \", \" \")\n    paren_string = replace(paren_string,\
    \ \"  \", \" \")\n    paren_string = replace(paren_string, \"  \", \" \")\n  \
    \  paren_string = replace(paren_string, \"  \", \" \")\n    paren_string = replace(paren_string,\
    \ \"  \", \" \")\n    paren_string = replace(paren_string, \"  \", \" \")\n  \
    \  paren_string = replace(paren_string, \"  \", \" \")\n    paren_string = replace(paren_string,\
    \ \"  \", \" \")\n   \nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpod4qecqo.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpod4qecqo.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpod4qecqo.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize a vector to store the maximum level of nesting for each group\n\
    \    max_nesting_levels = Int64[]\n    # Iterate through each group\n    for paren_group\
    \ in split(paren_string, \" \")\n        # Initialize a counter to keep track\
    \ of the current level of nesting\n        nesting_level = 0\n        # Initialize\
    \ a counter to keep track of the maximum level of nesting\n        max_nesting_level\
    \ = 0\n        # Iterate through each character in the group\n        for paren\
    \ in paren_group\n            # If the character is an opening parenthesis, increment\
    \ the nesting level\n            if paren == '('\n                nesting_level\
    \ += 1\n            # If the character is a closing parenthesis, decrement the\
    \ nesting level\n            elseif paren == ')'\n                nesting_level\
    \ -= 1\n            end\n            # If the current nesting level is greater\
    \ than the maximum nesting level, update the maximum nesting level\n         \
    \   if nesting_level > max_nesting_level\n                max_nesting_level =\
    \ nesting_level\n            end\n        end\n        # Push the maximum nesting\
    \ level for the current group to the vector\n        push!(max_nesting_levels,\
    \ max_nesting_level)\n    end\n    # Return the vector of maximum nesting levels\n\
    \    return max_nesting_levels\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize a vector to store the depth of each group\n    depth_vector\
    \ = Int64[]\n    # Initialize a counter to keep track of the depth of the current\
    \ group\n    depth = 0\n    # Initialize a variable to keep track of the current\
    \ group\n    current_group = \"\"\n    # Loop through the string\n    for i in\
    \ 1:length(paren_string)\n        # If the current character is a left parenthesis,\
    \ increase the depth by 1\n        if paren_string[i] == '('\n            depth\
    \ += 1\n        # If the current character is a right parenthesis, decrease the\
    \ depth by 1\n        elseif paren_string[i] == ')'\n            depth -= 1\n\
    \        # If the current character is a space, add the current group to the vector\
    \ and reset the current group\n        elseif paren_string[i] == ' '\n       \
    \     push!(depth_vector, depth)\n            current_group = \"\"\n        #\
    \ If the current character is not a parenthesis or a space, add it to the current\
    \ group\n        else\n            current_group = current_group * paren_string[i]\n\
    \        end\n    end\n    # Add the last group to the vector\n    push!(depth_vector,\
    \ depth)\n    # Return the vector\n    return depth_vector\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpf1fys_op.jl:42\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0, 0] ==\
    \ [2, 3, 1, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpf1fys_op.jl:42\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpf1fys_op.jl:41\ntest set: Test Failed at /tmp/tmpf1fys_op.jl:43\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n   Evaluated:\
    \ [0, 0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1] top-level scope at /tmp/tmpf1fys_op.jl:43\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpf1fys_op.jl:41\ntest set: Test Failed at /tmp/tmpf1fys_op.jl:44\n\
    \  Expression: candidate(\"(()(())((())))\") == [4]\n   Evaluated: [0] == [4]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpf1fys_op.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpf1fys_op.jl:41\nTest Summary: | Fail  Total\n\
    test set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpf1fys_op.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string =\
    \ replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \"\")\n    paren_string = replace(paren_string, \"((\", \"\")\n    paren_string\
    \ = replace(paren_string, \"))\", \"\")\n    paren_string = replace(paren_string,\
    \ \"(((\", \"\")\n    paren_string = replace(paren_string, \")))\", \"\")\n  \
    \  paren_string = replace(paren_string, \"((((\", \"\")\n    paren_string = replace(paren_string,\
    \ \")))))\", \"\")\n    paren_string = replace(paren_string, \"(((((\", \"\")\n\
    \    paren_string = replace(paren_string, \")))))))\", \"\")\n    paren_string\
    \ = replace(paren_string, \"((((((\", \"\")\n    paren_string = replace(paren_string,\
    \ \"))))))))\", \"\")\n    paren_string = replace(paren_string, \"(((((((\", \"\
    \")\n    paren_string = replace(paren_string, \"))))))))))\", \"\")\n    paren_string\
    \ = replace(paren_string, \"((((((((\", \"\")\n    paren_string = replace(paren_string,\
    \ \")))))))))))\", \"\")\n    paren_string = replace(paren_string, \"(((((((((\"\
    , \"\")\n    paren_string = replace(paren_string, \"))))))))))))\", \"\")\n  \
    \  paren_string = replace(paren_string, \"((((((((((\", \"\")\n    paren_string\
    \ = replace(paren_string, \")))))))))))))\", \"\")\n    paren_string = replace(paren_string,\
    \ \"(((((((((((\", \"\")\n    paren_string = replace(paren_string, \"))))))))))))))\"\
    , \"\")\n    paren_string = replace(paren_string, \"((((((((((((\", \"\")\n  \
    \  paren_string = replace(paren_string, \")))))))))))))))\", \"\")\n    paren_string\
    \ = replace(paren_string, \"((\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: space before \"(\" not allowed in \"\"((\\nusing\
    \ Test\\n\\n@testset begin\\n\\ncandidate = parse_nested_parens;\\n\\t@test(candidate(\"\
    (()()) (\" at /tmp/tmpmy1i4fb1.jl:40\nStacktrace:\n [1] top-level scope at /tmp/tmpmy1i4fb1.jl:40\n\
    \ [2] include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpmy1i4fb1.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize a vector to store the depth of each group\n    depth = Vector{Int64}()\n\
    \    # Initialize a counter to keep track of the depth\n    counter = 0\n    #\
    \ Iterate through each character in the string\n    for c in paren_string\n  \
    \      # If the character is an opening parenthesis, increase the counter\n  \
    \      if c == '('\n            counter += 1\n        # If the character is a\
    \ closing parenthesis, decrease the counter\n        elseif c == ')'\n       \
    \     counter -= 1\n        # If the character is a space, push the current counter\
    \ value to the vector and reset the counter\n        elseif c == ' '\n       \
    \     push!(depth, counter)\n            counter = 0\n        end\n    end\n \
    \   # Return the vector\n    return depth\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpw7fzyz3x.jl:35\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0] == [2,\
    \ 3, 1, 3]\nStacktrace:\n [1] top-level scope at /tmp/tmpw7fzyz3x.jl:35\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw7fzyz3x.jl:34\ntest set: Test Failed at /tmp/tmpw7fzyz3x.jl:36\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n   Evaluated:\
    \ [0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1] top-level scope at /tmp/tmpw7fzyz3x.jl:36\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw7fzyz3x.jl:34\ntest set: Test Failed at /tmp/tmpw7fzyz3x.jl:37\n\
    \  Expression: candidate(\"(()(())((())))\") == [4]\n   Evaluated: Int64[] ==\
    \ [4]\nStacktrace:\n [1] top-level scope at /tmp/tmpw7fzyz3x.jl:37\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw7fzyz3x.jl:34\nTest Summary: | Fail  Total\n\
    test set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpw7fzyz3x.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize a vector to store the maximum nesting level for each group\n\
    \    max_nesting_level = Vector{Int64}()\n    # Initialize a variable to store\
    \ the current nesting level\n    current_nesting_level = 0\n    # Initialize a\
    \ variable to store the maximum nesting level for the current group\n    max_nesting_level_current_group\
    \ = 0\n    # Loop through each character in the string\n    for character in paren_string\n\
    \        # If the character is an opening parenthesis, increment the current nesting\
    \ level\n        if character == '('\n            current_nesting_level += 1\n\
    \        # If the character is a closing parenthesis, decrement the current nesting\
    \ level\n        elseif character == ')'\n            current_nesting_level -=\
    \ 1\n        # If the character is a space, store the maximum nesting level for\
    \ the current group\n        elseif character == ' '\n            push!(max_nesting_level,\
    \ max_nesting_level_current_group)\n            # Reset the maximum nesting level\
    \ for the current group\n            max_nesting_level_current_group = 0\n   \
    \     end\n        # Update the maximum nesting level for the current group if\
    \ necessary\n        if current_nesting_level > max_nesting_level_current_group\n\
    \            max_nesting_level_current_group = current_nesting_level\n       \
    \ end\n    end\n    # Store the maximum nesting level for the last group\n   \
    \ push!(max_nesting_level, max_nesting_level_current_group)\n    return max_nesting_level\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = Vector{Int64}(undef,\
    \ length(paren_groups))\n    for (i, paren_group) in enumerate(paren_groups)\n\
    \        max_nesting[i] = max_nesting_level(paren_group)\n    end\n    return\
    \ max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpk4fn440z.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ max_nesting_level not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmpk4fn440z.jl:12\n   [2] top-level scope at /tmp/tmpk4fn440z.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpk4fn440z.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpk4fn440z.jl:22\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: max_nesting_level\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmpk4fn440z.jl:12\n\
    \   [2] top-level scope at /tmp/tmpk4fn440z.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpk4fn440z.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpk4fn440z.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: max_nesting_level not defined\n  Stacktrace:\n\
    \   [1] parse_nested_parens(::String) at /tmp/tmpk4fn440z.jl:12\n   [2] top-level\
    \ scope at /tmp/tmpk4fn440z.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpk4fn440z.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpk4fn440z.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    return [parse_nested_parens_helper(group)\
    \ for group in paren_groups]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmple5nvcvt.jl:17\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_nested_parens_helper not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmple5nvcvt.jl:10\n   [2] top-level scope at /tmp/tmple5nvcvt.jl:17\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmple5nvcvt.jl:16\n  \ntest set: Error During\
    \ Test at /tmp/tmple5nvcvt.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_nested_parens_helper\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmple5nvcvt.jl:10\n\
    \   [2] top-level scope at /tmp/tmple5nvcvt.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmple5nvcvt.jl:16\n  \ntest set: Error During\
    \ Test at /tmp/tmple5nvcvt.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: parse_nested_parens_helper not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmple5nvcvt.jl:10\n\
    \   [2] top-level scope at /tmp/tmple5nvcvt.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmple5nvcvt.jl:16\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmple5nvcvt.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    return [parse_nested_parens_helper(group)\
    \ for group in paren_groups]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpq2fuwlap.jl:17\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_nested_parens_helper not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmpq2fuwlap.jl:10\n   [2] top-level scope at /tmp/tmpq2fuwlap.jl:17\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq2fuwlap.jl:16\n  \ntest set: Error During\
    \ Test at /tmp/tmpq2fuwlap.jl:18\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_nested_parens_helper\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmpq2fuwlap.jl:10\n\
    \   [2] top-level scope at /tmp/tmpq2fuwlap.jl:18\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq2fuwlap.jl:16\n  \ntest set: Error During\
    \ Test at /tmp/tmpq2fuwlap.jl:19\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: parse_nested_parens_helper not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmpq2fuwlap.jl:10\n\
    \   [2] top-level scope at /tmp/tmpq2fuwlap.jl:19\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpq2fuwlap.jl:16\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpq2fuwlap.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = Vector{Int64}(undef,\
    \ length(paren_groups))\n    for i in 1:length(paren_groups)\n        max_nesting[i]\
    \ = parse_nested_parens_helper(paren_groups[i])\n    end\n    return max_nesting\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpstpl7ar_.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_nested_parens_helper not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmpstpl7ar_.jl:12\n   [2] top-level scope at /tmp/tmpstpl7ar_.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpstpl7ar_.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpstpl7ar_.jl:22\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_nested_parens_helper\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmpstpl7ar_.jl:12\n\
    \   [2] top-level scope at /tmp/tmpstpl7ar_.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpstpl7ar_.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpstpl7ar_.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: parse_nested_parens_helper not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmpstpl7ar_.jl:12\n\
    \   [2] top-level scope at /tmp/tmpstpl7ar_.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpstpl7ar_.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpstpl7ar_.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_list = split(paren_string, \" \")\n    max_nesting = []\n    for\
    \ paren in paren_list\n        max_nesting_level = 0\n        current_nesting_level\
    \ = 0\n        for c in paren\n            if c == '('\n                current_nesting_level\
    \ += 1\n            elseif c == ')'\n                current_nesting_level -=\
    \ 1\n            end\n            if current_nesting_level > max_nesting_level\n\
    \                max_nesting_level = current_nesting_level\n            end\n\
    \        end\n        push!(max_nesting, max_nesting_level)\n    end\n    return\
    \ max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = Vector{Int64}(undef,\
    \ length(paren_groups))\n    for i in 1:length(paren_groups)\n        max_nesting[i]\
    \ = get_max_nesting(paren_groups[i])\n    end\n    return max_nesting\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpl2tj9_ec.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ get_max_nesting not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmpl2tj9_ec.jl:12\n   [2] top-level scope at /tmp/tmpl2tj9_ec.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpl2tj9_ec.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpl2tj9_ec.jl:22\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: get_max_nesting not\
    \ defined\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmpl2tj9_ec.jl:12\n\
    \   [2] top-level scope at /tmp/tmpl2tj9_ec.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpl2tj9_ec.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpl2tj9_ec.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: get_max_nesting not defined\n  Stacktrace:\n\
    \   [1] parse_nested_parens(::String) at /tmp/tmpl2tj9_ec.jl:12\n   [2] top-level\
    \ scope at /tmp/tmpl2tj9_ec.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpl2tj9_ec.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpl2tj9_ec.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = []\n    for\
    \ paren_group in paren_groups\n        max_nesting_level = 0\n        nesting_level\
    \ = 0\n        for paren in paren_group\n            if paren == '('\n       \
    \         nesting_level += 1\n            elseif paren == ')'\n              \
    \  nesting_level -= 1\n            end\n            if nesting_level > max_nesting_level\n\
    \                max_nesting_level = nesting_level\n            end\n        end\n\
    \        push!(max_nesting, max_nesting_level)\n    end\n    return max_nesting\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_levels = Vector{Int64}(undef,\
    \ length(paren_groups))\n    for (i, paren_group) in enumerate(paren_groups)\n\
    \        level = 0\n        max_level = 0\n        for c in paren_group\n    \
    \        if c == '('\n                level += 1\n            elseif c == ')'\n\
    \                level -= 1\n            end\n            max_level = max(max_level,\
    \ level)\n        end\n        max_levels[i] = max_level\n    end\n    return\
    \ max_levels\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize a vector to store the depth of each group\n    depth_vector\
    \ = Vector{Int64}()\n    # Split the string into groups\n    groups = split(paren_string,\
    \ \" \")\n    # For each group, find the depth of nesting\n    for group in groups\n\
    \        depth = 0\n        max_depth = 0\n        for paren in group\n      \
    \      if paren == '('\n                depth += 1\n            elseif paren ==\
    \ ')'\n                depth -= 1\n            end\n            if depth > max_depth\n\
    \                max_depth = depth\n            end\n        end\n        push!(depth_vector,\
    \ max_depth)\n    end\n    return depth_vector\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string =\
    \ replace(paren_string, \")\", \" )\")\n    paren_string = replace(paren_string,\
    \ \"(\", \"( \")\n    paren_string = split(paren_string, \" \")\n    paren_string\
    \ = filter(x -> x != \"\", paren_string)\n    paren_string = filter(x -> x !=\
    \ \" \", paren_string)\n    paren_string = filter(x -> x != \"\", paren_string)\n\
    \    paren_string = filter(x -> x != \" \", paren_string)\n    paren_string =\
    \ filter(x -> x != \"\", paren_string)\n    paren_string = filter(x -> x != \"\
    \ \", paren_string)\n    paren_string = filter(x -> x != \"\", paren_string)\n\
    \    paren_string = filter(x -> x != \" \", paren_string)\n    paren_string =\
    \ filter(x -> x != \"\", paren_string)\n    paren_string = filter(x -> x != \"\
    \ \", paren_string)\n    paren_string = filter(x -> x != \"\", paren_string)\n\
    \    paren_string = filter(x -> x != \" \", paren_string)\n    paren_string =\
    \ filter(x -> x != \"\", paren_string)\n    paren_string = filter(x -> x != \"\
    \ \", paren_string)\n    paren_string = filter(x -> x != \"\", paren_string)\n\
    \    paren_string = filter(x -> x != \" \", paren_string)\n    paren_string =\
    \ filter(x -> x != \"\", paren_string)\n    paren_string = filter(x -> x != \"\
    \ \", paren_string)\n    paren_string = filter(x -> x != \"\", paren_string)\n\
    \    paren_string = filter(x -> x != \" \", paren_string)\n    paren_string =\
    \ filter(x -> x != \"\", paren_string)\n    paren_string = filter(x -> x != \"\
    \ \", paren_string)\n    p\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpw0jvex9v.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope at /tmp/tmpw0jvex9v.jl:1\n [2]\
    \ include(::Module, ::String) at ./Base.jl:377\n [3] exec_options(::Base.JLOptions)\
    \ at ./client.jl:288\n [4] _start() at ./client.jl:484\nin expression starting\
    \ at /tmp/tmpw0jvex9v.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = Vector{Int64}(undef,\
    \ length(paren_groups))\n    for (i, paren_group) in enumerate(paren_groups)\n\
    \        max_nesting[i] = parse_nested_parens_helper(paren_group)\n    end\n \
    \   return max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpeocfhvg1.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_nested_parens_helper not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String)\
    \ at /tmp/tmpeocfhvg1.jl:12\n   [2] top-level scope at /tmp/tmpeocfhvg1.jl:21\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpeocfhvg1.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpeocfhvg1.jl:22\n  Test threw exception\n  Expression: candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_nested_parens_helper\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmpeocfhvg1.jl:12\n\
    \   [2] top-level scope at /tmp/tmpeocfhvg1.jl:22\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpeocfhvg1.jl:20\n  \ntest set: Error During\
    \ Test at /tmp/tmpeocfhvg1.jl:23\n  Test threw exception\n  Expression: candidate(\"\
    (()(())((())))\") == [4]\n  UndefVarError: parse_nested_parens_helper not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(::String) at /tmp/tmpeocfhvg1.jl:12\n\
    \   [2] top-level scope at /tmp/tmpeocfhvg1.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpeocfhvg1.jl:20\n  \nTest Summary: | Error \
    \ Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpeocfhvg1.jl:18\n"
  exit_code: 1
  status: SyntaxError
