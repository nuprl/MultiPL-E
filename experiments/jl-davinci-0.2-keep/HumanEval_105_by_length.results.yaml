name: HumanEval_105_by_length
language: julia
results:
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sorted_arr\
    \ = sort(arr)\n    # reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # replace each digit by its corresponding name from \"One\", \"Two\", \"\
    Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\n    # create\
    \ a dictionary\n    dict = Dict(\"1\" => \"One\", \"2\" => \"Two\", \"3\" => \"\
    Three\", \"4\" => \"Four\", \"5\" => \"Five\", \"6\" => \"Six\", \"7\" => \"Seven\"\
    , \"8\" => \"Eight\", \"9\" => \"Nine\")\n    # convert the array to string\n\
    \    string_arr = string.(reversed_arr)\n    # create an empty array\n    result\
    \ = []\n    # loop through the array\n    for i in string_arr\n        # check\
    \ if the element is in the dictionary\n        if i in keys(dict)\n          \
    \  # append the value to the result array\n            push!(result, dict[i])\n\
    \        end\n    end\n    # return the result array\n    return result\nend\n\
    using Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # replace each digit by its corresponding\
    \ name from \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\"\n    for i in 1:length(arr)\n        if arr[i] == 1\n  \
    \          arr[i] = \"One\"\n        elseif arr[i] == 2\n            arr[i] =\
    \ \"Two\"\n        elseif arr[i] == 3\n            arr[i] = \"Three\"\n      \
    \  elseif arr[i] == 4\n            arr[i] = \"Four\"\n        elseif arr[i] ==\
    \ 5\n            arr[i] = \"Five\"\n        elseif arr[i] == 6\n            arr[i]\
    \ = \"Six\"\n        elseif arr[i] == 7\n            arr[i] = \"Seven\"\n    \
    \    elseif arr[i] == 8\n            arr[i] = \"Eight\"\n        elseif arr[i]\
    \ == 9\n            arr[i] = \"Nine\"\n        end\n    end\n    # return the\
    \ array\n    return arr\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\
    \t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\"\
    , \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp5pwkw7k7.jl:57\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: Cannot\
    \ `convert` an object of type String to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] setindex!(::Array{Int64,1}, ::String, ::Int64) at ./array.jl:826\n   [2]\
    \ by_length(::Array{Int64,1}) at /tmp/tmp5pwkw7k7.jl:44\n   [3] top-level scope\
    \ at /tmp/tmp5pwkw7k7.jl:57\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp5pwkw7k7.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmp5pwkw7k7.jl:59\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: Cannot `convert` an object of type String\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmp5pwkw7k7.jl:30\n   [3] top-level scope at /tmp/tmp5pwkw7k7.jl:59\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp5pwkw7k7.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmp5pwkw7k7.jl:60\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: Cannot `convert`\
    \ an object of type String to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmp5pwkw7k7.jl:34\n   [3] top-level scope at /tmp/tmp5pwkw7k7.jl:60\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp5pwkw7k7.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmp5pwkw7k7.jl:61\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: Cannot `convert` an\
    \ object of type String to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmp5pwkw7k7.jl:46\n   [3] top-level scope at /tmp/tmp5pwkw7k7.jl:61\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp5pwkw7k7.jl:56\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    1      4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5pwkw7k7.jl:54\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    arr = sort(arr)\n    arr\
    \ = reverse(arr)\n    arr = filter(x -> x in 1:9, arr)\n    return map(x -> [\"\
    One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\",\
    \ \"Nine\"][x], arr)\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\
    \t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\"\
    , \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # replace each digit by its corresponding\
    \ name from \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\"\n    for i in 1:length(arr)\n        if arr[i] == 1\n  \
    \          arr[i] = \"One\"\n        elseif arr[i] == 2\n            arr[i] =\
    \ \"Two\"\n        elseif arr[i] == 3\n            arr[i] = \"Three\"\n      \
    \  elseif arr[i] == 4\n            arr[i] = \"Four\"\n        elseif arr[i] ==\
    \ 5\n            arr[i] = \"Five\"\n        elseif arr[i] == 6\n            arr[i]\
    \ = \"Six\"\n        elseif arr[i] == 7\n            arr[i] = \"Seven\"\n    \
    \    elseif arr[i] == 8\n            arr[i] = \"Eight\"\n        elseif arr[i]\
    \ == 9\n            arr[i] = \"Nine\"\n        end\n    end\n    # return the\
    \ array\n    return arr\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\
    \t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\"\
    , \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp1eybxz3a.jl:57\\n  Test threw\
    \ exception\\n  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\\n  MethodError:\
    \ Cannot `convert` an object of type String to an object of type Int64\\n  Closest\
    \ candidates are:\\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\\\
    n    convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\\n  \
    \  convert(::Type{T}, !Matched::Ptr) where T<:Integer at pointer.jl:23\\n    ...\\\
    n  Stacktrace:\\n   [1] setindex!(::Array{Int64,1}, ::String, ::Int64) at ./array.jl:826\\\
    n   [2] by_length(::Array{Int64,1}) at /tmp/tmp1eybxz3a.jl:44\\n   [3] top-level\
    \ scope at /tmp/tmp1eybxz3a.jl:57\\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmp1eybxz3a.jl:56\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp1eybxz3a.jl:59\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\\n  MethodError: Cannot `convert` an object of type String\
    \ to an object of type Int64\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmp1eybxz3a.jl:30\\n   [3] top-level scope at /tmp/tmp1eybxz3a.jl:59\\\
    n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmp1eybxz3a.jl:56\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp1eybxz3a.jl:60\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\\n  MethodError: Cannot `convert`\
    \ an object of type String to an object of type Int64\\n  Closest candidates are:\\\
    n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmp1eybxz3a.jl:34\\n   [3] top-level scope at /tmp/tmp1eybxz3a.jl:60\\\
    n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmp1eybxz3a.jl:56\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp1eybxz3a.jl:61\\n  Test threw exception\\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\\n  MethodError: Cannot `convert`\
    \ an object of type String to an object of type Int64\\n  Closest candidates are:\\\
    n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmp1eybxz3a.jl:46\\n   [3] top-level scope at /tmp/tmp1eybxz3a.jl:61\\\
    n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmp1eybxz3a.jl:56\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    arr = sort(arr)\n    arr\
    \ = reverse(arr)\n    arr = filter(x -> x in 1:9, arr)\n    arr = map(x -> string(x),\
    \ arr)\n    arr = map(x -> replace(x, \"1\" => \"One\", \"2\" => \"Two\", \"3\"\
    \ => \"Three\", \"4\" => \"Four\", \"5\" => \"Five\", \"6\" => \"Six\", \"7\"\
    \ => \"Seven\", \"8\" => \"Eight\", \"9\" => \"Nine\"), arr)\n    return arr\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpf0jghclr.jl:35\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: no method\
    \ matching similar(::String, ::Type{Any})\n  Closest candidates are:\n    similar(!Matched::Array{T,1},\
    \ ::Type) where T at array.jl:358\n    similar(!Matched::Array{T,2}, ::Type) where\
    \ T at array.jl:359\n    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}})\
    \ where N at array.jl:361\n    ...\n  Stacktrace:\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\n \
    \  [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmpf0jghclr.jl:27\n   [5] iterate at ./generator.jl:47 [inlined]\n\
    \   [6] _collect at ./array.jl:678 [inlined]\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\n   [8] map at ./abstractarray.jl:2072 [inlined]\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmpf0jghclr.jl:27\n   [10] top-level scope at /tmp/tmpf0jghclr.jl:35\n\
    \   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [12] top-level scope at /tmp/tmpf0jghclr.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmpf0jghclr.jl:37\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: no method matching similar(::String, ::Type{Any})\n\
    \  Closest candidates are:\n    similar(!Matched::Array{T,1}, ::Type) where T\
    \ at array.jl:358\n    similar(!Matched::Array{T,2}, ::Type) where T at array.jl:359\n\
    \    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}}) where\
    \ N at array.jl:361\n    ...\n  Stacktrace:\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\n \
    \  [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmpf0jghclr.jl:27\n   [5] iterate at ./generator.jl:47 [inlined]\n\
    \   [6] _collect at ./array.jl:678 [inlined]\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\n   [8] map at ./abstractarray.jl:2072 [inlined]\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmpf0jghclr.jl:27\n   [10] top-level scope at /tmp/tmpf0jghclr.jl:37\n\
    \   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [12] top-level scope at /tmp/tmpf0jghclr.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmpf0jghclr.jl:38\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: no method matching\
    \ similar(::String, ::Type{Any})\n  Closest candidates are:\n    similar(!Matched::Array{T,1},\
    \ ::Type) where T at array.jl:358\n    similar(!Matched::Array{T,2}, ::Type) where\
    \ T at array.jl:359\n    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}})\
    \ where N at array.jl:361\n    ...\n  Stacktrace:\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\n \
    \  [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmpf0jghclr.jl:27\n   [5] iterate at ./generator.jl:47 [inlined]\n\
    \   [6] _collect at ./array.jl:678 [inlined]\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\n   [8] map at ./abstractarray.jl:2072 [inlined]\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmpf0jghclr.jl:27\n   [10] top-level scope at /tmp/tmpf0jghclr.jl:38\n\
    \   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [12] top-level scope at /tmp/tmpf0jghclr.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmpf0jghclr.jl:39\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: no method matching\
    \ similar(::String, ::Type{Any})\n  Closest candidates are:\n    similar(!Matched::Array{T,1},\
    \ ::Type) where T at array.jl:358\n    similar(!Matched::Array{T,2}, ::Type) where\
    \ T at array.jl:359\n    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}})\
    \ where N at array.jl:361\n    ...\n  Stacktrace:\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\n \
    \  [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmpf0jghclr.jl:27\n   [5] iterate at ./generator.jl:47 [inlined]\n\
    \   [6] _collect at ./array.jl:678 [inlined]\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\n   [8] map at ./abstractarray.jl:2072 [inlined]\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmpf0jghclr.jl:27\n   [10] top-level scope at /tmp/tmpf0jghclr.jl:39\n\
    \   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [12] top-level scope at /tmp/tmpf0jghclr.jl:34\n  \nTest Summary: | Pass \
    \ Error  Total\ntest set      |    1      4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpf0jghclr.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    arr_sort = sort(arr)\n \
    \   arr_reverse = reverse(arr_sort)\n    arr_string = []\n    for i in arr_reverse\n\
    \        if i == 1\n            push!(arr_string, \"One\")\n        elseif i ==\
    \ 2\n            push!(arr_string, \"Two\")\n        elseif i == 3\n         \
    \   push!(arr_string, \"Three\")\n        elseif i == 4\n            push!(arr_string,\
    \ \"Four\")\n        elseif i == 5\n            push!(arr_string, \"Five\")\n\
    \        elseif i == 6\n            push!(arr_string, \"Six\")\n        elseif\
    \ i == 7\n            push!(arr_string, \"Seven\")\n        elseif i == 8\n  \
    \          push!(arr_string, \"Eight\")\n        elseif i == 9\n            push!(arr_string,\
    \ \"Nine\")\n        end\n    end\n    return arr_string\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8,\
    \ 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\"\
    , \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\t@test(candidate([1,\
    \ -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2]) == [\"Three\", \"Two\"\
    , \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    #\
    \ reverse the array\n    # replace each digit by its corresponding name from \"\
    One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\",\
    \ \"Nine\"\n    # return the array\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"\
    Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpp_auw7tf.jl:33\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmpp_auw7tf.jl:27\n\
    \   [2] top-level scope at /tmp/tmpp_auw7tf.jl:33\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpp_auw7tf.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmpp_auw7tf.jl:34\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{String}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmpp_auw7tf.jl:27\n\
    \   [2] top-level scope at /tmp/tmpp_auw7tf.jl:34\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpp_auw7tf.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmpp_auw7tf.jl:35\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmpp_auw7tf.jl:27\n\
    \   [2] top-level scope at /tmp/tmpp_auw7tf.jl:35\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpp_auw7tf.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmpp_auw7tf.jl:36\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmpp_auw7tf.jl:27\n\
    \   [2] top-level scope at /tmp/tmpp_auw7tf.jl:36\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpp_auw7tf.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmpp_auw7tf.jl:37\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmpp_auw7tf.jl:27\n\
    \   [2] top-level scope at /tmp/tmpp_auw7tf.jl:37\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpp_auw7tf.jl:32\n  \nTest Summary: | Error \
    \ Total\ntest set      |     5      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpp_auw7tf.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sorted_arr\
    \ = sort(arr)\n    # reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # replace each digit by its corresponding name\n    result = []\n    for\
    \ i in reversed_arr\n        if i == 1\n            push!(result, \"One\")\n \
    \       elseif i == 2\n            push!(result, \"Two\")\n        elseif i ==\
    \ 3\n            push!(result, \"Three\")\n        elseif i == 4\n           \
    \ push!(result, \"Four\")\n        elseif i == 5\n            push!(result, \"\
    Five\")\n        elseif i == 6\n            push!(result, \"Six\")\n        elseif\
    \ i == 7\n            push!(result, \"Seven\")\n        elseif i == 8\n      \
    \      push!(result, \"Eight\")\n        elseif i == 9\n            push!(result,\
    \ \"Nine\")\n        end\n    end\n    return result\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3])\
    \ == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"\
    One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\t@test(candidate([1,\
    \ -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2]) == [\"Three\", \"Two\"\
    , \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    #\
    \ reverse the array\n    # replace each digit by its corresponding name from \"\
    One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\",\
    \ \"Nine\"\n    # return the resulting array\n    # if the array is empty, return\
    \ an empty array\n    # if the array has any strange number ignore it\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2, 1, 1,\
    \ 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmprin2fyml.jl:35\\n  Test threw\
    \ exception\\n  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{String,1}\\\
    n  Closest candidates are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] by_length(::Array{Int64,1}) at /tmp/tmprin2fyml.jl:29\\\
    n   [2] top-level scope at /tmp/tmprin2fyml.jl:35\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmprin2fyml.jl:34\\n  \\ntest set: Error During\
    \ Test at /tmp/tmprin2fyml.jl:36\\n  Test threw exception\\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{String}([])\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\\n  Closest candidates are:\\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] by_length(::Array{Int64,1}) at /tmp/tmprin2fyml.jl:29\\\
    n   [2] top-level scope at /tmp/tmprin2fyml.jl:36\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmprin2fyml.jl:34\\n  \\ntest set: Error During\
    \ Test at /tmp/tmprin2fyml.jl:37\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\\n  Closest candidates are:\\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] by_length(::Array{Int64,1}) at /tmp/tmprin2fyml.jl:29\\\
    n   [2] top-level scope at /tmp/tmprin2fyml.jl:37\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmprin2fyml.jl:34\\n  \\ntest set: Error During\
    \ Test at /tmp/tmprin2fyml.jl:38\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{String,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] by_length(::Array{Int64,1}) at /tmp/tmprin2fyml.jl:29\\\
    n   [2] top-level scope at /tmp/tmprin2fyml.jl:38\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmprin2fyml.jl:34\\n  \\ntest set: Error During\
    \ Test at /tmp/tmprin2fyml.jl:39\\n  Test threw exception\\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{String,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] by_length(::Array{Int64,1}) at /tmp/tmprin2fyml.jl:29\\\
    n   [2] top-level scope at /tmp/tmprin2fyml.jl:39\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmprin2fyml.jl:34\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    arr = sort(arr)\n    arr\
    \ = reverse(arr)\n    arr = filter(x -> x > 0 && x < 10, arr)\n    arr = map(x\
    \ -> string(x), arr)\n    arr = map(x -> replace(x, \"1\" => \"One\", \"2\" =>\
    \ \"Two\", \"3\" => \"Three\", \"4\" => \"Four\", \"5\" => \"Five\", \"6\" =>\
    \ \"Six\", \"7\" => \"Seven\", \"8\" => \"Eight\", \"9\" => \"Nine\"), arr)\n\
    \    return arr\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\
    \t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\"\
    , \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpj7wz1fne.jl:35\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: no method\
    \ matching similar(::String, ::Type{Any})\n  Closest candidates are:\n    similar(!Matched::Array{T,1},\
    \ ::Type) where T at array.jl:358\n    similar(!Matched::Array{T,2}, ::Type) where\
    \ T at array.jl:359\n    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}})\
    \ where N at array.jl:361\n    ...\n  Stacktrace:\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\n \
    \  [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmpj7wz1fne.jl:27\n   [5] iterate at ./generator.jl:47 [inlined]\n\
    \   [6] _collect at ./array.jl:678 [inlined]\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\n   [8] map at ./abstractarray.jl:2072 [inlined]\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmpj7wz1fne.jl:27\n   [10] top-level scope at /tmp/tmpj7wz1fne.jl:35\n\
    \   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [12] top-level scope at /tmp/tmpj7wz1fne.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmpj7wz1fne.jl:37\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: no method matching similar(::String, ::Type{Any})\n\
    \  Closest candidates are:\n    similar(!Matched::Array{T,1}, ::Type) where T\
    \ at array.jl:358\n    similar(!Matched::Array{T,2}, ::Type) where T at array.jl:359\n\
    \    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}}) where\
    \ N at array.jl:361\n    ...\n  Stacktrace:\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\n \
    \  [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmpj7wz1fne.jl:27\n   [5] iterate at ./generator.jl:47 [inlined]\n\
    \   [6] _collect at ./array.jl:678 [inlined]\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\n   [8] map at ./abstractarray.jl:2072 [inlined]\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmpj7wz1fne.jl:27\n   [10] top-level scope at /tmp/tmpj7wz1fne.jl:37\n\
    \   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [12] top-level scope at /tmp/tmpj7wz1fne.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmpj7wz1fne.jl:38\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: no method matching\
    \ similar(::String, ::Type{Any})\n  Closest candidates are:\n    similar(!Matched::Array{T,1},\
    \ ::Type) where T at array.jl:358\n    similar(!Matched::Array{T,2}, ::Type) where\
    \ T at array.jl:359\n    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}})\
    \ where N at array.jl:361\n    ...\n  Stacktrace:\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\n \
    \  [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmpj7wz1fne.jl:27\n   [5] iterate at ./generator.jl:47 [inlined]\n\
    \   [6] _collect at ./array.jl:678 [inlined]\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\n   [8] map at ./abstractarray.jl:2072 [inlined]\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmpj7wz1fne.jl:27\n   [10] top-level scope at /tmp/tmpj7wz1fne.jl:38\n\
    \   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [12] top-level scope at /tmp/tmpj7wz1fne.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmpj7wz1fne.jl:39\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: no method matching\
    \ similar(::String, ::Type{Any})\n  Closest candidates are:\n    similar(!Matched::Array{T,1},\
    \ ::Type) where T at array.jl:358\n    similar(!Matched::Array{T,2}, ::Type) where\
    \ T at array.jl:359\n    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}})\
    \ where N at array.jl:361\n    ...\n  Stacktrace:\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\n \
    \  [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmpj7wz1fne.jl:27\n   [5] iterate at ./generator.jl:47 [inlined]\n\
    \   [6] _collect at ./array.jl:678 [inlined]\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\n   [8] map at ./abstractarray.jl:2072 [inlined]\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmpj7wz1fne.jl:27\n   [10] top-level scope at /tmp/tmpj7wz1fne.jl:39\n\
    \   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [12] top-level scope at /tmp/tmpj7wz1fne.jl:34\n  \nTest Summary: | Pass \
    \ Error  Total\ntest set      |    1      4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpj7wz1fne.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sorted_arr\
    \ = sort(arr)\n    # reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # replace each digit by its corresponding name\n    result = []\n    for\
    \ i in reversed_arr\n        if i == 1\n            push!(result, \"One\")\n \
    \       elseif i == 2\n            push!(result, \"Two\")\n        elseif i ==\
    \ 3\n            push!(result, \"Three\")\n        elseif i == 4\n           \
    \ push!(result, \"Four\")\n        elseif i == 5\n            push!(result, \"\
    Five\")\n        elseif i == 6\n            push!(result, \"Six\")\n        elseif\
    \ i == 7\n            push!(result, \"Seven\")\n        elseif i == 8\n      \
    \      push!(result, \"Eight\")\n        elseif i == 9\n            push!(result,\
    \ \"Nine\")\n        end\n    end\n    return result\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3])\
    \ == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"\
    One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\t@test(candidate([1,\
    \ -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2]) == [\"Three\", \"Two\"\
    , \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    #\
    \ reverse the array\n    # convert each integer to its corresponding name\n  \
    \  # return the array\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\
    \t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\"\
    , \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpemqgoi7z.jl:33\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmpemqgoi7z.jl:27\n\
    \   [2] top-level scope at /tmp/tmpemqgoi7z.jl:33\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpemqgoi7z.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmpemqgoi7z.jl:34\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{String}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmpemqgoi7z.jl:27\n\
    \   [2] top-level scope at /tmp/tmpemqgoi7z.jl:34\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpemqgoi7z.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmpemqgoi7z.jl:35\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmpemqgoi7z.jl:27\n\
    \   [2] top-level scope at /tmp/tmpemqgoi7z.jl:35\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpemqgoi7z.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmpemqgoi7z.jl:36\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmpemqgoi7z.jl:27\n\
    \   [2] top-level scope at /tmp/tmpemqgoi7z.jl:36\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpemqgoi7z.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmpemqgoi7z.jl:37\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmpemqgoi7z.jl:27\n\
    \   [2] top-level scope at /tmp/tmpemqgoi7z.jl:37\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpemqgoi7z.jl:32\n  \nTest Summary: | Error \
    \ Total\ntest set      |     5      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpemqgoi7z.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sorted_arr\
    \ = sort(arr)\n    # reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # replace each digit by its corresponding name from \"One\", \"Two\", \"\
    Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\n    result\
    \ = []\n    for i in reversed_arr\n        if i == 1\n            push!(result,\
    \ \"One\")\n        elseif i == 2\n            push!(result, \"Two\")\n      \
    \  elseif i == 3\n            push!(result, \"Three\")\n        elseif i == 4\n\
    \            push!(result, \"Four\")\n        elseif i == 5\n            push!(result,\
    \ \"Five\")\n        elseif i == 6\n            push!(result, \"Six\")\n     \
    \   elseif i == 7\n            push!(result, \"Seven\")\n        elseif i == 8\n\
    \            push!(result, \"Eight\")\n        elseif i == 9\n            push!(result,\
    \ \"Nine\")\n        end\n    end\n    return result\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3])\
    \ == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"\
    One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\t@test(candidate([1,\
    \ -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2]) == [\"Three\", \"Two\"\
    , \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sorted_arr\
    \ = sort(arr)\n    # reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # create a dictionary to map each number to its name\n    num_to_name = Dict(1\
    \ => \"One\", 2 => \"Two\", 3 => \"Three\", 4 => \"Four\", 5 => \"Five\", 6 =>\
    \ \"Six\", 7 => \"Seven\", 8 => \"Eight\", 9 => \"Nine\")\n    # create an empty\
    \ array to store the names\n    names = []\n    # loop over the reversed array\n\
    \    for i in reversed_arr\n        # if the number is between 1 and 9 inclusive,\
    \ append its name to the names array\n        if i in keys(num_to_name)\n    \
    \        push!(names, num_to_name[i])\n        end\n    end\n    # return the\
    \ names array\n    return names\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"\
    Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # create a dictionary to map\
    \ the numbers to their names\n    dict = Dict(1 => \"One\", 2 => \"Two\", 3 =>\
    \ \"Three\", 4 => \"Four\", 5 => \"Five\", 6 => \"Six\", 7 => \"Seven\", 8 =>\
    \ \"Eight\", 9 => \"Nine\")\n    # create an empty array to store the names\n\
    \    names = []\n    # iterate through the array\n    for i in arr\n        #\
    \ if the number is in the dictionary, add it to the names array\n        if i\
    \ in keys(dict)\n            push!(names, dict[i])\n        end\n    end\n   \
    \ # return the names array\n    return names\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sorted_arr\
    \ = sort(arr)\n    # reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # replace each digit by its corresponding name from \"One\", \"Two\", \"\
    Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\n    result\
    \ = []\n    for i in reversed_arr\n        if i == 1\n            push!(result,\
    \ \"One\")\n        elseif i == 2\n            push!(result, \"Two\")\n      \
    \  elseif i == 3\n            push!(result, \"Three\")\n        elseif i == 4\n\
    \            push!(result, \"Four\")\n        elseif i == 5\n            push!(result,\
    \ \"Five\")\n        elseif i == 6\n            push!(result, \"Six\")\n     \
    \   elseif i == 7\n            push!(result, \"Seven\")\n        elseif i == 8\n\
    \            push!(result, \"Eight\")\n        elseif i == 9\n            push!(result,\
    \ \"Nine\")\n        end\n    end\n    return result\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3])\
    \ == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"\
    One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\t@test(candidate([1,\
    \ -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2]) == [\"Three\", \"Two\"\
    , \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    #\
    \ reverse the array\n    # replace each digit by its corresponding name from \"\
    One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\",\
    \ \"Nine\"\n    # return the array\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"\
    Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpfdy0wkpp.jl:33\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmpfdy0wkpp.jl:27\n\
    \   [2] top-level scope at /tmp/tmpfdy0wkpp.jl:33\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfdy0wkpp.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmpfdy0wkpp.jl:34\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{String}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmpfdy0wkpp.jl:27\n\
    \   [2] top-level scope at /tmp/tmpfdy0wkpp.jl:34\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfdy0wkpp.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmpfdy0wkpp.jl:35\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmpfdy0wkpp.jl:27\n\
    \   [2] top-level scope at /tmp/tmpfdy0wkpp.jl:35\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfdy0wkpp.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmpfdy0wkpp.jl:36\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmpfdy0wkpp.jl:27\n\
    \   [2] top-level scope at /tmp/tmpfdy0wkpp.jl:36\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfdy0wkpp.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmpfdy0wkpp.jl:37\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmpfdy0wkpp.jl:27\n\
    \   [2] top-level scope at /tmp/tmpfdy0wkpp.jl:37\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpfdy0wkpp.jl:32\n  \nTest Summary: | Error \
    \ Total\ntest set      |     5      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpfdy0wkpp.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # create a dictionary\n    dict\
    \ = Dict()\n    dict[1] = \"One\"\n    dict[2] = \"Two\"\n    dict[3] = \"Three\"\
    \n    dict[4] = \"Four\"\n    dict[5] = \"Five\"\n    dict[6] = \"Six\"\n    dict[7]\
    \ = \"Seven\"\n    dict[8] = \"Eight\"\n    dict[9] = \"Nine\"\n    # create a\
    \ new array\n    new_arr = []\n    # iterate through the array\n    for i in arr\n\
    \        # check if the number is between 1 and 9\n        if i in keys(dict)\n\
    \            # append the corresponding name to the new array\n            push!(new_arr,\
    \ dict[i])\n        end\n    end\n    # return the new array\n    return new_arr\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    arr = sort(arr)\n    arr\
    \ = reverse(arr)\n    for i in 1:length(arr)\n        if arr[i] == 1\n       \
    \     arr[i] = \"One\"\n        elseif arr[i] == 2\n            arr[i] = \"Two\"\
    \n        elseif arr[i] == 3\n            arr[i] = \"Three\"\n        elseif arr[i]\
    \ == 4\n            arr[i] = \"Four\"\n        elseif arr[i] == 5\n          \
    \  arr[i] = \"Five\"\n        elseif arr[i] == 6\n            arr[i] = \"Six\"\
    \n        elseif arr[i] == 7\n            arr[i] = \"Seven\"\n        elseif arr[i]\
    \ == 8\n            arr[i] = \"Eight\"\n        elseif arr[i] == 9\n         \
    \   arr[i] = \"Nine\"\n        else\n            arr[i] = \"\"\n        end\n\
    \    end\n    return arr\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\
    \t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\"\
    , \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpmghmhwn5.jl:55\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: Cannot\
    \ `convert` an object of type String to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] setindex!(::Array{Int64,1}, ::String, ::Int64) at ./array.jl:826\n   [2]\
    \ by_length(::Array{Int64,1}) at /tmp/tmpmghmhwn5.jl:41\n   [3] top-level scope\
    \ at /tmp/tmpmghmhwn5.jl:55\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpmghmhwn5.jl:54\n  \ntest set: Error During\
    \ Test at /tmp/tmpmghmhwn5.jl:57\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: Cannot `convert` an object of type String\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpmghmhwn5.jl:45\n   [3] top-level scope at /tmp/tmpmghmhwn5.jl:57\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpmghmhwn5.jl:54\n  \ntest set: Error During\
    \ Test at /tmp/tmpmghmhwn5.jl:58\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: Cannot `convert`\
    \ an object of type String to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpmghmhwn5.jl:31\n   [3] top-level scope at /tmp/tmpmghmhwn5.jl:58\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpmghmhwn5.jl:54\n  \ntest set: Error During\
    \ Test at /tmp/tmpmghmhwn5.jl:59\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: Cannot `convert` an\
    \ object of type String to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpmghmhwn5.jl:43\n   [3] top-level scope at /tmp/tmpmghmhwn5.jl:59\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpmghmhwn5.jl:54\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    1      4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmghmhwn5.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sorted_arr\
    \ = sort(arr)\n    # reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # create a dictionary to map the numbers to their names\n    dict = Dict(1\
    \ => \"One\", 2 => \"Two\", 3 => \"Three\", 4 => \"Four\", 5 => \"Five\", 6 =>\
    \ \"Six\", 7 => \"Seven\", 8 => \"Eight\", 9 => \"Nine\")\n    # create an empty\
    \ array to store the names\n    names = []\n    # loop through the reversed array\n\
    \    for i in reversed_arr\n        # if the number is in the dictionary, append\
    \ the name to the names array\n        if i in keys(dict)\n            push!(names,\
    \ dict[i])\n        end\n    end\n    # return the names array\n    return names\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # create a dictionary\n    dict\
    \ = Dict(1 => \"One\", 2 => \"Two\", 3 => \"Three\", 4 => \"Four\", 5 => \"Five\"\
    , 6 => \"Six\", 7 => \"Seven\", 8 => \"Eight\", 9 => \"Nine\")\n    # create a\
    \ new array\n    new_arr = []\n    # loop over the array\n    for i in arr\n \
    \       # check if the value is in the dictionary\n        if i in keys(dict)\n\
    \            # push the value to the new array\n            push!(new_arr, dict[i])\n\
    \        end\n    end\n    # return the new array\n    return new_arr\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2, 1, 1,\
    \ 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # replace each digit by its corresponding\
    \ name from \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\"\n    for i in 1:length(arr)\n        if arr[i] == 1\n  \
    \          arr[i] = \"One\"\n        elseif arr[i] == 2\n            arr[i] =\
    \ \"Two\"\n        elseif arr[i] == 3\n            arr[i] = \"Three\"\n      \
    \  elseif arr[i] == 4\n            arr[i] = \"Four\"\n        elseif arr[i] ==\
    \ 5\n            arr[i] = \"Five\"\n        elseif arr[i] == 6\n            arr[i]\
    \ = \"Six\"\n        elseif arr[i] == 7\n            arr[i] = \"Seven\"\n    \
    \    elseif arr[i] == 8\n            arr[i] = \"Eight\"\n        elseif arr[i]\
    \ == 9\n            arr[i] = \"Nine\"\n        end\n    end\n    # return the\
    \ array\n    return arr\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\
    \t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\"\
    , \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpi3hdh96y.jl:57\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: Cannot\
    \ `convert` an object of type String to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] setindex!(::Array{Int64,1}, ::String, ::Int64) at ./array.jl:826\n   [2]\
    \ by_length(::Array{Int64,1}) at /tmp/tmpi3hdh96y.jl:44\n   [3] top-level scope\
    \ at /tmp/tmpi3hdh96y.jl:57\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpi3hdh96y.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmpi3hdh96y.jl:59\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: Cannot `convert` an object of type String\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpi3hdh96y.jl:30\n   [3] top-level scope at /tmp/tmpi3hdh96y.jl:59\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpi3hdh96y.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmpi3hdh96y.jl:60\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: Cannot `convert`\
    \ an object of type String to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpi3hdh96y.jl:34\n   [3] top-level scope at /tmp/tmpi3hdh96y.jl:60\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpi3hdh96y.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmpi3hdh96y.jl:61\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: Cannot `convert` an\
    \ object of type String to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpi3hdh96y.jl:46\n   [3] top-level scope at /tmp/tmpi3hdh96y.jl:61\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpi3hdh96y.jl:56\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    1      4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpi3hdh96y.jl:54\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    arr = sort(arr)\n    arr\
    \ = reverse(arr)\n    arr = filter(x -> x in 1:9, arr)\n    return map(x -> string(x),\
    \ arr)\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmphqacjkyn.jl:33\n  Expression: candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"]\n   Evaluated: [\"8\", \"5\", \"4\", \"3\", \"2\"\
    , \"2\", \"1\", \"1\"] == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\",\
    \ \"Two\", \"One\", \"One\"]\nStacktrace:\n [1] top-level scope at /tmp/tmphqacjkyn.jl:33\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphqacjkyn.jl:32\ntest set: Test Failed at /tmp/tmphqacjkyn.jl:35\n\
    \  Expression: candidate([1, -1, 55]) == [\"One\"]\n   Evaluated: [\"1\"] == [\"\
    One\"]\nStacktrace:\n [1] top-level scope at /tmp/tmphqacjkyn.jl:35\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphqacjkyn.jl:32\ntest set: Test Failed at /tmp/tmphqacjkyn.jl:36\n\
    \  Expression: candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n   Evaluated:\
    \ [\"3\", \"2\", \"1\"] == [\"Three\", \"Two\", \"One\"]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmphqacjkyn.jl:36\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphqacjkyn.jl:32\ntest set: Test Failed at /tmp/tmphqacjkyn.jl:37\n\
    \  Expression: candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n   Evaluated:\
    \ [\"9\", \"8\", \"4\"] == [\"Nine\", \"Eight\", \"Four\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmphqacjkyn.jl:37\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphqacjkyn.jl:32\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphqacjkyn.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    arr = sort(arr)\n    arr\
    \ = reverse(arr)\n    arr = filter(x -> x > 0 && x < 10, arr)\n    arr = map(x\
    \ -> string(x), arr)\n    return arr\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"\
    Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpiuvh09lb.jl:34\\n  Expression: candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"]\\n   Evaluated: [\"8\", \"5\", \"4\", \"3\", \"2\"\
    , \"2\", \"1\", \"1\"] == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\",\
    \ \"Two\", \"One\", \"One\"]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpiuvh09lb.jl:34\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpiuvh09lb.jl:33\\ntest set: Test Failed at /tmp/tmpiuvh09lb.jl:36\\\
    n  Expression: candidate([1, -1, 55]) == [\"One\"]\\n   Evaluated: [\"1\"] ==\
    \ [\"One\"]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpiuvh09lb.jl:36\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpiuvh09lb.jl:33\\ntest set: Test Failed at /tmp/tmpiuvh09lb.jl:37\\\
    n  Expression: candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\\n  \
    \ Evaluated: [\"3\", \"2\", \"1\"] == [\"Three\", \"Two\", \"One\"]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpiuvh09lb.jl:37\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpiuvh09lb.jl:33\\ntest set: Test Failed at /tmp/tmpiuvh09lb.jl:38\\\
    n  Expression: candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\\n   Evaluated:\
    \ [\"9\", \"8\", \"4\"] == [\"Nine\", \"Eight\", \"Four\"]\\nStacktrace:\\n [1]\
    \ top-level scope at /tmp/tmpiuvh09lb.jl:38\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpiuvh09lb.jl:33\\nTest Summary: | Pass  Fail \
    \ '"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    arr = sort(arr)\n    arr\
    \ = reverse(arr)\n    result = []\n    for i in arr\n        if i == 1\n     \
    \       push!(result, \"One\")\n        elseif i == 2\n            push!(result,\
    \ \"Two\")\n        elseif i == 3\n            push!(result, \"Three\")\n    \
    \    elseif i == 4\n            push!(result, \"Four\")\n        elseif i == 5\n\
    \            push!(result, \"Five\")\n        elseif i == 6\n            push!(result,\
    \ \"Six\")\n        elseif i == 7\n            push!(result, \"Seven\")\n    \
    \    elseif i == 8\n            push!(result, \"Eight\")\n        elseif i ==\
    \ 9\n            push!(result, \"Nine\")\n        end\n    end\n    return result\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    arr = sort(arr)\n    arr\
    \ = reverse(arr)\n    arr = arr[arr .> 0]\n    arr = arr[arr .< 10]\n    arr =\
    \ string.(arr)\n    return arr\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"\
    Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp0fey9ukf.jl:35\n  Expression: candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"]\n   Evaluated: [\"8\", \"5\", \"4\", \"3\", \"2\"\
    , \"2\", \"1\", \"1\"] == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\",\
    \ \"Two\", \"One\", \"One\"]\nStacktrace:\n [1] top-level scope at /tmp/tmp0fey9ukf.jl:35\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0fey9ukf.jl:34\ntest set: Test Failed at /tmp/tmp0fey9ukf.jl:37\n\
    \  Expression: candidate([1, -1, 55]) == [\"One\"]\n   Evaluated: [\"1\"] == [\"\
    One\"]\nStacktrace:\n [1] top-level scope at /tmp/tmp0fey9ukf.jl:37\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0fey9ukf.jl:34\ntest set: Test Failed at /tmp/tmp0fey9ukf.jl:38\n\
    \  Expression: candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n   Evaluated:\
    \ [\"3\", \"2\", \"1\"] == [\"Three\", \"Two\", \"One\"]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp0fey9ukf.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0fey9ukf.jl:34\ntest set: Test Failed at /tmp/tmp0fey9ukf.jl:39\n\
    \  Expression: candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n   Evaluated:\
    \ [\"9\", \"8\", \"4\"] == [\"Nine\", \"Eight\", \"Four\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp0fey9ukf.jl:39\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0fey9ukf.jl:34\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0fey9ukf.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    arr_sorted = sort(arr)\n\
    \    arr_reversed = reverse(arr_sorted)\n    arr_filtered = filter(x -> x >= 1\
    \ && x <= 9, arr_reversed)\n    arr_mapped = map(x -> string(x), arr_filtered)\n\
    \    return arr_mapped\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\
    \t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\"\
    , \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp5bwz_ctw.jl:34\n  Expression: candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"]\n   Evaluated: [\"8\", \"5\", \"4\", \"3\", \"2\"\
    , \"2\", \"1\", \"1\"] == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\",\
    \ \"Two\", \"One\", \"One\"]\nStacktrace:\n [1] top-level scope at /tmp/tmp5bwz_ctw.jl:34\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5bwz_ctw.jl:33\ntest set: Test Failed at /tmp/tmp5bwz_ctw.jl:36\n\
    \  Expression: candidate([1, -1, 55]) == [\"One\"]\n   Evaluated: [\"1\"] == [\"\
    One\"]\nStacktrace:\n [1] top-level scope at /tmp/tmp5bwz_ctw.jl:36\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5bwz_ctw.jl:33\ntest set: Test Failed at /tmp/tmp5bwz_ctw.jl:37\n\
    \  Expression: candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n   Evaluated:\
    \ [\"3\", \"2\", \"1\"] == [\"Three\", \"Two\", \"One\"]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp5bwz_ctw.jl:37\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5bwz_ctw.jl:33\ntest set: Test Failed at /tmp/tmp5bwz_ctw.jl:38\n\
    \  Expression: candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n   Evaluated:\
    \ [\"9\", \"8\", \"4\"] == [\"Nine\", \"Eight\", \"Four\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp5bwz_ctw.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5bwz_ctw.jl:33\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5bwz_ctw.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sorted_arr\
    \ = sort(arr)\n    # reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # create a dictionary to map the numbers to their names\n    dict = Dict(1\
    \ => \"One\", 2 => \"Two\", 3 => \"Three\", 4 => \"Four\", 5 => \"Five\", 6 =>\
    \ \"Six\", 7 => \"Seven\", 8 => \"Eight\", 9 => \"Nine\")\n    # create an empty\
    \ array to store the names\n    names = []\n    # iterate through the reversed\
    \ array\n    for i in reversed_arr\n        # if the number is between 1 and 9\
    \ inclusive, append its name to the names array\n        if i in keys(dict)\n\
    \            push!(names, dict[i])\n        end\n    end\n    # return the names\
    \ array\n    return names\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\
    \t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\"\
    , \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # replace each digit by its corresponding\
    \ name from \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\"\n    for i in 1:length(arr)\n        if arr[i] == 1\n  \
    \          arr[i] = \"One\"\n        elseif arr[i] == 2\n            arr[i] =\
    \ \"Two\"\n        elseif arr[i] == 3\n            arr[i] = \"Three\"\n      \
    \  elseif arr[i] == 4\n            arr[i] = \"Four\"\n        elseif arr[i] ==\
    \ 5\n            arr[i] = \"Five\"\n        elseif arr[i] == 6\n            arr[i]\
    \ = \"Six\"\n        elseif arr[i] == 7\n            arr[i] = \"Seven\"\n    \
    \    elseif arr[i] == 8\n            arr[i] = \"Eight\"\n        elseif arr[i]\
    \ == 9\n            arr[i] = \"Nine\"\n        end\n    end\n    # return the\
    \ array\n    return arr\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\
    \t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\"\
    , \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpvjmuctbp.jl:57\\n  Test threw\
    \ exception\\n  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\\n  MethodError:\
    \ Cannot `convert` an object of type String to an object of type Int64\\n  Closest\
    \ candidates are:\\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\\\
    n    convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\\n  \
    \  convert(::Type{T}, !Matched::Ptr) where T<:Integer at pointer.jl:23\\n    ...\\\
    n  Stacktrace:\\n   [1] setindex!(::Array{Int64,1}, ::String, ::Int64) at ./array.jl:826\\\
    n   [2] by_length(::Array{Int64,1}) at /tmp/tmpvjmuctbp.jl:44\\n   [3] top-level\
    \ scope at /tmp/tmpvjmuctbp.jl:57\\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmpvjmuctbp.jl:56\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpvjmuctbp.jl:59\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\\n  MethodError: Cannot `convert` an object of type String\
    \ to an object of type Int64\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpvjmuctbp.jl:30\\n   [3] top-level scope at /tmp/tmpvjmuctbp.jl:59\\\
    n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmpvjmuctbp.jl:56\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpvjmuctbp.jl:60\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\\n  MethodError: Cannot `convert`\
    \ an object of type String to an object of type Int64\\n  Closest candidates are:\\\
    n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpvjmuctbp.jl:34\\n   [3] top-level scope at /tmp/tmpvjmuctbp.jl:60\\\
    n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmpvjmuctbp.jl:56\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpvjmuctbp.jl:61\\n  Test threw exception\\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\\n  MethodError: Cannot `convert`\
    \ an object of type String to an object of type Int64\\n  Closest candidates are:\\\
    n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpvjmuctbp.jl:46\\n   [3] top-level scope at /tmp/tmpvjmuctbp.jl:61\\\
    n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmpvjmuctbp.jl:56\\n  \\nTest Summary: | Pass\
    \  Error  Total\\ntest set      |    1      4      5\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    #\
    \ reverse the array\n    # replace each digit by its corresponding name from \"\
    One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\",\
    \ \"Nine\"\n    # return the array\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"\
    Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpuleuppk8.jl:33\\n  Test threw\
    \ exception\\n  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{String,1}\\\
    n  Closest candidates are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] by_length(::Array{Int64,1}) at /tmp/tmpuleuppk8.jl:27\\\
    n   [2] top-level scope at /tmp/tmpuleuppk8.jl:33\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpuleuppk8.jl:32\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpuleuppk8.jl:34\\n  Test threw exception\\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{String}([])\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\\n  Closest candidates are:\\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] by_length(::Array{Int64,1}) at /tmp/tmpuleuppk8.jl:27\\\
    n   [2] top-level scope at /tmp/tmpuleuppk8.jl:34\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpuleuppk8.jl:32\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpuleuppk8.jl:35\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\\n  Closest candidates are:\\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] by_length(::Array{Int64,1}) at /tmp/tmpuleuppk8.jl:27\\\
    n   [2] top-level scope at /tmp/tmpuleuppk8.jl:35\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpuleuppk8.jl:32\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpuleuppk8.jl:36\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{String,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] by_length(::Array{Int64,1}) at /tmp/tmpuleuppk8.jl:27\\\
    n   [2] top-level scope at /tmp/tmpuleuppk8.jl:36\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpuleuppk8.jl:32\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpuleuppk8.jl:37\\n  Test threw exception\\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{String,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] by_length(::Array{Int64,1}) at /tmp/tmpuleuppk8.jl:27\\\
    n   [2] top-level scope at /tmp/tmpuleuppk8.jl:37\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpuleuppk8.jl:32\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sorted_arr\
    \ = sort(arr)\n    # reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # replace each digit by its corresponding name\n    result = []\n    for\
    \ i in reversed_arr\n        if i == 1\n            push!(result, \"One\")\n \
    \       elseif i == 2\n            push!(result, \"Two\")\n        elseif i ==\
    \ 3\n            push!(result, \"Three\")\n        elseif i == 4\n           \
    \ push!(result, \"Four\")\n        elseif i == 5\n            push!(result, \"\
    Five\")\n        elseif i == 6\n            push!(result, \"Six\")\n        elseif\
    \ i == 7\n            push!(result, \"Seven\")\n        elseif i == 8\n      \
    \      push!(result, \"Eight\")\n        elseif i == 9\n            push!(result,\
    \ \"Nine\")\n        end\n    end\n    return result\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3])\
    \ == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"\
    One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\t@test(candidate([1,\
    \ -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2]) == [\"Three\", \"Two\"\
    , \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # your code here\n    return\
    \ []\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpdsb36gr3.jl:31\n  Expression: candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"]\n   Evaluated: String[] == [\"Eight\", \"Five\",\
    \ \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpdsb36gr3.jl:31\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdsb36gr3.jl:30\ntest set: Test Failed at /tmp/tmpdsb36gr3.jl:33\n\
    \  Expression: candidate([1, -1, 55]) == [\"One\"]\n   Evaluated: String[] ==\
    \ [\"One\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpdsb36gr3.jl:33\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdsb36gr3.jl:30\ntest set: Test Failed at /tmp/tmpdsb36gr3.jl:34\n\
    \  Expression: candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n   Evaluated:\
    \ String[] == [\"Three\", \"Two\", \"One\"]\nStacktrace:\n [1] top-level scope\
    \ at /tmp/tmpdsb36gr3.jl:34\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdsb36gr3.jl:30\ntest set: Test Failed at /tmp/tmpdsb36gr3.jl:35\n\
    \  Expression: candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n   Evaluated:\
    \ String[] == [\"Nine\", \"Eight\", \"Four\"]\nStacktrace:\n [1] top-level scope\
    \ at /tmp/tmpdsb36gr3.jl:35\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdsb36gr3.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpdsb36gr3.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sorted_arr\
    \ = sort(arr)\n    # reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # replace each digit by its corresponding name from \"One\", \"Two\", \"\
    Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\n    result\
    \ = []\n    for i in reversed_arr\n        if i == 1\n            push!(result,\
    \ \"One\")\n        elseif i == 2\n            push!(result, \"Two\")\n      \
    \  elseif i == 3\n            push!(result, \"Three\")\n        elseif i == 4\n\
    \            push!(result, \"Four\")\n        elseif i == 5\n            push!(result,\
    \ \"Five\")\n        elseif i == 6\n            push!(result, \"Six\")\n     \
    \   elseif i == 7\n            push!(result, \"Seven\")\n        elseif i == 8\n\
    \            push!(result, \"Eight\")\n        elseif i == 9\n            push!(result,\
    \ \"Nine\")\n        end\n    end\n    return result\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3])\
    \ == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"\
    One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\t@test(candidate([1,\
    \ -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2]) == [\"Three\", \"Two\"\
    , \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    arr = sort(arr)\n    arr\
    \ = reverse(arr)\n    arr = [string(i) for i in arr]\n    return arr\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2, 1, 1,\
    \ 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp28ae7cbf.jl:33\n  Expression: candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"]\n   Evaluated: [\"8\", \"5\", \"4\", \"3\", \"2\"\
    , \"2\", \"1\", \"1\"] == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\",\
    \ \"Two\", \"One\", \"One\"]\nStacktrace:\n [1] top-level scope at /tmp/tmp28ae7cbf.jl:33\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp28ae7cbf.jl:32\ntest set: Test Failed at /tmp/tmp28ae7cbf.jl:35\n\
    \  Expression: candidate([1, -1, 55]) == [\"One\"]\n   Evaluated: [\"55\", \"\
    1\", \"-1\"] == [\"One\"]\nStacktrace:\n [1] top-level scope at /tmp/tmp28ae7cbf.jl:35\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp28ae7cbf.jl:32\ntest set: Test Failed at /tmp/tmp28ae7cbf.jl:36\n\
    \  Expression: candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n   Evaluated:\
    \ [\"3\", \"2\", \"1\", \"-1\"] == [\"Three\", \"Two\", \"One\"]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp28ae7cbf.jl:36\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp28ae7cbf.jl:32\ntest set: Test Failed at /tmp/tmp28ae7cbf.jl:37\n\
    \  Expression: candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n   Evaluated:\
    \ [\"9\", \"8\", \"4\"] == [\"Nine\", \"Eight\", \"Four\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp28ae7cbf.jl:37\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp28ae7cbf.jl:32\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp28ae7cbf.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # replace each digit by its corresponding\
    \ name from \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\"\n    for i in 1:length(arr)\n        if arr[i] == 1\n  \
    \          arr[i] = \"One\"\n        elseif arr[i] == 2\n            arr[i] =\
    \ \"Two\"\n        elseif arr[i] == 3\n            arr[i] = \"Three\"\n      \
    \  elseif arr[i] == 4\n            arr[i] = \"Four\"\n        elseif arr[i] ==\
    \ 5\n            arr[i] = \"Five\"\n        elseif arr[i] == 6\n            arr[i]\
    \ = \"Six\"\n        elseif arr[i] == 7\n            arr[i] = \"Seven\"\n    \
    \    elseif arr[i] == 8\n            arr[i] = \"Eight\"\n        elseif arr[i]\
    \ == 9\n            arr[i] = \"Nine\"\n        end\n    end\n    # return the\
    \ array\n    return arr\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\
    \t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\"\
    , \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpl6l958q0.jl:57\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: Cannot\
    \ `convert` an object of type String to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] setindex!(::Array{Int64,1}, ::String, ::Int64) at ./array.jl:826\n   [2]\
    \ by_length(::Array{Int64,1}) at /tmp/tmpl6l958q0.jl:44\n   [3] top-level scope\
    \ at /tmp/tmpl6l958q0.jl:57\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpl6l958q0.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmpl6l958q0.jl:59\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: Cannot `convert` an object of type String\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpl6l958q0.jl:30\n   [3] top-level scope at /tmp/tmpl6l958q0.jl:59\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpl6l958q0.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmpl6l958q0.jl:60\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: Cannot `convert`\
    \ an object of type String to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpl6l958q0.jl:34\n   [3] top-level scope at /tmp/tmpl6l958q0.jl:60\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpl6l958q0.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmpl6l958q0.jl:61\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: Cannot `convert` an\
    \ object of type String to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpl6l958q0.jl:46\n   [3] top-level scope at /tmp/tmpl6l958q0.jl:61\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpl6l958q0.jl:56\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    1      4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpl6l958q0.jl:54\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    #\
    \ reverse the array\n    # replace each digit by its corresponding name from \"\
    One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\",\
    \ \"Nine\"\n    # return the resulting array\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp1lf8c3ah.jl:33\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp1lf8c3ah.jl:27\n\
    \   [2] top-level scope at /tmp/tmp1lf8c3ah.jl:33\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1lf8c3ah.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmp1lf8c3ah.jl:34\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{String}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp1lf8c3ah.jl:27\n\
    \   [2] top-level scope at /tmp/tmp1lf8c3ah.jl:34\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1lf8c3ah.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmp1lf8c3ah.jl:35\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp1lf8c3ah.jl:27\n\
    \   [2] top-level scope at /tmp/tmp1lf8c3ah.jl:35\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1lf8c3ah.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmp1lf8c3ah.jl:36\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp1lf8c3ah.jl:27\n\
    \   [2] top-level scope at /tmp/tmp1lf8c3ah.jl:36\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1lf8c3ah.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmp1lf8c3ah.jl:37\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp1lf8c3ah.jl:27\n\
    \   [2] top-level scope at /tmp/tmp1lf8c3ah.jl:37\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1lf8c3ah.jl:32\n  \nTest Summary: | Error \
    \ Total\ntest set      |     5      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1lf8c3ah.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    arr = sort(arr)\n    arr\
    \ = reverse(arr)\n    arr = [x for x in arr if x >= 1 && x <= 9]\n    arr = [string(x)\
    \ for x in arr]\n    return arr\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"\
    Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpagz9cc9w.jl:34\n  Expression: candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"]\n   Evaluated: [\"8\", \"5\", \"4\", \"3\", \"2\"\
    , \"2\", \"1\", \"1\"] == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\",\
    \ \"Two\", \"One\", \"One\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpagz9cc9w.jl:34\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpagz9cc9w.jl:33\ntest set: Test Failed at /tmp/tmpagz9cc9w.jl:36\n\
    \  Expression: candidate([1, -1, 55]) == [\"One\"]\n   Evaluated: [\"1\"] == [\"\
    One\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpagz9cc9w.jl:36\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpagz9cc9w.jl:33\ntest set: Test Failed at /tmp/tmpagz9cc9w.jl:37\n\
    \  Expression: candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n   Evaluated:\
    \ [\"3\", \"2\", \"1\"] == [\"Three\", \"Two\", \"One\"]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpagz9cc9w.jl:37\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpagz9cc9w.jl:33\ntest set: Test Failed at /tmp/tmpagz9cc9w.jl:38\n\
    \  Expression: candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n   Evaluated:\
    \ [\"9\", \"8\", \"4\"] == [\"Nine\", \"Eight\", \"Four\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpagz9cc9w.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpagz9cc9w.jl:33\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpagz9cc9w.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    arr = sort(arr)\n    arr\
    \ = reverse(arr)\n    arr = filter(x -> x in 1:9, arr)\n    return map(x -> string(x),\
    \ arr)\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpp527twqg.jl:33\\n  Expression: candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"]\\n   Evaluated: [\"8\", \"5\", \"4\", \"3\", \"2\"\
    , \"2\", \"1\", \"1\"] == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\",\
    \ \"Two\", \"One\", \"One\"]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpp527twqg.jl:33\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpp527twqg.jl:32\\ntest set: Test Failed at /tmp/tmpp527twqg.jl:35\\\
    n  Expression: candidate([1, -1, 55]) == [\"One\"]\\n   Evaluated: [\"1\"] ==\
    \ [\"One\"]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpp527twqg.jl:35\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpp527twqg.jl:32\\ntest set: Test Failed at /tmp/tmpp527twqg.jl:36\\\
    n  Expression: candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\\n  \
    \ Evaluated: [\"3\", \"2\", \"1\"] == [\"Three\", \"Two\", \"One\"]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpp527twqg.jl:36\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpp527twqg.jl:32\\ntest set: Test Failed at /tmp/tmpp527twqg.jl:37\\\
    n  Expression: candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\\n   Evaluated:\
    \ [\"9\", \"8\", \"4\"] == [\"Nine\", \"Eight\", \"Four\"]\\nStacktrace:\\n [1]\
    \ top-level scope at /tmp/tmpp527twqg.jl:37\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpp527twqg.jl:32\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sorted_arr\
    \ = sort(arr)\n    # reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # filter the array to only contain numbers between 1 and 9\n    filtered_arr\
    \ = filter(x -> x >= 1 && x <= 9, reversed_arr)\n    # map the filtered array\
    \ to the corresponding string\n    mapped_arr = map(x -> string(x), filtered_arr)\n\
    \    return mapped_arr\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\
    \t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\"\
    , \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp2x9oj1vi.jl:38\n  Expression: candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"]\n   Evaluated: [\"8\", \"5\", \"4\", \"3\", \"2\"\
    , \"2\", \"1\", \"1\"] == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\",\
    \ \"Two\", \"One\", \"One\"]\nStacktrace:\n [1] top-level scope at /tmp/tmp2x9oj1vi.jl:38\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2x9oj1vi.jl:37\ntest set: Test Failed at /tmp/tmp2x9oj1vi.jl:40\n\
    \  Expression: candidate([1, -1, 55]) == [\"One\"]\n   Evaluated: [\"1\"] == [\"\
    One\"]\nStacktrace:\n [1] top-level scope at /tmp/tmp2x9oj1vi.jl:40\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2x9oj1vi.jl:37\ntest set: Test Failed at /tmp/tmp2x9oj1vi.jl:41\n\
    \  Expression: candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n   Evaluated:\
    \ [\"3\", \"2\", \"1\"] == [\"Three\", \"Two\", \"One\"]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp2x9oj1vi.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2x9oj1vi.jl:37\ntest set: Test Failed at /tmp/tmp2x9oj1vi.jl:42\n\
    \  Expression: candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n   Evaluated:\
    \ [\"9\", \"8\", \"4\"] == [\"Nine\", \"Eight\", \"Four\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp2x9oj1vi.jl:42\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2x9oj1vi.jl:37\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2x9oj1vi.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sorted_arr\
    \ = sort(arr)\n    # reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # replace each digit by its corresponding name from \"One\", \"Two\", \"\
    Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\n    # create\
    \ a dictionary\n    d = Dict(\"1\" => \"One\", \"2\" => \"Two\", \"3\" => \"Three\"\
    , \"4\" => \"Four\", \"5\" => \"Five\", \"6\" => \"Six\", \"7\" => \"Seven\",\
    \ \"8\" => \"Eight\", \"9\" => \"Nine\")\n    # create an empty array\n    result\
    \ = []\n    # loop through the array\n    for i in reversed_arr\n        # check\
    \ if the number is between 1 and 9 inclusive\n        if i >= 1 && i <= 9\n  \
    \          # add the corresponding name to the result array\n            push!(result,\
    \ d[string(i)])\n        end\n    end\n    # return the result array\n    return\
    \ result\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sorted_arr\
    \ = sort(arr)\n    # reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # replace each digit by its corresponding name from \"One\", \"Two\", \"\
    Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\n    result\
    \ = []\n    for i in reversed_arr\n        if i == 1\n            push!(result,\
    \ \"One\")\n        elseif i == 2\n            push!(result, \"Two\")\n      \
    \  elseif i == 3\n            push!(result, \"Three\")\n        elseif i == 4\n\
    \            push!(result, \"Four\")\n        elseif i == 5\n            push!(result,\
    \ \"Five\")\n        elseif i == 6\n            push!(result, \"Six\")\n     \
    \   elseif i == 7\n            push!(result, \"Seven\")\n        elseif i == 8\n\
    \            push!(result, \"Eight\")\n        elseif i == 9\n            push!(result,\
    \ \"Nine\")\n        end\n    end\n    return result\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3])\
    \ == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"\
    One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\t@test(candidate([1,\
    \ -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2]) == [\"Three\", \"Two\"\
    , \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sorted_arr\
    \ = sort(arr)\n    # reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # replace each digit by its corresponding name\n    # create a dictionary\n\
    \    dict = Dict()\n    dict[1] = \"One\"\n    dict[2] = \"Two\"\n    dict[3]\
    \ = \"Three\"\n    dict[4] = \"Four\"\n    dict[5] = \"Five\"\n    dict[6] = \"\
    Six\"\n    dict[7] = \"Seven\"\n    dict[8] = \"Eight\"\n    dict[9] = \"Nine\"\
    \n    # create an empty array\n    result = []\n    # loop through the array\n\
    \    for i in reversed_arr\n        # if the number is between 1 and 9 inclusive\n\
    \        if 1 <= i <= 9\n            # append the corresponding name to the result\
    \ array\n            push!(result, dict[i])\n        end\n    end\n    # return\
    \ the result array\n    return result\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"\
    Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    arr = sort(arr)\n    arr\
    \ = reverse(arr)\n    arr = filter(x -> x in 1:9, arr)\n    arr = map(x -> string(x),\
    \ arr)\n    arr = map(x -> replace(x, \"1\" => \"One\", \"2\" => \"Two\", \"3\"\
    \ => \"Three\", \"4\" => \"Four\", \"5\" => \"Five\", \"6\" => \"Six\", \"7\"\
    \ => \"Seven\", \"8\" => \"Eight\", \"9\" => \"Nine\"), arr)\n    return arr\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpingqfpnt.jl:35\\n  Test threw\
    \ exception\\n  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\\n  MethodError:\
    \ no method matching similar(::String, ::Type{Any})\\n  Closest candidates are:\\\
    n    similar(!Matched::Array{T,1}, ::Type) where T at array.jl:358\\n    similar(!Matched::Array{T,2},\
    \ ::Type) where T at array.jl:359\\n    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}})\
    \ where N at array.jl:361\\n    ...\\n  Stacktrace:\\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\\n\
    \   [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmpingqfpnt.jl:27\\n   [5] iterate at ./generator.jl:47 [inlined]\\\
    n   [6] _collect at ./array.jl:678 [inlined]\\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\\n   [8] map at ./abstractarray.jl:2072 [inlined]\\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmpingqfpnt.jl:27\\n   [10] top-level scope at /tmp/tmpingqfpnt.jl:35\\\
    n   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [12] top-level scope at /tmp/tmpingqfpnt.jl:34\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpingqfpnt.jl:37\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\\n  MethodError: no method matching similar(::String,\
    \ ::Type{Any})\\n  Closest candidates are:\\n    similar(!Matched::Array{T,1},\
    \ ::Type) where T at array.jl:358\\n    similar(!Matched::Array{T,2}, ::Type)\
    \ where T at array.jl:359\\n    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}})\
    \ where N at array.jl:361\\n    ...\\n  Stacktrace:\\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\\n\
    \   [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmpingqfpnt.jl:27\\n   [5] iterate at ./generator.jl:47 [inlined]\\\
    n   [6] _collect at ./array.jl:678 [inlined]\\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\\n   [8] map at ./abstractarray.jl:2072 [inlined]\\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmpingqfpnt.jl:27\\n   [10] top-level scope at /tmp/tmpingqfpnt.jl:37\\\
    n   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [12] top-level scope at /tmp/tmpingqfpnt.jl:34\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpingqfpnt.jl:38\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\\n  MethodError: no method matching\
    \ similar(::String, ::Type{Any})\\n  Closest candidates are:\\n    similar(!Matched::Array{T,1},\
    \ ::Type) where T at array.jl:358\\n    similar(!Matched::Array{T,2}, ::Type)\
    \ where T at array.jl:359\\n    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}})\
    \ where N at array.jl:361\\n    ...\\n  Stacktrace:\\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\\n\
    \   [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmpingqfpnt.jl:27\\n   [5] iterate at ./generator.jl:47 [inlined]\\\
    n   [6] _collect at ./array.jl:678 [inlined]\\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\\n   [8] map at ./abstractarray.jl:2072 [inlined]\\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmpingqfpnt.jl:27\\n   [10] top-level scope at /tmp/tmpingqfpnt.jl:38\\\
    n   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [12] top-level scope at /tmp/tmpingqfpnt.jl:34\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpingqfpnt.jl:39\\n  Test threw exception\\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\\n  MethodError: no method matching\
    \ similar(::String, ::Type{Any})\\n  Closest candidates are:\\n    similar(!Matched::Array{T,1},\
    \ ::Type) where T at array.jl:358\\n    similar(!Matched::Array{T,2}, ::Type)\
    \ where T at array.jl:359\\n    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}})\
    \ where N at array.jl:361\\n    ...\\n  Stacktrace:\\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\\n\
    \   [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmpingqfpnt.jl:27\\n   [5] iterate at ./generator.jl:47 [inlined]\\\
    n   [6] _collect at ./array.jl:678 [inlined]\\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\\n   [8] map at ./abstractarray.jl:2072 [inlined]\\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmpingqfpnt.jl:27\\n   [10] top-level scope at /tmp/tmpingqfpnt.jl:39\\\
    n   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [12] top-level scope at /tmp/tmpingqfpnt.jl:34\\n  \\nTest Summary: | Pass\
    \  Error  Total\\ntest set      |    1      4      5\\n'"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sorted_arr\
    \ = sort(arr)\n    # reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # replace each digit by its corresponding name from \"One\", \"Two\", \"\
    Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\n    # create\
    \ a dictionary\n    d = Dict(\"1\" => \"One\", \"2\" => \"Two\", \"3\" => \"Three\"\
    , \"4\" => \"Four\", \"5\" => \"Five\", \"6\" => \"Six\", \"7\" => \"Seven\",\
    \ \"8\" => \"Eight\", \"9\" => \"Nine\")\n    # create a new array\n    new_arr\
    \ = []\n    # loop through the reversed_arr\n    for i in reversed_arr\n     \
    \   # check if the value is in the dictionary\n        if string(i) in keys(d)\n\
    \            # append the value to the new_arr\n            push!(new_arr, d[string(i)])\n\
    \        end\n    end\n    # return the new_arr\n    return new_arr\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2, 1, 1,\
    \ 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sorted_arr\
    \ = sort(arr)\n    # reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # replace each digit by its corresponding name from \"One\", \"Two\", \"\
    Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\n    # create\
    \ a dictionary\n    d = Dict(\"1\" => \"One\", \"2\" => \"Two\", \"3\" => \"Three\"\
    , \"4\" => \"Four\", \"5\" => \"Five\", \"6\" => \"Six\", \"7\" => \"Seven\",\
    \ \"8\" => \"Eight\", \"9\" => \"Nine\")\n    # create an empty array\n    new_arr\
    \ = []\n    # loop through the reversed_arr\n    for i in reversed_arr\n     \
    \   # if the element is in the dictionary\n        if string(i) in keys(d)\n \
    \           # append the corresponding name to the new_arr\n            push!(new_arr,\
    \ d[string(i)])\n        end\n    end\n    # return the new_arr\n    return new_arr\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    arr = sort(arr)\n    arr\
    \ = reverse(arr)\n    arr = filter(x -> x in 1:9, arr)\n    arr = map(x -> string(x),\
    \ arr)\n    arr = map(x -> replace(x, \"1\" => \"One\", \"2\" => \"Two\", \"3\"\
    \ => \"Three\", \"4\" => \"Four\", \"5\" => \"Five\", \"6\" => \"Six\", \"7\"\
    \ => \"Seven\", \"8\" => \"Eight\", \"9\" => \"Nine\"), arr)\n    return arr\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp09dh96kw.jl:35\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: no method\
    \ matching similar(::String, ::Type{Any})\n  Closest candidates are:\n    similar(!Matched::Array{T,1},\
    \ ::Type) where T at array.jl:358\n    similar(!Matched::Array{T,2}, ::Type) where\
    \ T at array.jl:359\n    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}})\
    \ where N at array.jl:361\n    ...\n  Stacktrace:\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\n \
    \  [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmp09dh96kw.jl:27\n   [5] iterate at ./generator.jl:47 [inlined]\n\
    \   [6] _collect at ./array.jl:678 [inlined]\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\n   [8] map at ./abstractarray.jl:2072 [inlined]\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmp09dh96kw.jl:27\n   [10] top-level scope at /tmp/tmp09dh96kw.jl:35\n\
    \   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [12] top-level scope at /tmp/tmp09dh96kw.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmp09dh96kw.jl:37\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: no method matching similar(::String, ::Type{Any})\n\
    \  Closest candidates are:\n    similar(!Matched::Array{T,1}, ::Type) where T\
    \ at array.jl:358\n    similar(!Matched::Array{T,2}, ::Type) where T at array.jl:359\n\
    \    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}}) where\
    \ N at array.jl:361\n    ...\n  Stacktrace:\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\n \
    \  [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmp09dh96kw.jl:27\n   [5] iterate at ./generator.jl:47 [inlined]\n\
    \   [6] _collect at ./array.jl:678 [inlined]\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\n   [8] map at ./abstractarray.jl:2072 [inlined]\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmp09dh96kw.jl:27\n   [10] top-level scope at /tmp/tmp09dh96kw.jl:37\n\
    \   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [12] top-level scope at /tmp/tmp09dh96kw.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmp09dh96kw.jl:38\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: no method matching\
    \ similar(::String, ::Type{Any})\n  Closest candidates are:\n    similar(!Matched::Array{T,1},\
    \ ::Type) where T at array.jl:358\n    similar(!Matched::Array{T,2}, ::Type) where\
    \ T at array.jl:359\n    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}})\
    \ where N at array.jl:361\n    ...\n  Stacktrace:\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\n \
    \  [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmp09dh96kw.jl:27\n   [5] iterate at ./generator.jl:47 [inlined]\n\
    \   [6] _collect at ./array.jl:678 [inlined]\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\n   [8] map at ./abstractarray.jl:2072 [inlined]\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmp09dh96kw.jl:27\n   [10] top-level scope at /tmp/tmp09dh96kw.jl:38\n\
    \   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [12] top-level scope at /tmp/tmp09dh96kw.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmp09dh96kw.jl:39\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: no method matching\
    \ similar(::String, ::Type{Any})\n  Closest candidates are:\n    similar(!Matched::Array{T,1},\
    \ ::Type) where T at array.jl:358\n    similar(!Matched::Array{T,2}, ::Type) where\
    \ T at array.jl:359\n    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}})\
    \ where N at array.jl:361\n    ...\n  Stacktrace:\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\n \
    \  [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmp09dh96kw.jl:27\n   [5] iterate at ./generator.jl:47 [inlined]\n\
    \   [6] _collect at ./array.jl:678 [inlined]\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\n   [8] map at ./abstractarray.jl:2072 [inlined]\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmp09dh96kw.jl:27\n   [10] top-level scope at /tmp/tmp09dh96kw.jl:39\n\
    \   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [12] top-level scope at /tmp/tmp09dh96kw.jl:34\n  \nTest Summary: | Pass \
    \ Error  Total\ntest set      |    1      4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp09dh96kw.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    arr = sort(arr)\n    arr\
    \ = reverse(arr)\n    arr = [string(i) for i in arr]\n    return arr\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2, 1, 1,\
    \ 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpvoqy4vdm.jl:33\n  Expression: candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"]\n   Evaluated: [\"8\", \"5\", \"4\", \"3\", \"2\"\
    , \"2\", \"1\", \"1\"] == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\",\
    \ \"Two\", \"One\", \"One\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpvoqy4vdm.jl:33\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvoqy4vdm.jl:32\ntest set: Test Failed at /tmp/tmpvoqy4vdm.jl:35\n\
    \  Expression: candidate([1, -1, 55]) == [\"One\"]\n   Evaluated: [\"55\", \"\
    1\", \"-1\"] == [\"One\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpvoqy4vdm.jl:35\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvoqy4vdm.jl:32\ntest set: Test Failed at /tmp/tmpvoqy4vdm.jl:36\n\
    \  Expression: candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n   Evaluated:\
    \ [\"3\", \"2\", \"1\", \"-1\"] == [\"Three\", \"Two\", \"One\"]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpvoqy4vdm.jl:36\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvoqy4vdm.jl:32\ntest set: Test Failed at /tmp/tmpvoqy4vdm.jl:37\n\
    \  Expression: candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n   Evaluated:\
    \ [\"9\", \"8\", \"4\"] == [\"Nine\", \"Eight\", \"Four\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpvoqy4vdm.jl:37\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvoqy4vdm.jl:32\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpvoqy4vdm.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # replace each digit by its corresponding\
    \ name from \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\"\n    # if the array is empty, return an empty array\n  \
    \  if length(arr) == 0\n        return []\n    end\n    # if the array has any\
    \ strange number ignore it\n    if arr[1] < 1 || arr[1] > 9\n        return []\n\
    \    end\n    # create a dictionary\n    d = Dict(1 => \"One\", 2 => \"Two\",\
    \ 3 => \"Three\", 4 => \"Four\", 5 => \"Five\", 6 => \"Six\", 7 => \"Seven\",\
    \ 8 => \"Eight\", 9 => \"Nine\")\n    # create a new array\n    new_arr = []\n\
    \    # loop through the array\n    for i in arr\n        # if the number is between\
    \ 1 and 9 inclusive, append the corresponding name to the new array\n        if\
    \ i >= 1 && i <= 9\n            push!(new_arr, d[i])\n        end\n    end\n \
    \   # return the new array\n    return new_arr\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpv42gj4ry.jl:57\\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\\n   Evaluated: String[] == [\"One\"]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpv42gj4ry.jl:57\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpv42gj4ry.jl:54\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    4     1      5\\n'"
  stderr: "b'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\\nin expression starting at /tmp/tmpv42gj4ry.jl:52\\n'"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    #\
    \ reverse the array\n    # replace each digit by its corresponding name from \"\
    One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\",\
    \ \"Nine\"\n    # return the array\n    return [\"One\"]\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8,\
    \ 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\"\
    , \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\t@test(candidate([1,\
    \ -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2]) == [\"Three\", \"Two\"\
    , \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpny3g0pwf.jl:34\n  Expression: candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"]\n   Evaluated: [\"One\"] == [\"Eight\", \"Five\"\
    , \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpny3g0pwf.jl:34\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpny3g0pwf.jl:33\ntest set: Test Failed at /tmp/tmpny3g0pwf.jl:35\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{String}([])\n   Evaluated:\
    \ [\"One\"] == String[]\nStacktrace:\n [1] top-level scope at /tmp/tmpny3g0pwf.jl:35\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpny3g0pwf.jl:33\ntest set: Test Failed at /tmp/tmpny3g0pwf.jl:37\n\
    \  Expression: candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n   Evaluated:\
    \ [\"One\"] == [\"Three\", \"Two\", \"One\"]\nStacktrace:\n [1] top-level scope\
    \ at /tmp/tmpny3g0pwf.jl:37\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpny3g0pwf.jl:33\ntest set: Test Failed at /tmp/tmpny3g0pwf.jl:38\n\
    \  Expression: candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n   Evaluated:\
    \ [\"One\"] == [\"Nine\", \"Eight\", \"Four\"]\nStacktrace:\n [1] top-level scope\
    \ at /tmp/tmpny3g0pwf.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpny3g0pwf.jl:33\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpny3g0pwf.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # replace each digit by its corresponding\
    \ name from \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\"\n    for i in 1:length(arr)\n        if arr[i] == 1\n  \
    \          arr[i] = \"One\"\n        elseif arr[i] == 2\n            arr[i] =\
    \ \"Two\"\n        elseif arr[i] == 3\n            arr[i] = \"Three\"\n      \
    \  elseif arr[i] == 4\n            arr[i] = \"Four\"\n        elseif arr[i] ==\
    \ 5\n            arr[i] = \"Five\"\n        elseif arr[i] == 6\n            arr[i]\
    \ = \"Six\"\n        elseif arr[i] == 7\n            arr[i] = \"Seven\"\n    \
    \    elseif arr[i] == 8\n            arr[i] = \"Eight\"\n        elseif arr[i]\
    \ == 9\n            arr[i] = \"Nine\"\n        end\n    end\n    # return the\
    \ array\n    return arr\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\
    \t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\"\
    , \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpcxx3ftrs.jl:57\\n  Test threw\
    \ exception\\n  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\\n  MethodError:\
    \ Cannot `convert` an object of type String to an object of type Int64\\n  Closest\
    \ candidates are:\\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\\\
    n    convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\\n  \
    \  convert(::Type{T}, !Matched::Ptr) where T<:Integer at pointer.jl:23\\n    ...\\\
    n  Stacktrace:\\n   [1] setindex!(::Array{Int64,1}, ::String, ::Int64) at ./array.jl:826\\\
    n   [2] by_length(::Array{Int64,1}) at /tmp/tmpcxx3ftrs.jl:44\\n   [3] top-level\
    \ scope at /tmp/tmpcxx3ftrs.jl:57\\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmpcxx3ftrs.jl:56\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpcxx3ftrs.jl:59\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\\n  MethodError: Cannot `convert` an object of type String\
    \ to an object of type Int64\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpcxx3ftrs.jl:30\\n   [3] top-level scope at /tmp/tmpcxx3ftrs.jl:59\\\
    n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmpcxx3ftrs.jl:56\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpcxx3ftrs.jl:60\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\\n  MethodError: Cannot `convert`\
    \ an object of type String to an object of type Int64\\n  Closest candidates are:\\\
    n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpcxx3ftrs.jl:34\\n   [3] top-level scope at /tmp/tmpcxx3ftrs.jl:60\\\
    n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmpcxx3ftrs.jl:56\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpcxx3ftrs.jl:61\\n  Test threw exception\\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\\n  MethodError: Cannot `convert`\
    \ an object of type String to an object of type Int64\\n  Closest candidates are:\\\
    n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpcxx3ftrs.jl:46\\n   [3] top-level scope at /tmp/tmpcxx3ftrs.jl:61\\\
    n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmpcxx3ftrs.jl:56\\n  \\nTest Summary: | Pass\
    \  Error  Total\\ntest set      |    1      4      5\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # replace each digit by its corresponding\
    \ name\n    for i in 1:length(arr)\n        if arr[i] == 1\n            arr[i]\
    \ = \"One\"\n        elseif arr[i] == 2\n            arr[i] = \"Two\"\n      \
    \  elseif arr[i] == 3\n            arr[i] = \"Three\"\n        elseif arr[i] ==\
    \ 4\n            arr[i] = \"Four\"\n        elseif arr[i] == 5\n            arr[i]\
    \ = \"Five\"\n        elseif arr[i] == 6\n            arr[i] = \"Six\"\n     \
    \   elseif arr[i] == 7\n            arr[i] = \"Seven\"\n        elseif arr[i]\
    \ == 8\n            arr[i] = \"Eight\"\n        elseif arr[i] == 9\n         \
    \   arr[i] = \"Nine\"\n        end\n    end\n    # return the array\n    return\
    \ arr\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpsvq8qzcl.jl:57\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: Cannot\
    \ `convert` an object of type String to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] setindex!(::Array{Int64,1}, ::String, ::Int64) at ./array.jl:826\n   [2]\
    \ by_length(::Array{Int64,1}) at /tmp/tmpsvq8qzcl.jl:44\n   [3] top-level scope\
    \ at /tmp/tmpsvq8qzcl.jl:57\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpsvq8qzcl.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmpsvq8qzcl.jl:59\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: Cannot `convert` an object of type String\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpsvq8qzcl.jl:30\n   [3] top-level scope at /tmp/tmpsvq8qzcl.jl:59\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpsvq8qzcl.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmpsvq8qzcl.jl:60\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: Cannot `convert`\
    \ an object of type String to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpsvq8qzcl.jl:34\n   [3] top-level scope at /tmp/tmpsvq8qzcl.jl:60\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpsvq8qzcl.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmpsvq8qzcl.jl:61\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: Cannot `convert` an\
    \ object of type String to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpsvq8qzcl.jl:46\n   [3] top-level scope at /tmp/tmpsvq8qzcl.jl:61\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpsvq8qzcl.jl:56\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    1      4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpsvq8qzcl.jl:54\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # replace each digit by its corresponding\
    \ name from \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\"\n    for i in 1:length(arr)\n        if arr[i] == 1\n  \
    \          arr[i] = \"One\"\n        elseif arr[i] == 2\n            arr[i] =\
    \ \"Two\"\n        elseif arr[i] == 3\n            arr[i] = \"Three\"\n      \
    \  elseif arr[i] == 4\n            arr[i] = \"Four\"\n        elseif arr[i] ==\
    \ 5\n            arr[i] = \"Five\"\n        elseif arr[i] == 6\n            arr[i]\
    \ = \"Six\"\n        elseif arr[i] == 7\n            arr[i] = \"Seven\"\n    \
    \    elseif arr[i] == 8\n            arr[i] = \"Eight\"\n        elseif arr[i]\
    \ == 9\n            arr[i] = \"Nine\"\n        end\n    end\n    # return the\
    \ array\n    return arr\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\
    \t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\"\
    , \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpqd8pm3im.jl:57\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: Cannot\
    \ `convert` an object of type String to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] setindex!(::Array{Int64,1}, ::String, ::Int64) at ./array.jl:826\n   [2]\
    \ by_length(::Array{Int64,1}) at /tmp/tmpqd8pm3im.jl:44\n   [3] top-level scope\
    \ at /tmp/tmpqd8pm3im.jl:57\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpqd8pm3im.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmpqd8pm3im.jl:59\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: Cannot `convert` an object of type String\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpqd8pm3im.jl:30\n   [3] top-level scope at /tmp/tmpqd8pm3im.jl:59\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpqd8pm3im.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmpqd8pm3im.jl:60\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: Cannot `convert`\
    \ an object of type String to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpqd8pm3im.jl:34\n   [3] top-level scope at /tmp/tmpqd8pm3im.jl:60\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpqd8pm3im.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmpqd8pm3im.jl:61\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: Cannot `convert` an\
    \ object of type String to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpqd8pm3im.jl:46\n   [3] top-level scope at /tmp/tmpqd8pm3im.jl:61\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpqd8pm3im.jl:56\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    1      4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqd8pm3im.jl:54\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    arr\
    \ = sort(arr)\n    # reverse the array\n    arr = reverse(arr)\n    # create a\
    \ dictionary\n    d = Dict(1 => \"One\", 2 => \"Two\", 3 => \"Three\", 4 => \"\
    Four\", 5 => \"Five\", 6 => \"Six\", 7 => \"Seven\", 8 => \"Eight\", 9 => \"Nine\"\
    )\n    # create an empty array\n    arr_new = []\n    # iterate through the array\n\
    \    for i in arr\n        # if the number is in the dictionary\n        if haskey(d,\
    \ i)\n            # append the value to the new array\n            push!(arr_new,\
    \ d[i])\n        end\n    end\n    # return the new array\n    return arr_new\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    #\
    \ reverse the array\n    # replace each digit by its corresponding name from \"\
    One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\",\
    \ \"Nine\"\n    # return the resulting array\n    # if the array is empty, return\
    \ an empty array\n    # if the array has any strange number ignore it\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2, 1, 1,\
    \ 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpi75s94n6.jl:35\\n  Test threw\
    \ exception\\n  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{String,1}\\\
    n  Closest candidates are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] by_length(::Array{Int64,1}) at /tmp/tmpi75s94n6.jl:29\\\
    n   [2] top-level scope at /tmp/tmpi75s94n6.jl:35\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpi75s94n6.jl:34\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpi75s94n6.jl:36\\n  Test threw exception\\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{String}([])\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\\n  Closest candidates are:\\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] by_length(::Array{Int64,1}) at /tmp/tmpi75s94n6.jl:29\\\
    n   [2] top-level scope at /tmp/tmpi75s94n6.jl:36\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpi75s94n6.jl:34\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpi75s94n6.jl:37\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\\n  Closest candidates are:\\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] by_length(::Array{Int64,1}) at /tmp/tmpi75s94n6.jl:29\\\
    n   [2] top-level scope at /tmp/tmpi75s94n6.jl:37\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpi75s94n6.jl:34\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpi75s94n6.jl:38\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{String,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] by_length(::Array{Int64,1}) at /tmp/tmpi75s94n6.jl:29\\\
    n   [2] top-level scope at /tmp/tmpi75s94n6.jl:38\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpi75s94n6.jl:34\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpi75s94n6.jl:39\\n  Test threw exception\\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{String,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] by_length(::Array{Int64,1}) at /tmp/tmpi75s94n6.jl:29\\\
    n   [2] top-level scope at /tmp/tmpi75s94n6.jl:39\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpi75s94n6.jl:34\\n  \\nTest Summary: | Error\
    \  Total\\ntest set      |     5      5\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # replace each digit by its corresponding\
    \ name from \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\"\n    for i in 1:length(arr)\n        if arr[i] == 1\n  \
    \          arr[i] = \"One\"\n        elseif arr[i] == 2\n            arr[i] =\
    \ \"Two\"\n        elseif arr[i] == 3\n            arr[i] = \"Three\"\n      \
    \  elseif arr[i] == 4\n            arr[i] = \"Four\"\n        elseif arr[i] ==\
    \ 5\n            arr[i] = \"Five\"\n        elseif arr[i] == 6\n            arr[i]\
    \ = \"Six\"\n        elseif arr[i] == 7\n            arr[i] = \"Seven\"\n    \
    \    elseif arr[i] == 8\n            arr[i] = \"Eight\"\n        elseif arr[i]\
    \ == 9\n            arr[i] = \"Nine\"\n        end\n    end\n    # return the\
    \ array\n    return arr\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\
    \t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\"\
    , \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp5h169ekt.jl:57\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: Cannot\
    \ `convert` an object of type String to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] setindex!(::Array{Int64,1}, ::String, ::Int64) at ./array.jl:826\n   [2]\
    \ by_length(::Array{Int64,1}) at /tmp/tmp5h169ekt.jl:44\n   [3] top-level scope\
    \ at /tmp/tmp5h169ekt.jl:57\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp5h169ekt.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmp5h169ekt.jl:59\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: Cannot `convert` an object of type String\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmp5h169ekt.jl:30\n   [3] top-level scope at /tmp/tmp5h169ekt.jl:59\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp5h169ekt.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmp5h169ekt.jl:60\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: Cannot `convert`\
    \ an object of type String to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmp5h169ekt.jl:34\n   [3] top-level scope at /tmp/tmp5h169ekt.jl:60\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp5h169ekt.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmp5h169ekt.jl:61\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: Cannot `convert` an\
    \ object of type String to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmp5h169ekt.jl:46\n   [3] top-level scope at /tmp/tmp5h169ekt.jl:61\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp5h169ekt.jl:56\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    1      4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5h169ekt.jl:54\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # create a vector of strings\n\
    \    v = Vector{String}(undef, length(arr))\n    # iterate over the array\n  \
    \  for i in 1:length(arr)\n        # if the number is between 1 and 9 inclusive\n\
    \        if arr[i] >= 1 && arr[i] <= 9\n            # replace the number with\
    \ its corresponding name\n            if arr[i] == 1\n                v[i] = \"\
    One\"\n            elseif arr[i] == 2\n                v[i] = \"Two\"\n      \
    \      elseif arr[i] == 3\n                v[i] = \"Three\"\n            elseif\
    \ arr[i] == 4\n                v[i] = \"Four\"\n            elseif arr[i] == 5\n\
    \                v[i] = \"Five\"\n            elseif arr[i] == 6\n           \
    \     v[i] = \"Six\"\n            elseif arr[i] == 7\n                v[i] = \"\
    Seven\"\n            elseif arr[i] == 8\n                v[i] = \"Eight\"\n  \
    \          elseif arr[i] == 9\n                v[i] = \"Nine\"\n            end\n\
    \        end\n    end\n    # return the vector of strings\n    return v\nend\n\
    using Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp8dtsb7ds.jl:65\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n   Evaluated: [#undef, \"One\", #undef] == [\"One\"]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp8dtsb7ds.jl:65\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8dtsb7ds.jl:62\ntest set: Test Failed at /tmp/tmp8dtsb7ds.jl:66\n\
    \  Expression: candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n   Evaluated:\
    \ [\"Three\", \"Two\", \"One\", #undef] == [\"Three\", \"Two\", \"One\"]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp8dtsb7ds.jl:66\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8dtsb7ds.jl:62\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8dtsb7ds.jl:60\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    #\
    \ reverse the array\n    # replace each digit by its corresponding name from \"\
    One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\",\
    \ \"Nine\"\n    # return the result\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"\
    Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmphbgzl76n.jl:33\\n  Test threw\
    \ exception\\n  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{String,1}\\\
    n  Closest candidates are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] by_length(::Array{Int64,1}) at /tmp/tmphbgzl76n.jl:27\\\
    n   [2] top-level scope at /tmp/tmphbgzl76n.jl:33\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmphbgzl76n.jl:32\\n  \\ntest set: Error During\
    \ Test at /tmp/tmphbgzl76n.jl:34\\n  Test threw exception\\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{String}([])\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\\n  Closest candidates are:\\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] by_length(::Array{Int64,1}) at /tmp/tmphbgzl76n.jl:27\\\
    n   [2] top-level scope at /tmp/tmphbgzl76n.jl:34\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmphbgzl76n.jl:32\\n  \\ntest set: Error During\
    \ Test at /tmp/tmphbgzl76n.jl:35\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\\n  Closest candidates are:\\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] by_length(::Array{Int64,1}) at /tmp/tmphbgzl76n.jl:27\\\
    n   [2] top-level scope at /tmp/tmphbgzl76n.jl:35\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmphbgzl76n.jl:32\\n  \\ntest set: Error During\
    \ Test at /tmp/tmphbgzl76n.jl:36\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{String,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] by_length(::Array{Int64,1}) at /tmp/tmphbgzl76n.jl:27\\\
    n   [2] top-level scope at /tmp/tmphbgzl76n.jl:36\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmphbgzl76n.jl:32\\n  \\ntest set: Error During\
    \ Test at /tmp/tmphbgzl76n.jl:37\\n  Test threw exception\\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{String,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] by_length(::Array{Int64,1}) at /tmp/tmphbgzl76n.jl:27\\\
    n   [2] top-level scope at /tmp/tmphbgzl76n.jl:37\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmphbgzl76n.jl:32\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # create a dictionary\n    dict\
    \ = Dict(\"One\" => 1, \"Two\" => 2, \"Three\" => 3, \"Four\" => 4, \"Five\" =>\
    \ 5, \"Six\" => 6, \"Seven\" => 7, \"Eight\" => 8, \"Nine\" => 9)\n    # create\
    \ an empty array\n    arr_str = []\n    # loop over the array\n    for i in arr\n\
    \        # check if the number is between 1 and 9\n        if i in 1:9\n     \
    \       # append the corresponding name to the empty array\n            push!(arr_str,\
    \ get(dict, i, 0))\n        end\n    end\n    # return the array\n    return arr_str\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp3mkksvu1.jl:47\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: Cannot\
    \ `convert` an object of type Int64 to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] setindex!(::Array{String,1}, ::Int64, ::Int64) at ./array.jl:826\n   [2]\
    \ copyto!(::Array{String,1}, ::Array{Any,1}) at ./multidimensional.jl:962\n  \
    \ [3] Array at ./array.jl:541 [inlined]\n   [4] convert at ./array.jl:533 [inlined]\n\
    \   [5] by_length(::Array{Int64,1}) at /tmp/tmp3mkksvu1.jl:40\n   [6] top-level\
    \ scope at /tmp/tmp3mkksvu1.jl:47\n   [7] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [8] top-level scope at /tmp/tmp3mkksvu1.jl:46\n  \ntest set: Error During\
    \ Test at /tmp/tmp3mkksvu1.jl:49\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: Cannot `convert` an object of type Int64\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] setindex!(::Array{String,1}, ::Int64, ::Int64) at ./array.jl:826\n   [2]\
    \ copyto!(::Array{String,1}, ::Array{Any,1}) at ./multidimensional.jl:962\n  \
    \ [3] Array at ./array.jl:541 [inlined]\n   [4] convert at ./array.jl:533 [inlined]\n\
    \   [5] by_length(::Array{Int64,1}) at /tmp/tmp3mkksvu1.jl:40\n   [6] top-level\
    \ scope at /tmp/tmp3mkksvu1.jl:49\n   [7] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [8] top-level scope at /tmp/tmp3mkksvu1.jl:46\n  \ntest set: Error During\
    \ Test at /tmp/tmp3mkksvu1.jl:50\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: Cannot `convert`\
    \ an object of type Int64 to an object of type String\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] setindex!(::Array{String,1}, ::Int64, ::Int64) at ./array.jl:826\n   [2]\
    \ copyto!(::Array{String,1}, ::Array{Any,1}) at ./multidimensional.jl:962\n  \
    \ [3] Array at ./array.jl:541 [inlined]\n   [4] convert at ./array.jl:533 [inlined]\n\
    \   [5] by_length(::Array{Int64,1}) at /tmp/tmp3mkksvu1.jl:40\n   [6] top-level\
    \ scope at /tmp/tmp3mkksvu1.jl:50\n   [7] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [8] top-level scope at /tmp/tmp3mkksvu1.jl:46\n  \ntest set: Error During\
    \ Test at /tmp/tmp3mkksvu1.jl:51\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: Cannot `convert` an\
    \ object of type Int64 to an object of type String\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] setindex!(::Array{String,1}, ::Int64, ::Int64) at ./array.jl:826\n   [2]\
    \ copyto!(::Array{String,1}, ::Array{Any,1}) at ./multidimensional.jl:962\n  \
    \ [3] Array at ./array.jl:541 [inlined]\n   [4] convert at ./array.jl:533 [inlined]\n\
    \   [5] by_length(::Array{Int64,1}) at /tmp/tmp3mkksvu1.jl:40\n   [6] top-level\
    \ scope at /tmp/tmp3mkksvu1.jl:51\n   [7] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [8] top-level scope at /tmp/tmp3mkksvu1.jl:46\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    1      4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3mkksvu1.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # replace each digit by its corresponding\
    \ name from \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\"\n    for i in arr\n        if i == 1\n            arr[i]\
    \ = \"One\"\n        elseif i == 2\n            arr[i] = \"Two\"\n        elseif\
    \ i == 3\n            arr[i] = \"Three\"\n        elseif i == 4\n            arr[i]\
    \ = \"Four\"\n        elseif i == 5\n            arr[i] = \"Five\"\n        elseif\
    \ i == 6\n            arr[i] = \"Six\"\n        elseif i == 7\n            arr[i]\
    \ = \"Seven\"\n        elseif i == 8\n            arr[i] = \"Eight\"\n       \
    \ elseif i == 9\n            arr[i] = \"Nine\"\n        end\n    end\n    return\
    \ arr\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpq5qc6yrx.jl:56\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: Cannot\
    \ `convert` an object of type String to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] setindex!(::Array{Int64,1}, ::String, ::Int64) at ./array.jl:826\n   [2]\
    \ by_length(::Array{Int64,1}) at /tmp/tmpq5qc6yrx.jl:44\n   [3] top-level scope\
    \ at /tmp/tmpq5qc6yrx.jl:56\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpq5qc6yrx.jl:55\n  \ntest set: Error During\
    \ Test at /tmp/tmpq5qc6yrx.jl:58\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: Cannot `convert` an object of type String\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpq5qc6yrx.jl:30\n   [3] top-level scope at /tmp/tmpq5qc6yrx.jl:58\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpq5qc6yrx.jl:55\n  \ntest set: Error During\
    \ Test at /tmp/tmpq5qc6yrx.jl:59\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: Cannot `convert`\
    \ an object of type String to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpq5qc6yrx.jl:34\n   [3] top-level scope at /tmp/tmpq5qc6yrx.jl:59\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpq5qc6yrx.jl:55\n  \ntest set: Error During\
    \ Test at /tmp/tmpq5qc6yrx.jl:60\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: Cannot `convert` an\
    \ object of type String to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpq5qc6yrx.jl:46\n   [3] top-level scope at /tmp/tmpq5qc6yrx.jl:60\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpq5qc6yrx.jl:55\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    1      4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpq5qc6yrx.jl:53\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    #\
    \ reverse the array\n    # replace each digit by its corresponding name\n    #\
    \ return the array\n    return arr\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"\
    Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpkbf80f7y.jl:34\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: Cannot\
    \ `convert` an object of type Int64 to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] setindex!(::Array{String,1}, ::Int64, ::Int64) at ./array.jl:826\n   [2]\
    \ copyto! at ./multidimensional.jl:962 [inlined]\n   [3] Array{String,1}(::Array{Int64,1})\
    \ at ./array.jl:541\n   [4] convert at ./array.jl:533 [inlined]\n   [5] by_length(::Array{Int64,1})\
    \ at /tmp/tmpkbf80f7y.jl:27\n   [6] top-level scope at /tmp/tmpkbf80f7y.jl:34\n\
    \   [7] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [8] top-level scope at /tmp/tmpkbf80f7y.jl:33\n  \ntest set: Error During\
    \ Test at /tmp/tmpkbf80f7y.jl:36\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: Cannot `convert` an object of type Int64\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] setindex!(::Array{String,1}, ::Int64, ::Int64) at ./array.jl:826\n   [2]\
    \ copyto! at ./multidimensional.jl:962 [inlined]\n   [3] Array{String,1}(::Array{Int64,1})\
    \ at ./array.jl:541\n   [4] convert at ./array.jl:533 [inlined]\n   [5] by_length(::Array{Int64,1})\
    \ at /tmp/tmpkbf80f7y.jl:27\n   [6] top-level scope at /tmp/tmpkbf80f7y.jl:36\n\
    \   [7] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [8] top-level scope at /tmp/tmpkbf80f7y.jl:33\n  \ntest set: Error During\
    \ Test at /tmp/tmpkbf80f7y.jl:37\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: Cannot `convert`\
    \ an object of type Int64 to an object of type String\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] setindex!(::Array{String,1}, ::Int64, ::Int64) at ./array.jl:826\n   [2]\
    \ copyto! at ./multidimensional.jl:962 [inlined]\n   [3] Array{String,1}(::Array{Int64,1})\
    \ at ./array.jl:541\n   [4] convert at ./array.jl:533 [inlined]\n   [5] by_length(::Array{Int64,1})\
    \ at /tmp/tmpkbf80f7y.jl:27\n   [6] top-level scope at /tmp/tmpkbf80f7y.jl:37\n\
    \   [7] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [8] top-level scope at /tmp/tmpkbf80f7y.jl:33\n  \ntest set: Error During\
    \ Test at /tmp/tmpkbf80f7y.jl:38\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: Cannot `convert` an\
    \ object of type Int64 to an object of type String\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] setindex!(::Array{String,1}, ::Int64, ::Int64) at ./array.jl:826\n   [2]\
    \ copyto! at ./multidimensional.jl:962 [inlined]\n   [3] Array{String,1}(::Array{Int64,1})\
    \ at ./array.jl:541\n   [4] convert at ./array.jl:533 [inlined]\n   [5] by_length(::Array{Int64,1})\
    \ at /tmp/tmpkbf80f7y.jl:27\n   [6] top-level scope at /tmp/tmpkbf80f7y.jl:38\n\
    \   [7] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [8] top-level scope at /tmp/tmpkbf80f7y.jl:33\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    1      4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpkbf80f7y.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sorted_arr\
    \ = sort(arr)\n    # reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # replace each digit by its corresponding name\n    result = []\n    for\
    \ i in reversed_arr\n        if i == 1\n            push!(result, \"One\")\n \
    \       elseif i == 2\n            push!(result, \"Two\")\n        elseif i ==\
    \ 3\n            push!(result, \"Three\")\n        elseif i == 4\n           \
    \ push!(result, \"Four\")\n        elseif i == 5\n            push!(result, \"\
    Five\")\n        elseif i == 6\n            push!(result, \"Six\")\n        elseif\
    \ i == 7\n            push!(result, \"Seven\")\n        elseif i == 8\n      \
    \      push!(result, \"Eight\")\n        elseif i == 9\n            push!(result,\
    \ \"Nine\")\n        end\n    end\n    return result\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3])\
    \ == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"\
    One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\t@test(candidate([1,\
    \ -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2]) == [\"Three\", \"Two\"\
    , \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # create a dictionary with the\
    \ numbers and their names\n    d = Dict(1 => \"One\", 2 => \"Two\", 3 => \"Three\"\
    , 4 => \"Four\", 5 => \"Five\", 6 => \"Six\", 7 => \"Seven\", 8 => \"Eight\",\
    \ 9 => \"Nine\")\n    # create an empty array\n    arr_names = []\n    # iterate\
    \ over the array\n    for i in arr\n        # if the number is in the dictionary,\
    \ add it to the array\n        if i in keys(d)\n            push!(arr_names, d[i])\n\
    \        end\n    end\n    # return the array\n    return arr_names\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2, 1, 1,\
    \ 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # Your code here\n    return\
    \ []\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp5ju4pqpm.jl:31\n  Expression: candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"]\n   Evaluated: String[] == [\"Eight\", \"Five\",\
    \ \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp5ju4pqpm.jl:31\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5ju4pqpm.jl:30\ntest set: Test Failed at /tmp/tmp5ju4pqpm.jl:33\n\
    \  Expression: candidate([1, -1, 55]) == [\"One\"]\n   Evaluated: String[] ==\
    \ [\"One\"]\nStacktrace:\n [1] top-level scope at /tmp/tmp5ju4pqpm.jl:33\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5ju4pqpm.jl:30\ntest set: Test Failed at /tmp/tmp5ju4pqpm.jl:34\n\
    \  Expression: candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n   Evaluated:\
    \ String[] == [\"Three\", \"Two\", \"One\"]\nStacktrace:\n [1] top-level scope\
    \ at /tmp/tmp5ju4pqpm.jl:34\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5ju4pqpm.jl:30\ntest set: Test Failed at /tmp/tmp5ju4pqpm.jl:35\n\
    \  Expression: candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n   Evaluated:\
    \ String[] == [\"Nine\", \"Eight\", \"Four\"]\nStacktrace:\n [1] top-level scope\
    \ at /tmp/tmp5ju4pqpm.jl:35\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5ju4pqpm.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5ju4pqpm.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # create a dictionary\n    dict\
    \ = Dict(\"One\" => 1, \"Two\" => 2, \"Three\" => 3, \"Four\" => 4, \"Five\" =>\
    \ 5, \"Six\" => 6, \"Seven\" => 7, \"Eight\" => 8, \"Nine\" => 9)\n    # create\
    \ a new array\n    new_arr = []\n    # iterate through the array\n    for i in\
    \ arr\n        # if the number is between 1 and 9 inclusive\n        if 1 <= i\
    \ <= 9\n            # append the corresponding name to the new array\n       \
    \     push!(new_arr, get(dict, i, \"None\"))\n        end\n    end\n    # return\
    \ the new array\n    return new_arr\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"\
    Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpja9s0p9b.jl:47\n  Expression: candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"]\n   Evaluated: [\"None\", \"None\", \"None\", \"\
    None\", \"None\", \"None\", \"None\", \"None\"] == [\"Eight\", \"Five\", \"Four\"\
    , \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpja9s0p9b.jl:47\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpja9s0p9b.jl:46\ntest set: Test Failed at /tmp/tmpja9s0p9b.jl:49\n\
    \  Expression: candidate([1, -1, 55]) == [\"One\"]\n   Evaluated: [\"None\"] ==\
    \ [\"One\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpja9s0p9b.jl:49\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpja9s0p9b.jl:46\ntest set: Test Failed at /tmp/tmpja9s0p9b.jl:50\n\
    \  Expression: candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n   Evaluated:\
    \ [\"None\", \"None\", \"None\"] == [\"Three\", \"Two\", \"One\"]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpja9s0p9b.jl:50\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpja9s0p9b.jl:46\ntest set: Test Failed at /tmp/tmpja9s0p9b.jl:51\n\
    \  Expression: candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n   Evaluated:\
    \ [\"None\", \"None\", \"None\"] == [\"Nine\", \"Eight\", \"Four\"]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpja9s0p9b.jl:51\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpja9s0p9b.jl:46\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpja9s0p9b.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sorted_arr\
    \ = sort(arr)\n    # reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # replace each digit by its corresponding name from \"One\", \"Two\", \"\
    Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\n    # create\
    \ a dictionary to map the numbers to their names\n    num_to_name = Dict(1 =>\
    \ \"One\", 2 => \"Two\", 3 => \"Three\", 4 => \"Four\", 5 => \"Five\", 6 => \"\
    Six\", 7 => \"Seven\", 8 => \"Eight\", 9 => \"Nine\")\n    # create an empty array\
    \ to store the names\n    names = []\n    # loop through the reversed array\n\
    \    for i in reversed_arr\n        # if the number is between 1 and 9 inclusive,\
    \ add the name to the names array\n        if i in keys(num_to_name)\n       \
    \     push!(names, num_to_name[i])\n        end\n    end\n    # return the names\
    \ array\n    return names\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\
    \t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\"\
    , \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    arr = sort(arr)\n    arr\
    \ = reverse(arr)\n    arr = filter(x -> x in 1:9, arr)\n    arr = map(x -> string(x),\
    \ arr)\n    arr = map(x -> replace(x, \"1\" => \"One\", \"2\" => \"Two\", \"3\"\
    \ => \"Three\", \"4\" => \"Four\", \"5\" => \"Five\", \"6\" => \"Six\", \"7\"\
    \ => \"Seven\", \"8\" => \"Eight\", \"9\" => \"Nine\"), arr)\n    return arr\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpzvvuzj5z.jl:35\\n  Test threw\
    \ exception\\n  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\\n  MethodError:\
    \ no method matching similar(::String, ::Type{Any})\\n  Closest candidates are:\\\
    n    similar(!Matched::Array{T,1}, ::Type) where T at array.jl:358\\n    similar(!Matched::Array{T,2},\
    \ ::Type) where T at array.jl:359\\n    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}})\
    \ where N at array.jl:361\\n    ...\\n  Stacktrace:\\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\\n\
    \   [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmpzvvuzj5z.jl:27\\n   [5] iterate at ./generator.jl:47 [inlined]\\\
    n   [6] _collect at ./array.jl:678 [inlined]\\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\\n   [8] map at ./abstractarray.jl:2072 [inlined]\\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmpzvvuzj5z.jl:27\\n   [10] top-level scope at /tmp/tmpzvvuzj5z.jl:35\\\
    n   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [12] top-level scope at /tmp/tmpzvvuzj5z.jl:34\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpzvvuzj5z.jl:37\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\\n  MethodError: no method matching similar(::String,\
    \ ::Type{Any})\\n  Closest candidates are:\\n    similar(!Matched::Array{T,1},\
    \ ::Type) where T at array.jl:358\\n    similar(!Matched::Array{T,2}, ::Type)\
    \ where T at array.jl:359\\n    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}})\
    \ where N at array.jl:361\\n    ...\\n  Stacktrace:\\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\\n\
    \   [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmpzvvuzj5z.jl:27\\n   [5] iterate at ./generator.jl:47 [inlined]\\\
    n   [6] _collect at ./array.jl:678 [inlined]\\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\\n   [8] map at ./abstractarray.jl:2072 [inlined]\\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmpzvvuzj5z.jl:27\\n   [10] top-level scope at /tmp/tmpzvvuzj5z.jl:37\\\
    n   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [12] top-level scope at /tmp/tmpzvvuzj5z.jl:34\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpzvvuzj5z.jl:38\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\\n  MethodError: no method matching\
    \ similar(::String, ::Type{Any})\\n  Closest candidates are:\\n    similar(!Matched::Array{T,1},\
    \ ::Type) where T at array.jl:358\\n    similar(!Matched::Array{T,2}, ::Type)\
    \ where T at array.jl:359\\n    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}})\
    \ where N at array.jl:361\\n    ...\\n  Stacktrace:\\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\\n\
    \   [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmpzvvuzj5z.jl:27\\n   [5] iterate at ./generator.jl:47 [inlined]\\\
    n   [6] _collect at ./array.jl:678 [inlined]\\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\\n   [8] map at ./abstractarray.jl:2072 [inlined]\\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmpzvvuzj5z.jl:27\\n   [10] top-level scope at /tmp/tmpzvvuzj5z.jl:38\\\
    n   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [12] top-level scope at /tmp/tmpzvvuzj5z.jl:34\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpzvvuzj5z.jl:39\\n  Test threw exception\\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\\n  MethodError: no method matching\
    \ similar(::String, ::Type{Any})\\n  Closest candidates are:\\n    similar(!Matched::Array{T,1},\
    \ ::Type) where T at array.jl:358\\n    similar(!Matched::Array{T,2}, ::Type)\
    \ where T at array.jl:359\\n    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}})\
    \ where N at array.jl:361\\n    ...\\n  Stacktrace:\\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\\n\
    \   [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmpzvvuzj5z.jl:27\\n   [5] iterate at ./generator.jl:47 [inlined]\\\
    n   [6] _collect at ./array.jl:678 [inlined]\\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\\n   [8] map at ./abstractarray.jl:2072 [inlined]\\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmpzvvuzj5z.jl:27\\n   [10] top-level scope at /tmp/tmpzvvuzj5z.jl:39\\\
    n   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [12] top-level scope at /tmp/tmpzvvuzj5z.jl:34\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sorted_arr\
    \ = sort(arr)\n    # reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # replace each digit by its corresponding name from \"One\", \"Two\", \"\
    Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\n    # create\
    \ a dictionary\n    d = Dict(\"1\" => \"One\", \"2\" => \"Two\", \"3\" => \"Three\"\
    , \"4\" => \"Four\", \"5\" => \"Five\", \"6\" => \"Six\", \"7\" => \"Seven\",\
    \ \"8\" => \"Eight\", \"9\" => \"Nine\")\n    # create an empty array\n    new_arr\
    \ = []\n    # loop through the array\n    for i in reversed_arr\n        # check\
    \ if the number is between 1 and 9\n        if i >= 1 && i <= 9\n            #\
    \ append the corresponding name to the new array\n            push!(new_arr, d[string(i)])\n\
    \        end\n    end\n    # return the new array\n    return new_arr\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2, 1, 1,\
    \ 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # replace each digit by its corresponding\
    \ name from \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\"\n    for i in 1:length(arr)\n        if arr[i] == 1\n  \
    \          arr[i] = \"One\"\n        elseif arr[i] == 2\n            arr[i] =\
    \ \"Two\"\n        elseif arr[i] == 3\n            arr[i] = \"Three\"\n      \
    \  elseif arr[i] == 4\n            arr[i] = \"Four\"\n        elseif arr[i] ==\
    \ 5\n            arr[i] = \"Five\"\n        elseif arr[i] == 6\n            arr[i]\
    \ = \"Six\"\n        elseif arr[i] == 7\n            arr[i] = \"Seven\"\n    \
    \    elseif arr[i] == 8\n            arr[i] = \"Eight\"\n        elseif arr[i]\
    \ == 9\n            arr[i] = \"Nine\"\n        end\n    end\n    # return the\
    \ array\n    return arr\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\
    \t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\"\
    , \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp1q0cgmkv.jl:57\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: Cannot\
    \ `convert` an object of type String to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] setindex!(::Array{Int64,1}, ::String, ::Int64) at ./array.jl:826\n   [2]\
    \ by_length(::Array{Int64,1}) at /tmp/tmp1q0cgmkv.jl:44\n   [3] top-level scope\
    \ at /tmp/tmp1q0cgmkv.jl:57\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp1q0cgmkv.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmp1q0cgmkv.jl:59\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: Cannot `convert` an object of type String\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmp1q0cgmkv.jl:30\n   [3] top-level scope at /tmp/tmp1q0cgmkv.jl:59\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp1q0cgmkv.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmp1q0cgmkv.jl:60\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: Cannot `convert`\
    \ an object of type String to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmp1q0cgmkv.jl:34\n   [3] top-level scope at /tmp/tmp1q0cgmkv.jl:60\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp1q0cgmkv.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmp1q0cgmkv.jl:61\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: Cannot `convert` an\
    \ object of type String to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmp1q0cgmkv.jl:46\n   [3] top-level scope at /tmp/tmp1q0cgmkv.jl:61\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp1q0cgmkv.jl:56\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    1      4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1q0cgmkv.jl:54\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    arr = sort(arr)\n    arr\
    \ = reverse(arr)\n    arr = filter(x -> x in 1:9, arr)\n    arr = map(x -> string(x),\
    \ arr)\n    arr = map(x -> replace(x, \"1\" => \"One\", \"2\" => \"Two\", \"3\"\
    \ => \"Three\", \"4\" => \"Four\", \"5\" => \"Five\", \"6\" => \"Six\", \"7\"\
    \ => \"Seven\", \"8\" => \"Eight\", \"9\" => \"Nine\"), arr)\n    return arr\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpbgaaxden.jl:35\\n  Test threw\
    \ exception\\n  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\\n  MethodError:\
    \ no method matching similar(::String, ::Type{Any})\\n  Closest candidates are:\\\
    n    similar(!Matched::Array{T,1}, ::Type) where T at array.jl:358\\n    similar(!Matched::Array{T,2},\
    \ ::Type) where T at array.jl:359\\n    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}})\
    \ where N at array.jl:361\\n    ...\\n  Stacktrace:\\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\\n\
    \   [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmpbgaaxden.jl:27\\n   [5] iterate at ./generator.jl:47 [inlined]\\\
    n   [6] _collect at ./array.jl:678 [inlined]\\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\\n   [8] map at ./abstractarray.jl:2072 [inlined]\\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmpbgaaxden.jl:27\\n   [10] top-level scope at /tmp/tmpbgaaxden.jl:35\\\
    n   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [12] top-level scope at /tmp/tmpbgaaxden.jl:34\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpbgaaxden.jl:37\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\\n  MethodError: no method matching similar(::String,\
    \ ::Type{Any})\\n  Closest candidates are:\\n    similar(!Matched::Array{T,1},\
    \ ::Type) where T at array.jl:358\\n    similar(!Matched::Array{T,2}, ::Type)\
    \ where T at array.jl:359\\n    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}})\
    \ where N at array.jl:361\\n    ...\\n  Stacktrace:\\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\\n\
    \   [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmpbgaaxden.jl:27\\n   [5] iterate at ./generator.jl:47 [inlined]\\\
    n   [6] _collect at ./array.jl:678 [inlined]\\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\\n   [8] map at ./abstractarray.jl:2072 [inlined]\\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmpbgaaxden.jl:27\\n   [10] top-level scope at /tmp/tmpbgaaxden.jl:37\\\
    n   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [12] top-level scope at /tmp/tmpbgaaxden.jl:34\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpbgaaxden.jl:38\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\\n  MethodError: no method matching\
    \ similar(::String, ::Type{Any})\\n  Closest candidates are:\\n    similar(!Matched::Array{T,1},\
    \ ::Type) where T at array.jl:358\\n    similar(!Matched::Array{T,2}, ::Type)\
    \ where T at array.jl:359\\n    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}})\
    \ where N at array.jl:361\\n    ...\\n  Stacktrace:\\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\\n\
    \   [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmpbgaaxden.jl:27\\n   [5] iterate at ./generator.jl:47 [inlined]\\\
    n   [6] _collect at ./array.jl:678 [inlined]\\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\\n   [8] map at ./abstractarray.jl:2072 [inlined]\\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmpbgaaxden.jl:27\\n   [10] top-level scope at /tmp/tmpbgaaxden.jl:38\\\
    n   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [12] top-level scope at /tmp/tmpbgaaxden.jl:34\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpbgaaxden.jl:39\\n  Test threw exception\\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\\n  MethodError: no method matching\
    \ similar(::String, ::Type{Any})\\n  Closest candidates are:\\n    similar(!Matched::Array{T,1},\
    \ ::Type) where T at array.jl:358\\n    similar(!Matched::Array{T,2}, ::Type)\
    \ where T at array.jl:359\\n    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}})\
    \ where N at array.jl:361\\n    ...\\n  Stacktrace:\\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\\n\
    \   [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmpbgaaxden.jl:27\\n   [5] iterate at ./generator.jl:47 [inlined]\\\
    n   [6] _collect at ./array.jl:678 [inlined]\\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\\n   [8] map at ./abstractarray.jl:2072 [inlined]\\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmpbgaaxden.jl:27\\n   [10] top-level scope at /tmp/tmpbgaaxden.jl:39\\\
    n   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [12] top-level scope at /tmp/tmpbgaaxden.jl:34\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    arr = sort(arr)\n    arr\
    \ = reverse(arr)\n    arr = [string(i) for i in arr]\n    return arr\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2, 1, 1,\
    \ 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpxvxaldzf.jl:33\n  Expression: candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"]\n   Evaluated: [\"8\", \"5\", \"4\", \"3\", \"2\"\
    , \"2\", \"1\", \"1\"] == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\",\
    \ \"Two\", \"One\", \"One\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpxvxaldzf.jl:33\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxvxaldzf.jl:32\ntest set: Test Failed at /tmp/tmpxvxaldzf.jl:35\n\
    \  Expression: candidate([1, -1, 55]) == [\"One\"]\n   Evaluated: [\"55\", \"\
    1\", \"-1\"] == [\"One\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpxvxaldzf.jl:35\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxvxaldzf.jl:32\ntest set: Test Failed at /tmp/tmpxvxaldzf.jl:36\n\
    \  Expression: candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n   Evaluated:\
    \ [\"3\", \"2\", \"1\", \"-1\"] == [\"Three\", \"Two\", \"One\"]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpxvxaldzf.jl:36\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxvxaldzf.jl:32\ntest set: Test Failed at /tmp/tmpxvxaldzf.jl:37\n\
    \  Expression: candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n   Evaluated:\
    \ [\"9\", \"8\", \"4\"] == [\"Nine\", \"Eight\", \"Four\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpxvxaldzf.jl:37\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxvxaldzf.jl:32\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxvxaldzf.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # create an empty array to store\
    \ the results\n    result = String[]\n    # iterate over the array\n    for i\
    \ in arr\n        # if the number is between 1 and 9 inclusive\n        if 1 <=\
    \ i <= 9\n            # append the corresponding name to the result array\n  \
    \          push!(result, string(i))\n        end\n    end\n    # return the result\
    \ array\n    return result\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\
    \t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\"\
    , \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp00t2hy8e.jl:45\n  Expression: candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"]\n   Evaluated: [\"8\", \"5\", \"4\", \"3\", \"2\"\
    , \"2\", \"1\", \"1\"] == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\",\
    \ \"Two\", \"One\", \"One\"]\nStacktrace:\n [1] top-level scope at /tmp/tmp00t2hy8e.jl:45\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp00t2hy8e.jl:44\ntest set: Test Failed at /tmp/tmp00t2hy8e.jl:47\n\
    \  Expression: candidate([1, -1, 55]) == [\"One\"]\n   Evaluated: [\"1\"] == [\"\
    One\"]\nStacktrace:\n [1] top-level scope at /tmp/tmp00t2hy8e.jl:47\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp00t2hy8e.jl:44\ntest set: Test Failed at /tmp/tmp00t2hy8e.jl:48\n\
    \  Expression: candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n   Evaluated:\
    \ [\"3\", \"2\", \"1\"] == [\"Three\", \"Two\", \"One\"]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp00t2hy8e.jl:48\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp00t2hy8e.jl:44\ntest set: Test Failed at /tmp/tmp00t2hy8e.jl:49\n\
    \  Expression: candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n   Evaluated:\
    \ [\"9\", \"8\", \"4\"] == [\"Nine\", \"Eight\", \"Four\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp00t2hy8e.jl:49\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp00t2hy8e.jl:44\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp00t2hy8e.jl:42\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    arr = sort(arr)\n    arr\
    \ = reverse(arr)\n    arr = [i for i in arr if i in 1:9]\n    arr = [string(i)\
    \ for i in arr]\n    return arr\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"\
    Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmph53o7bdh.jl:34\\n  Expression: candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"]\\n   Evaluated: [\"8\", \"5\", \"4\", \"3\", \"2\"\
    , \"2\", \"1\", \"1\"] == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\",\
    \ \"Two\", \"One\", \"One\"]\\nStacktrace:\\n [1] top-level scope at /tmp/tmph53o7bdh.jl:34\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmph53o7bdh.jl:33\\ntest set: Test Failed at /tmp/tmph53o7bdh.jl:36\\\
    n  Expression: candidate([1, -1, 55]) == [\"One\"]\\n   Evaluated: [\"1\"] ==\
    \ [\"One\"]\\nStacktrace:\\n [1] top-level scope at /tmp/tmph53o7bdh.jl:36\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmph53o7bdh.jl:33\\ntest set: Test Failed at /tmp/tmph53o7bdh.jl:37\\\
    n  Expression: candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\\n  \
    \ Evaluated: [\"3\", \"2\", \"1\"] == [\"Three\", \"Two\", \"One\"]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmph53o7bdh.jl:37\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmph53o7bdh.jl:33\\ntest set: Test Failed at /tmp/tmph53o7bdh.jl:38\\\
    n  Expression: candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\\n   Evaluated:\
    \ [\"9\", \"8\", \"4\"] == [\"Nine\", \"Eight\", \"Four\"]\\nStacktrace:\\n [1]\
    \ top-level scope at /tmp/tmph53o7bdh.jl:38\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmph53o7bdh.jl:33\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    arr = sort(arr)\n    arr\
    \ = reverse(arr)\n    arr = filter(x -> x < 10 && x > 0, arr)\n    arr = map(x\
    \ -> string(x), arr)\n    arr = map(x -> replace(x, \"1\" => \"One\", \"2\" =>\
    \ \"Two\", \"3\" => \"Three\", \"4\" => \"Four\", \"5\" => \"Five\", \"6\" =>\
    \ \"Six\", \"7\" => \"Seven\", \"8\" => \"Eight\", \"9\" => \"Nine\"), arr)\n\
    \    return arr\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\
    \t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\"\
    , \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp1us1bqsb.jl:35\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: no method\
    \ matching similar(::String, ::Type{Any})\n  Closest candidates are:\n    similar(!Matched::Array{T,1},\
    \ ::Type) where T at array.jl:358\n    similar(!Matched::Array{T,2}, ::Type) where\
    \ T at array.jl:359\n    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}})\
    \ where N at array.jl:361\n    ...\n  Stacktrace:\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\n \
    \  [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmp1us1bqsb.jl:27\n   [5] iterate at ./generator.jl:47 [inlined]\n\
    \   [6] _collect at ./array.jl:678 [inlined]\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\n   [8] map at ./abstractarray.jl:2072 [inlined]\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmp1us1bqsb.jl:27\n   [10] top-level scope at /tmp/tmp1us1bqsb.jl:35\n\
    \   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [12] top-level scope at /tmp/tmp1us1bqsb.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmp1us1bqsb.jl:37\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: no method matching similar(::String, ::Type{Any})\n\
    \  Closest candidates are:\n    similar(!Matched::Array{T,1}, ::Type) where T\
    \ at array.jl:358\n    similar(!Matched::Array{T,2}, ::Type) where T at array.jl:359\n\
    \    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}}) where\
    \ N at array.jl:361\n    ...\n  Stacktrace:\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\n \
    \  [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmp1us1bqsb.jl:27\n   [5] iterate at ./generator.jl:47 [inlined]\n\
    \   [6] _collect at ./array.jl:678 [inlined]\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\n   [8] map at ./abstractarray.jl:2072 [inlined]\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmp1us1bqsb.jl:27\n   [10] top-level scope at /tmp/tmp1us1bqsb.jl:37\n\
    \   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [12] top-level scope at /tmp/tmp1us1bqsb.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmp1us1bqsb.jl:38\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: no method matching\
    \ similar(::String, ::Type{Any})\n  Closest candidates are:\n    similar(!Matched::Array{T,1},\
    \ ::Type) where T at array.jl:358\n    similar(!Matched::Array{T,2}, ::Type) where\
    \ T at array.jl:359\n    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}})\
    \ where N at array.jl:361\n    ...\n  Stacktrace:\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\n \
    \  [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmp1us1bqsb.jl:27\n   [5] iterate at ./generator.jl:47 [inlined]\n\
    \   [6] _collect at ./array.jl:678 [inlined]\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\n   [8] map at ./abstractarray.jl:2072 [inlined]\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmp1us1bqsb.jl:27\n   [10] top-level scope at /tmp/tmp1us1bqsb.jl:38\n\
    \   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [12] top-level scope at /tmp/tmp1us1bqsb.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmp1us1bqsb.jl:39\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: no method matching\
    \ similar(::String, ::Type{Any})\n  Closest candidates are:\n    similar(!Matched::Array{T,1},\
    \ ::Type) where T at array.jl:358\n    similar(!Matched::Array{T,2}, ::Type) where\
    \ T at array.jl:359\n    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}})\
    \ where N at array.jl:361\n    ...\n  Stacktrace:\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\n \
    \  [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmp1us1bqsb.jl:27\n   [5] iterate at ./generator.jl:47 [inlined]\n\
    \   [6] _collect at ./array.jl:678 [inlined]\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\n   [8] map at ./abstractarray.jl:2072 [inlined]\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmp1us1bqsb.jl:27\n   [10] top-level scope at /tmp/tmp1us1bqsb.jl:39\n\
    \   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [12] top-level scope at /tmp/tmp1us1bqsb.jl:34\n  \nTest Summary: | Pass \
    \ Error  Total\ntest set      |    1      4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1us1bqsb.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # replace each digit by its corresponding\
    \ name from \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\"\n    # if the array is empty, return an empty array\n  \
    \  if length(arr) == 0\n        return []\n    end\n    # if the array has any\
    \ strange number ignore it\n    if length(arr) == 1 && arr[1] > 9\n        return\
    \ []\n    end\n    # if the array has any strange number ignore it\n    if length(arr)\
    \ == 1 && arr[1] < 1\n        return []\n    end\n    # if the array has any strange\
    \ number ignore it\n    if length(arr) == 1 && arr[1] > 9\n        return []\n\
    \    end\n    # if the array has any strange number ignore it\n    if length(arr)\
    \ == 1 && arr[1] < 1\n        return []\n    end\n    # if the array has any strange\
    \ number ignore it\n    if length(arr) == 2 && arr[1] > 9\n        return []\n\
    \    end\n    # if the array has any strange number ignore it\n    if length(arr)\
    \ == 2 && arr[1] < 1\n        return []\n    end\n    # if the array has any strange\
    \ number ignore it\n    if length(arr) == 2 && arr[2] > 9\n        return []\n\
    \    end\n    # if the array has any strange number ignore it\n    if length(arr)\
    \ == 2 && arr[2] < 1\n        return []\n    end\n    # if the array has any strange\
    \ number ignore it\n    if length(arr) == 3 && arr[1] > 9\n        return []\n\
    \    end\n    # if the array has any strange number ignore it\n    if length(arr)\
    \ == 3 && arr[1] < 1\n        return []\n    end\n    # if the array has any strange\
    \ number ignore it\n    if length(arr) == 3 && arr[2] > 9\n        return []\n\
    \    end\n    # if the array has any strange number ignore it\n    if length(arr)\
    \ == 3 && arr[2] < 1\n        return []\n   \nusing Test\n\n@testset begin\n\n\
    candidate = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpdwg1rlk6.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpdwg1rlk6.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sorted_arr\
    \ = sort(arr)\n    # reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # replace each digit by its corresponding name from \"One\", \"Two\", \"\
    Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\n    # create\
    \ a dictionary\n    dict = Dict(1 => \"One\", 2 => \"Two\", 3 => \"Three\", 4\
    \ => \"Four\", 5 => \"Five\", 6 => \"Six\", 7 => \"Seven\", 8 => \"Eight\", 9\
    \ => \"Nine\")\n    # create an empty array\n    new_arr = []\n    # iterate through\
    \ the reversed array\n    for i in reversed_arr\n        # check if the number\
    \ is in the dictionary\n        if i in keys(dict)\n            # if it is, append\
    \ the corresponding value to the new array\n            push!(new_arr, dict[i])\n\
    \        end\n    end\n    # return the new array\n    return new_arr\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2, 1, 1,\
    \ 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    #\
    \ reverse the array\n    # replace each digit by its corresponding name from \"\
    One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\",\
    \ \"Nine\"\n    # return the array\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"\
    Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp8uc1fqr2.jl:33\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp8uc1fqr2.jl:27\n\
    \   [2] top-level scope at /tmp/tmp8uc1fqr2.jl:33\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8uc1fqr2.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmp8uc1fqr2.jl:34\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{String}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp8uc1fqr2.jl:27\n\
    \   [2] top-level scope at /tmp/tmp8uc1fqr2.jl:34\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8uc1fqr2.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmp8uc1fqr2.jl:35\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp8uc1fqr2.jl:27\n\
    \   [2] top-level scope at /tmp/tmp8uc1fqr2.jl:35\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8uc1fqr2.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmp8uc1fqr2.jl:36\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp8uc1fqr2.jl:27\n\
    \   [2] top-level scope at /tmp/tmp8uc1fqr2.jl:36\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8uc1fqr2.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmp8uc1fqr2.jl:37\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp8uc1fqr2.jl:27\n\
    \   [2] top-level scope at /tmp/tmp8uc1fqr2.jl:37\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp8uc1fqr2.jl:32\n  \nTest Summary: | Error \
    \ Total\ntest set      |     5      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8uc1fqr2.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # replace each digit by its corresponding\
    \ name from \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\"\n    for i in 1:length(arr)\n        if arr[i] == 1\n  \
    \          arr[i] = \"One\"\n        elseif arr[i] == 2\n            arr[i] =\
    \ \"Two\"\n        elseif arr[i] == 3\n            arr[i] = \"Three\"\n      \
    \  elseif arr[i] == 4\n            arr[i] = \"Four\"\n        elseif arr[i] ==\
    \ 5\n            arr[i] = \"Five\"\n        elseif arr[i] == 6\n            arr[i]\
    \ = \"Six\"\n        elseif arr[i] == 7\n            arr[i] = \"Seven\"\n    \
    \    elseif arr[i] == 8\n            arr[i] = \"Eight\"\n        elseif arr[i]\
    \ == 9\n            arr[i] = \"Nine\"\n        end\n    end\n    # return the\
    \ array\n    return arr\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\
    \t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\"\
    , \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmptrasi5b5.jl:57\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: Cannot\
    \ `convert` an object of type String to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] setindex!(::Array{Int64,1}, ::String, ::Int64) at ./array.jl:826\n   [2]\
    \ by_length(::Array{Int64,1}) at /tmp/tmptrasi5b5.jl:44\n   [3] top-level scope\
    \ at /tmp/tmptrasi5b5.jl:57\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmptrasi5b5.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmptrasi5b5.jl:59\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: Cannot `convert` an object of type String\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmptrasi5b5.jl:30\n   [3] top-level scope at /tmp/tmptrasi5b5.jl:59\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmptrasi5b5.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmptrasi5b5.jl:60\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: Cannot `convert`\
    \ an object of type String to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmptrasi5b5.jl:34\n   [3] top-level scope at /tmp/tmptrasi5b5.jl:60\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmptrasi5b5.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmptrasi5b5.jl:61\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: Cannot `convert` an\
    \ object of type String to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmptrasi5b5.jl:46\n   [3] top-level scope at /tmp/tmptrasi5b5.jl:61\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmptrasi5b5.jl:56\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    1      4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmptrasi5b5.jl:54\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sorted_arr\
    \ = sort(arr)\n    # reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # replace each digit by its corresponding name from \"One\", \"Two\", \"\
    Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\n    # create\
    \ a dictionary\n    dict = Dict(\"1\" => \"One\", \"2\" => \"Two\", \"3\" => \"\
    Three\", \"4\" => \"Four\", \"5\" => \"Five\", \"6\" => \"Six\", \"7\" => \"Seven\"\
    , \"8\" => \"Eight\", \"9\" => \"Nine\")\n    # create an empty array\n    new_arr\
    \ = []\n    # loop through the reversed array\n    for i in reversed_arr\n   \
    \     # check if the number is between 1 and 9 inclusive\n        if i >= 1 &&\
    \ i <= 9\n            # push the corresponding name to the new array\n       \
    \     push!(new_arr, dict[string(i)])\n        end\n    end\n    # return the\
    \ new array\n    return new_arr\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"\
    Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    arr = sort(arr)\n    arr\
    \ = reverse(arr)\n    arr = [string(i) for i in arr]\n    return arr\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2, 1, 1,\
    \ 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpyg6oqiq6.jl:33\\n  Expression: candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"]\\n   Evaluated: [\"8\", \"5\", \"4\", \"3\", \"2\"\
    , \"2\", \"1\", \"1\"] == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\",\
    \ \"Two\", \"One\", \"One\"]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpyg6oqiq6.jl:33\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpyg6oqiq6.jl:32\\ntest set: Test Failed at /tmp/tmpyg6oqiq6.jl:35\\\
    n  Expression: candidate([1, -1, 55]) == [\"One\"]\\n   Evaluated: [\"55\", \"\
    1\", \"-1\"] == [\"One\"]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpyg6oqiq6.jl:35\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpyg6oqiq6.jl:32\\ntest set: Test Failed at /tmp/tmpyg6oqiq6.jl:36\\\
    n  Expression: candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\\n  \
    \ Evaluated: [\"3\", \"2\", \"1\", \"-1\"] == [\"Three\", \"Two\", \"One\"]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpyg6oqiq6.jl:36\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpyg6oqiq6.jl:32\\ntest set: Test Failed at /tmp/tmpyg6oqiq6.jl:37\\\
    n  Expression: candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\\n   Evaluated:\
    \ [\"9\", \"8\", \"4\"] == [\"Nine\", \"Eight\", \"Four\"]\\nStacktrace:\\n [1]\
    \ top-level scope at /tmp/tmpyg6oqiq6.jl:37\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpyg6oqiq6.jl:32\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    1     4      5\\n'"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    arr = sort(arr)\n    arr\
    \ = reverse(arr)\n    arr = filter(x -> x in 1:9, arr)\n    arr = map(x -> string(x),\
    \ arr)\n    arr = map(x -> replace(x, \"1\" => \"One\", \"2\" => \"Two\", \"3\"\
    \ => \"Three\", \"4\" => \"Four\", \"5\" => \"Five\", \"6\" => \"Six\", \"7\"\
    \ => \"Seven\", \"8\" => \"Eight\", \"9\" => \"Nine\"), arr)\n    return arr\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpn7wt_ph7.jl:35\\n  Test threw\
    \ exception\\n  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\\n  MethodError:\
    \ no method matching similar(::String, ::Type{Any})\\n  Closest candidates are:\\\
    n    similar(!Matched::Array{T,1}, ::Type) where T at array.jl:358\\n    similar(!Matched::Array{T,2},\
    \ ::Type) where T at array.jl:359\\n    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}})\
    \ where N at array.jl:361\\n    ...\\n  Stacktrace:\\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\\n\
    \   [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmpn7wt_ph7.jl:27\\n   [5] iterate at ./generator.jl:47 [inlined]\\\
    n   [6] _collect at ./array.jl:678 [inlined]\\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\\n   [8] map at ./abstractarray.jl:2072 [inlined]\\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmpn7wt_ph7.jl:27\\n   [10] top-level scope at /tmp/tmpn7wt_ph7.jl:35\\\
    n   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [12] top-level scope at /tmp/tmpn7wt_ph7.jl:34\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpn7wt_ph7.jl:37\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\\n  MethodError: no method matching similar(::String,\
    \ ::Type{Any})\\n  Closest candidates are:\\n    similar(!Matched::Array{T,1},\
    \ ::Type) where T at array.jl:358\\n    similar(!Matched::Array{T,2}, ::Type)\
    \ where T at array.jl:359\\n    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}})\
    \ where N at array.jl:361\\n    ...\\n  Stacktrace:\\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\\n\
    \   [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmpn7wt_ph7.jl:27\\n   [5] iterate at ./generator.jl:47 [inlined]\\\
    n   [6] _collect at ./array.jl:678 [inlined]\\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\\n   [8] map at ./abstractarray.jl:2072 [inlined]\\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmpn7wt_ph7.jl:27\\n   [10] top-level scope at /tmp/tmpn7wt_ph7.jl:37\\\
    n   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [12] top-level scope at /tmp/tmpn7wt_ph7.jl:34\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpn7wt_ph7.jl:38\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\\n  MethodError: no method matching\
    \ similar(::String, ::Type{Any})\\n  Closest candidates are:\\n    similar(!Matched::Array{T,1},\
    \ ::Type) where T at array.jl:358\\n    similar(!Matched::Array{T,2}, ::Type)\
    \ where T at array.jl:359\\n    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}})\
    \ where N at array.jl:361\\n    ...\\n  Stacktrace:\\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\\n\
    \   [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmpn7wt_ph7.jl:27\\n   [5] iterate at ./generator.jl:47 [inlined]\\\
    n   [6] _collect at ./array.jl:678 [inlined]\\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\\n   [8] map at ./abstractarray.jl:2072 [inlined]\\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmpn7wt_ph7.jl:27\\n   [10] top-level scope at /tmp/tmpn7wt_ph7.jl:38\\\
    n   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [12] top-level scope at /tmp/tmpn7wt_ph7.jl:34\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpn7wt_ph7.jl:39\\n  Test threw exception\\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\\n  MethodError: no method matching\
    \ similar(::String, ::Type{Any})\\n  Closest candidates are:\\n    similar(!Matched::Array{T,1},\
    \ ::Type) where T at array.jl:358\\n    similar(!Matched::Array{T,2}, ::Type)\
    \ where T at array.jl:359\\n    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}})\
    \ where N at array.jl:361\\n    ...\\n  Stacktrace:\\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\\n\
    \   [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmpn7wt_ph7.jl:27\\n   [5] iterate at ./generator.jl:47 [inlined]\\\
    n   [6] _collect at ./array.jl:678 [inlined]\\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\\n   [8] map at ./abstractarray.jl:2072 [inlined]\\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmpn7wt_ph7.jl:27\\n   [10] top-level scope at /tmp/tmpn7wt_ph7.jl:39\\\
    n   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [12] top-level scope at /tmp/tmpn7wt_ph7.jl:34\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # replace each digit by its corresponding\
    \ name from \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\"\n    for i in 1:length(arr)\n        if arr[i] == 1\n  \
    \          arr[i] = \"One\"\n        elseif arr[i] == 2\n            arr[i] =\
    \ \"Two\"\n        elseif arr[i] == 3\n            arr[i] = \"Three\"\n      \
    \  elseif arr[i] == 4\n            arr[i] = \"Four\"\n        elseif arr[i] ==\
    \ 5\n            arr[i] = \"Five\"\n        elseif arr[i] == 6\n            arr[i]\
    \ = \"Six\"\n        elseif arr[i] == 7\n            arr[i] = \"Seven\"\n    \
    \    elseif arr[i] == 8\n            arr[i] = \"Eight\"\n        elseif arr[i]\
    \ == 9\n            arr[i] = \"Nine\"\n        end\n    end\n    # return the\
    \ array\n    return arr\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\
    \t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\"\
    , \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp2xwmbkup.jl:57\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: Cannot\
    \ `convert` an object of type String to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] setindex!(::Array{Int64,1}, ::String, ::Int64) at ./array.jl:826\n   [2]\
    \ by_length(::Array{Int64,1}) at /tmp/tmp2xwmbkup.jl:44\n   [3] top-level scope\
    \ at /tmp/tmp2xwmbkup.jl:57\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp2xwmbkup.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmp2xwmbkup.jl:59\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: Cannot `convert` an object of type String\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmp2xwmbkup.jl:30\n   [3] top-level scope at /tmp/tmp2xwmbkup.jl:59\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp2xwmbkup.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmp2xwmbkup.jl:60\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: Cannot `convert`\
    \ an object of type String to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmp2xwmbkup.jl:34\n   [3] top-level scope at /tmp/tmp2xwmbkup.jl:60\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp2xwmbkup.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmp2xwmbkup.jl:61\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: Cannot `convert` an\
    \ object of type String to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmp2xwmbkup.jl:46\n   [3] top-level scope at /tmp/tmp2xwmbkup.jl:61\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp2xwmbkup.jl:56\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    1      4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2xwmbkup.jl:54\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    #\
    \ reverse the array\n    # replace each digit by its corresponding name from \"\
    One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\",\
    \ \"Nine\"\n    # return the array\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"\
    Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp_zjju69b.jl:33\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp_zjju69b.jl:27\n\
    \   [2] top-level scope at /tmp/tmp_zjju69b.jl:33\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_zjju69b.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmp_zjju69b.jl:34\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{String}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp_zjju69b.jl:27\n\
    \   [2] top-level scope at /tmp/tmp_zjju69b.jl:34\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_zjju69b.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmp_zjju69b.jl:35\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp_zjju69b.jl:27\n\
    \   [2] top-level scope at /tmp/tmp_zjju69b.jl:35\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_zjju69b.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmp_zjju69b.jl:36\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp_zjju69b.jl:27\n\
    \   [2] top-level scope at /tmp/tmp_zjju69b.jl:36\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_zjju69b.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmp_zjju69b.jl:37\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp_zjju69b.jl:27\n\
    \   [2] top-level scope at /tmp/tmp_zjju69b.jl:37\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_zjju69b.jl:32\n  \nTest Summary: | Error \
    \ Total\ntest set      |     5      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_zjju69b.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # replace each digit by its corresponding\
    \ name from \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\"\n    for i in 1:length(arr)\n        if arr[i] == 1\n  \
    \          arr[i] = \"One\"\n        elseif arr[i] == 2\n            arr[i] =\
    \ \"Two\"\n        elseif arr[i] == 3\n            arr[i] = \"Three\"\n      \
    \  elseif arr[i] == 4\n            arr[i] = \"Four\"\n        elseif arr[i] ==\
    \ 5\n            arr[i] = \"Five\"\n        elseif arr[i] == 6\n            arr[i]\
    \ = \"Six\"\n        elseif arr[i] == 7\n            arr[i] = \"Seven\"\n    \
    \    elseif arr[i] == 8\n            arr[i] = \"Eight\"\n        elseif arr[i]\
    \ == 9\n            arr[i] = \"Nine\"\n        end\n    end\n    # return the\
    \ array\n    return arr\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\
    \t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\"\
    , \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpons5areq.jl:57\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: Cannot\
    \ `convert` an object of type String to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] setindex!(::Array{Int64,1}, ::String, ::Int64) at ./array.jl:826\n   [2]\
    \ by_length(::Array{Int64,1}) at /tmp/tmpons5areq.jl:44\n   [3] top-level scope\
    \ at /tmp/tmpons5areq.jl:57\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpons5areq.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmpons5areq.jl:59\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: Cannot `convert` an object of type String\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpons5areq.jl:30\n   [3] top-level scope at /tmp/tmpons5areq.jl:59\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpons5areq.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmpons5areq.jl:60\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: Cannot `convert`\
    \ an object of type String to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpons5areq.jl:34\n   [3] top-level scope at /tmp/tmpons5areq.jl:60\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpons5areq.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmpons5areq.jl:61\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: Cannot `convert` an\
    \ object of type String to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpons5areq.jl:46\n   [3] top-level scope at /tmp/tmpons5areq.jl:61\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpons5areq.jl:56\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    1      4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpons5areq.jl:54\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    arr = sort(arr)\n    arr\
    \ = reverse(arr)\n    result = []\n    for i in arr\n        if i == 1\n     \
    \       push!(result, \"One\")\n        elseif i == 2\n            push!(result,\
    \ \"Two\")\n        elseif i == 3\n            push!(result, \"Three\")\n    \
    \    elseif i == 4\n            push!(result, \"Four\")\n        elseif i == 5\n\
    \            push!(result, \"Five\")\n        elseif i == 6\n            push!(result,\
    \ \"Six\")\n        elseif i == 7\n            push!(result, \"Seven\")\n    \
    \    elseif i == 8\n            push!(result, \"Eight\")\n        elseif i ==\
    \ 9\n            push!(result, \"Nine\")\n        end\n    end\n    return result\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # replace each digit by its corresponding\
    \ name\n    for i in 1:length(arr)\n        if arr[i] == 1\n            arr[i]\
    \ = \"One\"\n        elseif arr[i] == 2\n            arr[i] = \"Two\"\n      \
    \  elseif arr[i] == 3\n            arr[i] = \"Three\"\n        elseif arr[i] ==\
    \ 4\n            arr[i] = \"Four\"\n        elseif arr[i] == 5\n            arr[i]\
    \ = \"Five\"\n        elseif arr[i] == 6\n            arr[i] = \"Six\"\n     \
    \   elseif arr[i] == 7\n            arr[i] = \"Seven\"\n        elseif arr[i]\
    \ == 8\n            arr[i] = \"Eight\"\n        elseif arr[i] == 9\n         \
    \   arr[i] = \"Nine\"\n        end\n    end\n    # return the array\n    return\
    \ arr\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpb0mss0ta.jl:57\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: Cannot\
    \ `convert` an object of type String to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] setindex!(::Array{Int64,1}, ::String, ::Int64) at ./array.jl:826\n   [2]\
    \ by_length(::Array{Int64,1}) at /tmp/tmpb0mss0ta.jl:44\n   [3] top-level scope\
    \ at /tmp/tmpb0mss0ta.jl:57\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpb0mss0ta.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmpb0mss0ta.jl:59\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: Cannot `convert` an object of type String\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpb0mss0ta.jl:30\n   [3] top-level scope at /tmp/tmpb0mss0ta.jl:59\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpb0mss0ta.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmpb0mss0ta.jl:60\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: Cannot `convert`\
    \ an object of type String to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpb0mss0ta.jl:34\n   [3] top-level scope at /tmp/tmpb0mss0ta.jl:60\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpb0mss0ta.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmpb0mss0ta.jl:61\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: Cannot `convert` an\
    \ object of type String to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpb0mss0ta.jl:46\n   [3] top-level scope at /tmp/tmpb0mss0ta.jl:61\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpb0mss0ta.jl:56\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    1      4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpb0mss0ta.jl:54\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sorted_arr\
    \ = sort(arr)\n    # reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # replace each digit by its corresponding name from \"One\", \"Two\", \"\
    Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\n    # if\
    \ the array is empty, return an empty array\n    if length(reversed_arr) == 0\n\
    \        return []\n    end\n    # if the array has any strange number ignore\
    \ it\n    if length(reversed_arr) == 1 && reversed_arr[1] > 9\n        return\
    \ []\n    end\n    # if the array has any strange number ignore it\n    if length(reversed_arr)\
    \ == 1 && reversed_arr[1] < 1\n        return []\n    end\n    # if the array\
    \ has any strange number ignore it\n    if length(reversed_arr) == 1 && reversed_arr[1]\
    \ == 0\n        return []\n    end\n    # if the array has any strange number\
    \ ignore it\n    if length(reversed_arr) == 1 && reversed_arr[1] < 0\n       \
    \ return []\n    end\n    # if the array has any strange number ignore it\n  \
    \  if length(reversed_arr) == 1 && reversed_arr[1] > 9\n        return []\n  \
    \  end\n    # if the array has any strange number ignore it\n    if length(reversed_arr)\
    \ == 1 && reversed_arr[1] < 1\n        return []\n    end\n    # if the array\
    \ has any strange number ignore it\n    if length(reversed_arr) == 1 && reversed_arr[1]\
    \ == 0\n        return []\n    end\n    # if the array has any strange number\
    \ ignore it\n    if length(reversed_arr) == 1 && reversed_arr[1] < 0\n       \
    \ return []\n    end\n    # if the array has any strange number ignore it\n  \
    \  if length(reversed_arr) == 1 && reversed_arr[1] > 9\n        return []\n  \
    \  end\n    # if the array has any strange number ignore it\n    if length(reversed_arr)\
    \ == 1 && reversed_arr[1] < 1\n        return\nusing Test\n\n@testset begin\n\n\
    candidate = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpe884nvpe.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpe884nvpe.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # replace each digit by its corresponding\
    \ name from \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\"\n    for i in 1:length(arr)\n        if arr[i] == 1\n  \
    \          arr[i] = \"One\"\n        elseif arr[i] == 2\n            arr[i] =\
    \ \"Two\"\n        elseif arr[i] == 3\n            arr[i] = \"Three\"\n      \
    \  elseif arr[i] == 4\n            arr[i] = \"Four\"\n        elseif arr[i] ==\
    \ 5\n            arr[i] = \"Five\"\n        elseif arr[i] == 6\n            arr[i]\
    \ = \"Six\"\n        elseif arr[i] == 7\n            arr[i] = \"Seven\"\n    \
    \    elseif arr[i] == 8\n            arr[i] = \"Eight\"\n        elseif arr[i]\
    \ == 9\n            arr[i] = \"Nine\"\n        end\n    end\n    # return the\
    \ array\n    return arr\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\
    \t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\"\
    , \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpgtqo_zzz.jl:57\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: Cannot\
    \ `convert` an object of type String to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] setindex!(::Array{Int64,1}, ::String, ::Int64) at ./array.jl:826\n   [2]\
    \ by_length(::Array{Int64,1}) at /tmp/tmpgtqo_zzz.jl:44\n   [3] top-level scope\
    \ at /tmp/tmpgtqo_zzz.jl:57\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpgtqo_zzz.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmpgtqo_zzz.jl:59\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: Cannot `convert` an object of type String\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpgtqo_zzz.jl:30\n   [3] top-level scope at /tmp/tmpgtqo_zzz.jl:59\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpgtqo_zzz.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmpgtqo_zzz.jl:60\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: Cannot `convert`\
    \ an object of type String to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpgtqo_zzz.jl:34\n   [3] top-level scope at /tmp/tmpgtqo_zzz.jl:60\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpgtqo_zzz.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmpgtqo_zzz.jl:61\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: Cannot `convert` an\
    \ object of type String to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpgtqo_zzz.jl:46\n   [3] top-level scope at /tmp/tmpgtqo_zzz.jl:61\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpgtqo_zzz.jl:56\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    1      4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgtqo_zzz.jl:54\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    #\
    \ reverse the array\n    # replace each digit by its corresponding name\n    #\
    \ return the array\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\
    \t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\"\
    , \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpkc15tg29.jl:33\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmpkc15tg29.jl:27\n\
    \   [2] top-level scope at /tmp/tmpkc15tg29.jl:33\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkc15tg29.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmpkc15tg29.jl:34\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{String}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmpkc15tg29.jl:27\n\
    \   [2] top-level scope at /tmp/tmpkc15tg29.jl:34\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkc15tg29.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmpkc15tg29.jl:35\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmpkc15tg29.jl:27\n\
    \   [2] top-level scope at /tmp/tmpkc15tg29.jl:35\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkc15tg29.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmpkc15tg29.jl:36\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmpkc15tg29.jl:27\n\
    \   [2] top-level scope at /tmp/tmpkc15tg29.jl:36\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkc15tg29.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmpkc15tg29.jl:37\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmpkc15tg29.jl:27\n\
    \   [2] top-level scope at /tmp/tmpkc15tg29.jl:37\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpkc15tg29.jl:32\n  \nTest Summary: | Error \
    \ Total\ntest set      |     5      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpkc15tg29.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # replace each digit by its corresponding\
    \ name from \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\"\n    for i in 1:length(arr)\n        if arr[i] == 1\n  \
    \          arr[i] = \"One\"\n        elseif arr[i] == 2\n            arr[i] =\
    \ \"Two\"\n        elseif arr[i] == 3\n            arr[i] = \"Three\"\n      \
    \  elseif arr[i] == 4\n            arr[i] = \"Four\"\n        elseif arr[i] ==\
    \ 5\n            arr[i] = \"Five\"\n        elseif arr[i] == 6\n            arr[i]\
    \ = \"Six\"\n        elseif arr[i] == 7\n            arr[i] = \"Seven\"\n    \
    \    elseif arr[i] == 8\n            arr[i] = \"Eight\"\n        elseif arr[i]\
    \ == 9\n            arr[i] = \"Nine\"\n        end\n    end\n    # return the\
    \ array\n    return arr\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\
    \t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\"\
    , \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmptm2otsy4.jl:57\\n  Test threw\
    \ exception\\n  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\\n  MethodError:\
    \ Cannot `convert` an object of type String to an object of type Int64\\n  Closest\
    \ candidates are:\\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\\\
    n    convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\\n  \
    \  convert(::Type{T}, !Matched::Ptr) where T<:Integer at pointer.jl:23\\n    ...\\\
    n  Stacktrace:\\n   [1] setindex!(::Array{Int64,1}, ::String, ::Int64) at ./array.jl:826\\\
    n   [2] by_length(::Array{Int64,1}) at /tmp/tmptm2otsy4.jl:44\\n   [3] top-level\
    \ scope at /tmp/tmptm2otsy4.jl:57\\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmptm2otsy4.jl:56\\n  \\ntest set: Error During\
    \ Test at /tmp/tmptm2otsy4.jl:59\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\\n  MethodError: Cannot `convert` an object of type String\
    \ to an object of type Int64\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmptm2otsy4.jl:30\\n   [3] top-level scope at /tmp/tmptm2otsy4.jl:59\\\
    n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmptm2otsy4.jl:56\\n  \\ntest set: Error During\
    \ Test at /tmp/tmptm2otsy4.jl:60\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\\n  MethodError: Cannot `convert`\
    \ an object of type String to an object of type Int64\\n  Closest candidates are:\\\
    n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmptm2otsy4.jl:34\\n   [3] top-level scope at /tmp/tmptm2otsy4.jl:60\\\
    n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmptm2otsy4.jl:56\\n  \\ntest set: Error During\
    \ Test at /tmp/tmptm2otsy4.jl:61\\n  Test threw exception\\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\\n  MethodError: Cannot `convert`\
    \ an object of type String to an object of type Int64\\n  Closest candidates are:\\\
    n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmptm2otsy4.jl:46\\n   [3] top-level scope at /tmp/tmptm2otsy4.jl:61\\\
    n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmptm2otsy4.jl:56\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sorted_arr\
    \ = sort(arr)\n    # reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # replace each digit by its corresponding name from \"One\", \"Two\", \"\
    Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\n    result\
    \ = []\n    for i in reversed_arr\n        if i == 1\n            push!(result,\
    \ \"One\")\n        elseif i == 2\n            push!(result, \"Two\")\n      \
    \  elseif i == 3\n            push!(result, \"Three\")\n        elseif i == 4\n\
    \            push!(result, \"Four\")\n        elseif i == 5\n            push!(result,\
    \ \"Five\")\n        elseif i == 6\n            push!(result, \"Six\")\n     \
    \   elseif i == 7\n            push!(result, \"Seven\")\n        elseif i == 8\n\
    \            push!(result, \"Eight\")\n        elseif i == 9\n            push!(result,\
    \ \"Nine\")\n        end\n    end\n    return result\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3])\
    \ == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"\
    One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\t@test(candidate([1,\
    \ -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2]) == [\"Three\", \"Two\"\
    , \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sorted_arr\
    \ = sort(arr)\n    # reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # replace each digit by its corresponding name\n    # create a dictionary\n\
    \    d = Dict(\"1\" => \"One\", \"2\" => \"Two\", \"3\" => \"Three\", \"4\" =>\
    \ \"Four\", \"5\" => \"Five\", \"6\" => \"Six\", \"7\" => \"Seven\", \"8\" =>\
    \ \"Eight\", \"9\" => \"Nine\")\n    # create an empty array\n    new_arr = []\n\
    \    # loop through the reversed array\n    for i in reversed_arr\n        # check\
    \ if the element is between 1 and 9\n        if i in 1:9\n            # push the\
    \ element into the new array\n            push!(new_arr, d[string(i)])\n     \
    \   end\n    end\n    # return the new array\n    return new_arr\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2, 1, 1, 4, 5,\
    \ 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # replace each digit by its corresponding\
    \ name from \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\"\n    for i in 1:length(arr)\n        if arr[i] == 1\n  \
    \          arr[i] = \"One\"\n        elseif arr[i] == 2\n            arr[i] =\
    \ \"Two\"\n        elseif arr[i] == 3\n            arr[i] = \"Three\"\n      \
    \  elseif arr[i] == 4\n            arr[i] = \"Four\"\n        elseif arr[i] ==\
    \ 5\n            arr[i] = \"Five\"\n        elseif arr[i] == 6\n            arr[i]\
    \ = \"Six\"\n        elseif arr[i] == 7\n            arr[i] = \"Seven\"\n    \
    \    elseif arr[i] == 8\n            arr[i] = \"Eight\"\n        elseif arr[i]\
    \ == 9\n            arr[i] = \"Nine\"\n        end\n    end\n    return arr\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpq9h7s3v_.jl:56\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: Cannot\
    \ `convert` an object of type String to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] setindex!(::Array{Int64,1}, ::String, ::Int64) at ./array.jl:826\n   [2]\
    \ by_length(::Array{Int64,1}) at /tmp/tmpq9h7s3v_.jl:44\n   [3] top-level scope\
    \ at /tmp/tmpq9h7s3v_.jl:56\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpq9h7s3v_.jl:55\n  \ntest set: Error During\
    \ Test at /tmp/tmpq9h7s3v_.jl:58\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: Cannot `convert` an object of type String\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpq9h7s3v_.jl:30\n   [3] top-level scope at /tmp/tmpq9h7s3v_.jl:58\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpq9h7s3v_.jl:55\n  \ntest set: Error During\
    \ Test at /tmp/tmpq9h7s3v_.jl:59\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: Cannot `convert`\
    \ an object of type String to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpq9h7s3v_.jl:34\n   [3] top-level scope at /tmp/tmpq9h7s3v_.jl:59\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpq9h7s3v_.jl:55\n  \ntest set: Error During\
    \ Test at /tmp/tmpq9h7s3v_.jl:60\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: Cannot `convert` an\
    \ object of type String to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpq9h7s3v_.jl:46\n   [3] top-level scope at /tmp/tmpq9h7s3v_.jl:60\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpq9h7s3v_.jl:55\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    1      4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpq9h7s3v_.jl:53\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sorted_arr\
    \ = sort(arr)\n    # reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # replace each digit by its corresponding name from \"One\", \"Two\", \"\
    Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\n    # create\
    \ a dictionary\n    d = Dict(1 => \"One\", 2 => \"Two\", 3 => \"Three\", 4 =>\
    \ \"Four\", 5 => \"Five\", 6 => \"Six\", 7 => \"Seven\", 8 => \"Eight\", 9 =>\
    \ \"Nine\")\n    # create an empty array\n    result = []\n    # loop through\
    \ the array\n    for i in reversed_arr\n        # check if the number is between\
    \ 1 and 9 inclusive\n        if i in keys(d)\n            # append the corresponding\
    \ name to the result array\n            push!(result, d[i])\n        end\n   \
    \ end\n    # return the result array\n    return result\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3])\
    \ == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"\
    One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\t@test(candidate([1,\
    \ -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2]) == [\"Three\", \"Two\"\
    , \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    arr = sort(arr)\n    arr\
    \ = reverse(arr)\n    arr = [string(i) for i in arr]\n    return arr\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2, 1, 1,\
    \ 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmptbvzmw6f.jl:33\\n  Expression: candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"]\\n   Evaluated: [\"8\", \"5\", \"4\", \"3\", \"2\"\
    , \"2\", \"1\", \"1\"] == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\",\
    \ \"Two\", \"One\", \"One\"]\\nStacktrace:\\n [1] top-level scope at /tmp/tmptbvzmw6f.jl:33\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmptbvzmw6f.jl:32\\ntest set: Test Failed at /tmp/tmptbvzmw6f.jl:35\\\
    n  Expression: candidate([1, -1, 55]) == [\"One\"]\\n   Evaluated: [\"55\", \"\
    1\", \"-1\"] == [\"One\"]\\nStacktrace:\\n [1] top-level scope at /tmp/tmptbvzmw6f.jl:35\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmptbvzmw6f.jl:32\\ntest set: Test Failed at /tmp/tmptbvzmw6f.jl:36\\\
    n  Expression: candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\\n  \
    \ Evaluated: [\"3\", \"2\", \"1\", \"-1\"] == [\"Three\", \"Two\", \"One\"]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmptbvzmw6f.jl:36\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmptbvzmw6f.jl:32\\ntest set: Test Failed at /tmp/tmptbvzmw6f.jl:37\\\
    n  Expression: candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\\n   Evaluated:\
    \ [\"9\", \"8\", \"4\"] == [\"Nine\", \"Eight\", \"Four\"]\\nStacktrace:\\n [1]\
    \ top-level scope at /tmp/tmptbvzmw6f.jl:37\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmptbvzmw6f.jl:32\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    1     4      5\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    arr = sort(arr)\n    arr\
    \ = reverse(arr)\n    arr = filter(x -> x in 1:9, arr)\n    arr = map(x -> string(x),\
    \ arr)\n    return arr\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\
    \t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\"\
    , \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpcg67dmef.jl:34\n  Expression: candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"]\n   Evaluated: [\"8\", \"5\", \"4\", \"3\", \"2\"\
    , \"2\", \"1\", \"1\"] == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\",\
    \ \"Two\", \"One\", \"One\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpcg67dmef.jl:34\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpcg67dmef.jl:33\ntest set: Test Failed at /tmp/tmpcg67dmef.jl:36\n\
    \  Expression: candidate([1, -1, 55]) == [\"One\"]\n   Evaluated: [\"1\"] == [\"\
    One\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpcg67dmef.jl:36\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpcg67dmef.jl:33\ntest set: Test Failed at /tmp/tmpcg67dmef.jl:37\n\
    \  Expression: candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n   Evaluated:\
    \ [\"3\", \"2\", \"1\"] == [\"Three\", \"Two\", \"One\"]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpcg67dmef.jl:37\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpcg67dmef.jl:33\ntest set: Test Failed at /tmp/tmpcg67dmef.jl:38\n\
    \  Expression: candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n   Evaluated:\
    \ [\"9\", \"8\", \"4\"] == [\"Nine\", \"Eight\", \"Four\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpcg67dmef.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpcg67dmef.jl:33\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpcg67dmef.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # Sort the array\n    sorted_arr\
    \ = sort(arr)\n    # Reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # Replace each digit by its corresponding name from \"One\", \"Two\", \"\
    Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\n    for\
    \ i in 1:length(reversed_arr)\n        if reversed_arr[i] == 1\n            reversed_arr[i]\
    \ = \"One\"\n        elseif reversed_arr[i] == 2\n            reversed_arr[i]\
    \ = \"Two\"\n        elseif reversed_arr[i] == 3\n            reversed_arr[i]\
    \ = \"Three\"\n        elseif reversed_arr[i] == 4\n            reversed_arr[i]\
    \ = \"Four\"\n        elseif reversed_arr[i] == 5\n            reversed_arr[i]\
    \ = \"Five\"\n        elseif reversed_arr[i] == 6\n            reversed_arr[i]\
    \ = \"Six\"\n        elseif reversed_arr[i] == 7\n            reversed_arr[i]\
    \ = \"Seven\"\n        elseif reversed_arr[i] == 8\n            reversed_arr[i]\
    \ = \"Eight\"\n        elseif reversed_arr[i] == 9\n            reversed_arr[i]\
    \ = \"Nine\"\n        end\n    end\n    return reversed_arr\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2, 1, 1, 4, 5,\
    \ 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpiazr4eb4.jl:56\\n  Test threw\
    \ exception\\n  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\\n  MethodError:\
    \ Cannot `convert` an object of type String to an object of type Int64\\n  Closest\
    \ candidates are:\\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\\\
    n    convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\\n  \
    \  convert(::Type{T}, !Matched::Ptr) where T<:Integer at pointer.jl:23\\n    ...\\\
    n  Stacktrace:\\n   [1] setindex!(::Array{Int64,1}, ::String, ::Int64) at ./array.jl:826\\\
    n   [2] by_length(::Array{Int64,1}) at /tmp/tmpiazr4eb4.jl:44\\n   [3] top-level\
    \ scope at /tmp/tmpiazr4eb4.jl:56\\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmpiazr4eb4.jl:55\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpiazr4eb4.jl:58\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\\n  MethodError: Cannot `convert` an object of type String\
    \ to an object of type Int64\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpiazr4eb4.jl:30\\n   [3] top-level scope at /tmp/tmpiazr4eb4.jl:58\\\
    n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmpiazr4eb4.jl:55\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpiazr4eb4.jl:59\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\\n  MethodError: Cannot `convert`\
    \ an object of type String to an object of type Int64\\n  Closest candidates are:\\\
    n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpiazr4eb4.jl:34\\n   [3] top-level scope at /tmp/tmpiazr4eb4.jl:59\\\
    n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmpiazr4eb4.jl:55\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpiazr4eb4.jl:60\\n  Test threw exception\\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\\n  MethodError: Cannot `convert`\
    \ an object of type String to an object of type Int64\\n  Closest candidates are:\\\
    n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpiazr4eb4.jl:46\\n   [3] top-level scope at /tmp/tmpiazr4eb4.jl:60\\\
    n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmpiazr4eb4.jl:55\\n  \\nTest Summary: | Pass\
    \  Error  Total\\ntest set      |    1      4      5\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # create a dictionary to map\
    \ numbers to their names\n    dict = Dict(1 => \"One\", 2 => \"Two\", 3 => \"\
    Three\", 4 => \"Four\", 5 => \"Five\", 6 => \"Six\", 7 => \"Seven\", 8 => \"Eight\"\
    , 9 => \"Nine\")\n    # create a new array to store the names\n    names = []\n\
    \    # loop through the array\n    for i in arr\n        # if the number is between\
    \ 1 and 9 inclusive\n        if i >= 1 && i <= 9\n            # append the name\
    \ of the number to the names array\n            push!(names, dict[i])\n      \
    \  end\n    end\n    # return the names array\n    return names\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2, 1, 1, 4, 5,\
    \ 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    arr = sort(arr)\n    arr\
    \ = reverse(arr)\n    arr = [string(i) for i in arr]\n    return arr\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2, 1, 1,\
    \ 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp03781o_h.jl:33\n  Expression: candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"]\n   Evaluated: [\"8\", \"5\", \"4\", \"3\", \"2\"\
    , \"2\", \"1\", \"1\"] == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\",\
    \ \"Two\", \"One\", \"One\"]\nStacktrace:\n [1] top-level scope at /tmp/tmp03781o_h.jl:33\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp03781o_h.jl:32\ntest set: Test Failed at /tmp/tmp03781o_h.jl:35\n\
    \  Expression: candidate([1, -1, 55]) == [\"One\"]\n   Evaluated: [\"55\", \"\
    1\", \"-1\"] == [\"One\"]\nStacktrace:\n [1] top-level scope at /tmp/tmp03781o_h.jl:35\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp03781o_h.jl:32\ntest set: Test Failed at /tmp/tmp03781o_h.jl:36\n\
    \  Expression: candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n   Evaluated:\
    \ [\"3\", \"2\", \"1\", \"-1\"] == [\"Three\", \"Two\", \"One\"]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp03781o_h.jl:36\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp03781o_h.jl:32\ntest set: Test Failed at /tmp/tmp03781o_h.jl:37\n\
    \  Expression: candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n   Evaluated:\
    \ [\"9\", \"8\", \"4\"] == [\"Nine\", \"Eight\", \"Four\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp03781o_h.jl:37\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp03781o_h.jl:32\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp03781o_h.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    #\
    \ reverse the array\n    # replace each digit by its corresponding name\n    #\
    \ return the array\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\
    \t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\"\
    , \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp3be29lsm.jl:33\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp3be29lsm.jl:27\n\
    \   [2] top-level scope at /tmp/tmp3be29lsm.jl:33\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3be29lsm.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmp3be29lsm.jl:34\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{String}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp3be29lsm.jl:27\n\
    \   [2] top-level scope at /tmp/tmp3be29lsm.jl:34\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3be29lsm.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmp3be29lsm.jl:35\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp3be29lsm.jl:27\n\
    \   [2] top-level scope at /tmp/tmp3be29lsm.jl:35\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3be29lsm.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmp3be29lsm.jl:36\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp3be29lsm.jl:27\n\
    \   [2] top-level scope at /tmp/tmp3be29lsm.jl:36\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3be29lsm.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmp3be29lsm.jl:37\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp3be29lsm.jl:27\n\
    \   [2] top-level scope at /tmp/tmp3be29lsm.jl:37\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp3be29lsm.jl:32\n  \nTest Summary: | Error \
    \ Total\ntest set      |     5      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3be29lsm.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sorted_arr\
    \ = sort(arr)\n    # reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # replace each digit by its corresponding name from \"One\", \"Two\", \"\
    Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\n    # create\
    \ an array of strings\n    string_arr = []\n    # iterate over the array\n   \
    \ for i in reversed_arr\n        # check if the number is between 1 and 9\n  \
    \      if i >= 1 && i <= 9\n            # append the corresponding string to the\
    \ array\n            push!(string_arr, string(i))\n        end\n    end\n    #\
    \ return the array\n    return string_arr\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmps6xhupuh.jl:46\\n  Expression: candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"]\\n   Evaluated: [\"8\", \"5\", \"4\", \"3\", \"2\"\
    , \"2\", \"1\", \"1\"] == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\",\
    \ \"Two\", \"One\", \"One\"]\\nStacktrace:\\n [1] top-level scope at /tmp/tmps6xhupuh.jl:46\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmps6xhupuh.jl:45\\ntest set: Test Failed at /tmp/tmps6xhupuh.jl:48\\\
    n  Expression: candidate([1, -1, 55]) == [\"One\"]\\n   Evaluated: [\"1\"] ==\
    \ [\"One\"]\\nStacktrace:\\n [1] top-level scope at /tmp/tmps6xhupuh.jl:48\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmps6xhupuh.jl:45\\ntest set: Test Failed at /tmp/tmps6xhupuh.jl:49\\\
    n  Expression: candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\\n  \
    \ Evaluated: [\"3\", \"2\", \"1\"] == [\"Three\", \"Two\", \"One\"]\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmps6xhupuh.jl:49\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmps6xhupuh.jl:45\\ntest set: Test Failed at /tmp/tmps6xhupuh.jl:50\\\
    n  Expression: candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\\n   Evaluated:\
    \ [\"9\", \"8\", \"4\"] == [\"Nine\", \"Eight\", \"Four\"]\\nStacktrace:\\n [1]\
    \ top-level scope at /tmp/tmps6xhupuh.jl:50\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmps6xhupuh.jl:45\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    1     4      5\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sorted_arr\
    \ = sort(arr)\n    # reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # replace each digit by its corresponding name from \"One\", \"Two\", \"\
    Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\n    # create\
    \ a dictionary\n    d = Dict(\"1\" => \"One\", \"2\" => \"Two\", \"3\" => \"Three\"\
    , \"4\" => \"Four\", \"5\" => \"Five\", \"6\" => \"Six\", \"7\" => \"Seven\",\
    \ \"8\" => \"Eight\", \"9\" => \"Nine\")\n    # create a new array\n    new_arr\
    \ = []\n    # loop through the array\n    for i in reversed_arr\n        # if\
    \ the element is between 1 and 9 inclusive\n        if i >= 1 && i <= 9\n    \
    \        # append the corresponding name to the new array\n            push!(new_arr,\
    \ d[string(i)])\n        end\n    end\n    # return the new array\n    return\
    \ new_arr\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    arr = sort(arr)\n    arr\
    \ = reverse(arr)\n    arr = [string(x) for x in arr]\n    return arr\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2, 1, 1,\
    \ 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpxqn657d6.jl:33\n  Expression: candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"]\n   Evaluated: [\"8\", \"5\", \"4\", \"3\", \"2\"\
    , \"2\", \"1\", \"1\"] == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\",\
    \ \"Two\", \"One\", \"One\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpxqn657d6.jl:33\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxqn657d6.jl:32\ntest set: Test Failed at /tmp/tmpxqn657d6.jl:35\n\
    \  Expression: candidate([1, -1, 55]) == [\"One\"]\n   Evaluated: [\"55\", \"\
    1\", \"-1\"] == [\"One\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpxqn657d6.jl:35\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxqn657d6.jl:32\ntest set: Test Failed at /tmp/tmpxqn657d6.jl:36\n\
    \  Expression: candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n   Evaluated:\
    \ [\"3\", \"2\", \"1\", \"-1\"] == [\"Three\", \"Two\", \"One\"]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpxqn657d6.jl:36\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxqn657d6.jl:32\ntest set: Test Failed at /tmp/tmpxqn657d6.jl:37\n\
    \  Expression: candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n   Evaluated:\
    \ [\"9\", \"8\", \"4\"] == [\"Nine\", \"Eight\", \"Four\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpxqn657d6.jl:37\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxqn657d6.jl:32\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxqn657d6.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # create a dictionary to map\
    \ the numbers to their names\n    dict = Dict(1 => \"One\", 2 => \"Two\", 3 =>\
    \ \"Three\", 4 => \"Four\", 5 => \"Five\", 6 => \"Six\", 7 => \"Seven\", 8 =>\
    \ \"Eight\", 9 => \"Nine\")\n    # create an empty array to store the names\n\
    \    names = []\n    # iterate through the array\n    for i in arr\n        #\
    \ if the number is in the dictionary, append it to the names array\n        if\
    \ i in keys(dict)\n            push!(names, dict[i])\n        end\n    end\n \
    \   # return the names array\n    return names\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    arr = sort(arr)\n    arr\
    \ = reverse(arr)\n    arr = filter(x -> x in 1:9, arr)\n    arr = map(x -> string(x),\
    \ arr)\n    arr = map(x -> replace(x, \"1\" => \"One\", \"2\" => \"Two\", \"3\"\
    \ => \"Three\", \"4\" => \"Four\", \"5\" => \"Five\", \"6\" => \"Six\", \"7\"\
    \ => \"Seven\", \"8\" => \"Eight\", \"9\" => \"Nine\"), arr)\n    return arr\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp4iz3xvxh.jl:35\\n  Test threw\
    \ exception\\n  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\\n  MethodError:\
    \ no method matching similar(::String, ::Type{Any})\\n  Closest candidates are:\\\
    n    similar(!Matched::Array{T,1}, ::Type) where T at array.jl:358\\n    similar(!Matched::Array{T,2},\
    \ ::Type) where T at array.jl:359\\n    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}})\
    \ where N at array.jl:361\\n    ...\\n  Stacktrace:\\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\\n\
    \   [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmp4iz3xvxh.jl:27\\n   [5] iterate at ./generator.jl:47 [inlined]\\\
    n   [6] _collect at ./array.jl:678 [inlined]\\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\\n   [8] map at ./abstractarray.jl:2072 [inlined]\\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmp4iz3xvxh.jl:27\\n   [10] top-level scope at /tmp/tmp4iz3xvxh.jl:35\\\
    n   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [12] top-level scope at /tmp/tmp4iz3xvxh.jl:34\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp4iz3xvxh.jl:37\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\\n  MethodError: no method matching similar(::String,\
    \ ::Type{Any})\\n  Closest candidates are:\\n    similar(!Matched::Array{T,1},\
    \ ::Type) where T at array.jl:358\\n    similar(!Matched::Array{T,2}, ::Type)\
    \ where T at array.jl:359\\n    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}})\
    \ where N at array.jl:361\\n    ...\\n  Stacktrace:\\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\\n\
    \   [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmp4iz3xvxh.jl:27\\n   [5] iterate at ./generator.jl:47 [inlined]\\\
    n   [6] _collect at ./array.jl:678 [inlined]\\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\\n   [8] map at ./abstractarray.jl:2072 [inlined]\\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmp4iz3xvxh.jl:27\\n   [10] top-level scope at /tmp/tmp4iz3xvxh.jl:37\\\
    n   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [12] top-level scope at /tmp/tmp4iz3xvxh.jl:34\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp4iz3xvxh.jl:38\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\\n  MethodError: no method matching\
    \ similar(::String, ::Type{Any})\\n  Closest candidates are:\\n    similar(!Matched::Array{T,1},\
    \ ::Type) where T at array.jl:358\\n    similar(!Matched::Array{T,2}, ::Type)\
    \ where T at array.jl:359\\n    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}})\
    \ where N at array.jl:361\\n    ...\\n  Stacktrace:\\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\\n\
    \   [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmp4iz3xvxh.jl:27\\n   [5] iterate at ./generator.jl:47 [inlined]\\\
    n   [6] _collect at ./array.jl:678 [inlined]\\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\\n   [8] map at ./abstractarray.jl:2072 [inlined]\\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmp4iz3xvxh.jl:27\\n   [10] top-level scope at /tmp/tmp4iz3xvxh.jl:38\\\
    n   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [12] top-level scope at /tmp/tmp4iz3xvxh.jl:34\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp4iz3xvxh.jl:39\\n  Test threw exception\\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\\n  MethodError: no method matching\
    \ similar(::String, ::Type{Any})\\n  Closest candidates are:\\n    similar(!Matched::Array{T,1},\
    \ ::Type) where T at array.jl:358\\n    similar(!Matched::Array{T,2}, ::Type)\
    \ where T at array.jl:359\\n    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}})\
    \ where N at array.jl:361\\n    ...\\n  Stacktrace:\\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\\n\
    \   [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmp4iz3xvxh.jl:27\\n   [5] iterate at ./generator.jl:47 [inlined]\\\
    n   [6] _collect at ./array.jl:678 [inlined]\\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\\n   [8] map at ./abstractarray.jl:2072 [inlined]\\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmp4iz3xvxh.jl:27\\n   [10] top-level scope at /tmp/tmp4iz3xvxh.jl:39\\\
    n   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [12] top-level scope at /tmp/tmp4iz3xvxh.jl:34\\n  \\nTest Summary: | Pass\
    \  Error  Total\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # create a dictionary\n    dict\
    \ = Dict(\"One\" => 1, \"Two\" => 2, \"Three\" => 3, \"Four\" => 4, \"Five\" =>\
    \ 5, \"Six\" => 6, \"Seven\" => 7, \"Eight\" => 8, \"Nine\" => 9)\n    # create\
    \ a vector of strings\n    str_vec = String[]\n    # iterate over the array\n\
    \    for i in arr\n        # check if the number is between 1 and 9\n        if\
    \ i in 1:9\n            # iterate over the dictionary\n            for (key, value)\
    \ in dict\n                # check if the value is equal to the number\n     \
    \           if value == i\n                    # push the key to the vector\n\
    \                    push!(str_vec, key)\n                end\n            end\n\
    \        end\n    end\n    # return the vector\n    return str_vec\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2, 1, 1,\
    \ 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # replace each digit by its corresponding\
    \ name from \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\"\n    # if the array is empty, return an empty array\n  \
    \  if length(arr) == 0\n        return []\n    end\n    # if the array has any\
    \ strange number ignore it\n    if length(arr) == 1 && arr[1] > 9\n        return\
    \ []\n    end\n    # if the array has any strange number ignore it\n    if length(arr)\
    \ == 1 && arr[1] < 1\n        return []\n    end\n    # if the array has any strange\
    \ number ignore it\n    if length(arr) == 1 && arr[1] == 0\n        return []\n\
    \    end\n    # if the array has any strange number ignore it\n    if length(arr)\
    \ == 1 && arr[1] == -1\n        return []\n    end\n    # if the array has any\
    \ strange number ignore it\n    if length(arr) == 1 && arr[1] == -2\n        return\
    \ []\n    end\n    # if the array has any strange number ignore it\n    if length(arr)\
    \ == 1 && arr[1] == -3\n        return []\n    end\n    # if the array has any\
    \ strange number ignore it\n    if length(arr) == 1 && arr[1] == -4\n        return\
    \ []\n    end\n    # if the array has any strange number ignore it\n    if length(arr)\
    \ == 1 && arr[1] == -5\n        return []\n    end\n    # if the array has any\
    \ strange number ignore it\n    if length(arr) == 1 && arr[1] == -6\n        return\
    \ []\n    end\n    # if the array has any strange number ignore it\n    if length(arr)\
    \ == 1 && arr[1] == -7\n        return []\n    end\n    # if the array has any\
    \ strange number ignore it\n    if length(arr) == 1 && arr[1] == -8\n        return\
    \ []\n    end\n    # if the array has any strange number ignore it\n    if length(arr)\
    \ == 1 && arr[1]\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp4shdvonr.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp4shdvonr.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sorted_arr\
    \ = sort(arr)\n    # reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # replace each digit by its corresponding name from \"One\", \"Two\", \"\
    Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\n    # create\
    \ a dictionary\n    d = Dict(\"1\" => \"One\", \"2\" => \"Two\", \"3\" => \"Three\"\
    , \"4\" => \"Four\", \"5\" => \"Five\", \"6\" => \"Six\", \"7\" => \"Seven\",\
    \ \"8\" => \"Eight\", \"9\" => \"Nine\")\n    # create an empty array\n    new_arr\
    \ = []\n    # iterate over the reversed array\n    for i in reversed_arr\n   \
    \     # check if the element is between 1 and 9\n        if i >= 1 && i <= 9\n\
    \            # append the corresponding name to the new array\n            push!(new_arr,\
    \ d[string(i)])\n        end\n    end\n    # return the new array\n    return\
    \ new_arr\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sorted_arr\
    \ = sort(arr)\n    # reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # replace each digit by its corresponding name from \"One\", \"Two\", \"\
    Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\n    # create\
    \ a dictionary\n    dict = Dict(\"1\" => \"One\", \"2\" => \"Two\", \"3\" => \"\
    Three\", \"4\" => \"Four\", \"5\" => \"Five\", \"6\" => \"Six\", \"7\" => \"Seven\"\
    , \"8\" => \"Eight\", \"9\" => \"Nine\")\n    # create a new array\n    new_arr\
    \ = []\n    # loop through the reversed array\n    for i in reversed_arr\n   \
    \     # if the value is between 1 and 9 inclusive\n        if i >= 1 && i <= 9\n\
    \            # push the value to the new array\n            push!(new_arr, dict[string(i)])\n\
    \        end\n    end\n    # return the new array\n    return new_arr\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2, 1, 1,\
    \ 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sorted_arr\
    \ = sort(arr)\n    # reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # replace each digit by its corresponding name from \"One\", \"Two\", \"\
    Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\n    result\
    \ = []\n    for i in reversed_arr\n        if i == 1\n            push!(result,\
    \ \"One\")\n        elseif i == 2\n            push!(result, \"Two\")\n      \
    \  elseif i == 3\n            push!(result, \"Three\")\n        elseif i == 4\n\
    \            push!(result, \"Four\")\n        elseif i == 5\n            push!(result,\
    \ \"Five\")\n        elseif i == 6\n            push!(result, \"Six\")\n     \
    \   elseif i == 7\n            push!(result, \"Seven\")\n        elseif i == 8\n\
    \            push!(result, \"Eight\")\n        elseif i == 9\n            push!(result,\
    \ \"Nine\")\n        end\n    end\n    return result\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3])\
    \ == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"\
    One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\t@test(candidate([1,\
    \ -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2]) == [\"Three\", \"Two\"\
    , \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    arr = sort(arr)\n    arr\
    \ = reverse(arr)\n    arr = filter(x -> x in 1:9, arr)\n    return [string(x)\
    \ for x in arr]\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\
    \t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\"\
    , \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmppm450di2.jl:33\n  Expression: candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"]\n   Evaluated: [\"8\", \"5\", \"4\", \"3\", \"2\"\
    , \"2\", \"1\", \"1\"] == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\",\
    \ \"Two\", \"One\", \"One\"]\nStacktrace:\n [1] top-level scope at /tmp/tmppm450di2.jl:33\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmppm450di2.jl:32\ntest set: Test Failed at /tmp/tmppm450di2.jl:35\n\
    \  Expression: candidate([1, -1, 55]) == [\"One\"]\n   Evaluated: [\"1\"] == [\"\
    One\"]\nStacktrace:\n [1] top-level scope at /tmp/tmppm450di2.jl:35\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmppm450di2.jl:32\ntest set: Test Failed at /tmp/tmppm450di2.jl:36\n\
    \  Expression: candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n   Evaluated:\
    \ [\"3\", \"2\", \"1\"] == [\"Three\", \"Two\", \"One\"]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmppm450di2.jl:36\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmppm450di2.jl:32\ntest set: Test Failed at /tmp/tmppm450di2.jl:37\n\
    \  Expression: candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n   Evaluated:\
    \ [\"9\", \"8\", \"4\"] == [\"Nine\", \"Eight\", \"Four\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmppm450di2.jl:37\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmppm450di2.jl:32\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmppm450di2.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sorted_arr\
    \ = sort(arr)\n    # reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # replace each digit by its corresponding name from \"One\", \"Two\", \"\
    Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\n    result\
    \ = []\n    for i in reversed_arr\n        if i == 1\n            push!(result,\
    \ \"One\")\n        elseif i == 2\n            push!(result, \"Two\")\n      \
    \  elseif i == 3\n            push!(result, \"Three\")\n        elseif i == 4\n\
    \            push!(result, \"Four\")\n        elseif i == 5\n            push!(result,\
    \ \"Five\")\n        elseif i == 6\n            push!(result, \"Six\")\n     \
    \   elseif i == 7\n            push!(result, \"Seven\")\n        elseif i == 8\n\
    \            push!(result, \"Eight\")\n        elseif i == 9\n            push!(result,\
    \ \"Nine\")\n        end\n    end\n    return result\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3])\
    \ == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"\
    One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\t@test(candidate([1,\
    \ -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2]) == [\"Three\", \"Two\"\
    , \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sorted_arr\
    \ = sort(arr)\n    # reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # replace each digit by its corresponding name from \"One\", \"Two\", \"\
    Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\n    # create\
    \ a dictionary\n    dict = Dict(\"1\" => \"One\", \"2\" => \"Two\", \"3\" => \"\
    Three\", \"4\" => \"Four\", \"5\" => \"Five\", \"6\" => \"Six\", \"7\" => \"Seven\"\
    , \"8\" => \"Eight\", \"9\" => \"Nine\")\n    # create a new array\n    new_arr\
    \ = []\n    # loop through the reversed array\n    for i in reversed_arr\n   \
    \     # if the element is between 1 and 9 inclusive\n        if i >= 1 && i <=\
    \ 9\n            # append the corresponding name to the new array\n          \
    \  push!(new_arr, dict[string(i)])\n        end\n    end\n    # return the new\
    \ array\n    return new_arr\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\"\
    , \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # create a dictionary to map\
    \ the numbers to their names\n    number_names = Dict(1 => \"One\", 2 => \"Two\"\
    , 3 => \"Three\", 4 => \"Four\", 5 => \"Five\", 6 => \"Six\", 7 => \"Seven\",\
    \ 8 => \"Eight\", 9 => \"Nine\")\n    # create a vector to store the names\n \
    \   names = Vector{String}()\n    # loop through the array\n    for i in arr\n\
    \        # if the number is between 1 and 9 inclusive, add its name to the vector\n\
    \        if i in keys(number_names)\n            push!(names, number_names[i])\n\
    \        end\n    end\n    # return the vector of names\n    return names\nend\n\
    using Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    \"\"\"\n    Given an array\
    \ of integers, sort the integers that are between 1 and 9 inclusive,\n    reverse\
    \ the resulting array, and then replace each digit by its corresponding name from\n\
    \    \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\"\
    , \"Nine\".\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpe__1cd56.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpe__1cd56.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    arr = sort(arr)\n    arr\
    \ = reverse(arr)\n    result = []\n    for i in arr\n        if i == 1\n     \
    \       push!(result, \"One\")\n        elseif i == 2\n            push!(result,\
    \ \"Two\")\n        elseif i == 3\n            push!(result, \"Three\")\n    \
    \    elseif i == 4\n            push!(result, \"Four\")\n        elseif i == 5\n\
    \            push!(result, \"Five\")\n        elseif i == 6\n            push!(result,\
    \ \"Six\")\n        elseif i == 7\n            push!(result, \"Seven\")\n    \
    \    elseif i == 8\n            push!(result, \"Eight\")\n        elseif i ==\
    \ 9\n            push!(result, \"Nine\")\n        end\n    end\n    return result\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # replace each digit by its corresponding\
    \ name from \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\"\n    for i in 1:length(arr)\n        if arr[i] == 1\n  \
    \          arr[i] = \"One\"\n        elseif arr[i] == 2\n            arr[i] =\
    \ \"Two\"\n        elseif arr[i] == 3\n            arr[i] = \"Three\"\n      \
    \  elseif arr[i] == 4\n            arr[i] = \"Four\"\n        elseif arr[i] ==\
    \ 5\n            arr[i] = \"Five\"\n        elseif arr[i] == 6\n            arr[i]\
    \ = \"Six\"\n        elseif arr[i] == 7\n            arr[i] = \"Seven\"\n    \
    \    elseif arr[i] == 8\n            arr[i] = \"Eight\"\n        elseif arr[i]\
    \ == 9\n            arr[i] = \"Nine\"\n        end\n    end\n    # return the\
    \ array\n    return arr\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\
    \t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\"\
    , \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpq934ovb7.jl:57\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: Cannot\
    \ `convert` an object of type String to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] setindex!(::Array{Int64,1}, ::String, ::Int64) at ./array.jl:826\n   [2]\
    \ by_length(::Array{Int64,1}) at /tmp/tmpq934ovb7.jl:44\n   [3] top-level scope\
    \ at /tmp/tmpq934ovb7.jl:57\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpq934ovb7.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmpq934ovb7.jl:59\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: Cannot `convert` an object of type String\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpq934ovb7.jl:30\n   [3] top-level scope at /tmp/tmpq934ovb7.jl:59\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpq934ovb7.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmpq934ovb7.jl:60\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: Cannot `convert`\
    \ an object of type String to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpq934ovb7.jl:34\n   [3] top-level scope at /tmp/tmpq934ovb7.jl:60\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpq934ovb7.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmpq934ovb7.jl:61\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: Cannot `convert` an\
    \ object of type String to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpq934ovb7.jl:46\n   [3] top-level scope at /tmp/tmpq934ovb7.jl:61\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpq934ovb7.jl:56\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    1      4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpq934ovb7.jl:54\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # replace each digit by its corresponding\
    \ name from \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\"\n    for i in 1:length(arr)\n        if arr[i] == 1\n  \
    \          arr[i] = \"One\"\n        elseif arr[i] == 2\n            arr[i] =\
    \ \"Two\"\n        elseif arr[i] == 3\n            arr[i] = \"Three\"\n      \
    \  elseif arr[i] == 4\n            arr[i] = \"Four\"\n        elseif arr[i] ==\
    \ 5\n            arr[i] = \"Five\"\n        elseif arr[i] == 6\n            arr[i]\
    \ = \"Six\"\n        elseif arr[i] == 7\n            arr[i] = \"Seven\"\n    \
    \    elseif arr[i] == 8\n            arr[i] = \"Eight\"\n        elseif arr[i]\
    \ == 9\n            arr[i] = \"Nine\"\n        end\n    end\n    # return the\
    \ array\n    return arr\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\
    \t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\"\
    , \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmphywleljx.jl:57\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: Cannot\
    \ `convert` an object of type String to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] setindex!(::Array{Int64,1}, ::String, ::Int64) at ./array.jl:826\n   [2]\
    \ by_length(::Array{Int64,1}) at /tmp/tmphywleljx.jl:44\n   [3] top-level scope\
    \ at /tmp/tmphywleljx.jl:57\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmphywleljx.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmphywleljx.jl:59\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: Cannot `convert` an object of type String\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmphywleljx.jl:30\n   [3] top-level scope at /tmp/tmphywleljx.jl:59\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmphywleljx.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmphywleljx.jl:60\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: Cannot `convert`\
    \ an object of type String to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmphywleljx.jl:34\n   [3] top-level scope at /tmp/tmphywleljx.jl:60\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmphywleljx.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmphywleljx.jl:61\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: Cannot `convert` an\
    \ object of type String to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmphywleljx.jl:46\n   [3] top-level scope at /tmp/tmphywleljx.jl:61\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmphywleljx.jl:56\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    1      4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphywleljx.jl:54\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sorted_arr\
    \ = sort(arr)\n    # reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # create a dictionary to map the numbers to their names\n    dict = Dict(1\
    \ => \"One\", 2 => \"Two\", 3 => \"Three\", 4 => \"Four\", 5 => \"Five\", 6 =>\
    \ \"Six\", 7 => \"Seven\", 8 => \"Eight\", 9 => \"Nine\")\n    # create an empty\
    \ array to store the names\n    names = []\n    # loop through the array\n   \
    \ for i in reversed_arr\n        # if the number is between 1 and 9, push its\
    \ name to the names array\n        if i in 1:9\n            push!(names, dict[i])\n\
    \        end\n    end\n    # return the names array\n    return names\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2, 1, 1,\
    \ 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    arr = sort(arr)\n    arr\
    \ = reverse(arr)\n    arr = [string(i) for i in arr]\n    return arr\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2, 1, 1,\
    \ 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpb9w5j9ft.jl:33\n  Expression: candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"]\n   Evaluated: [\"8\", \"5\", \"4\", \"3\", \"2\"\
    , \"2\", \"1\", \"1\"] == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\",\
    \ \"Two\", \"One\", \"One\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpb9w5j9ft.jl:33\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpb9w5j9ft.jl:32\ntest set: Test Failed at /tmp/tmpb9w5j9ft.jl:35\n\
    \  Expression: candidate([1, -1, 55]) == [\"One\"]\n   Evaluated: [\"55\", \"\
    1\", \"-1\"] == [\"One\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpb9w5j9ft.jl:35\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpb9w5j9ft.jl:32\ntest set: Test Failed at /tmp/tmpb9w5j9ft.jl:36\n\
    \  Expression: candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n   Evaluated:\
    \ [\"3\", \"2\", \"1\", \"-1\"] == [\"Three\", \"Two\", \"One\"]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpb9w5j9ft.jl:36\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpb9w5j9ft.jl:32\ntest set: Test Failed at /tmp/tmpb9w5j9ft.jl:37\n\
    \  Expression: candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n   Evaluated:\
    \ [\"9\", \"8\", \"4\"] == [\"Nine\", \"Eight\", \"Four\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpb9w5j9ft.jl:37\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpb9w5j9ft.jl:32\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpb9w5j9ft.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    arr = sort(arr)\n    arr\
    \ = reverse(arr)\n    arr = filter(x -> x in 1:9, arr)\n    arr = map(x -> string(x),\
    \ arr)\n    arr = map(x -> replace(x, \"1\" => \"One\", \"2\" => \"Two\", \"3\"\
    \ => \"Three\", \"4\" => \"Four\", \"5\" => \"Five\", \"6\" => \"Six\", \"7\"\
    \ => \"Seven\", \"8\" => \"Eight\", \"9\" => \"Nine\"), arr)\n    return arr\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp38nee5pq.jl:35\\n  Test threw\
    \ exception\\n  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\\n  MethodError:\
    \ no method matching similar(::String, ::Type{Any})\\n  Closest candidates are:\\\
    n    similar(!Matched::Array{T,1}, ::Type) where T at array.jl:358\\n    similar(!Matched::Array{T,2},\
    \ ::Type) where T at array.jl:359\\n    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}})\
    \ where N at array.jl:361\\n    ...\\n  Stacktrace:\\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\\n\
    \   [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmp38nee5pq.jl:27\\n   [5] iterate at ./generator.jl:47 [inlined]\\\
    n   [6] _collect at ./array.jl:678 [inlined]\\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\\n   [8] map at ./abstractarray.jl:2072 [inlined]\\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmp38nee5pq.jl:27\\n   [10] top-level scope at /tmp/tmp38nee5pq.jl:35\\\
    n   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [12] top-level scope at /tmp/tmp38nee5pq.jl:34\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp38nee5pq.jl:37\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\\n  MethodError: no method matching similar(::String,\
    \ ::Type{Any})\\n  Closest candidates are:\\n    similar(!Matched::Array{T,1},\
    \ ::Type) where T at array.jl:358\\n    similar(!Matched::Array{T,2}, ::Type)\
    \ where T at array.jl:359\\n    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}})\
    \ where N at array.jl:361\\n    ...\\n  Stacktrace:\\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\\n\
    \   [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmp38nee5pq.jl:27\\n   [5] iterate at ./generator.jl:47 [inlined]\\\
    n   [6] _collect at ./array.jl:678 [inlined]\\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\\n   [8] map at ./abstractarray.jl:2072 [inlined]\\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmp38nee5pq.jl:27\\n   [10] top-level scope at /tmp/tmp38nee5pq.jl:37\\\
    n   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [12] top-level scope at /tmp/tmp38nee5pq.jl:34\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp38nee5pq.jl:38\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\\n  MethodError: no method matching\
    \ similar(::String, ::Type{Any})\\n  Closest candidates are:\\n    similar(!Matched::Array{T,1},\
    \ ::Type) where T at array.jl:358\\n    similar(!Matched::Array{T,2}, ::Type)\
    \ where T at array.jl:359\\n    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}})\
    \ where N at array.jl:361\\n    ...\\n  Stacktrace:\\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\\n\
    \   [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmp38nee5pq.jl:27\\n   [5] iterate at ./generator.jl:47 [inlined]\\\
    n   [6] _collect at ./array.jl:678 [inlined]\\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\\n   [8] map at ./abstractarray.jl:2072 [inlined]\\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmp38nee5pq.jl:27\\n   [10] top-level scope at /tmp/tmp38nee5pq.jl:38\\\
    n   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [12] top-level scope at /tmp/tmp38nee5pq.jl:34\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp38nee5pq.jl:39\\n  Test threw exception\\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\\n  MethodError: no method matching\
    \ similar(::String, ::Type{Any})\\n  Closest candidates are:\\n    similar(!Matched::Array{T,1},\
    \ ::Type) where T at array.jl:358\\n    similar(!Matched::Array{T,2}, ::Type)\
    \ where T at array.jl:359\\n    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}})\
    \ where N at array.jl:361\\n    ...\\n  Stacktrace:\\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\\n\
    \   [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmp38nee5pq.jl:27\\n   [5] iterate at ./generator.jl:47 [inlined]\\\
    n   [6] _collect at ./array.jl:678 [inlined]\\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\\n   [8] map at ./abstractarray.jl:2072 [inlined]\\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmp38nee5pq.jl:27\\n   [10] top-level scope at /tmp/tmp38nee5pq.jl:39\\\
    n   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [12] top-level scope at /tmp/tmp38nee5pq.jl:34\\n  \\nTest Summary: | Pass\
    \  Error  Total\\ntest set      |    1      4      5\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    #\
    \ reverse the array\n    # replace each digit by its corresponding name from \"\
    One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\",\
    \ \"Nine\"\n    # return the array\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"\
    Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpw641npnm.jl:33\\n  Test threw\
    \ exception\\n  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{String,1}\\\
    n  Closest candidates are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] by_length(::Array{Int64,1}) at /tmp/tmpw641npnm.jl:27\\\
    n   [2] top-level scope at /tmp/tmpw641npnm.jl:33\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpw641npnm.jl:32\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpw641npnm.jl:34\\n  Test threw exception\\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{String}([])\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\\n  Closest candidates are:\\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] by_length(::Array{Int64,1}) at /tmp/tmpw641npnm.jl:27\\\
    n   [2] top-level scope at /tmp/tmpw641npnm.jl:34\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpw641npnm.jl:32\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpw641npnm.jl:35\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\\n  Closest candidates are:\\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] by_length(::Array{Int64,1}) at /tmp/tmpw641npnm.jl:27\\\
    n   [2] top-level scope at /tmp/tmpw641npnm.jl:35\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpw641npnm.jl:32\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpw641npnm.jl:36\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{String,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] by_length(::Array{Int64,1}) at /tmp/tmpw641npnm.jl:27\\\
    n   [2] top-level scope at /tmp/tmpw641npnm.jl:36\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpw641npnm.jl:32\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpw641npnm.jl:37\\n  Test threw exception\\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{String,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] by_length(::Array{Int64,1}) at /tmp/tmpw641npnm.jl:27\\\
    n   [2] top-level scope at /tmp/tmpw641npnm.jl:37\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpw641npnm.jl:32\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # replace each digit by its corresponding\
    \ name from \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\"\n    for i in 1:length(arr)\n        if arr[i] == 1\n  \
    \          arr[i] = \"One\"\n        elseif arr[i] == 2\n            arr[i] =\
    \ \"Two\"\n        elseif arr[i] == 3\n            arr[i] = \"Three\"\n      \
    \  elseif arr[i] == 4\n            arr[i] = \"Four\"\n        elseif arr[i] ==\
    \ 5\n            arr[i] = \"Five\"\n        elseif arr[i] == 6\n            arr[i]\
    \ = \"Six\"\n        elseif arr[i] == 7\n            arr[i] = \"Seven\"\n    \
    \    elseif arr[i] == 8\n            arr[i] = \"Eight\"\n        elseif arr[i]\
    \ == 9\n            arr[i] = \"Nine\"\n        end\n    end\n    # return the\
    \ array\n    return arr\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\
    \t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\"\
    , \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp21b5lpir.jl:57\\n  Test threw\
    \ exception\\n  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\\n  MethodError:\
    \ Cannot `convert` an object of type String to an object of type Int64\\n  Closest\
    \ candidates are:\\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\\\
    n    convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\\n  \
    \  convert(::Type{T}, !Matched::Ptr) where T<:Integer at pointer.jl:23\\n    ...\\\
    n  Stacktrace:\\n   [1] setindex!(::Array{Int64,1}, ::String, ::Int64) at ./array.jl:826\\\
    n   [2] by_length(::Array{Int64,1}) at /tmp/tmp21b5lpir.jl:44\\n   [3] top-level\
    \ scope at /tmp/tmp21b5lpir.jl:57\\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmp21b5lpir.jl:56\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp21b5lpir.jl:59\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\\n  MethodError: Cannot `convert` an object of type String\
    \ to an object of type Int64\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmp21b5lpir.jl:30\\n   [3] top-level scope at /tmp/tmp21b5lpir.jl:59\\\
    n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmp21b5lpir.jl:56\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp21b5lpir.jl:60\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\\n  MethodError: Cannot `convert`\
    \ an object of type String to an object of type Int64\\n  Closest candidates are:\\\
    n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmp21b5lpir.jl:34\\n   [3] top-level scope at /tmp/tmp21b5lpir.jl:60\\\
    n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmp21b5lpir.jl:56\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp21b5lpir.jl:61\\n  Test threw exception\\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\\n  MethodError: Cannot `convert`\
    \ an object of type String to an object of type Int64\\n  Closest candidates are:\\\
    n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmp21b5lpir.jl:46\\n   [3] top-level scope at /tmp/tmp21b5lpir.jl:61\\\
    n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmp21b5lpir.jl:56\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sorted_arr\
    \ = sort(arr)\n    # reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # replace each digit by its corresponding name from \"One\", \"Two\", \"\
    Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\n    for\
    \ i in 1:length(reversed_arr)\n        if reversed_arr[i] == 1\n            reversed_arr[i]\
    \ = \"One\"\n        elseif reversed_arr[i] == 2\n            reversed_arr[i]\
    \ = \"Two\"\n        elseif reversed_arr[i] == 3\n            reversed_arr[i]\
    \ = \"Three\"\n        elseif reversed_arr[i] == 4\n            reversed_arr[i]\
    \ = \"Four\"\n        elseif reversed_arr[i] == 5\n            reversed_arr[i]\
    \ = \"Five\"\n        elseif reversed_arr[i] == 6\n            reversed_arr[i]\
    \ = \"Six\"\n        elseif reversed_arr[i] == 7\n            reversed_arr[i]\
    \ = \"Seven\"\n        elseif reversed_arr[i] == 8\n            reversed_arr[i]\
    \ = \"Eight\"\n        elseif reversed_arr[i] == 9\n            reversed_arr[i]\
    \ = \"Nine\"\n        end\n    end\n    return reversed_arr\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2, 1, 1, 4, 5,\
    \ 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp5s4t1fnq.jl:56\\n  Test threw\
    \ exception\\n  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\\n  MethodError:\
    \ Cannot `convert` an object of type String to an object of type Int64\\n  Closest\
    \ candidates are:\\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\\\
    n    convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\\n  \
    \  convert(::Type{T}, !Matched::Ptr) where T<:Integer at pointer.jl:23\\n    ...\\\
    n  Stacktrace:\\n   [1] setindex!(::Array{Int64,1}, ::String, ::Int64) at ./array.jl:826\\\
    n   [2] by_length(::Array{Int64,1}) at /tmp/tmp5s4t1fnq.jl:44\\n   [3] top-level\
    \ scope at /tmp/tmp5s4t1fnq.jl:56\\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmp5s4t1fnq.jl:55\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp5s4t1fnq.jl:58\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\\n  MethodError: Cannot `convert` an object of type String\
    \ to an object of type Int64\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmp5s4t1fnq.jl:30\\n   [3] top-level scope at /tmp/tmp5s4t1fnq.jl:58\\\
    n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmp5s4t1fnq.jl:55\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp5s4t1fnq.jl:59\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\\n  MethodError: Cannot `convert`\
    \ an object of type String to an object of type Int64\\n  Closest candidates are:\\\
    n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmp5s4t1fnq.jl:34\\n   [3] top-level scope at /tmp/tmp5s4t1fnq.jl:59\\\
    n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmp5s4t1fnq.jl:55\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp5s4t1fnq.jl:60\\n  Test threw exception\\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\\n  MethodError: Cannot `convert`\
    \ an object of type String to an object of type Int64\\n  Closest candidates are:\\\
    n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmp5s4t1fnq.jl:46\\n   [3] top-level scope at /tmp/tmp5s4t1fnq.jl:60\\\
    n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmp5s4t1fnq.jl:55\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    arr = sort(arr)\n    arr\
    \ = reverse(arr)\n    arr = [string(i) for i in arr]\n    return arr\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2, 1, 1,\
    \ 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpketlp3ra.jl:33\n  Expression: candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"]\n   Evaluated: [\"8\", \"5\", \"4\", \"3\", \"2\"\
    , \"2\", \"1\", \"1\"] == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\",\
    \ \"Two\", \"One\", \"One\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpketlp3ra.jl:33\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpketlp3ra.jl:32\ntest set: Test Failed at /tmp/tmpketlp3ra.jl:35\n\
    \  Expression: candidate([1, -1, 55]) == [\"One\"]\n   Evaluated: [\"55\", \"\
    1\", \"-1\"] == [\"One\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpketlp3ra.jl:35\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpketlp3ra.jl:32\ntest set: Test Failed at /tmp/tmpketlp3ra.jl:36\n\
    \  Expression: candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n   Evaluated:\
    \ [\"3\", \"2\", \"1\", \"-1\"] == [\"Three\", \"Two\", \"One\"]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpketlp3ra.jl:36\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpketlp3ra.jl:32\ntest set: Test Failed at /tmp/tmpketlp3ra.jl:37\n\
    \  Expression: candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n   Evaluated:\
    \ [\"9\", \"8\", \"4\"] == [\"Nine\", \"Eight\", \"Four\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpketlp3ra.jl:37\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpketlp3ra.jl:32\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpketlp3ra.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sorted_arr\
    \ = sort(arr)\n    # reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # replace each digit by its corresponding name from \"One\", \"Two\", \"\
    Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\n    # create\
    \ a dictionary\n    dict = Dict(\"1\" => \"One\", \"2\" => \"Two\", \"3\" => \"\
    Three\", \"4\" => \"Four\", \"5\" => \"Five\", \"6\" => \"Six\", \"7\" => \"Seven\"\
    , \"8\" => \"Eight\", \"9\" => \"Nine\")\n    # create a new array\n    new_arr\
    \ = []\n    # loop through the reversed array\n    for i in reversed_arr\n   \
    \     # check if the number is between 1 and 9\n        if i >= 1 && i <= 9\n\
    \            # push the corresponding name to the new array\n            push!(new_arr,\
    \ dict[string(i)])\n        end\n    end\n    # return the new array\n    return\
    \ new_arr\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # create a dictionary\n    d\
    \ = Dict(1 => \"One\", 2 => \"Two\", 3 => \"Three\", 4 => \"Four\", 5 => \"Five\"\
    , 6 => \"Six\", 7 => \"Seven\", 8 => \"Eight\", 9 => \"Nine\")\n    # create an\
    \ empty array\n    result = []\n    # loop through the array\n    for i in arr\n\
    \        # if the number is between 1 and 9 inclusive\n        if i in keys(d)\n\
    \            # append the corresponding name to the result array\n           \
    \ push!(result, d[i])\n        end\n    end\n    # return the result array\n \
    \   return result\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\
    \t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\"\
    , \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # Sort the array\n    sorted_arr\
    \ = sort(arr)\n    # Reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # Replace each digit by its corresponding name from \"One\", \"Two\", \"\
    Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\n    result\
    \ = []\n    for i in reversed_arr\n        if i == 1\n            push!(result,\
    \ \"One\")\n        elseif i == 2\n            push!(result, \"Two\")\n      \
    \  elseif i == 3\n            push!(result, \"Three\")\n        elseif i == 4\n\
    \            push!(result, \"Four\")\n        elseif i == 5\n            push!(result,\
    \ \"Five\")\n        elseif i == 6\n            push!(result, \"Six\")\n     \
    \   elseif i == 7\n            push!(result, \"Seven\")\n        elseif i == 8\n\
    \            push!(result, \"Eight\")\n        elseif i == 9\n            push!(result,\
    \ \"Nine\")\n        end\n    end\n    return result\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3])\
    \ == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"\
    One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\t@test(candidate([1,\
    \ -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2]) == [\"Three\", \"Two\"\
    , \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sorted_arr\
    \ = sort(arr)\n    # reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # replace each digit by its corresponding name from \"One\", \"Two\", \"\
    Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\n    # create\
    \ a dictionary\n    dict = Dict(\"1\" => \"One\", \"2\" => \"Two\", \"3\" => \"\
    Three\", \"4\" => \"Four\", \"5\" => \"Five\", \"6\" => \"Six\", \"7\" => \"Seven\"\
    , \"8\" => \"Eight\", \"9\" => \"Nine\")\n    # create an empty array\n    arr_string\
    \ = []\n    # loop through the reversed array\n    for i in reversed_arr\n   \
    \     # if the element is between 1 and 9 inclusive, append the corresponding\
    \ name to the array\n        if i >= 1 && i <= 9\n            push!(arr_string,\
    \ dict[string(i)])\n        end\n    end\n    # return the array\n    return arr_string\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    arr = sort(arr)\n    arr\
    \ = reverse(arr)\n    arr = [string(i) for i in arr]\n    return arr\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2, 1, 1,\
    \ 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpeddd1vl2.jl:33\\n  Expression: candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"]\\n   Evaluated: [\"8\", \"5\", \"4\", \"3\", \"2\"\
    , \"2\", \"1\", \"1\"] == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\",\
    \ \"Two\", \"One\", \"One\"]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpeddd1vl2.jl:33\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpeddd1vl2.jl:32\\ntest set: Test Failed at /tmp/tmpeddd1vl2.jl:35\\\
    n  Expression: candidate([1, -1, 55]) == [\"One\"]\\n   Evaluated: [\"55\", \"\
    1\", \"-1\"] == [\"One\"]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpeddd1vl2.jl:35\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpeddd1vl2.jl:32\\ntest set: Test Failed at /tmp/tmpeddd1vl2.jl:36\\\
    n  Expression: candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\\n  \
    \ Evaluated: [\"3\", \"2\", \"1\", \"-1\"] == [\"Three\", \"Two\", \"One\"]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpeddd1vl2.jl:36\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpeddd1vl2.jl:32\\ntest set: Test Failed at /tmp/tmpeddd1vl2.jl:37\\\
    n  Expression: candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\\n   Evaluated:\
    \ [\"9\", \"8\", \"4\"] == [\"Nine\", \"Eight\", \"Four\"]\\nStacktrace:\\n [1]\
    \ top-level scope at /tmp/tmpeddd1vl2.jl:37\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpeddd1vl2.jl:32\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # Sort the array\n    sort!(arr)\n\
    \    # Reverse the array\n    reverse!(arr)\n    # Create a dictionary to map\
    \ the numbers to their names\n    num_dict = Dict(1 => \"One\", 2 => \"Two\",\
    \ 3 => \"Three\", 4 => \"Four\", 5 => \"Five\", 6 => \"Six\", 7 => \"Seven\",\
    \ 8 => \"Eight\", 9 => \"Nine\")\n    # Create an empty array to store the names\n\
    \    names = []\n    # Iterate through the array\n    for i in arr\n        #\
    \ If the number is in the dictionary, add it to the names array\n        if i\
    \ in keys(num_dict)\n            push!(names, num_dict[i])\n        end\n    end\n\
    \    # Return the names array\n    return names\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # Sort the array\n    sorted_arr\
    \ = sort(arr)\n    # Reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # Replace each digit by its corresponding name from \"One\", \"Two\", \"\
    Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\n    # Create\
    \ a dictionary\n    d = Dict(\"1\" => \"One\", \"2\" => \"Two\", \"3\" => \"Three\"\
    , \"4\" => \"Four\", \"5\" => \"Five\", \"6\" => \"Six\", \"7\" => \"Seven\",\
    \ \"8\" => \"Eight\", \"9\" => \"Nine\")\n    # Create an empty array\n    result\
    \ = []\n    # Loop through the array\n    for i in reversed_arr\n        # If\
    \ the number is between 1 and 9 inclusive\n        if i in 1:9\n            #\
    \ Push the corresponding name to the result array\n            push!(result, d[string(i)])\n\
    \        end\n    end\n    # Return the result array\n    return result\nend\n\
    using Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # create a dictionary to map\
    \ the numbers to their names\n    num_dict = Dict(1 => \"One\", 2 => \"Two\",\
    \ 3 => \"Three\", 4 => \"Four\", 5 => \"Five\", 6 => \"Six\", 7 => \"Seven\",\
    \ 8 => \"Eight\", 9 => \"Nine\")\n    # create a vector to store the names\n \
    \   names = Vector{String}()\n    # loop through the array\n    for i in arr\n\
    \        # if the number is in the dictionary, push it to the names vector\n \
    \       if i in keys(num_dict)\n            push!(names, num_dict[i])\n      \
    \  end\n    end\n    # return the names vector\n    return names\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2, 1, 1, 4, 5,\
    \ 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sorted_arr\
    \ = sort(arr)\n    # reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # create a dictionary to map the numbers to their names\n    num_to_name\
    \ = Dict(1 => \"One\", 2 => \"Two\", 3 => \"Three\", 4 => \"Four\", 5 => \"Five\"\
    , 6 => \"Six\", 7 => \"Seven\", 8 => \"Eight\", 9 => \"Nine\")\n    # create an\
    \ empty array to store the names\n    names = []\n    # iterate over the reversed\
    \ array\n    for i in reversed_arr\n        # if the number is between 1 and 9\
    \ inclusive, add its name to the names array\n        if i in keys(num_to_name)\n\
    \            push!(names, num_to_name[i])\n        end\n    end\n    # return\
    \ the names array\n    return names\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"\
    Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    arr = sort(arr)\n    arr\
    \ = reverse(arr)\n    arr = filter(x -> x in 1:9, arr)\n    return map(x -> string(x),\
    \ arr)\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp2gsxm0ea.jl:33\n  Expression: candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"]\n   Evaluated: [\"8\", \"5\", \"4\", \"3\", \"2\"\
    , \"2\", \"1\", \"1\"] == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\",\
    \ \"Two\", \"One\", \"One\"]\nStacktrace:\n [1] top-level scope at /tmp/tmp2gsxm0ea.jl:33\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2gsxm0ea.jl:32\ntest set: Test Failed at /tmp/tmp2gsxm0ea.jl:35\n\
    \  Expression: candidate([1, -1, 55]) == [\"One\"]\n   Evaluated: [\"1\"] == [\"\
    One\"]\nStacktrace:\n [1] top-level scope at /tmp/tmp2gsxm0ea.jl:35\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2gsxm0ea.jl:32\ntest set: Test Failed at /tmp/tmp2gsxm0ea.jl:36\n\
    \  Expression: candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n   Evaluated:\
    \ [\"3\", \"2\", \"1\"] == [\"Three\", \"Two\", \"One\"]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp2gsxm0ea.jl:36\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2gsxm0ea.jl:32\ntest set: Test Failed at /tmp/tmp2gsxm0ea.jl:37\n\
    \  Expression: candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n   Evaluated:\
    \ [\"9\", \"8\", \"4\"] == [\"Nine\", \"Eight\", \"Four\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp2gsxm0ea.jl:37\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2gsxm0ea.jl:32\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2gsxm0ea.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    arr = sort(arr)\n    arr\
    \ = reverse(arr)\n    arr = filter(x -> x in 1:9, arr)\n    arr = map(x -> string(x),\
    \ arr)\n    arr = map(x -> replace(x, \"1\" => \"One\", \"2\" => \"Two\", \"3\"\
    \ => \"Three\", \"4\" => \"Four\", \"5\" => \"Five\", \"6\" => \"Six\", \"7\"\
    \ => \"Seven\", \"8\" => \"Eight\", \"9\" => \"Nine\"), arr)\n    return arr\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmplauk9ua2.jl:35\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: no method\
    \ matching similar(::String, ::Type{Any})\n  Closest candidates are:\n    similar(!Matched::Array{T,1},\
    \ ::Type) where T at array.jl:358\n    similar(!Matched::Array{T,2}, ::Type) where\
    \ T at array.jl:359\n    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}})\
    \ where N at array.jl:361\n    ...\n  Stacktrace:\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\n \
    \  [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmplauk9ua2.jl:27\n   [5] iterate at ./generator.jl:47 [inlined]\n\
    \   [6] _collect at ./array.jl:678 [inlined]\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\n   [8] map at ./abstractarray.jl:2072 [inlined]\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmplauk9ua2.jl:27\n   [10] top-level scope at /tmp/tmplauk9ua2.jl:35\n\
    \   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [12] top-level scope at /tmp/tmplauk9ua2.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmplauk9ua2.jl:37\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: no method matching similar(::String, ::Type{Any})\n\
    \  Closest candidates are:\n    similar(!Matched::Array{T,1}, ::Type) where T\
    \ at array.jl:358\n    similar(!Matched::Array{T,2}, ::Type) where T at array.jl:359\n\
    \    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}}) where\
    \ N at array.jl:361\n    ...\n  Stacktrace:\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\n \
    \  [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmplauk9ua2.jl:27\n   [5] iterate at ./generator.jl:47 [inlined]\n\
    \   [6] _collect at ./array.jl:678 [inlined]\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\n   [8] map at ./abstractarray.jl:2072 [inlined]\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmplauk9ua2.jl:27\n   [10] top-level scope at /tmp/tmplauk9ua2.jl:37\n\
    \   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [12] top-level scope at /tmp/tmplauk9ua2.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmplauk9ua2.jl:38\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: no method matching\
    \ similar(::String, ::Type{Any})\n  Closest candidates are:\n    similar(!Matched::Array{T,1},\
    \ ::Type) where T at array.jl:358\n    similar(!Matched::Array{T,2}, ::Type) where\
    \ T at array.jl:359\n    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}})\
    \ where N at array.jl:361\n    ...\n  Stacktrace:\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\n \
    \  [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmplauk9ua2.jl:27\n   [5] iterate at ./generator.jl:47 [inlined]\n\
    \   [6] _collect at ./array.jl:678 [inlined]\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\n   [8] map at ./abstractarray.jl:2072 [inlined]\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmplauk9ua2.jl:27\n   [10] top-level scope at /tmp/tmplauk9ua2.jl:38\n\
    \   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [12] top-level scope at /tmp/tmplauk9ua2.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmplauk9ua2.jl:39\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: no method matching\
    \ similar(::String, ::Type{Any})\n  Closest candidates are:\n    similar(!Matched::Array{T,1},\
    \ ::Type) where T at array.jl:358\n    similar(!Matched::Array{T,2}, ::Type) where\
    \ T at array.jl:359\n    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}})\
    \ where N at array.jl:361\n    ...\n  Stacktrace:\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\n \
    \  [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmplauk9ua2.jl:27\n   [5] iterate at ./generator.jl:47 [inlined]\n\
    \   [6] _collect at ./array.jl:678 [inlined]\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\n   [8] map at ./abstractarray.jl:2072 [inlined]\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmplauk9ua2.jl:27\n   [10] top-level scope at /tmp/tmplauk9ua2.jl:39\n\
    \   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [12] top-level scope at /tmp/tmplauk9ua2.jl:34\n  \nTest Summary: | Pass \
    \ Error  Total\ntest set      |    1      4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmplauk9ua2.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    #\
    \ reverse the array\n    # replace each digit by its corresponding name from \"\
    One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\",\
    \ \"Nine\"\n    # return the array\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"\
    Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp_fr2mgb4.jl:33\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp_fr2mgb4.jl:27\n\
    \   [2] top-level scope at /tmp/tmp_fr2mgb4.jl:33\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_fr2mgb4.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmp_fr2mgb4.jl:34\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{String}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp_fr2mgb4.jl:27\n\
    \   [2] top-level scope at /tmp/tmp_fr2mgb4.jl:34\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_fr2mgb4.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmp_fr2mgb4.jl:35\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp_fr2mgb4.jl:27\n\
    \   [2] top-level scope at /tmp/tmp_fr2mgb4.jl:35\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_fr2mgb4.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmp_fr2mgb4.jl:36\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp_fr2mgb4.jl:27\n\
    \   [2] top-level scope at /tmp/tmp_fr2mgb4.jl:36\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_fr2mgb4.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmp_fr2mgb4.jl:37\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp_fr2mgb4.jl:27\n\
    \   [2] top-level scope at /tmp/tmp_fr2mgb4.jl:37\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_fr2mgb4.jl:32\n  \nTest Summary: | Error \
    \ Total\ntest set      |     5      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_fr2mgb4.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # replace each digit by its corresponding\
    \ name\n    for i in 1:length(arr)\n        if arr[i] == 1\n            arr[i]\
    \ = \"One\"\n        elseif arr[i] == 2\n            arr[i] = \"Two\"\n      \
    \  elseif arr[i] == 3\n            arr[i] = \"Three\"\n        elseif arr[i] ==\
    \ 4\n            arr[i] = \"Four\"\n        elseif arr[i] == 5\n            arr[i]\
    \ = \"Five\"\n        elseif arr[i] == 6\n            arr[i] = \"Six\"\n     \
    \   elseif arr[i] == 7\n            arr[i] = \"Seven\"\n        elseif arr[i]\
    \ == 8\n            arr[i] = \"Eight\"\n        elseif arr[i] == 9\n         \
    \   arr[i] = \"Nine\"\n        else\n            arr[i] = \" \"\n        end\n\
    \    end\n    # delete the strange number\n    deleteat!(arr, findall(arr .==\
    \ \" \"))\n    return arr\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\
    \t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\"\
    , \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpsdvix4lp.jl:60\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: Cannot\
    \ `convert` an object of type String to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] setindex!(::Array{Int64,1}, ::String, ::Int64) at ./array.jl:826\n   [2]\
    \ by_length(::Array{Int64,1}) at /tmp/tmpsdvix4lp.jl:44\n   [3] top-level scope\
    \ at /tmp/tmpsdvix4lp.jl:60\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpsdvix4lp.jl:59\n  \ntest set: Error During\
    \ Test at /tmp/tmpsdvix4lp.jl:62\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: Cannot `convert` an object of type String\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpsdvix4lp.jl:48\n   [3] top-level scope at /tmp/tmpsdvix4lp.jl:62\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpsdvix4lp.jl:59\n  \ntest set: Error During\
    \ Test at /tmp/tmpsdvix4lp.jl:63\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: Cannot `convert`\
    \ an object of type String to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpsdvix4lp.jl:34\n   [3] top-level scope at /tmp/tmpsdvix4lp.jl:63\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpsdvix4lp.jl:59\n  \ntest set: Error During\
    \ Test at /tmp/tmpsdvix4lp.jl:64\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: Cannot `convert` an\
    \ object of type String to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpsdvix4lp.jl:46\n   [3] top-level scope at /tmp/tmpsdvix4lp.jl:64\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpsdvix4lp.jl:59\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    1      4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpsdvix4lp.jl:57\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # replace each digit by its corresponding\
    \ name from \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\"\n    for i in 1:length(arr)\n        if arr[i] == 1\n  \
    \          arr[i] = \"One\"\n        elseif arr[i] == 2\n            arr[i] =\
    \ \"Two\"\n        elseif arr[i] == 3\n            arr[i] = \"Three\"\n      \
    \  elseif arr[i] == 4\n            arr[i] = \"Four\"\n        elseif arr[i] ==\
    \ 5\n            arr[i] = \"Five\"\n        elseif arr[i] == 6\n            arr[i]\
    \ = \"Six\"\n        elseif arr[i] == 7\n            arr[i] = \"Seven\"\n    \
    \    elseif arr[i] == 8\n            arr[i] = \"Eight\"\n        elseif arr[i]\
    \ == 9\n            arr[i] = \"Nine\"\n        end\n    end\n    # return the\
    \ array\n    return arr\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\
    \t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\"\
    , \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmppheb0f1u.jl:57\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: Cannot\
    \ `convert` an object of type String to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] setindex!(::Array{Int64,1}, ::String, ::Int64) at ./array.jl:826\n   [2]\
    \ by_length(::Array{Int64,1}) at /tmp/tmppheb0f1u.jl:44\n   [3] top-level scope\
    \ at /tmp/tmppheb0f1u.jl:57\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmppheb0f1u.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmppheb0f1u.jl:59\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: Cannot `convert` an object of type String\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmppheb0f1u.jl:30\n   [3] top-level scope at /tmp/tmppheb0f1u.jl:59\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmppheb0f1u.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmppheb0f1u.jl:60\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: Cannot `convert`\
    \ an object of type String to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmppheb0f1u.jl:34\n   [3] top-level scope at /tmp/tmppheb0f1u.jl:60\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmppheb0f1u.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmppheb0f1u.jl:61\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: Cannot `convert` an\
    \ object of type String to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmppheb0f1u.jl:46\n   [3] top-level scope at /tmp/tmppheb0f1u.jl:61\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmppheb0f1u.jl:56\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    1      4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmppheb0f1u.jl:54\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # replace each digit by its corresponding\
    \ name\n    for i in 1:length(arr)\n        if arr[i] == 1\n            arr[i]\
    \ = \"One\"\n        elseif arr[i] == 2\n            arr[i] = \"Two\"\n      \
    \  elseif arr[i] == 3\n            arr[i] = \"Three\"\n        elseif arr[i] ==\
    \ 4\n            arr[i] = \"Four\"\n        elseif arr[i] == 5\n            arr[i]\
    \ = \"Five\"\n        elseif arr[i] == 6\n            arr[i] = \"Six\"\n     \
    \   elseif arr[i] == 7\n            arr[i] = \"Seven\"\n        elseif arr[i]\
    \ == 8\n            arr[i] = \"Eight\"\n        elseif arr[i] == 9\n         \
    \   arr[i] = \"Nine\"\n        end\n    end\n    # return the array\n    return\
    \ arr\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp0oxz2txj.jl:57\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: Cannot\
    \ `convert` an object of type String to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] setindex!(::Array{Int64,1}, ::String, ::Int64) at ./array.jl:826\n   [2]\
    \ by_length(::Array{Int64,1}) at /tmp/tmp0oxz2txj.jl:44\n   [3] top-level scope\
    \ at /tmp/tmp0oxz2txj.jl:57\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp0oxz2txj.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmp0oxz2txj.jl:59\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: Cannot `convert` an object of type String\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmp0oxz2txj.jl:30\n   [3] top-level scope at /tmp/tmp0oxz2txj.jl:59\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp0oxz2txj.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmp0oxz2txj.jl:60\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: Cannot `convert`\
    \ an object of type String to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmp0oxz2txj.jl:34\n   [3] top-level scope at /tmp/tmp0oxz2txj.jl:60\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp0oxz2txj.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmp0oxz2txj.jl:61\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: Cannot `convert` an\
    \ object of type String to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmp0oxz2txj.jl:46\n   [3] top-level scope at /tmp/tmp0oxz2txj.jl:61\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp0oxz2txj.jl:56\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    1      4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0oxz2txj.jl:54\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    arr_sorted = sort(arr)\n\
    \    arr_reversed = reverse(arr_sorted)\n    arr_string = []\n    for i in arr_reversed\n\
    \        if i == 1\n            push!(arr_string, \"One\")\n        elseif i ==\
    \ 2\n            push!(arr_string, \"Two\")\n        elseif i == 3\n         \
    \   push!(arr_string, \"Three\")\n        elseif i == 4\n            push!(arr_string,\
    \ \"Four\")\n        elseif i == 5\n            push!(arr_string, \"Five\")\n\
    \        elseif i == 6\n            push!(arr_string, \"Six\")\n        elseif\
    \ i == 7\n            push!(arr_string, \"Seven\")\n        elseif i == 8\n  \
    \          push!(arr_string, \"Eight\")\n        elseif i == 9\n            push!(arr_string,\
    \ \"Nine\")\n        end\n    end\n    return arr_string\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8,\
    \ 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\"\
    , \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\t@test(candidate([1,\
    \ -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2]) == [\"Three\", \"Two\"\
    , \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    #\
    \ reverse the array\n    # replace each digit by its corresponding name from \"\
    One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\",\
    \ \"Nine\"\n    # return the array\n    return arr\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3])\
    \ == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"\
    One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\t@test(candidate([1,\
    \ -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2]) == [\"Three\", \"Two\"\
    , \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmps69l7gm0.jl:34\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: Cannot\
    \ `convert` an object of type Int64 to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] setindex!(::Array{String,1}, ::Int64, ::Int64) at ./array.jl:826\n   [2]\
    \ copyto! at ./multidimensional.jl:962 [inlined]\n   [3] Array{String,1}(::Array{Int64,1})\
    \ at ./array.jl:541\n   [4] convert at ./array.jl:533 [inlined]\n   [5] by_length(::Array{Int64,1})\
    \ at /tmp/tmps69l7gm0.jl:27\n   [6] top-level scope at /tmp/tmps69l7gm0.jl:34\n\
    \   [7] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [8] top-level scope at /tmp/tmps69l7gm0.jl:33\n  \ntest set: Error During\
    \ Test at /tmp/tmps69l7gm0.jl:36\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: Cannot `convert` an object of type Int64\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] setindex!(::Array{String,1}, ::Int64, ::Int64) at ./array.jl:826\n   [2]\
    \ copyto! at ./multidimensional.jl:962 [inlined]\n   [3] Array{String,1}(::Array{Int64,1})\
    \ at ./array.jl:541\n   [4] convert at ./array.jl:533 [inlined]\n   [5] by_length(::Array{Int64,1})\
    \ at /tmp/tmps69l7gm0.jl:27\n   [6] top-level scope at /tmp/tmps69l7gm0.jl:36\n\
    \   [7] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [8] top-level scope at /tmp/tmps69l7gm0.jl:33\n  \ntest set: Error During\
    \ Test at /tmp/tmps69l7gm0.jl:37\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: Cannot `convert`\
    \ an object of type Int64 to an object of type String\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] setindex!(::Array{String,1}, ::Int64, ::Int64) at ./array.jl:826\n   [2]\
    \ copyto! at ./multidimensional.jl:962 [inlined]\n   [3] Array{String,1}(::Array{Int64,1})\
    \ at ./array.jl:541\n   [4] convert at ./array.jl:533 [inlined]\n   [5] by_length(::Array{Int64,1})\
    \ at /tmp/tmps69l7gm0.jl:27\n   [6] top-level scope at /tmp/tmps69l7gm0.jl:37\n\
    \   [7] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [8] top-level scope at /tmp/tmps69l7gm0.jl:33\n  \ntest set: Error During\
    \ Test at /tmp/tmps69l7gm0.jl:38\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: Cannot `convert` an\
    \ object of type Int64 to an object of type String\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] setindex!(::Array{String,1}, ::Int64, ::Int64) at ./array.jl:826\n   [2]\
    \ copyto! at ./multidimensional.jl:962 [inlined]\n   [3] Array{String,1}(::Array{Int64,1})\
    \ at ./array.jl:541\n   [4] convert at ./array.jl:533 [inlined]\n   [5] by_length(::Array{Int64,1})\
    \ at /tmp/tmps69l7gm0.jl:27\n   [6] top-level scope at /tmp/tmps69l7gm0.jl:38\n\
    \   [7] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [8] top-level scope at /tmp/tmps69l7gm0.jl:33\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    1      4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmps69l7gm0.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # replace each digit by its corresponding\
    \ name from \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\"\n    for i in 1:length(arr)\n        if arr[i] == 1\n  \
    \          arr[i] = \"One\"\n        elseif arr[i] == 2\n            arr[i] =\
    \ \"Two\"\n        elseif arr[i] == 3\n            arr[i] = \"Three\"\n      \
    \  elseif arr[i] == 4\n            arr[i] = \"Four\"\n        elseif arr[i] ==\
    \ 5\n            arr[i] = \"Five\"\n        elseif arr[i] == 6\n            arr[i]\
    \ = \"Six\"\n        elseif arr[i] == 7\n            arr[i] = \"Seven\"\n    \
    \    elseif arr[i] == 8\n            arr[i] = \"Eight\"\n        elseif arr[i]\
    \ == 9\n            arr[i] = \"Nine\"\n        end\n    end\n    # return the\
    \ array\n    return arr\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\
    \t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\"\
    , \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpa6181vve.jl:57\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: Cannot\
    \ `convert` an object of type String to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] setindex!(::Array{Int64,1}, ::String, ::Int64) at ./array.jl:826\n   [2]\
    \ by_length(::Array{Int64,1}) at /tmp/tmpa6181vve.jl:44\n   [3] top-level scope\
    \ at /tmp/tmpa6181vve.jl:57\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpa6181vve.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmpa6181vve.jl:59\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: Cannot `convert` an object of type String\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpa6181vve.jl:30\n   [3] top-level scope at /tmp/tmpa6181vve.jl:59\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpa6181vve.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmpa6181vve.jl:60\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: Cannot `convert`\
    \ an object of type String to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpa6181vve.jl:34\n   [3] top-level scope at /tmp/tmpa6181vve.jl:60\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpa6181vve.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmpa6181vve.jl:61\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: Cannot `convert` an\
    \ object of type String to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpa6181vve.jl:46\n   [3] top-level scope at /tmp/tmpa6181vve.jl:61\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpa6181vve.jl:56\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    1      4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpa6181vve.jl:54\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    #\
    \ reverse the array\n    # replace each digit by its corresponding name from \"\
    One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\",\
    \ \"Nine\"\n    # return the array\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"\
    Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmprjpkrvpg.jl:33\\n  Test threw\
    \ exception\\n  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Array{String,1}\\\
    n  Closest candidates are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] by_length(::Array{Int64,1}) at /tmp/tmprjpkrvpg.jl:27\\\
    n   [2] top-level scope at /tmp/tmprjpkrvpg.jl:33\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmprjpkrvpg.jl:32\\n  \\ntest set: Error During\
    \ Test at /tmp/tmprjpkrvpg.jl:34\\n  Test threw exception\\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{String}([])\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\\n  Closest candidates are:\\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] by_length(::Array{Int64,1}) at /tmp/tmprjpkrvpg.jl:27\\\
    n   [2] top-level scope at /tmp/tmprjpkrvpg.jl:34\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmprjpkrvpg.jl:32\\n  \\ntest set: Error During\
    \ Test at /tmp/tmprjpkrvpg.jl:35\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\\n  Closest candidates are:\\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] by_length(::Array{Int64,1}) at /tmp/tmprjpkrvpg.jl:27\\\
    n   [2] top-level scope at /tmp/tmprjpkrvpg.jl:35\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmprjpkrvpg.jl:32\\n  \\ntest set: Error During\
    \ Test at /tmp/tmprjpkrvpg.jl:36\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{String,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] by_length(::Array{Int64,1}) at /tmp/tmprjpkrvpg.jl:27\\\
    n   [2] top-level scope at /tmp/tmprjpkrvpg.jl:36\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmprjpkrvpg.jl:32\\n  \\ntest set: Error During\
    \ Test at /tmp/tmprjpkrvpg.jl:37\\n  Test threw exception\\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{String,1}\\n  Closest candidates\
    \ are:\\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] by_length(::Array{Int64,1}) at /tmp/tmprjpkrvpg.jl:27\\\
    n   [2] top-level scope at /tmp/tmprjpkrvpg.jl:37\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmprjpkrvpg.jl:32\\n  \\nTest Summary: | Error\
    \  Total\\ntest set      |     5      5\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    #\
    \ reverse the array\n    # replace each digit by its corresponding name from \"\
    One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\",\
    \ \"Nine\"\n    # return the array\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"\
    Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpqorkue21.jl:33\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmpqorkue21.jl:27\n\
    \   [2] top-level scope at /tmp/tmpqorkue21.jl:33\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqorkue21.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmpqorkue21.jl:34\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{String}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmpqorkue21.jl:27\n\
    \   [2] top-level scope at /tmp/tmpqorkue21.jl:34\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqorkue21.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmpqorkue21.jl:35\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmpqorkue21.jl:27\n\
    \   [2] top-level scope at /tmp/tmpqorkue21.jl:35\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqorkue21.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmpqorkue21.jl:36\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmpqorkue21.jl:27\n\
    \   [2] top-level scope at /tmp/tmpqorkue21.jl:36\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqorkue21.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmpqorkue21.jl:37\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmpqorkue21.jl:27\n\
    \   [2] top-level scope at /tmp/tmpqorkue21.jl:37\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpqorkue21.jl:32\n  \nTest Summary: | Error \
    \ Total\ntest set      |     5      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqorkue21.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sorted_arr\
    \ = sort(arr)\n    # reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # replace each digit by its corresponding name from \"One\", \"Two\", \"\
    Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\n    res\
    \ = []\n    for i in reversed_arr\n        if i == 1\n            push!(res, \"\
    One\")\n        elseif i == 2\n            push!(res, \"Two\")\n        elseif\
    \ i == 3\n            push!(res, \"Three\")\n        elseif i == 4\n         \
    \   push!(res, \"Four\")\n        elseif i == 5\n            push!(res, \"Five\"\
    )\n        elseif i == 6\n            push!(res, \"Six\")\n        elseif i ==\
    \ 7\n            push!(res, \"Seven\")\n        elseif i == 8\n            push!(res,\
    \ \"Eight\")\n        elseif i == 9\n            push!(res, \"Nine\")\n      \
    \  end\n    end\n    return res\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"\
    Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    arr = sort(arr)\n    arr\
    \ = reverse(arr)\n    arr = filter(x -> x in 1:9, arr)\n    arr = map(x -> string(x),\
    \ arr)\n    return arr\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\
    \t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\"\
    , \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpuoby3ws4.jl:34\n  Expression: candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"]\n   Evaluated: [\"8\", \"5\", \"4\", \"3\", \"2\"\
    , \"2\", \"1\", \"1\"] == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\",\
    \ \"Two\", \"One\", \"One\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpuoby3ws4.jl:34\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpuoby3ws4.jl:33\ntest set: Test Failed at /tmp/tmpuoby3ws4.jl:36\n\
    \  Expression: candidate([1, -1, 55]) == [\"One\"]\n   Evaluated: [\"1\"] == [\"\
    One\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpuoby3ws4.jl:36\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpuoby3ws4.jl:33\ntest set: Test Failed at /tmp/tmpuoby3ws4.jl:37\n\
    \  Expression: candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n   Evaluated:\
    \ [\"3\", \"2\", \"1\"] == [\"Three\", \"Two\", \"One\"]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpuoby3ws4.jl:37\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpuoby3ws4.jl:33\ntest set: Test Failed at /tmp/tmpuoby3ws4.jl:38\n\
    \  Expression: candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n   Evaluated:\
    \ [\"9\", \"8\", \"4\"] == [\"Nine\", \"Eight\", \"Four\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpuoby3ws4.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpuoby3ws4.jl:33\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpuoby3ws4.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # replace each digit by its corresponding\
    \ name from \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\"\n    for i in 1:length(arr)\n        if arr[i] == 1\n  \
    \          arr[i] = \"One\"\n        elseif arr[i] == 2\n            arr[i] =\
    \ \"Two\"\n        elseif arr[i] == 3\n            arr[i] = \"Three\"\n      \
    \  elseif arr[i] == 4\n            arr[i] = \"Four\"\n        elseif arr[i] ==\
    \ 5\n            arr[i] = \"Five\"\n        elseif arr[i] == 6\n            arr[i]\
    \ = \"Six\"\n        elseif arr[i] == 7\n            arr[i] = \"Seven\"\n    \
    \    elseif arr[i] == 8\n            arr[i] = \"Eight\"\n        elseif arr[i]\
    \ == 9\n            arr[i] = \"Nine\"\n        end\n    end\n    # return the\
    \ array\n    return arr\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\
    \t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\"\
    , \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpuj8mf9yz.jl:57\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: Cannot\
    \ `convert` an object of type String to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] setindex!(::Array{Int64,1}, ::String, ::Int64) at ./array.jl:826\n   [2]\
    \ by_length(::Array{Int64,1}) at /tmp/tmpuj8mf9yz.jl:44\n   [3] top-level scope\
    \ at /tmp/tmpuj8mf9yz.jl:57\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpuj8mf9yz.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmpuj8mf9yz.jl:59\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: Cannot `convert` an object of type String\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpuj8mf9yz.jl:30\n   [3] top-level scope at /tmp/tmpuj8mf9yz.jl:59\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpuj8mf9yz.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmpuj8mf9yz.jl:60\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: Cannot `convert`\
    \ an object of type String to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpuj8mf9yz.jl:34\n   [3] top-level scope at /tmp/tmpuj8mf9yz.jl:60\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpuj8mf9yz.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmpuj8mf9yz.jl:61\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: Cannot `convert` an\
    \ object of type String to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpuj8mf9yz.jl:46\n   [3] top-level scope at /tmp/tmpuj8mf9yz.jl:61\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpuj8mf9yz.jl:56\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    1      4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpuj8mf9yz.jl:54\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # replace each digit by its corresponding\
    \ name from \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\"\n    for i in 1:length(arr)\n        if arr[i] == 1\n  \
    \          arr[i] = \"One\"\n        elseif arr[i] == 2\n            arr[i] =\
    \ \"Two\"\n        elseif arr[i] == 3\n            arr[i] = \"Three\"\n      \
    \  elseif arr[i] == 4\n            arr[i] = \"Four\"\n        elseif arr[i] ==\
    \ 5\n            arr[i] = \"Five\"\n        elseif arr[i] == 6\n            arr[i]\
    \ = \"Six\"\n        elseif arr[i] == 7\n            arr[i] = \"Seven\"\n    \
    \    elseif arr[i] == 8\n            arr[i] = \"Eight\"\n        elseif arr[i]\
    \ == 9\n            arr[i] = \"Nine\"\n        end\n    end\n    return arr\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp2wa64bdf.jl:56\\n  Test threw\
    \ exception\\n  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\\n  MethodError:\
    \ Cannot `convert` an object of type String to an object of type Int64\\n  Closest\
    \ candidates are:\\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\\\
    n    convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\\n  \
    \  convert(::Type{T}, !Matched::Ptr) where T<:Integer at pointer.jl:23\\n    ...\\\
    n  Stacktrace:\\n   [1] setindex!(::Array{Int64,1}, ::String, ::Int64) at ./array.jl:826\\\
    n   [2] by_length(::Array{Int64,1}) at /tmp/tmp2wa64bdf.jl:44\\n   [3] top-level\
    \ scope at /tmp/tmp2wa64bdf.jl:56\\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmp2wa64bdf.jl:55\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp2wa64bdf.jl:58\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\\n  MethodError: Cannot `convert` an object of type String\
    \ to an object of type Int64\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmp2wa64bdf.jl:30\\n   [3] top-level scope at /tmp/tmp2wa64bdf.jl:58\\\
    n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmp2wa64bdf.jl:55\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp2wa64bdf.jl:59\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\\n  MethodError: Cannot `convert`\
    \ an object of type String to an object of type Int64\\n  Closest candidates are:\\\
    n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmp2wa64bdf.jl:34\\n   [3] top-level scope at /tmp/tmp2wa64bdf.jl:59\\\
    n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmp2wa64bdf.jl:55\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp2wa64bdf.jl:60\\n  Test threw exception\\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\\n  MethodError: Cannot `convert`\
    \ an object of type String to an object of type Int64\\n  Closest candidates are:\\\
    n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmp2wa64bdf.jl:46\\n   [3] top-level scope at /tmp/tmp2wa64bdf.jl:60\\\
    n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmp2wa64bdf.jl:55\\n  \\nTest Summary: | Pass\
    \  Error  '"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # replace each digit by its corresponding\
    \ name from \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\"\n    # create a dictionary\n    d = Dict(\"One\" => 1, \"\
    Two\" => 2, \"Three\" => 3, \"Four\" => 4, \"Five\" => 5, \"Six\" => 6, \"Seven\"\
    \ => 7, \"Eight\" => 8, \"Nine\" => 9)\n    # create a new array\n    new_arr\
    \ = []\n    # loop through the array\n    for i in arr\n        # check if the\
    \ number is between 1 and 9\n        if i in keys(d)\n            # append the\
    \ corresponding name to the new array\n            push!(new_arr, d[i])\n    \
    \    end\n    end\n    # return the new array\n    return new_arr\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2, 1, 1,\
    \ 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp9kx3mkah.jl:48\n  Expression: candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"]\n   Evaluated: String[] == [\"Eight\", \"Five\",\
    \ \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp9kx3mkah.jl:48\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9kx3mkah.jl:47\ntest set: Test Failed at /tmp/tmp9kx3mkah.jl:50\n\
    \  Expression: candidate([1, -1, 55]) == [\"One\"]\n   Evaluated: String[] ==\
    \ [\"One\"]\nStacktrace:\n [1] top-level scope at /tmp/tmp9kx3mkah.jl:50\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9kx3mkah.jl:47\ntest set: Test Failed at /tmp/tmp9kx3mkah.jl:51\n\
    \  Expression: candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n   Evaluated:\
    \ String[] == [\"Three\", \"Two\", \"One\"]\nStacktrace:\n [1] top-level scope\
    \ at /tmp/tmp9kx3mkah.jl:51\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9kx3mkah.jl:47\ntest set: Test Failed at /tmp/tmp9kx3mkah.jl:52\n\
    \  Expression: candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n   Evaluated:\
    \ String[] == [\"Nine\", \"Eight\", \"Four\"]\nStacktrace:\n [1] top-level scope\
    \ at /tmp/tmp9kx3mkah.jl:52\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9kx3mkah.jl:47\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9kx3mkah.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    arr = sort(arr)\n    arr\
    \ = reverse(arr)\n    arr = filter(x -> x in 1:9, arr)\n    arr = map(x -> string(x),\
    \ arr)\n    arr = map(x -> replace(x, \"1\" => \"One\", \"2\" => \"Two\", \"3\"\
    \ => \"Three\", \"4\" => \"Four\", \"5\" => \"Five\", \"6\" => \"Six\", \"7\"\
    \ => \"Seven\", \"8\" => \"Eight\", \"9\" => \"Nine\"), arr)\n    return arr\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp8bvega_2.jl:35\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: no method\
    \ matching similar(::String, ::Type{Any})\n  Closest candidates are:\n    similar(!Matched::Array{T,1},\
    \ ::Type) where T at array.jl:358\n    similar(!Matched::Array{T,2}, ::Type) where\
    \ T at array.jl:359\n    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}})\
    \ where N at array.jl:361\n    ...\n  Stacktrace:\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\n \
    \  [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmp8bvega_2.jl:27\n   [5] iterate at ./generator.jl:47 [inlined]\n\
    \   [6] _collect at ./array.jl:678 [inlined]\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\n   [8] map at ./abstractarray.jl:2072 [inlined]\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmp8bvega_2.jl:27\n   [10] top-level scope at /tmp/tmp8bvega_2.jl:35\n\
    \   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [12] top-level scope at /tmp/tmp8bvega_2.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmp8bvega_2.jl:37\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: no method matching similar(::String, ::Type{Any})\n\
    \  Closest candidates are:\n    similar(!Matched::Array{T,1}, ::Type) where T\
    \ at array.jl:358\n    similar(!Matched::Array{T,2}, ::Type) where T at array.jl:359\n\
    \    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}}) where\
    \ N at array.jl:361\n    ...\n  Stacktrace:\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\n \
    \  [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmp8bvega_2.jl:27\n   [5] iterate at ./generator.jl:47 [inlined]\n\
    \   [6] _collect at ./array.jl:678 [inlined]\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\n   [8] map at ./abstractarray.jl:2072 [inlined]\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmp8bvega_2.jl:27\n   [10] top-level scope at /tmp/tmp8bvega_2.jl:37\n\
    \   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [12] top-level scope at /tmp/tmp8bvega_2.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmp8bvega_2.jl:38\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: no method matching\
    \ similar(::String, ::Type{Any})\n  Closest candidates are:\n    similar(!Matched::Array{T,1},\
    \ ::Type) where T at array.jl:358\n    similar(!Matched::Array{T,2}, ::Type) where\
    \ T at array.jl:359\n    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}})\
    \ where N at array.jl:361\n    ...\n  Stacktrace:\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\n \
    \  [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmp8bvega_2.jl:27\n   [5] iterate at ./generator.jl:47 [inlined]\n\
    \   [6] _collect at ./array.jl:678 [inlined]\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\n   [8] map at ./abstractarray.jl:2072 [inlined]\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmp8bvega_2.jl:27\n   [10] top-level scope at /tmp/tmp8bvega_2.jl:38\n\
    \   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [12] top-level scope at /tmp/tmp8bvega_2.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmp8bvega_2.jl:39\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: no method matching\
    \ similar(::String, ::Type{Any})\n  Closest candidates are:\n    similar(!Matched::Array{T,1},\
    \ ::Type) where T at array.jl:358\n    similar(!Matched::Array{T,2}, ::Type) where\
    \ T at array.jl:359\n    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}})\
    \ where N at array.jl:361\n    ...\n  Stacktrace:\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\n \
    \  [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmp8bvega_2.jl:27\n   [5] iterate at ./generator.jl:47 [inlined]\n\
    \   [6] _collect at ./array.jl:678 [inlined]\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\n   [8] map at ./abstractarray.jl:2072 [inlined]\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmp8bvega_2.jl:27\n   [10] top-level scope at /tmp/tmp8bvega_2.jl:39\n\
    \   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [12] top-level scope at /tmp/tmp8bvega_2.jl:34\n  \nTest Summary: | Pass \
    \ Error  Total\ntest set      |    1      4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8bvega_2.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sorted_arr\
    \ = sort(arr)\n    # reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # replace each digit by its corresponding name from \"One\", \"Two\", \"\
    Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\n    # create\
    \ a dictionary to map the numbers to their names\n    number_names = Dict(1 =>\
    \ \"One\", 2 => \"Two\", 3 => \"Three\", 4 => \"Four\", 5 => \"Five\", 6 => \"\
    Six\", 7 => \"Seven\", 8 => \"Eight\", 9 => \"Nine\")\n    # create an empty array\
    \ to store the names\n    names = []\n    # loop through the reversed array\n\
    \    for i in reversed_arr\n        # check if the number is between 1 and 9\n\
    \        if i >= 1 && i <= 9\n            # if yes, append the name to the names\
    \ array\n            push!(names, number_names[i])\n        end\n    end\n   \
    \ # return the names array\n    return names\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # replace each digit by its corresponding\
    \ name from \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\"\n    for i in 1:length(arr)\n        if arr[i] == 1\n  \
    \          arr[i] = \"One\"\n        elseif arr[i] == 2\n            arr[i] =\
    \ \"Two\"\n        elseif arr[i] == 3\n            arr[i] = \"Three\"\n      \
    \  elseif arr[i] == 4\n            arr[i] = \"Four\"\n        elseif arr[i] ==\
    \ 5\n            arr[i] = \"Five\"\n        elseif arr[i] == 6\n            arr[i]\
    \ = \"Six\"\n        elseif arr[i] == 7\n            arr[i] = \"Seven\"\n    \
    \    elseif arr[i] == 8\n            arr[i] = \"Eight\"\n        elseif arr[i]\
    \ == 9\n            arr[i] = \"Nine\"\n        end\n    end\n    # return the\
    \ array\n    return arr\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\
    \t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\"\
    , \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpo43f10hl.jl:57\\n  Test threw\
    \ exception\\n  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\\n  MethodError:\
    \ Cannot `convert` an object of type String to an object of type Int64\\n  Closest\
    \ candidates are:\\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\\\
    n    convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\\n  \
    \  convert(::Type{T}, !Matched::Ptr) where T<:Integer at pointer.jl:23\\n    ...\\\
    n  Stacktrace:\\n   [1] setindex!(::Array{Int64,1}, ::String, ::Int64) at ./array.jl:826\\\
    n   [2] by_length(::Array{Int64,1}) at /tmp/tmpo43f10hl.jl:44\\n   [3] top-level\
    \ scope at /tmp/tmpo43f10hl.jl:57\\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmpo43f10hl.jl:56\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpo43f10hl.jl:59\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\\n  MethodError: Cannot `convert` an object of type String\
    \ to an object of type Int64\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpo43f10hl.jl:30\\n   [3] top-level scope at /tmp/tmpo43f10hl.jl:59\\\
    n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmpo43f10hl.jl:56\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpo43f10hl.jl:60\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\\n  MethodError: Cannot `convert`\
    \ an object of type String to an object of type Int64\\n  Closest candidates are:\\\
    n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpo43f10hl.jl:34\\n   [3] top-level scope at /tmp/tmpo43f10hl.jl:60\\\
    n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmpo43f10hl.jl:56\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpo43f10hl.jl:61\\n  Test threw exception\\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\\n  MethodError: Cannot `convert`\
    \ an object of type String to an object of type Int64\\n  Closest candidates are:\\\
    n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpo43f10hl.jl:46\\n   [3] top-level scope at /tmp/tmpo43f10hl.jl:61\\\
    n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmpo43f10hl.jl:56\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    arr = sort(arr)\n    arr\
    \ = reverse(arr)\n    result = []\n    for i in arr\n        if i == 1\n     \
    \       push!(result, \"One\")\n        elseif i == 2\n            push!(result,\
    \ \"Two\")\n        elseif i == 3\n            push!(result, \"Three\")\n    \
    \    elseif i == 4\n            push!(result, \"Four\")\n        elseif i == 5\n\
    \            push!(result, \"Five\")\n        elseif i == 6\n            push!(result,\
    \ \"Six\")\n        elseif i == 7\n            push!(result, \"Seven\")\n    \
    \    elseif i == 8\n            push!(result, \"Eight\")\n        elseif i ==\
    \ 9\n            push!(result, \"Nine\")\n        end\n    end\n    return result\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # replace each digit by its corresponding\
    \ name from \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\"\n    for i in 1:length(arr)\n        if arr[i] == 1\n  \
    \          arr[i] = \"One\"\n        elseif arr[i] == 2\n            arr[i] =\
    \ \"Two\"\n        elseif arr[i] == 3\n            arr[i] = \"Three\"\n      \
    \  elseif arr[i] == 4\n            arr[i] = \"Four\"\n        elseif arr[i] ==\
    \ 5\n            arr[i] = \"Five\"\n        elseif arr[i] == 6\n            arr[i]\
    \ = \"Six\"\n        elseif arr[i] == 7\n            arr[i] = \"Seven\"\n    \
    \    elseif arr[i] == 8\n            arr[i] = \"Eight\"\n        elseif arr[i]\
    \ == 9\n            arr[i] = \"Nine\"\n        end\n    end\n    return arr\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp8fo1xve9.jl:56\\n  Test threw\
    \ exception\\n  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\\n  MethodError:\
    \ Cannot `convert` an object of type String to an object of type Int64\\n  Closest\
    \ candidates are:\\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\\\
    n    convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\\n  \
    \  convert(::Type{T}, !Matched::Ptr) where T<:Integer at pointer.jl:23\\n    ...\\\
    n  Stacktrace:\\n   [1] setindex!(::Array{Int64,1}, ::String, ::Int64) at ./array.jl:826\\\
    n   [2] by_length(::Array{Int64,1}) at /tmp/tmp8fo1xve9.jl:44\\n   [3] top-level\
    \ scope at /tmp/tmp8fo1xve9.jl:56\\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmp8fo1xve9.jl:55\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp8fo1xve9.jl:58\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\\n  MethodError: Cannot `convert` an object of type String\
    \ to an object of type Int64\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmp8fo1xve9.jl:30\\n   [3] top-level scope at /tmp/tmp8fo1xve9.jl:58\\\
    n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmp8fo1xve9.jl:55\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp8fo1xve9.jl:59\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\\n  MethodError: Cannot `convert`\
    \ an object of type String to an object of type Int64\\n  Closest candidates are:\\\
    n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmp8fo1xve9.jl:34\\n   [3] top-level scope at /tmp/tmp8fo1xve9.jl:59\\\
    n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmp8fo1xve9.jl:55\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp8fo1xve9.jl:60\\n  Test threw exception\\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\\n  MethodError: Cannot `convert`\
    \ an object of type String to an object of type Int64\\n  Closest candidates are:\\\
    n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmp8fo1xve9.jl:46\\n   [3] top-level scope at /tmp/tmp8fo1xve9.jl:60\\\
    n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmp8fo1xve9.jl:55\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    sorted_arr = sort(arr)\n\
    \    reverse_arr = reverse(sorted_arr)\n    result = []\n    for i in reverse_arr\n\
    \        if i == 1\n            push!(result, \"One\")\n        elseif i == 2\n\
    \            push!(result, \"Two\")\n        elseif i == 3\n            push!(result,\
    \ \"Three\")\n        elseif i == 4\n            push!(result, \"Four\")\n   \
    \     elseif i == 5\n            push!(result, \"Five\")\n        elseif i ==\
    \ 6\n            push!(result, \"Six\")\n        elseif i == 7\n            push!(result,\
    \ \"Seven\")\n        elseif i == 8\n            push!(result, \"Eight\")\n  \
    \      elseif i == 9\n            push!(result, \"Nine\")\n        end\n    end\n\
    \    return result\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\
    \t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\"\
    , \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # replace each digit by its corresponding\
    \ name from \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\"\n    for i in 1:length(arr)\n        if arr[i] == 1\n  \
    \          arr[i] = \"One\"\n        elseif arr[i] == 2\n            arr[i] =\
    \ \"Two\"\n        elseif arr[i] == 3\n            arr[i] = \"Three\"\n      \
    \  elseif arr[i] == 4\n            arr[i] = \"Four\"\n        elseif arr[i] ==\
    \ 5\n            arr[i] = \"Five\"\n        elseif arr[i] == 6\n            arr[i]\
    \ = \"Six\"\n        elseif arr[i] == 7\n            arr[i] = \"Seven\"\n    \
    \    elseif arr[i] == 8\n            arr[i] = \"Eight\"\n        elseif arr[i]\
    \ == 9\n            arr[i] = \"Nine\"\n        end\n    end\n    # return the\
    \ array\n    return arr\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\
    \t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\"\
    , \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp84iqv8bs.jl:57\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: Cannot\
    \ `convert` an object of type String to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] setindex!(::Array{Int64,1}, ::String, ::Int64) at ./array.jl:826\n   [2]\
    \ by_length(::Array{Int64,1}) at /tmp/tmp84iqv8bs.jl:44\n   [3] top-level scope\
    \ at /tmp/tmp84iqv8bs.jl:57\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp84iqv8bs.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmp84iqv8bs.jl:59\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: Cannot `convert` an object of type String\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmp84iqv8bs.jl:30\n   [3] top-level scope at /tmp/tmp84iqv8bs.jl:59\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp84iqv8bs.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmp84iqv8bs.jl:60\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: Cannot `convert`\
    \ an object of type String to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmp84iqv8bs.jl:34\n   [3] top-level scope at /tmp/tmp84iqv8bs.jl:60\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp84iqv8bs.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmp84iqv8bs.jl:61\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: Cannot `convert` an\
    \ object of type String to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmp84iqv8bs.jl:46\n   [3] top-level scope at /tmp/tmp84iqv8bs.jl:61\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp84iqv8bs.jl:56\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    1      4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp84iqv8bs.jl:54\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sorted_arr\
    \ = sort(arr)\n    # reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # replace the digits by their names\n    for i in 1:length(reversed_arr)\n\
    \        if reversed_arr[i] == 1\n            reversed_arr[i] = \"One\"\n    \
    \    elseif reversed_arr[i] == 2\n            reversed_arr[i] = \"Two\"\n    \
    \    elseif reversed_arr[i] == 3\n            reversed_arr[i] = \"Three\"\n  \
    \      elseif reversed_arr[i] == 4\n            reversed_arr[i] = \"Four\"\n \
    \       elseif reversed_arr[i] == 5\n            reversed_arr[i] = \"Five\"\n\
    \        elseif reversed_arr[i] == 6\n            reversed_arr[i] = \"Six\"\n\
    \        elseif reversed_arr[i] == 7\n            reversed_arr[i] = \"Seven\"\n\
    \        elseif reversed_arr[i] == 8\n            reversed_arr[i] = \"Eight\"\n\
    \        elseif reversed_arr[i] == 9\n            reversed_arr[i] = \"Nine\"\n\
    \        end\n    end\n    # return the result\n    return reversed_arr\nend\n\
    using Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp4p5pnyb5.jl:57\\n  Test threw\
    \ exception\\n  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\\n  MethodError:\
    \ Cannot `convert` an object of type String to an object of type Int64\\n  Closest\
    \ candidates are:\\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\\\
    n    convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\\n  \
    \  convert(::Type{T}, !Matched::Ptr) where T<:Integer at pointer.jl:23\\n    ...\\\
    n  Stacktrace:\\n   [1] setindex!(::Array{Int64,1}, ::String, ::Int64) at ./array.jl:826\\\
    n   [2] by_length(::Array{Int64,1}) at /tmp/tmp4p5pnyb5.jl:44\\n   [3] top-level\
    \ scope at /tmp/tmp4p5pnyb5.jl:57\\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmp4p5pnyb5.jl:56\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp4p5pnyb5.jl:59\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\\n  MethodError: Cannot `convert` an object of type String\
    \ to an object of type Int64\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmp4p5pnyb5.jl:30\\n   [3] top-level scope at /tmp/tmp4p5pnyb5.jl:59\\\
    n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmp4p5pnyb5.jl:56\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp4p5pnyb5.jl:60\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\\n  MethodError: Cannot `convert`\
    \ an object of type String to an object of type Int64\\n  Closest candidates are:\\\
    n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmp4p5pnyb5.jl:34\\n   [3] top-level scope at /tmp/tmp4p5pnyb5.jl:60\\\
    n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmp4p5pnyb5.jl:56\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp4p5pnyb5.jl:61\\n  Test threw exception\\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\\n  MethodError: Cannot `convert`\
    \ an object of type String to an object of type Int64\\n  Closest candidates are:\\\
    n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmp4p5pnyb5.jl:46\\n   [3] top-level scope at /tmp/tmp4p5pnyb5.jl:61\\\
    n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmp4p5pnyb5.jl:56\\n  \\nTest Summary: | Pass\
    \  Error  Total\\ntest set      |    1      4      5\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sorted_arr\
    \ = sort(arr)\n    # reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # replace each digit by its corresponding name from \"One\", \"Two\", \"\
    Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\n    result\
    \ = []\n    for i in reversed_arr\n        if i == 1\n            push!(result,\
    \ \"One\")\n        elseif i == 2\n            push!(result, \"Two\")\n      \
    \  elseif i == 3\n            push!(result, \"Three\")\n        elseif i == 4\n\
    \            push!(result, \"Four\")\n        elseif i == 5\n            push!(result,\
    \ \"Five\")\n        elseif i == 6\n            push!(result, \"Six\")\n     \
    \   elseif i == 7\n            push!(result, \"Seven\")\n        elseif i == 8\n\
    \            push!(result, \"Eight\")\n        elseif i == 9\n            push!(result,\
    \ \"Nine\")\n        end\n    end\n    return result\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3])\
    \ == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"\
    One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\t@test(candidate([1,\
    \ -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2]) == [\"Three\", \"Two\"\
    , \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # Sort the array\n    sorted_arr\
    \ = sort(arr)\n    # Reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # Replace each digit by its corresponding name from \"One\", \"Two\", \"\
    Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\n    # Create\
    \ a dictionary with the numbers as keys and the names as values\n    names_dict\
    \ = Dict(1 => \"One\", 2 => \"Two\", 3 => \"Three\", 4 => \"Four\", 5 => \"Five\"\
    , 6 => \"Six\", 7 => \"Seven\", 8 => \"Eight\", 9 => \"Nine\")\n    # Create an\
    \ empty array to store the names\n    names_arr = []\n    # Loop through the reversed\
    \ array\n    for i in reversed_arr\n        # If the number is in the dictionary,\
    \ append the name to the names array\n        if i in keys(names_dict)\n     \
    \       push!(names_arr, names_dict[i])\n        end\n    end\n    # Return the\
    \ names array\n    return names_arr\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"\
    Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    arr = sort(arr)\n    arr\
    \ = reverse(arr)\n    arr = filter(x -> x in 1:9, arr)\n    arr = map(x -> string(x),\
    \ arr)\n    return arr\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\
    \t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\"\
    , \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp0ilmjp3u.jl:34\\n  Expression: candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"]\\n   Evaluated: [\"8\", \"5\", \"4\", \"3\", \"2\"\
    , \"2\", \"1\", \"1\"] == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\",\
    \ \"Two\", \"One\", \"One\"]\\nStacktrace:\\n [1] top-level scope at '"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    arr = sort(arr)\n    arr\
    \ = reverse(arr)\n    new_arr = []\n    for i in arr\n        if i == 1\n    \
    \        push!(new_arr, \"One\")\n        elseif i == 2\n            push!(new_arr,\
    \ \"Two\")\n        elseif i == 3\n            push!(new_arr, \"Three\")\n   \
    \     elseif i == 4\n            push!(new_arr, \"Four\")\n        elseif i ==\
    \ 5\n            push!(new_arr, \"Five\")\n        elseif i == 6\n           \
    \ push!(new_arr, \"Six\")\n        elseif i == 7\n            push!(new_arr, \"\
    Seven\")\n        elseif i == 8\n            push!(new_arr, \"Eight\")\n     \
    \   elseif i == 9\n            push!(new_arr, \"Nine\")\n        end\n    end\n\
    \    return new_arr\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\
    \t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\"\
    , \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # create a dictionary to map\
    \ the number to its name\n    dict = Dict(1 => \"One\", 2 => \"Two\", 3 => \"\
    Three\", 4 => \"Four\", 5 => \"Five\", 6 => \"Six\", 7 => \"Seven\", 8 => \"Eight\"\
    , 9 => \"Nine\")\n    # create an empty array to store the result\n    result\
    \ = []\n    # loop through the array\n    for i in arr\n        # if the number\
    \ is in the dictionary, append the name to the result array\n        if i in keys(dict)\n\
    \            push!(result, dict[i])\n        end\n    end\n    # return the result\
    \ array\n    return result\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\
    \t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\"\
    , \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # replace each digit by its corresponding\
    \ name from \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\"\n    for i in 1:length(arr)\n        if arr[i] == 1\n  \
    \          arr[i] = \"One\"\n        elseif arr[i] == 2\n            arr[i] =\
    \ \"Two\"\n        elseif arr[i] == 3\n            arr[i] = \"Three\"\n      \
    \  elseif arr[i] == 4\n            arr[i] = \"Four\"\n        elseif arr[i] ==\
    \ 5\n            arr[i] = \"Five\"\n        elseif arr[i] == 6\n            arr[i]\
    \ = \"Six\"\n        elseif arr[i] == 7\n            arr[i] = \"Seven\"\n    \
    \    elseif arr[i] == 8\n            arr[i] = \"Eight\"\n        elseif arr[i]\
    \ == 9\n            arr[i] = \"Nine\"\n        end\n    end\n    return arr\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp2ulnyb6c.jl:56\\n  Test threw\
    \ exception\\n  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\\n  MethodError:\
    \ Cannot `convert` an object of type String to an object of type Int64\\n  Closest\
    \ candidates are:\\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\\\
    n    convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\\n  \
    \  convert(::Type{T}, !Matched::Ptr) where T<:Integer at pointer.jl:23\\n    ...\\\
    n  Stacktrace:\\n   [1] setindex!(::Array{Int64,1}, ::String, ::Int64) at ./array.jl:826\\\
    n   [2] by_length(::Array{Int64,1}) at /tmp/tmp2ulnyb6c.jl:44\\n   [3] top-level\
    \ scope at /tmp/tmp2ulnyb6c.jl:56\\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmp2ulnyb6c.jl:55\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp2ulnyb6c.jl:58\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\\n  MethodError: Cannot `convert` an object of type String\
    \ to an object of type Int64\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmp2ulnyb6c.jl:30\\n   [3] top-level scope at /tmp/tmp2ulnyb6c.jl:58\\\
    n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmp2ulnyb6c.jl:55\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp2ulnyb6c.jl:59\\n  Test threw exception\\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\\n  MethodError: Cannot `convert`\
    \ an object of type String to an object of type Int64\\n  Closest candidates are:\\\
    n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmp2ulnyb6c.jl:34\\n   [3] top-level scope at /tmp/tmp2ulnyb6c.jl:59\\\
    n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmp2ulnyb6c.jl:55\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp2ulnyb6c.jl:60\\n  Test threw exception\\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\\n  MethodError: Cannot `convert`\
    \ an object of type String to an object of type Int64\\n  Closest candidates are:\\\
    n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\\n    ...\\n  Stacktrace:\\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmp2ulnyb6c.jl:46\\n   [3] top-level scope at /tmp/tmp2ulnyb6c.jl:60\\\
    n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmp2ulnyb6c.jl:55\\n  \\nTest Summary: | Pass\
    \  Error  Total\\ntest set      |    1      4      5\\n'"
  stderr: "b'ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 4 errored,\
    \ 0 broken.\\nin expression starting at /tmp/tmp2ulnyb6c.jl:53\\n'"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    #\
    \ reverse the array\n    # replace each digit by its corresponding name from \"\
    One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\",\
    \ \"Nine\"\n    # return the array\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"\
    Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp6uz0yblv.jl:33\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp6uz0yblv.jl:27\n\
    \   [2] top-level scope at /tmp/tmp6uz0yblv.jl:33\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6uz0yblv.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmp6uz0yblv.jl:34\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{String}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp6uz0yblv.jl:27\n\
    \   [2] top-level scope at /tmp/tmp6uz0yblv.jl:34\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6uz0yblv.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmp6uz0yblv.jl:35\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp6uz0yblv.jl:27\n\
    \   [2] top-level scope at /tmp/tmp6uz0yblv.jl:35\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6uz0yblv.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmp6uz0yblv.jl:36\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp6uz0yblv.jl:27\n\
    \   [2] top-level scope at /tmp/tmp6uz0yblv.jl:36\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6uz0yblv.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmp6uz0yblv.jl:37\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp6uz0yblv.jl:27\n\
    \   [2] top-level scope at /tmp/tmp6uz0yblv.jl:37\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6uz0yblv.jl:32\n  \nTest Summary: | Error \
    \ Total\ntest set      |     5      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6uz0yblv.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # create a new array to store\
    \ the result\n    result = []\n    # iterate over the array\n    for i in arr\n\
    \        # if the number is between 1 and 9 inclusive\n        if 1 <= i <= 9\n\
    \            # append the corresponding name to the result array\n           \
    \ push!(result, string(i))\n        end\n    end\n    # return the result array\n\
    \    return result\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\
    \t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\"\
    , \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpdo0q_56x.jl:45\n  Expression: candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"]\n   Evaluated: [\"8\", \"5\", \"4\", \"3\", \"2\"\
    , \"2\", \"1\", \"1\"] == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\",\
    \ \"Two\", \"One\", \"One\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpdo0q_56x.jl:45\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdo0q_56x.jl:44\ntest set: Test Failed at /tmp/tmpdo0q_56x.jl:47\n\
    \  Expression: candidate([1, -1, 55]) == [\"One\"]\n   Evaluated: [\"1\"] == [\"\
    One\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpdo0q_56x.jl:47\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdo0q_56x.jl:44\ntest set: Test Failed at /tmp/tmpdo0q_56x.jl:48\n\
    \  Expression: candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n   Evaluated:\
    \ [\"3\", \"2\", \"1\"] == [\"Three\", \"Two\", \"One\"]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpdo0q_56x.jl:48\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdo0q_56x.jl:44\ntest set: Test Failed at /tmp/tmpdo0q_56x.jl:49\n\
    \  Expression: candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n   Evaluated:\
    \ [\"9\", \"8\", \"4\"] == [\"Nine\", \"Eight\", \"Four\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpdo0q_56x.jl:49\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdo0q_56x.jl:44\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpdo0q_56x.jl:42\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    #\
    \ reverse the array\n    # replace each digit by its corresponding name from \"\
    One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\",\
    \ \"Nine\"\n    # return the array\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"\
    Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp24icxdmu.jl:33\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp24icxdmu.jl:27\n\
    \   [2] top-level scope at /tmp/tmp24icxdmu.jl:33\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp24icxdmu.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmp24icxdmu.jl:34\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{String}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp24icxdmu.jl:27\n\
    \   [2] top-level scope at /tmp/tmp24icxdmu.jl:34\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp24icxdmu.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmp24icxdmu.jl:35\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp24icxdmu.jl:27\n\
    \   [2] top-level scope at /tmp/tmp24icxdmu.jl:35\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp24icxdmu.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmp24icxdmu.jl:36\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp24icxdmu.jl:27\n\
    \   [2] top-level scope at /tmp/tmp24icxdmu.jl:36\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp24icxdmu.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmp24icxdmu.jl:37\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp24icxdmu.jl:27\n\
    \   [2] top-level scope at /tmp/tmp24icxdmu.jl:37\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp24icxdmu.jl:32\n  \nTest Summary: | Error \
    \ Total\ntest set      |     5      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp24icxdmu.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    #\
    \ reverse the array\n    # replace each digit by its corresponding name from \"\
    One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\",\
    \ \"Nine\"\n    # return the array\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"\
    Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp2oy3ljgb.jl:33\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp2oy3ljgb.jl:27\n\
    \   [2] top-level scope at /tmp/tmp2oy3ljgb.jl:33\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2oy3ljgb.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmp2oy3ljgb.jl:34\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{String}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp2oy3ljgb.jl:27\n\
    \   [2] top-level scope at /tmp/tmp2oy3ljgb.jl:34\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2oy3ljgb.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmp2oy3ljgb.jl:35\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp2oy3ljgb.jl:27\n\
    \   [2] top-level scope at /tmp/tmp2oy3ljgb.jl:35\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2oy3ljgb.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmp2oy3ljgb.jl:36\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp2oy3ljgb.jl:27\n\
    \   [2] top-level scope at /tmp/tmp2oy3ljgb.jl:36\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2oy3ljgb.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmp2oy3ljgb.jl:37\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp2oy3ljgb.jl:27\n\
    \   [2] top-level scope at /tmp/tmp2oy3ljgb.jl:37\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp2oy3ljgb.jl:32\n  \nTest Summary: | Error \
    \ Total\ntest set      |     5      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2oy3ljgb.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    #\
    \ reverse the array\n    # replace each digit by its corresponding name from \"\
    One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\",\
    \ \"Nine\"\n    # return the resulting array\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp_hnqiv6e.jl:33\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp_hnqiv6e.jl:27\n\
    \   [2] top-level scope at /tmp/tmp_hnqiv6e.jl:33\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_hnqiv6e.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmp_hnqiv6e.jl:34\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{String}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp_hnqiv6e.jl:27\n\
    \   [2] top-level scope at /tmp/tmp_hnqiv6e.jl:34\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_hnqiv6e.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmp_hnqiv6e.jl:35\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp_hnqiv6e.jl:27\n\
    \   [2] top-level scope at /tmp/tmp_hnqiv6e.jl:35\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_hnqiv6e.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmp_hnqiv6e.jl:36\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp_hnqiv6e.jl:27\n\
    \   [2] top-level scope at /tmp/tmp_hnqiv6e.jl:36\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_hnqiv6e.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmp_hnqiv6e.jl:37\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp_hnqiv6e.jl:27\n\
    \   [2] top-level scope at /tmp/tmp_hnqiv6e.jl:37\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_hnqiv6e.jl:32\n  \nTest Summary: | Error \
    \ Total\ntest set      |     5      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_hnqiv6e.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # replace each digit by its corresponding\
    \ name from \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\"\n    for i in 1:length(arr)\n        if arr[i] == 1\n  \
    \          arr[i] = \"One\"\n        elseif arr[i] == 2\n            arr[i] =\
    \ \"Two\"\n        elseif arr[i] == 3\n            arr[i] = \"Three\"\n      \
    \  elseif arr[i] == 4\n            arr[i] = \"Four\"\n        elseif arr[i] ==\
    \ 5\n            arr[i] = \"Five\"\n        elseif arr[i] == 6\n            arr[i]\
    \ = \"Six\"\n        elseif arr[i] == 7\n            arr[i] = \"Seven\"\n    \
    \    elseif arr[i] == 8\n            arr[i] = \"Eight\"\n        elseif arr[i]\
    \ == 9\n            arr[i] = \"Nine\"\n        end\n    end\n    # return the\
    \ array\n    return arr\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\
    \t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\"\
    , \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpul5xb4n6.jl:57\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: Cannot\
    \ `convert` an object of type String to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] setindex!(::Array{Int64,1}, ::String, ::Int64) at ./array.jl:826\n   [2]\
    \ by_length(::Array{Int64,1}) at /tmp/tmpul5xb4n6.jl:44\n   [3] top-level scope\
    \ at /tmp/tmpul5xb4n6.jl:57\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpul5xb4n6.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmpul5xb4n6.jl:59\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: Cannot `convert` an object of type String\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpul5xb4n6.jl:30\n   [3] top-level scope at /tmp/tmpul5xb4n6.jl:59\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpul5xb4n6.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmpul5xb4n6.jl:60\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: Cannot `convert`\
    \ an object of type String to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpul5xb4n6.jl:34\n   [3] top-level scope at /tmp/tmpul5xb4n6.jl:60\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpul5xb4n6.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmpul5xb4n6.jl:61\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: Cannot `convert` an\
    \ object of type String to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpul5xb4n6.jl:46\n   [3] top-level scope at /tmp/tmpul5xb4n6.jl:61\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpul5xb4n6.jl:56\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    1      4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpul5xb4n6.jl:54\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    arr = sort(arr)\n    arr\
    \ = reverse(arr)\n    result = []\n    for i in arr\n        if i == 1\n     \
    \       push!(result, \"One\")\n        elseif i == 2\n            push!(result,\
    \ \"Two\")\n        elseif i == 3\n            push!(result, \"Three\")\n    \
    \    elseif i == 4\n            push!(result, \"Four\")\n        elseif i == 5\n\
    \            push!(result, \"Five\")\n        elseif i == 6\n            push!(result,\
    \ \"Six\")\n        elseif i == 7\n            push!(result, \"Seven\")\n    \
    \    elseif i == 8\n            push!(result, \"Eight\")\n        elseif i ==\
    \ 9\n            push!(result, \"Nine\")\n        end\n    end\n    return result\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sorted_arr\
    \ = sort(arr)\n    # reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # replace each digit by its corresponding name from \"One\", \"Two\", \"\
    Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\n    # create\
    \ a dictionary\n    d = Dict(\"1\" => \"One\", \"2\" => \"Two\", \"3\" => \"Three\"\
    , \"4\" => \"Four\", \"5\" => \"Five\", \"6\" => \"Six\", \"7\" => \"Seven\",\
    \ \"8\" => \"Eight\", \"9\" => \"Nine\")\n    # create a new array\n    new_arr\
    \ = []\n    # loop through the reversed array\n    for i in reversed_arr\n   \
    \     # if the number is between 1 and 9 inclusive\n        if i >= 1 && i <=\
    \ 9\n            # append the corresponding name to the new array\n          \
    \  push!(new_arr, d[string(i)])\n        end\n    end\n    # return the new array\n\
    \    return new_arr\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\
    \t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\"\
    , \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # create a dictionary to map\
    \ the numbers to their names\n    dict = Dict(\"1\" => \"One\", \"2\" => \"Two\"\
    , \"3\" => \"Three\", \"4\" => \"Four\", \"5\" => \"Five\", \"6\" => \"Six\",\
    \ \"7\" => \"Seven\", \"8\" => \"Eight\", \"9\" => \"Nine\")\n    # create an\
    \ empty array to store the names\n    names = []\n    # loop through the array\n\
    \    for i in arr\n        # if the number is between 1 and 9 inclusive, append\
    \ its name to the names array\n        if i >= 1 && i <= 9\n            push!(names,\
    \ dict[string(i)])\n        end\n    end\n    # return the names array\n    return\
    \ names\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sorted_arr\
    \ = sort(arr)\n    # reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # replace each digit by its corresponding name from \"One\", \"Two\", \"\
    Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\n    # create\
    \ a dictionary\n    d = Dict(\"1\" => \"One\", \"2\" => \"Two\", \"3\" => \"Three\"\
    , \"4\" => \"Four\", \"5\" => \"Five\", \"6\" => \"Six\", \"7\" => \"Seven\",\
    \ \"8\" => \"Eight\", \"9\" => \"Nine\")\n    # create an empty array\n    result\
    \ = []\n    # iterate over the reversed array\n    for i in reversed_arr\n   \
    \     # if the element is in the dictionary\n        if string(i) in keys(d)\n\
    \            # append the corresponding value to the result array\n          \
    \  push!(result, d[string(i)])\n        end\n    end\n    # return the result\
    \ array\n    return result\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\
    \t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\"\
    , \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sorted_arr\
    \ = sort(arr)\n    # reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # replace each digit by its corresponding name from \"One\", \"Two\", \"\
    Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\n    # create\
    \ a dictionary\n    dict = Dict(\"1\" => \"One\", \"2\" => \"Two\", \"3\" => \"\
    Three\", \"4\" => \"Four\", \"5\" => \"Five\", \"6\" => \"Six\", \"7\" => \"Seven\"\
    , \"8\" => \"Eight\", \"9\" => \"Nine\")\n    # create an empty array\n    result\
    \ = []\n    # iterate through the reversed array\n    for i in reversed_arr\n\
    \        # if the value is between 1 and 9 inclusive, push the corresponding name\
    \ to the result array\n        if i >= 1 && i <= 9\n            push!(result,\
    \ dict[string(i)])\n        end\n    end\n    # return the result array\n    return\
    \ result\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # create a dictionary\n    dict\
    \ = Dict(\"One\" => 1, \"Two\" => 2, \"Three\" => 3, \"Four\" => 4, \"Five\" =>\
    \ 5, \"Six\" => 6, \"Seven\" => 7, \"Eight\" => 8, \"Nine\" => 9)\n    # create\
    \ an empty array\n    arr_str = []\n    # loop through the array\n    for i in\
    \ arr\n        # check if the number is in the dictionary\n        if i in keys(dict)\n\
    \            # if it is, append the value to the array\n            push!(arr_str,\
    \ dict[i])\n        end\n    end\n    # return the array\n    return arr_str\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpcehqtak0.jl:47\n  Expression: candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"]\n   Evaluated: String[] == [\"Eight\", \"Five\",\
    \ \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpcehqtak0.jl:47\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpcehqtak0.jl:46\ntest set: Test Failed at /tmp/tmpcehqtak0.jl:49\n\
    \  Expression: candidate([1, -1, 55]) == [\"One\"]\n   Evaluated: String[] ==\
    \ [\"One\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpcehqtak0.jl:49\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpcehqtak0.jl:46\ntest set: Test Failed at /tmp/tmpcehqtak0.jl:50\n\
    \  Expression: candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n   Evaluated:\
    \ String[] == [\"Three\", \"Two\", \"One\"]\nStacktrace:\n [1] top-level scope\
    \ at /tmp/tmpcehqtak0.jl:50\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpcehqtak0.jl:46\ntest set: Test Failed at /tmp/tmpcehqtak0.jl:51\n\
    \  Expression: candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n   Evaluated:\
    \ String[] == [\"Nine\", \"Eight\", \"Four\"]\nStacktrace:\n [1] top-level scope\
    \ at /tmp/tmpcehqtak0.jl:51\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpcehqtak0.jl:46\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpcehqtak0.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # YOUR CODE HERE\n    return\
    \ [\"One\"]\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp56p3xfn2.jl:31\n  Expression: candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"]\n   Evaluated: [\"One\"] == [\"Eight\", \"Five\"\
    , \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp56p3xfn2.jl:31\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp56p3xfn2.jl:30\ntest set: Test Failed at /tmp/tmp56p3xfn2.jl:32\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{String}([])\n   Evaluated:\
    \ [\"One\"] == String[]\nStacktrace:\n [1] top-level scope at /tmp/tmp56p3xfn2.jl:32\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp56p3xfn2.jl:30\ntest set: Test Failed at /tmp/tmp56p3xfn2.jl:34\n\
    \  Expression: candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n   Evaluated:\
    \ [\"One\"] == [\"Three\", \"Two\", \"One\"]\nStacktrace:\n [1] top-level scope\
    \ at /tmp/tmp56p3xfn2.jl:34\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp56p3xfn2.jl:30\ntest set: Test Failed at /tmp/tmp56p3xfn2.jl:35\n\
    \  Expression: candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n   Evaluated:\
    \ [\"One\"] == [\"Nine\", \"Eight\", \"Four\"]\nStacktrace:\n [1] top-level scope\
    \ at /tmp/tmp56p3xfn2.jl:35\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp56p3xfn2.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp56p3xfn2.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    #\
    \ reverse the array\n    # replace each digit by its corresponding name from \"\
    One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\",\
    \ \"Nine\"\n    # return the resulting array\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpbrme32kd.jl:33\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmpbrme32kd.jl:27\n\
    \   [2] top-level scope at /tmp/tmpbrme32kd.jl:33\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbrme32kd.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmpbrme32kd.jl:34\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{String}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmpbrme32kd.jl:27\n\
    \   [2] top-level scope at /tmp/tmpbrme32kd.jl:34\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbrme32kd.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmpbrme32kd.jl:35\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmpbrme32kd.jl:27\n\
    \   [2] top-level scope at /tmp/tmpbrme32kd.jl:35\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbrme32kd.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmpbrme32kd.jl:36\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmpbrme32kd.jl:27\n\
    \   [2] top-level scope at /tmp/tmpbrme32kd.jl:36\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbrme32kd.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmpbrme32kd.jl:37\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmpbrme32kd.jl:27\n\
    \   [2] top-level scope at /tmp/tmpbrme32kd.jl:37\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpbrme32kd.jl:32\n  \nTest Summary: | Error \
    \ Total\ntest set      |     5      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbrme32kd.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sorted_arr\
    \ = sort(arr)\n    # reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # replace each digit by its corresponding name from \"One\", \"Two\", \"\
    Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\n    # create\
    \ a dictionary\n    dict = Dict(\"1\" => \"One\", \"2\" => \"Two\", \"3\" => \"\
    Three\", \"4\" => \"Four\", \"5\" => \"Five\", \"6\" => \"Six\", \"7\" => \"Seven\"\
    , \"8\" => \"Eight\", \"9\" => \"Nine\")\n    # create an empty array\n    result\
    \ = []\n    # loop through the array\n    for i in reversed_arr\n        # if\
    \ the value is between 1 and 9 inclusive, push the corresponding name to the result\
    \ array\n        if i >= 1 && i <= 9\n            push!(result, dict[string(i)])\n\
    \        end\n    end\n    # return the result array\n    return result\nend\n\
    using Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # Sort the array\n    sorted_arr\
    \ = sort(arr)\n    # Reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # Replace each digit by its corresponding name\n    result = []\n    for\
    \ i in reversed_arr\n        if i == 1\n            push!(result, \"One\")\n \
    \       elseif i == 2\n            push!(result, \"Two\")\n        elseif i ==\
    \ 3\n            push!(result, \"Three\")\n        elseif i == 4\n           \
    \ push!(result, \"Four\")\n        elseif i == 5\n            push!(result, \"\
    Five\")\n        elseif i == 6\n            push!(result, \"Six\")\n        elseif\
    \ i == 7\n            push!(result, \"Seven\")\n        elseif i == 8\n      \
    \      push!(result, \"Eight\")\n        elseif i == 9\n            push!(result,\
    \ \"Nine\")\n        end\n    end\n    return result\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3])\
    \ == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"\
    One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\t@test(candidate([1,\
    \ -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2]) == [\"Three\", \"Two\"\
    , \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    arr = sort(arr)\n    arr\
    \ = reverse(arr)\n    arr = filter(x -> x in 1:9, arr)\n    arr = map(x -> string(x),\
    \ arr)\n    arr = map(x -> replace(x, \"1\" => \"One\", \"2\" => \"Two\", \"3\"\
    \ => \"Three\", \"4\" => \"Four\", \"5\" => \"Five\", \"6\" => \"Six\", \"7\"\
    \ => \"Seven\", \"8\" => \"Eight\", \"9\" => \"Nine\"), arr)\n    return arr\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp15yc68i0.jl:35\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: no method\
    \ matching similar(::String, ::Type{Any})\n  Closest candidates are:\n    similar(!Matched::Array{T,1},\
    \ ::Type) where T at array.jl:358\n    similar(!Matched::Array{T,2}, ::Type) where\
    \ T at array.jl:359\n    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}})\
    \ where N at array.jl:361\n    ...\n  Stacktrace:\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\n \
    \  [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmp15yc68i0.jl:27\n   [5] iterate at ./generator.jl:47 [inlined]\n\
    \   [6] _collect at ./array.jl:678 [inlined]\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\n   [8] map at ./abstractarray.jl:2072 [inlined]\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmp15yc68i0.jl:27\n   [10] top-level scope at /tmp/tmp15yc68i0.jl:35\n\
    \   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [12] top-level scope at /tmp/tmp15yc68i0.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmp15yc68i0.jl:37\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: no method matching similar(::String, ::Type{Any})\n\
    \  Closest candidates are:\n    similar(!Matched::Array{T,1}, ::Type) where T\
    \ at array.jl:358\n    similar(!Matched::Array{T,2}, ::Type) where T at array.jl:359\n\
    \    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}}) where\
    \ N at array.jl:361\n    ...\n  Stacktrace:\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\n \
    \  [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmp15yc68i0.jl:27\n   [5] iterate at ./generator.jl:47 [inlined]\n\
    \   [6] _collect at ./array.jl:678 [inlined]\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\n   [8] map at ./abstractarray.jl:2072 [inlined]\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmp15yc68i0.jl:27\n   [10] top-level scope at /tmp/tmp15yc68i0.jl:37\n\
    \   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [12] top-level scope at /tmp/tmp15yc68i0.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmp15yc68i0.jl:38\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: no method matching\
    \ similar(::String, ::Type{Any})\n  Closest candidates are:\n    similar(!Matched::Array{T,1},\
    \ ::Type) where T at array.jl:358\n    similar(!Matched::Array{T,2}, ::Type) where\
    \ T at array.jl:359\n    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}})\
    \ where N at array.jl:361\n    ...\n  Stacktrace:\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\n \
    \  [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmp15yc68i0.jl:27\n   [5] iterate at ./generator.jl:47 [inlined]\n\
    \   [6] _collect at ./array.jl:678 [inlined]\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\n   [8] map at ./abstractarray.jl:2072 [inlined]\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmp15yc68i0.jl:27\n   [10] top-level scope at /tmp/tmp15yc68i0.jl:38\n\
    \   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [12] top-level scope at /tmp/tmp15yc68i0.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmp15yc68i0.jl:39\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: no method matching\
    \ similar(::String, ::Type{Any})\n  Closest candidates are:\n    similar(!Matched::Array{T,1},\
    \ ::Type) where T at array.jl:358\n    similar(!Matched::Array{T,2}, ::Type) where\
    \ T at array.jl:359\n    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}})\
    \ where N at array.jl:361\n    ...\n  Stacktrace:\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\n \
    \  [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmp15yc68i0.jl:27\n   [5] iterate at ./generator.jl:47 [inlined]\n\
    \   [6] _collect at ./array.jl:678 [inlined]\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\n   [8] map at ./abstractarray.jl:2072 [inlined]\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmp15yc68i0.jl:27\n   [10] top-level scope at /tmp/tmp15yc68i0.jl:39\n\
    \   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [12] top-level scope at /tmp/tmp15yc68i0.jl:34\n  \nTest Summary: | Pass \
    \ Error  Total\ntest set      |    1      4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp15yc68i0.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # replace each digit by its corresponding\
    \ name from \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\"\n    for i in 1:length(arr)\n        if arr[i] == 1\n  \
    \          arr[i] = \"One\"\n        elseif arr[i] == 2\n            arr[i] =\
    \ \"Two\"\n        elseif arr[i] == 3\n            arr[i] = \"Three\"\n      \
    \  elseif arr[i] == 4\n            arr[i] = \"Four\"\n        elseif arr[i] ==\
    \ 5\n            arr[i] = \"Five\"\n        elseif arr[i] == 6\n            arr[i]\
    \ = \"Six\"\n        elseif arr[i] == 7\n            arr[i] = \"Seven\"\n    \
    \    elseif arr[i] == 8\n            arr[i] = \"Eight\"\n        elseif arr[i]\
    \ == 9\n            arr[i] = \"Nine\"\n        end\n    end\n    # return the\
    \ array\n    return arr\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\
    \t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\"\
    , \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpubg9wjn4.jl:57\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: Cannot\
    \ `convert` an object of type String to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] setindex!(::Array{Int64,1}, ::String, ::Int64) at ./array.jl:826\n   [2]\
    \ by_length(::Array{Int64,1}) at /tmp/tmpubg9wjn4.jl:44\n   [3] top-level scope\
    \ at /tmp/tmpubg9wjn4.jl:57\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpubg9wjn4.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmpubg9wjn4.jl:59\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: Cannot `convert` an object of type String\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpubg9wjn4.jl:30\n   [3] top-level scope at /tmp/tmpubg9wjn4.jl:59\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpubg9wjn4.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmpubg9wjn4.jl:60\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: Cannot `convert`\
    \ an object of type String to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpubg9wjn4.jl:34\n   [3] top-level scope at /tmp/tmpubg9wjn4.jl:60\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpubg9wjn4.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmpubg9wjn4.jl:61\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: Cannot `convert` an\
    \ object of type String to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpubg9wjn4.jl:46\n   [3] top-level scope at /tmp/tmpubg9wjn4.jl:61\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpubg9wjn4.jl:56\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    1      4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpubg9wjn4.jl:54\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sorted_arr\
    \ = sort(arr)\n    # reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # replace each digit by its corresponding name from \"One\", \"Two\", \"\
    Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\n    # create\
    \ a dictionary\n    dict = Dict(\"1\" => \"One\", \"2\" => \"Two\", \"3\" => \"\
    Three\", \"4\" => \"Four\", \"5\" => \"Five\", \"6\" => \"Six\", \"7\" => \"Seven\"\
    , \"8\" => \"Eight\", \"9\" => \"Nine\")\n    # create an empty array\n    new_arr\
    \ = []\n    # loop through the reversed array\n    for i in reversed_arr\n   \
    \     # if the number is between 1 and 9 inclusive\n        if i >= 1 && i <=\
    \ 9\n            # push the corresponding name to the new array\n            push!(new_arr,\
    \ dict[string(i)])\n        end\n    end\n    # return the new array\n    return\
    \ new_arr\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    arr = sort(arr)\n    arr\
    \ = reverse(arr)\n    arr = [string(i) for i in arr]\n    return arr\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2, 1, 1,\
    \ 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpro0ju6le.jl:33\n  Expression: candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"]\n   Evaluated: [\"8\", \"5\", \"4\", \"3\", \"2\"\
    , \"2\", \"1\", \"1\"] == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\",\
    \ \"Two\", \"One\", \"One\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpro0ju6le.jl:33\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpro0ju6le.jl:32\ntest set: Test Failed at /tmp/tmpro0ju6le.jl:35\n\
    \  Expression: candidate([1, -1, 55]) == [\"One\"]\n   Evaluated: [\"55\", \"\
    1\", \"-1\"] == [\"One\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpro0ju6le.jl:35\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpro0ju6le.jl:32\ntest set: Test Failed at /tmp/tmpro0ju6le.jl:36\n\
    \  Expression: candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n   Evaluated:\
    \ [\"3\", \"2\", \"1\", \"-1\"] == [\"Three\", \"Two\", \"One\"]\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpro0ju6le.jl:36\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpro0ju6le.jl:32\ntest set: Test Failed at /tmp/tmpro0ju6le.jl:37\n\
    \  Expression: candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n   Evaluated:\
    \ [\"9\", \"8\", \"4\"] == [\"Nine\", \"Eight\", \"Four\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpro0ju6le.jl:37\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpro0ju6le.jl:32\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpro0ju6le.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # Sort the array\n    sorted_arr\
    \ = sort(arr)\n    # Reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # Replace each digit by its corresponding name from \"One\", \"Two\", \"\
    Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\n    # Create\
    \ a dictionary\n    dict = Dict(1 => \"One\", 2 => \"Two\", 3 => \"Three\", 4\
    \ => \"Four\", 5 => \"Five\", 6 => \"Six\", 7 => \"Seven\", 8 => \"Eight\", 9\
    \ => \"Nine\")\n    # Create an empty array\n    new_arr = []\n    # Iterate over\
    \ the reversed array\n    for i in reversed_arr\n        # If the value is in\
    \ the dictionary\n        if i in keys(dict)\n            # Append the value to\
    \ the new array\n            push!(new_arr, dict[i])\n        end\n    end\n \
    \   # Return the new array\n    return new_arr\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sort!(arr)\n\
    \    # reverse the array\n    reverse!(arr)\n    # replace each digit by its corresponding\
    \ name\n    for i in 1:length(arr)\n        if arr[i] == 1\n            arr[i]\
    \ = \"One\"\n        elseif arr[i] == 2\n            arr[i] = \"Two\"\n      \
    \  elseif arr[i] == 3\n            arr[i] = \"Three\"\n        elseif arr[i] ==\
    \ 4\n            arr[i] = \"Four\"\n        elseif arr[i] == 5\n            arr[i]\
    \ = \"Five\"\n        elseif arr[i] == 6\n            arr[i] = \"Six\"\n     \
    \   elseif arr[i] == 7\n            arr[i] = \"Seven\"\n        elseif arr[i]\
    \ == 8\n            arr[i] = \"Eight\"\n        elseif arr[i] == 9\n         \
    \   arr[i] = \"Nine\"\n        end\n    end\n    # return the array\n    return\
    \ arr\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpjgk_wtfo.jl:57\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: Cannot\
    \ `convert` an object of type String to an object of type Int64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n \
    \   convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n \
    \  [1] setindex!(::Array{Int64,1}, ::String, ::Int64) at ./array.jl:826\n   [2]\
    \ by_length(::Array{Int64,1}) at /tmp/tmpjgk_wtfo.jl:44\n   [3] top-level scope\
    \ at /tmp/tmpjgk_wtfo.jl:57\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpjgk_wtfo.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmpjgk_wtfo.jl:59\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: Cannot `convert` an object of type String\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T}, !Matched::Number)\
    \ where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr) where\
    \ T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpjgk_wtfo.jl:30\n   [3] top-level scope at /tmp/tmpjgk_wtfo.jl:59\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpjgk_wtfo.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmpjgk_wtfo.jl:60\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: Cannot `convert`\
    \ an object of type String to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpjgk_wtfo.jl:34\n   [3] top-level scope at /tmp/tmpjgk_wtfo.jl:60\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpjgk_wtfo.jl:56\n  \ntest set: Error During\
    \ Test at /tmp/tmpjgk_wtfo.jl:61\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: Cannot `convert` an\
    \ object of type String to an object of type Int64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at number.jl:7\n    convert(::Type{T}, !Matched::Ptr)\
    \ where T<:Integer at pointer.jl:23\n    ...\n  Stacktrace:\n   [1] setindex!(::Array{Int64,1},\
    \ ::String, ::Int64) at ./array.jl:826\n   [2] by_length(::Array{Int64,1}) at\
    \ /tmp/tmpjgk_wtfo.jl:46\n   [3] top-level scope at /tmp/tmpjgk_wtfo.jl:61\n \
    \  [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpjgk_wtfo.jl:56\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    1      4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpjgk_wtfo.jl:54\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sorted_arr\
    \ = sort(arr)\n    # reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # replace each digit by its corresponding name\n    result = []\n    for\
    \ i in reversed_arr\n        if i == 1\n            push!(result, \"One\")\n \
    \       elseif i == 2\n            push!(result, \"Two\")\n        elseif i ==\
    \ 3\n            push!(result, \"Three\")\n        elseif i == 4\n           \
    \ push!(result, \"Four\")\n        elseif i == 5\n            push!(result, \"\
    Five\")\n        elseif i == 6\n            push!(result, \"Six\")\n        elseif\
    \ i == 7\n            push!(result, \"Seven\")\n        elseif i == 8\n      \
    \      push!(result, \"Eight\")\n        elseif i == 9\n            push!(result,\
    \ \"Nine\")\n        end\n    end\n    return result\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3])\
    \ == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"\
    One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\t@test(candidate([1,\
    \ -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2]) == [\"Three\", \"Two\"\
    , \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    arr = sort(arr)\n    arr\
    \ = reverse(arr)\n    arr = filter(x -> x >= 1 && x <= 9, arr)\n    arr = map(x\
    \ -> string(x), arr)\n    arr = map(x -> replace(x, \"1\" => \"One\", \"2\" =>\
    \ \"Two\", \"3\" => \"Three\", \"4\" => \"Four\", \"5\" => \"Five\", \"6\" =>\
    \ \"Six\", \"7\" => \"Seven\", \"8\" => \"Eight\", \"9\" => \"Nine\"), arr)\n\
    \    return arr\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\
    \t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\"\
    , \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpyziol2ko.jl:35\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: no method\
    \ matching similar(::String, ::Type{Any})\n  Closest candidates are:\n    similar(!Matched::Array{T,1},\
    \ ::Type) where T at array.jl:358\n    similar(!Matched::Array{T,2}, ::Type) where\
    \ T at array.jl:359\n    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}})\
    \ where N at array.jl:361\n    ...\n  Stacktrace:\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\n \
    \  [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmpyziol2ko.jl:27\n   [5] iterate at ./generator.jl:47 [inlined]\n\
    \   [6] _collect at ./array.jl:678 [inlined]\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\n   [8] map at ./abstractarray.jl:2072 [inlined]\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmpyziol2ko.jl:27\n   [10] top-level scope at /tmp/tmpyziol2ko.jl:35\n\
    \   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [12] top-level scope at /tmp/tmpyziol2ko.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmpyziol2ko.jl:37\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: no method matching similar(::String, ::Type{Any})\n\
    \  Closest candidates are:\n    similar(!Matched::Array{T,1}, ::Type) where T\
    \ at array.jl:358\n    similar(!Matched::Array{T,2}, ::Type) where T at array.jl:359\n\
    \    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}}) where\
    \ N at array.jl:361\n    ...\n  Stacktrace:\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\n \
    \  [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmpyziol2ko.jl:27\n   [5] iterate at ./generator.jl:47 [inlined]\n\
    \   [6] _collect at ./array.jl:678 [inlined]\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\n   [8] map at ./abstractarray.jl:2072 [inlined]\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmpyziol2ko.jl:27\n   [10] top-level scope at /tmp/tmpyziol2ko.jl:37\n\
    \   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [12] top-level scope at /tmp/tmpyziol2ko.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmpyziol2ko.jl:38\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: no method matching\
    \ similar(::String, ::Type{Any})\n  Closest candidates are:\n    similar(!Matched::Array{T,1},\
    \ ::Type) where T at array.jl:358\n    similar(!Matched::Array{T,2}, ::Type) where\
    \ T at array.jl:359\n    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}})\
    \ where N at array.jl:361\n    ...\n  Stacktrace:\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\n \
    \  [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmpyziol2ko.jl:27\n   [5] iterate at ./generator.jl:47 [inlined]\n\
    \   [6] _collect at ./array.jl:678 [inlined]\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\n   [8] map at ./abstractarray.jl:2072 [inlined]\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmpyziol2ko.jl:27\n   [10] top-level scope at /tmp/tmpyziol2ko.jl:38\n\
    \   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [12] top-level scope at /tmp/tmpyziol2ko.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmpyziol2ko.jl:39\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: no method matching\
    \ similar(::String, ::Type{Any})\n  Closest candidates are:\n    similar(!Matched::Array{T,1},\
    \ ::Type) where T at array.jl:358\n    similar(!Matched::Array{T,2}, ::Type) where\
    \ T at array.jl:359\n    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}})\
    \ where N at array.jl:361\n    ...\n  Stacktrace:\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\n \
    \  [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmpyziol2ko.jl:27\n   [5] iterate at ./generator.jl:47 [inlined]\n\
    \   [6] _collect at ./array.jl:678 [inlined]\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\n   [8] map at ./abstractarray.jl:2072 [inlined]\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmpyziol2ko.jl:27\n   [10] top-level scope at /tmp/tmpyziol2ko.jl:39\n\
    \   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [12] top-level scope at /tmp/tmpyziol2ko.jl:34\n  \nTest Summary: | Pass \
    \ Error  Total\ntest set      |    1      4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpyziol2ko.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    arr = sort(arr)\n    arr\
    \ = reverse(arr)\n    arr = filter(x -> x in 1:9, arr)\n    arr = map(x -> string(x),\
    \ arr)\n    arr = map(x -> replace(x, \"1\" => \"One\", \"2\" => \"Two\", \"3\"\
    \ => \"Three\", \"4\" => \"Four\", \"5\" => \"Five\", \"6\" => \"Six\", \"7\"\
    \ => \"Seven\", \"8\" => \"Eight\", \"9\" => \"Nine\"), arr)\n    return arr\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpg50p52w9.jl:35\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: no method\
    \ matching similar(::String, ::Type{Any})\n  Closest candidates are:\n    similar(!Matched::Array{T,1},\
    \ ::Type) where T at array.jl:358\n    similar(!Matched::Array{T,2}, ::Type) where\
    \ T at array.jl:359\n    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}})\
    \ where N at array.jl:361\n    ...\n  Stacktrace:\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\n \
    \  [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmpg50p52w9.jl:27\n   [5] iterate at ./generator.jl:47 [inlined]\n\
    \   [6] _collect at ./array.jl:678 [inlined]\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\n   [8] map at ./abstractarray.jl:2072 [inlined]\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmpg50p52w9.jl:27\n   [10] top-level scope at /tmp/tmpg50p52w9.jl:35\n\
    \   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [12] top-level scope at /tmp/tmpg50p52w9.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmpg50p52w9.jl:37\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: no method matching similar(::String, ::Type{Any})\n\
    \  Closest candidates are:\n    similar(!Matched::Array{T,1}, ::Type) where T\
    \ at array.jl:358\n    similar(!Matched::Array{T,2}, ::Type) where T at array.jl:359\n\
    \    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}}) where\
    \ N at array.jl:361\n    ...\n  Stacktrace:\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\n \
    \  [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmpg50p52w9.jl:27\n   [5] iterate at ./generator.jl:47 [inlined]\n\
    \   [6] _collect at ./array.jl:678 [inlined]\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\n   [8] map at ./abstractarray.jl:2072 [inlined]\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmpg50p52w9.jl:27\n   [10] top-level scope at /tmp/tmpg50p52w9.jl:37\n\
    \   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [12] top-level scope at /tmp/tmpg50p52w9.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmpg50p52w9.jl:38\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: no method matching\
    \ similar(::String, ::Type{Any})\n  Closest candidates are:\n    similar(!Matched::Array{T,1},\
    \ ::Type) where T at array.jl:358\n    similar(!Matched::Array{T,2}, ::Type) where\
    \ T at array.jl:359\n    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}})\
    \ where N at array.jl:361\n    ...\n  Stacktrace:\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\n \
    \  [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmpg50p52w9.jl:27\n   [5] iterate at ./generator.jl:47 [inlined]\n\
    \   [6] _collect at ./array.jl:678 [inlined]\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\n   [8] map at ./abstractarray.jl:2072 [inlined]\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmpg50p52w9.jl:27\n   [10] top-level scope at /tmp/tmpg50p52w9.jl:38\n\
    \   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [12] top-level scope at /tmp/tmpg50p52w9.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmpg50p52w9.jl:39\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: no method matching\
    \ similar(::String, ::Type{Any})\n  Closest candidates are:\n    similar(!Matched::Array{T,1},\
    \ ::Type) where T at array.jl:358\n    similar(!Matched::Array{T,2}, ::Type) where\
    \ T at array.jl:359\n    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}})\
    \ where N at array.jl:361\n    ...\n  Stacktrace:\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\n \
    \  [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmpg50p52w9.jl:27\n   [5] iterate at ./generator.jl:47 [inlined]\n\
    \   [6] _collect at ./array.jl:678 [inlined]\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\n   [8] map at ./abstractarray.jl:2072 [inlined]\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmpg50p52w9.jl:27\n   [10] top-level scope at /tmp/tmpg50p52w9.jl:39\n\
    \   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [12] top-level scope at /tmp/tmpg50p52w9.jl:34\n  \nTest Summary: | Pass \
    \ Error  Total\ntest set      |    1      4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpg50p52w9.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    arr = sort(arr)\n    arr\
    \ = reverse(arr)\n    arr = filter(x -> x in 1:9, arr)\n    return map(x -> Dict(1\
    \ => \"One\", 2 => \"Two\", 3 => \"Three\", 4 => \"Four\", 5 => \"Five\", 6 =>\
    \ \"Six\", 7 => \"Seven\", 8 => \"Eight\", 9 => \"Nine\")[x], arr)\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2, 1, 1,\
    \ 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sorted_arr\
    \ = sort(arr)\n    # reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # replace each digit by its corresponding name from \"One\", \"Two\", \"\
    Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\n    # create\
    \ a dictionary\n    d = Dict(\"1\" => \"One\", \"2\" => \"Two\", \"3\" => \"Three\"\
    , \"4\" => \"Four\", \"5\" => \"Five\", \"6\" => \"Six\", \"7\" => \"Seven\",\
    \ \"8\" => \"Eight\", \"9\" => \"Nine\")\n    # create an empty array\n    result\
    \ = []\n    # iterate over the reversed array\n    for i in reversed_arr\n   \
    \     # check if the number is between 1 and 9 inclusive\n        if i >= 1 &&\
    \ i <= 9\n            # if so, push the corresponding name to the result array\n\
    \            push!(result, d[string(i)])\n        end\n    end\n    # return the\
    \ result array\n    return result\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"\
    Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    #\
    \ reverse the array\n    # replace each digit by its corresponding name from \"\
    One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\",\
    \ \"Nine\"\n    # return the array\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"\
    Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp96f0quie.jl:33\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp96f0quie.jl:27\n\
    \   [2] top-level scope at /tmp/tmp96f0quie.jl:33\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp96f0quie.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmp96f0quie.jl:34\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{String}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp96f0quie.jl:27\n\
    \   [2] top-level scope at /tmp/tmp96f0quie.jl:34\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp96f0quie.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmp96f0quie.jl:35\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp96f0quie.jl:27\n\
    \   [2] top-level scope at /tmp/tmp96f0quie.jl:35\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp96f0quie.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmp96f0quie.jl:36\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp96f0quie.jl:27\n\
    \   [2] top-level scope at /tmp/tmp96f0quie.jl:36\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp96f0quie.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmp96f0quie.jl:37\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp96f0quie.jl:27\n\
    \   [2] top-level scope at /tmp/tmp96f0quie.jl:37\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp96f0quie.jl:32\n  \nTest Summary: | Error \
    \ Total\ntest set      |     5      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp96f0quie.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    arr = sort(arr)\n    arr\
    \ = reverse(arr)\n    arr = filter(x -> x in 1:9, arr)\n    arr = map(x -> string(x),\
    \ arr)\n    arr = map(x -> replace(x, \"1\" => \"One\", \"2\" => \"Two\", \"3\"\
    \ => \"Three\", \"4\" => \"Four\", \"5\" => \"Five\", \"6\" => \"Six\", \"7\"\
    \ => \"Seven\", \"8\" => \"Eight\", \"9\" => \"Nine\"), arr)\n    return arr\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp6ol3kfx1.jl:35\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: no method\
    \ matching similar(::String, ::Type{Any})\n  Closest candidates are:\n    similar(!Matched::Array{T,1},\
    \ ::Type) where T at array.jl:358\n    similar(!Matched::Array{T,2}, ::Type) where\
    \ T at array.jl:359\n    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}})\
    \ where N at array.jl:361\n    ...\n  Stacktrace:\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\n \
    \  [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmp6ol3kfx1.jl:27\n   [5] iterate at ./generator.jl:47 [inlined]\n\
    \   [6] _collect at ./array.jl:678 [inlined]\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\n   [8] map at ./abstractarray.jl:2072 [inlined]\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmp6ol3kfx1.jl:27\n   [10] top-level scope at /tmp/tmp6ol3kfx1.jl:35\n\
    \   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [12] top-level scope at /tmp/tmp6ol3kfx1.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmp6ol3kfx1.jl:37\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: no method matching similar(::String, ::Type{Any})\n\
    \  Closest candidates are:\n    similar(!Matched::Array{T,1}, ::Type) where T\
    \ at array.jl:358\n    similar(!Matched::Array{T,2}, ::Type) where T at array.jl:359\n\
    \    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}}) where\
    \ N at array.jl:361\n    ...\n  Stacktrace:\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\n \
    \  [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmp6ol3kfx1.jl:27\n   [5] iterate at ./generator.jl:47 [inlined]\n\
    \   [6] _collect at ./array.jl:678 [inlined]\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\n   [8] map at ./abstractarray.jl:2072 [inlined]\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmp6ol3kfx1.jl:27\n   [10] top-level scope at /tmp/tmp6ol3kfx1.jl:37\n\
    \   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [12] top-level scope at /tmp/tmp6ol3kfx1.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmp6ol3kfx1.jl:38\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: no method matching\
    \ similar(::String, ::Type{Any})\n  Closest candidates are:\n    similar(!Matched::Array{T,1},\
    \ ::Type) where T at array.jl:358\n    similar(!Matched::Array{T,2}, ::Type) where\
    \ T at array.jl:359\n    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}})\
    \ where N at array.jl:361\n    ...\n  Stacktrace:\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\n \
    \  [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmp6ol3kfx1.jl:27\n   [5] iterate at ./generator.jl:47 [inlined]\n\
    \   [6] _collect at ./array.jl:678 [inlined]\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\n   [8] map at ./abstractarray.jl:2072 [inlined]\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmp6ol3kfx1.jl:27\n   [10] top-level scope at /tmp/tmp6ol3kfx1.jl:38\n\
    \   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [12] top-level scope at /tmp/tmp6ol3kfx1.jl:34\n  \ntest set: Error During\
    \ Test at /tmp/tmp6ol3kfx1.jl:39\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: no method matching\
    \ similar(::String, ::Type{Any})\n  Closest candidates are:\n    similar(!Matched::Array{T,1},\
    \ ::Type) where T at array.jl:358\n    similar(!Matched::Array{T,2}, ::Type) where\
    \ T at array.jl:359\n    similar(!Matched::Array, ::Type, !Matched::Tuple{Vararg{Int64,N}})\
    \ where N at array.jl:361\n    ...\n  Stacktrace:\n   [1] _similar_or_copy(::String,\
    \ ::Type{Any}) at ./set.jl:414\n   [2] replace(::String, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N; count::Nothing) at ./set.jl:529\n \
    \  [3] replace(::String, ::Pair{String,String}, ::Pair{String,String}, ::Pair{String,String},\
    \ ::Vararg{Pair{String,String},N} where N) at ./set.jl:526\n   [4] (::var\"#5#8\"\
    )(::String) at /tmp/tmp6ol3kfx1.jl:27\n   [5] iterate at ./generator.jl:47 [inlined]\n\
    \   [6] _collect at ./array.jl:678 [inlined]\n   [7] collect_similar at ./array.jl:607\
    \ [inlined]\n   [8] map at ./abstractarray.jl:2072 [inlined]\n   [9] by_length(::Array{Int64,1})\
    \ at /tmp/tmp6ol3kfx1.jl:27\n   [10] top-level scope at /tmp/tmp6ol3kfx1.jl:39\n\
    \   [11] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [12] top-level scope at /tmp/tmp6ol3kfx1.jl:34\n  \nTest Summary: | Pass \
    \ Error  Total\ntest set      |    1      4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6ol3kfx1.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # Sort the array\n    sorted_arr\
    \ = sort(arr)\n    # Reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # Create a dictionary of numbers and their names\n    num_dict = Dict(1 =>\
    \ \"One\", 2 => \"Two\", 3 => \"Three\", 4 => \"Four\", 5 => \"Five\", 6 => \"\
    Six\", 7 => \"Seven\", 8 => \"Eight\", 9 => \"Nine\")\n    # Create an empty array\
    \ to store the names\n    names = []\n    # Iterate through the array and add\
    \ the names to the array\n    for i in reversed_arr\n        if i in keys(num_dict)\n\
    \            push!(names, num_dict[i])\n        end\n    end\n    # Return the\
    \ array of names\n    return names\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"\
    Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    arr_sorted = sort(arr)\n\
    \    arr_sorted = reverse(arr_sorted)\n    arr_sorted = [i for i in arr_sorted\
    \ if i in 1:9]\n    arr_sorted = [string(i) for i in arr_sorted]\n    return arr_sorted\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpplmvoykk.jl:34\n  Expression: candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"]\n   Evaluated: [\"8\", \"5\", \"4\", \"3\", \"2\"\
    , \"2\", \"1\", \"1\"] == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\",\
    \ \"Two\", \"One\", \"One\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpplmvoykk.jl:34\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpplmvoykk.jl:33\ntest set: Test Failed at /tmp/tmpplmvoykk.jl:36\n\
    \  Expression: candidate([1, -1, 55]) == [\"One\"]\n   Evaluated: [\"1\"] == [\"\
    One\"]\nStacktrace:\n [1] top-level scope at /tmp/tmpplmvoykk.jl:36\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpplmvoykk.jl:33\ntest set: Test Failed at /tmp/tmpplmvoykk.jl:37\n\
    \  Expression: candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n   Evaluated:\
    \ [\"3\", \"2\", \"1\"] == [\"Three\", \"Two\", \"One\"]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpplmvoykk.jl:37\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpplmvoykk.jl:33\ntest set: Test Failed at /tmp/tmpplmvoykk.jl:38\n\
    \  Expression: candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n   Evaluated:\
    \ [\"9\", \"8\", \"4\"] == [\"Nine\", \"Eight\", \"Four\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpplmvoykk.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpplmvoykk.jl:33\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpplmvoykk.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sorted_arr\
    \ = sort(arr)\n    # reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # create an empty array to store the names\n    names = []\n    # iterate\
    \ over the reversed array\n    for i in reversed_arr\n        # if the number\
    \ is between 1 and 9 inclusive\n        if 1 <= i <= 9\n            # append the\
    \ name of the number to the names array\n            push!(names, number_to_name(i))\n\
    \        end\n    end\n    # return the names array\n    return names\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2, 1, 1,\
    \ 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpr6lmftwe.jl:45\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  UndefVarError: number_to_name\
    \ not defined\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmpr6lmftwe.jl:34\n\
    \   [2] top-level scope at /tmp/tmpr6lmftwe.jl:45\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpr6lmftwe.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmpr6lmftwe.jl:47\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  UndefVarError: number_to_name not defined\n  Stacktrace:\n\
    \   [1] by_length(::Array{Int64,1}) at /tmp/tmpr6lmftwe.jl:34\n   [2] top-level\
    \ scope at /tmp/tmpr6lmftwe.jl:47\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpr6lmftwe.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmpr6lmftwe.jl:48\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  UndefVarError: number_to_name\
    \ not defined\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmpr6lmftwe.jl:34\n\
    \   [2] top-level scope at /tmp/tmpr6lmftwe.jl:48\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpr6lmftwe.jl:44\n  \ntest set: Error During\
    \ Test at /tmp/tmpr6lmftwe.jl:49\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  UndefVarError: number_to_name not\
    \ defined\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmpr6lmftwe.jl:34\n\
    \   [2] top-level scope at /tmp/tmpr6lmftwe.jl:49\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpr6lmftwe.jl:44\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    1      4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpr6lmftwe.jl:42\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    #\
    \ reverse the array\n    # replace each digit by its corresponding name from \"\
    One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\",\
    \ \"Nine\"\n    # return the array\n    return [\"One\"]\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8,\
    \ 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\"\
    , \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\t@test(candidate([1,\
    \ -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2]) == [\"Three\", \"Two\"\
    , \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpm4g72x1o.jl:34\n  Expression: candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"]\n   Evaluated: [\"One\"] == [\"Eight\", \"Five\"\
    , \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpm4g72x1o.jl:34\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpm4g72x1o.jl:33\ntest set: Test Failed at /tmp/tmpm4g72x1o.jl:35\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{String}([])\n   Evaluated:\
    \ [\"One\"] == String[]\nStacktrace:\n [1] top-level scope at /tmp/tmpm4g72x1o.jl:35\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpm4g72x1o.jl:33\ntest set: Test Failed at /tmp/tmpm4g72x1o.jl:37\n\
    \  Expression: candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n   Evaluated:\
    \ [\"One\"] == [\"Three\", \"Two\", \"One\"]\nStacktrace:\n [1] top-level scope\
    \ at /tmp/tmpm4g72x1o.jl:37\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpm4g72x1o.jl:33\ntest set: Test Failed at /tmp/tmpm4g72x1o.jl:38\n\
    \  Expression: candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n   Evaluated:\
    \ [\"One\"] == [\"Nine\", \"Eight\", \"Four\"]\nStacktrace:\n [1] top-level scope\
    \ at /tmp/tmpm4g72x1o.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpm4g72x1o.jl:33\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpm4g72x1o.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    #\
    \ reverse the array\n    # replace each digit by its corresponding name from \"\
    One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\",\
    \ \"Nine\"\n    # return the resulting array\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp1kalxo5h.jl:33\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp1kalxo5h.jl:27\n\
    \   [2] top-level scope at /tmp/tmp1kalxo5h.jl:33\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1kalxo5h.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmp1kalxo5h.jl:34\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{String}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp1kalxo5h.jl:27\n\
    \   [2] top-level scope at /tmp/tmp1kalxo5h.jl:34\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1kalxo5h.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmp1kalxo5h.jl:35\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp1kalxo5h.jl:27\n\
    \   [2] top-level scope at /tmp/tmp1kalxo5h.jl:35\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1kalxo5h.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmp1kalxo5h.jl:36\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp1kalxo5h.jl:27\n\
    \   [2] top-level scope at /tmp/tmp1kalxo5h.jl:36\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1kalxo5h.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmp1kalxo5h.jl:37\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp1kalxo5h.jl:27\n\
    \   [2] top-level scope at /tmp/tmp1kalxo5h.jl:37\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp1kalxo5h.jl:32\n  \nTest Summary: | Error \
    \ Total\ntest set      |     5      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1kalxo5h.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    #\
    \ reverse the array\n    # replace each digit by its corresponding name from \"\
    One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\",\
    \ \"Nine\"\n    # return the array\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"\
    Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp54cky4qy.jl:33\n  Test threw exception\n\
    \  Expression: candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"\
    Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{String,1}\n \
    \ Closest candidates are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp54cky4qy.jl:27\n\
    \   [2] top-level scope at /tmp/tmp54cky4qy.jl:33\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp54cky4qy.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmp54cky4qy.jl:34\n  Test threw exception\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{String}([])\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp54cky4qy.jl:27\n\
    \   [2] top-level scope at /tmp/tmp54cky4qy.jl:34\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp54cky4qy.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmp54cky4qy.jl:35\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 55]) == [\"One\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{String,1}\n  Closest candidates are:\n    convert(::Type{Array{String,1}},\
    \ !Matched::LibGit2.StrArrayStruct) at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp54cky4qy.jl:27\n\
    \   [2] top-level scope at /tmp/tmp54cky4qy.jl:35\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp54cky4qy.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmp54cky4qy.jl:36\n  Test threw exception\n  Expression: candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp54cky4qy.jl:27\n\
    \   [2] top-level scope at /tmp/tmp54cky4qy.jl:36\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp54cky4qy.jl:32\n  \ntest set: Error During\
    \ Test at /tmp/tmp54cky4qy.jl:37\n  Test threw exception\n  Expression: candidate([9,\
    \ 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n  MethodError: Cannot `convert` an\
    \ object of type Nothing to an object of type Array{String,1}\n  Closest candidates\
    \ are:\n    convert(::Type{Array{String,1}}, !Matched::LibGit2.StrArrayStruct)\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LibGit2/src/strarray.jl:14\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] by_length(::Array{Int64,1}) at /tmp/tmp54cky4qy.jl:27\n\
    \   [2] top-level scope at /tmp/tmp54cky4qy.jl:37\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp54cky4qy.jl:32\n  \nTest Summary: | Error \
    \ Total\ntest set      |     5      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp54cky4qy.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # your code here\n    return\
    \ []\nend\nusing Test\n\n@testset begin\n\ncandidate = by_length;\n\t@test(candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([])) == Vector{String}([]))\n\
    \t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1, -1, 3, 2])\
    \ == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) == [\"Nine\"\
    , \"Eight\", \"Four\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmprag1_hdc.jl:31\n  Expression: candidate([2,\
    \ 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"]\n   Evaluated: String[] == [\"Eight\", \"Five\",\
    \ \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmprag1_hdc.jl:31\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprag1_hdc.jl:30\ntest set: Test Failed at /tmp/tmprag1_hdc.jl:33\n\
    \  Expression: candidate([1, -1, 55]) == [\"One\"]\n   Evaluated: String[] ==\
    \ [\"One\"]\nStacktrace:\n [1] top-level scope at /tmp/tmprag1_hdc.jl:33\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprag1_hdc.jl:30\ntest set: Test Failed at /tmp/tmprag1_hdc.jl:34\n\
    \  Expression: candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n   Evaluated:\
    \ String[] == [\"Three\", \"Two\", \"One\"]\nStacktrace:\n [1] top-level scope\
    \ at /tmp/tmprag1_hdc.jl:34\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprag1_hdc.jl:30\ntest set: Test Failed at /tmp/tmprag1_hdc.jl:35\n\
    \  Expression: candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n   Evaluated:\
    \ String[] == [\"Nine\", \"Eight\", \"Four\"]\nStacktrace:\n [1] top-level scope\
    \ at /tmp/tmprag1_hdc.jl:35\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprag1_hdc.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    1     4      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmprag1_hdc.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of integers, sort the integers that are between\
    \ 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit\
    \ by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr\
    \ = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4,\
    \ 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return\
    \ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]\n    \n      If the array is empty, return an empty array:\n      arr = []\n\
    \      return []\n    \n      If the array has any strange number ignore it:\n\
    \      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n         \
    \   -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\nfunction\
    \ by_length(arr::Vector{Int64})::Vector{String} \n    # sort the array\n    sorted_arr\
    \ = sort(arr)\n    # reverse the array\n    reversed_arr = reverse(sorted_arr)\n\
    \    # replace each digit by its corresponding name from \"One\", \"Two\", \"\
    Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\n    # create\
    \ a dictionary\n    dict = Dict(\"1\" => \"One\", \"2\" => \"Two\", \"3\" => \"\
    Three\", \"4\" => \"Four\", \"5\" => \"Five\", \"6\" => \"Six\", \"7\" => \"Seven\"\
    , \"8\" => \"Eight\", \"9\" => \"Nine\")\n    # create an empty array\n    new_arr\
    \ = []\n    # loop through the reversed array\n    for i in reversed_arr\n   \
    \     # if the element is between 1 and 9 inclusive\n        if i >= 1 && i <=\
    \ 9\n            # append the corresponding name to the new array\n          \
    \  push!(new_arr, dict[string(i)])\n        end\n    end\n    # return the new\
    \ array\n    return new_arr\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ by_length;\n\t@test(candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\"\
    , \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{String}([]))\n\t@test(candidate([1, -1, 55]) == [\"One\"])\n\t@test(candidate([1,\
    \ -1, 3, 2]) == [\"Three\", \"Two\", \"One\"])\n\t@test(candidate([9, 4, 8]) ==\
    \ [\"Nine\", \"Eight\", \"Four\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    5      5\n"
  exit_code: 0
  status: OK
